%% File generated by erl-openapi on "2022-03-07T09:09:05Z".

-module(stripe_client).

-export([encode_q/4, encode_h/4]).
-export([get_radar_early_fraud_warnings/1, get_radar_early_fraud_warnings/2]).
-export([post_charges_charge_refunds/1, post_charges_charge_refunds/2]).
-export([get_charges_charge_refunds/1, get_charges_charge_refunds/2]).
-export([post_identity_verification_sessions_session_redact/1,
         post_identity_verification_sessions_session_redact/2]).
-export([post_billing_portal_configurations_configuration/1,
         post_billing_portal_configurations_configuration/2]).
-export([get_billing_portal_configurations_configuration/1,
         get_billing_portal_configurations_configuration/2]).
-export([post_payment_methods/1, post_payment_methods/2]).
-export([get_payment_methods/1, get_payment_methods/2]).
-export([delete_radar_value_lists_value_list/1, delete_radar_value_lists_value_list/2]).
-export([post_radar_value_lists_value_list/1, post_radar_value_lists_value_list/2]).
-export([get_radar_value_lists_value_list/1, get_radar_value_lists_value_list/2]).
-export([post_charges_charge_capture/1, post_charges_charge_capture/2]).
-export([get_disputes/1, get_disputes/2]).
-export([post_prices_price/1, post_prices_price/2]).
-export([get_prices_price/1, get_prices_price/2]).
-export([post_accounts/1, post_accounts/2]).
-export([get_accounts/1, get_accounts/2]).
-export([post_identity_verification_sessions_session_cancel/1,
         post_identity_verification_sessions_session_cancel/2]).
-export([delete_account_persons_person/1, delete_account_persons_person/2]).
-export([post_account_persons_person/1, post_account_persons_person/2]).
-export([get_account_persons_person/1, get_account_persons_person/2]).
-export([post_issuing_authorizations_authorization/1,
         post_issuing_authorizations_authorization/2]).
-export([get_issuing_authorizations_authorization/1,
         get_issuing_authorizations_authorization/2]).
-export([get_files_file/1, get_files_file/2]).
-export([post_issuing_cards_card/1, post_issuing_cards_card/2]).
-export([get_issuing_cards_card/1, get_issuing_cards_card/2]).
-export([post_sources_source_verify/1, post_sources_source_verify/2]).
-export([post_invoiceitems/1, post_invoiceitems/2]).
-export([get_invoiceitems/1, get_invoiceitems/2]).
-export([delete_ephemeral_keys_key/1, delete_ephemeral_keys_key/2]).
-export([get_exchange_rates/1, get_exchange_rates/2]).
-export([post_setup_intents_intent/1, post_setup_intents_intent/2]).
-export([get_setup_intents_intent/1, get_setup_intents_intent/2]).
-export([post_files/1, post_files/2]).
-export([get_files/1, get_files/2]).
-export([delete_customers_customer_bank_accounts_id/1,
         delete_customers_customer_bank_accounts_id/2]).
-export([post_customers_customer_bank_accounts_id/1,
         post_customers_customer_bank_accounts_id/2]).
-export([get_customers_customer_bank_accounts_id/1,
         get_customers_customer_bank_accounts_id/2]).
-export([get_issuer_fraud_records_issuer_fraud_record/1,
         get_issuer_fraud_records_issuer_fraud_record/2]).
-export([delete_accounts_account_people_person/1,
         delete_accounts_account_people_person/2]).
-export([post_accounts_account_people_person/1, post_accounts_account_people_person/2]).
-export([get_accounts_account_people_person/1, get_accounts_account_people_person/2]).
-export([post_payouts/1, post_payouts/2]).
-export([get_payouts/1, get_payouts/2]).
-export([post_account_capabilities_capability/1, post_account_capabilities_capability/2]).
-export([get_account_capabilities_capability/1, get_account_capabilities_capability/2]).
-export([get_sources_source_mandate_notifications_mandate_notification/1,
         get_sources_source_mandate_notifications_mandate_notification/2]).
-export([post_application_fees_fee_refunds_id/1, post_application_fees_fee_refunds_id/2]).
-export([get_application_fees_fee_refunds_id/1, get_application_fees_fee_refunds_id/2]).
-export([delete_customers_customer_discount/1, delete_customers_customer_discount/2]).
-export([get_customers_customer_discount/1, get_customers_customer_discount/2]).
-export([post_coupons/1, post_coupons/2]).
-export([get_coupons/1, get_coupons/2]).
-export([post_charges_charge_dispute_close/1, post_charges_charge_dispute_close/2]).
-export([delete_plans_plan/1, delete_plans_plan/2]).
-export([post_plans_plan/1, post_plans_plan/2]).
-export([get_plans_plan/1, get_plans_plan/2]).
-export([post_customers_customer_bank_accounts/1,
         post_customers_customer_bank_accounts/2]).
-export([get_customers_customer_bank_accounts/1, get_customers_customer_bank_accounts/2]).
-export([delete_terminal_readers_reader/1, delete_terminal_readers_reader/2]).
-export([post_terminal_readers_reader/1, post_terminal_readers_reader/2]).
-export([get_terminal_readers_reader/1, get_terminal_readers_reader/2]).
-export([delete_accounts_account_persons_person/1,
         delete_accounts_account_persons_person/2]).
-export([post_accounts_account_persons_person/1, post_accounts_account_persons_person/2]).
-export([get_accounts_account_persons_person/1, get_accounts_account_persons_person/2]).
-export([post_credit_notes_id_void/1, post_credit_notes_id_void/2]).
-export([post_customers_customer_sources/1, post_customers_customer_sources/2]).
-export([get_customers_customer_sources/1, get_customers_customer_sources/2]).
-export([post_account_links/1, post_account_links/2]).
-export([post_payouts_payout/1, post_payouts_payout/2]).
-export([get_payouts_payout/1, get_payouts_payout/2]).
-export([delete_subscription_items_item/1, delete_subscription_items_item/2]).
-export([post_subscription_items_item/1, post_subscription_items_item/2]).
-export([get_subscription_items_item/1, get_subscription_items_item/2]).
-export([post_products/1, post_products/2]).
-export([get_products/1, get_products/2]).
-export([get_reporting_report_types_report_type/1,
         get_reporting_report_types_report_type/2]).
-export([post_quotes_quote_accept/1, post_quotes_quote_accept/2]).
-export([get_mandates_mandate/1, get_mandates_mandate/2]).
-export([post_customers_customer_subscriptions/1,
         post_customers_customer_subscriptions/2]).
-export([get_customers_customer_subscriptions/1, get_customers_customer_subscriptions/2]).
-export([get_order_returns_id/1, get_order_returns_id/2]).
-export([post_transfers_id_reversals/1, post_transfers_id_reversals/2]).
-export([get_transfers_id_reversals/1, get_transfers_id_reversals/2]).
-export([get_reviews_review/1, get_reviews_review/2]).
-export([delete_accounts_account_bank_accounts_id/1,
         delete_accounts_account_bank_accounts_id/2]).
-export([post_accounts_account_bank_accounts_id/1,
         post_accounts_account_bank_accounts_id/2]).
-export([get_accounts_account_bank_accounts_id/1,
         get_accounts_account_bank_accounts_id/2]).
-export([post_issuing_settlements_settlement/1, post_issuing_settlements_settlement/2]).
-export([get_issuing_settlements_settlement/1, get_issuing_settlements_settlement/2]).
-export([post_promotion_codes_promotion_code/1, post_promotion_codes_promotion_code/2]).
-export([get_promotion_codes_promotion_code/1, get_promotion_codes_promotion_code/2]).
-export([post_subscription_schedules_schedule_cancel/1,
         post_subscription_schedules_schedule_cancel/2]).
-export([post_identity_verification_sessions/1, post_identity_verification_sessions/2]).
-export([get_identity_verification_sessions/1, get_identity_verification_sessions/2]).
-export([post_radar_value_list_items/1, post_radar_value_list_items/2]).
-export([get_radar_value_list_items/1, get_radar_value_list_items/2]).
-export([get_events_id/1, get_events_id/2]).
-export([get_country_specs/1, get_country_specs/2]).
-export([post_payment_intents_intent_verify_microdeposits/1,
         post_payment_intents_intent_verify_microdeposits/2]).
-export([post_subscription_items_subscription_item_usage_records/1,
         post_subscription_items_subscription_item_usage_records/2]).
-export([get_balance_history/1, get_balance_history/2]).
-export([get_order_returns/1, get_order_returns/2]).
-export([delete_account_external_accounts_id/1, delete_account_external_accounts_id/2]).
-export([post_account_external_accounts_id/1, post_account_external_accounts_id/2]).
-export([get_account_external_accounts_id/1, get_account_external_accounts_id/2]).
-export([post_apple_pay_domains/1, post_apple_pay_domains/2]).
-export([get_apple_pay_domains/1, get_apple_pay_domains/2]).
-export([post_credit_notes/1, post_credit_notes/2]).
-export([get_credit_notes/1, get_credit_notes/2]).
-export([get_sigma_scheduled_query_runs_scheduled_query_run/1,
         get_sigma_scheduled_query_runs_scheduled_query_run/2]).
-export([delete_coupons_coupon/1, delete_coupons_coupon/2]).
-export([post_coupons_coupon/1, post_coupons_coupon/2]).
-export([get_coupons_coupon/1, get_coupons_coupon/2]).
-export([delete_customers_customer_tax_ids_id/1, delete_customers_customer_tax_ids_id/2]).
-export([get_customers_customer_tax_ids_id/1, get_customers_customer_tax_ids_id/2]).
-export([get_radar_early_fraud_warnings_early_fraud_warning/1,
         get_radar_early_fraud_warnings_early_fraud_warning/2]).
-export([get_issuing_settlements/1, get_issuing_settlements/2]).
-export([post_file_links/1, post_file_links/2]).
-export([get_file_links/1, get_file_links/2]).
-export([get_identity_verification_reports_report/1,
         get_identity_verification_reports_report/2]).
-export([post_transfers/1, post_transfers/2]).
-export([get_transfers/1, get_transfers/2]).
-export([delete_subscriptions_subscription_exposed_id_discount/1,
         delete_subscriptions_subscription_exposed_id_discount/2]).
-export([post_application_fees_id_refunds/1, post_application_fees_id_refunds/2]).
-export([get_application_fees_id_refunds/1, get_application_fees_id_refunds/2]).
-export([post_accounts_account_bank_accounts/1, post_accounts_account_bank_accounts/2]).
-export([delete_accounts_account/1, delete_accounts_account/2]).
-export([post_accounts_account/1, post_accounts_account/2]).
-export([get_accounts_account/1, get_accounts_account/2]).
-export([post_subscription_schedules_schedule/1, post_subscription_schedules_schedule/2]).
-export([get_subscription_schedules_schedule/1, get_subscription_schedules_schedule/2]).
-export([post_invoices_invoice_pay/1, post_invoices_invoice_pay/2]).
-export([post_transfers_transfer_reversals_id/1, post_transfers_transfer_reversals_id/2]).
-export([get_transfers_transfer_reversals_id/1, get_transfers_transfer_reversals_id/2]).
-export([post_topups_topup/1, post_topups_topup/2]).
-export([get_topups_topup/1, get_topups_topup/2]).
-export([delete_recipients_id/1, delete_recipients_id/2]).
-export([post_recipients_id/1, post_recipients_id/2]).
-export([get_recipients_id/1, get_recipients_id/2]).
-export([get_invoices_invoice_lines/1, get_invoices_invoice_lines/2]).
-export([delete_accounts_account_external_accounts_id/1,
         delete_accounts_account_external_accounts_id/2]).
-export([post_accounts_account_external_accounts_id/1,
         post_accounts_account_external_accounts_id/2]).
-export([get_accounts_account_external_accounts_id/1,
         get_accounts_account_external_accounts_id/2]).
-export([post_topups/1, post_topups/2]).
-export([get_topups/1, get_topups/2]).
-export([post_orders_id_returns/1, post_orders_id_returns/2]).
-export([post_orders_id/1, post_orders_id/2]).
-export([get_orders_id/1, get_orders_id/2]).
-export([delete_apple_pay_domains_domain/1, delete_apple_pay_domains_domain/2]).
-export([get_apple_pay_domains_domain/1, get_apple_pay_domains_domain/2]).
-export([get_issuing_transactions/1, get_issuing_transactions/2]).
-export([post_charges_charge_refund/1, post_charges_charge_refund/2]).
-export([post_payment_methods_payment_method_attach/1,
         post_payment_methods_payment_method_attach/2]).
-export([post_payment_intents_intent_cancel/1, post_payment_intents_intent_cancel/2]).
-export([get_accounts_account_capabilities/1, get_accounts_account_capabilities/2]).
-export([get_credit_notes_preview_lines/1, get_credit_notes_preview_lines/2]).
-export([post_subscriptions/1, post_subscriptions/2]).
-export([get_subscriptions/1, get_subscriptions/2]).
-export([get_setup_attempts/1, get_setup_attempts/2]).
-export([delete_customers_customer_subscriptions_subscription_exposed_id/1,
         delete_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([post_customers_customer_subscriptions_subscription_exposed_id/1,
         post_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([get_customers_customer_subscriptions_subscription_exposed_id/1,
         get_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([get_bitcoin_receivers_id/1, get_bitcoin_receivers_id/2]).
-export([post_orders/1, post_orders/2]).
-export([get_orders/1, get_orders/2]).
-export([post_ephemeral_keys/1, post_ephemeral_keys/2]).
-export([delete_webhook_endpoints_webhook_endpoint/1,
         delete_webhook_endpoints_webhook_endpoint/2]).
-export([post_webhook_endpoints_webhook_endpoint/1,
         post_webhook_endpoints_webhook_endpoint/2]).
-export([get_webhook_endpoints_webhook_endpoint/1,
         get_webhook_endpoints_webhook_endpoint/2]).
-export([post_account_persons/1, post_account_persons/2]).
-export([get_account_persons/1, get_account_persons/2]).
-export([get_account_capabilities/1, get_account_capabilities/2]).
-export([post_checkout_sessions_session_expire/1,
         post_checkout_sessions_session_expire/2]).
-export([get_bitcoin_receivers_receiver_transactions/1,
         get_bitcoin_receivers_receiver_transactions/2]).
-export([post_quotes_quote/1, post_quotes_quote/2]).
-export([get_quotes_quote/1, get_quotes_quote/2]).
-export([post_account_people/1, post_account_people/2]).
-export([get_account_people/1, get_account_people/2]).
-export([post_setup_intents_intent_confirm/1, post_setup_intents_intent_confirm/2]).
-export([post_customers_customer_cards/1, post_customers_customer_cards/2]).
-export([get_customers_customer_cards/1, get_customers_customer_cards/2]).
-export([get_identity_verification_reports/1, get_identity_verification_reports/2]).
-export([post_accounts_account_persons/1, post_accounts_account_persons/2]).
-export([get_accounts_account_persons/1, get_accounts_account_persons/2]).
-export([post_application_fees_id_refund/1, post_application_fees_id_refund/2]).
-export([post_payment_intents/1, post_payment_intents/2]).
-export([get_payment_intents/1, get_payment_intents/2]).
-export([post_skus/1, post_skus/2]).
-export([get_skus/1, get_skus/2]).
-export([post_webhook_endpoints/1, post_webhook_endpoints/2]).
-export([get_webhook_endpoints/1, get_webhook_endpoints/2]).
-export([get_balance/1, get_balance/2]).
-export([post_customers_customer_balance_transactions_transaction/1,
         post_customers_customer_balance_transactions_transaction/2]).
-export([get_customers_customer_balance_transactions_transaction/1,
         get_customers_customer_balance_transactions_transaction/2]).
-export([post_payment_methods_payment_method/1, post_payment_methods_payment_method/2]).
-export([get_payment_methods_payment_method/1, get_payment_methods_payment_method/2]).
-export([post_topups_topup_cancel/1, post_topups_topup_cancel/2]).
-export([get_events/1, get_events/2]).
-export([post_charges_charge_refunds_refund/1, post_charges_charge_refunds_refund/2]).
-export([get_charges_charge_refunds_refund/1, get_charges_charge_refunds_refund/2]).
-export([post_accounts_account_capabilities_capability/1,
         post_accounts_account_capabilities_capability/2]).
-export([get_accounts_account_capabilities_capability/1,
         get_accounts_account_capabilities_capability/2]).
-export([post_subscription_items/1, post_subscription_items/2]).
-export([get_subscription_items/1, get_subscription_items/2]).
-export([get_quotes_quote_pdf/1, get_quotes_quote_pdf/2]).
-export([delete_account_bank_accounts_id/1, delete_account_bank_accounts_id/2]).
-export([post_account_bank_accounts_id/1, post_account_bank_accounts_id/2]).
-export([get_account_bank_accounts_id/1, get_account_bank_accounts_id/2]).
-export([get_payment_links_payment_link_line_items/1,
         get_payment_links_payment_link_line_items/2]).
-export([get_subscription_items_subscription_item_usage_record_summaries/1,
         get_subscription_items_subscription_item_usage_record_summaries/2]).
-export([post_payment_intents_intent/1, post_payment_intents_intent/2]).
-export([get_payment_intents_intent/1, get_payment_intents_intent/2]).
-export([post_charges/1, post_charges/2]).
-export([get_charges/1, get_charges/2]).
-export([post_accounts_account_external_accounts/1,
         post_accounts_account_external_accounts/2]).
-export([get_accounts_account_external_accounts/1,
         get_accounts_account_external_accounts/2]).
-export([get_issuing_authorizations/1, get_issuing_authorizations/2]).
-export([delete_products_id/1, delete_products_id/2]).
-export([post_products_id/1, post_products_id/2]).
-export([get_products_id/1, get_products_id/2]).
-export([post_setup_intents_intent_verify_microdeposits/1,
         post_setup_intents_intent_verify_microdeposits/2]).
-export([get_reporting_report_types/1, get_reporting_report_types/2]).
-export([post_account_external_accounts/1, post_account_external_accounts/2]).
-export([get_account_external_accounts/1, get_account_external_accounts/2]).
-export([post_radar_value_lists/1, post_radar_value_lists/2]).
-export([get_radar_value_lists/1, get_radar_value_lists/2]).
-export([post_shipping_rates/1, post_shipping_rates/2]).
-export([get_shipping_rates/1, get_shipping_rates/2]).
-export([post_file_links_link/1, post_file_links_link/2]).
-export([get_file_links_link/1, get_file_links_link/2]).
-export([get3d_secure_three_d_secure/1, get3d_secure_three_d_secure/2]).
-export([post_invoices_invoice_send/1, post_invoices_invoice_send/2]).
-export([get_invoices_upcoming/1, get_invoices_upcoming/2]).
-export([get_checkout_sessions_session_line_items/1,
         get_checkout_sessions_session_line_items/2]).
-export([get_tax_codes/1, get_tax_codes/2]).
-export([post_invoices/1, post_invoices/2]).
-export([get_invoices/1, get_invoices/2]).
-export([post_charges_charge/1, post_charges_charge/2]).
-export([get_charges_charge/1, get_charges_charge/2]).
-export([post_invoices_invoice_mark_uncollectible/1,
         post_invoices_invoice_mark_uncollectible/2]).
-export([post_customers_customer_sources_id_verify/1,
         post_customers_customer_sources_id_verify/2]).
-export([post_orders_id_pay/1, post_orders_id_pay/2]).
-export([post_customers_customer_bank_accounts_id_verify/1,
         post_customers_customer_bank_accounts_id_verify/2]).
-export([delete_account_people_person/1, delete_account_people_person/2]).
-export([post_account_people_person/1, post_account_people_person/2]).
-export([get_account_people_person/1, get_account_people_person/2]).
-export([post_checkout_sessions/1, post_checkout_sessions/2]).
-export([get_checkout_sessions/1, get_checkout_sessions/2]).
-export([post_accounts_account_login_links/1, post_accounts_account_login_links/2]).
-export([post_terminal_readers/1, post_terminal_readers/2]).
-export([get_terminal_readers/1, get_terminal_readers/2]).
-export([post_issuing_disputes/1, post_issuing_disputes/2]).
-export([get_issuing_disputes/1, get_issuing_disputes/2]).
-export([post3d_secure/1, post3d_secure/2]).
-export([post_prices/1, post_prices/2]).
-export([get_prices/1, get_prices/2]).
-export([delete_invoices_invoice/1, delete_invoices_invoice/2]).
-export([post_invoices_invoice/1, post_invoices_invoice/2]).
-export([get_invoices_invoice/1, get_invoices_invoice/2]).
-export([post_identity_verification_sessions_session/1,
         post_identity_verification_sessions_session/2]).
-export([get_identity_verification_sessions_session/1,
         get_identity_verification_sessions_session/2]).
-export([get_balance_transactions_id/1, get_balance_transactions_id/2]).
-export([post_setup_intents_intent_cancel/1, post_setup_intents_intent_cancel/2]).
-export([post_issuing_transactions_transaction/1,
         post_issuing_transactions_transaction/2]).
-export([get_issuing_transactions_transaction/1, get_issuing_transactions_transaction/2]).
-export([post_terminal_connection_tokens/1, post_terminal_connection_tokens/2]).
-export([get_reviews/1, get_reviews/2]).
-export([post_promotion_codes/1, post_promotion_codes/2]).
-export([get_promotion_codes/1, get_promotion_codes/2]).
-export([delete_customers_customer_subscriptions_subscription_exposed_id_discount/1,
         delete_customers_customer_subscriptions_subscription_exposed_id_discount/2]).
-export([get_customers_customer_subscriptions_subscription_exposed_id_discount/1,
         get_customers_customer_subscriptions_subscription_exposed_id_discount/2]).
-export([get_quotes_quote_computed_upfront_line_items/1,
         get_quotes_quote_computed_upfront_line_items/2]).
-export([delete_radar_value_list_items_item/1, delete_radar_value_list_items_item/2]).
-export([get_radar_value_list_items_item/1, get_radar_value_list_items_item/2]).
-export([get_issuer_fraud_records/1, get_issuer_fraud_records/2]).
-export([post_tax_rates_tax_rate/1, post_tax_rates_tax_rate/2]).
-export([get_tax_rates_tax_rate/1, get_tax_rates_tax_rate/2]).
-export([post_recipients/1, post_recipients/2]).
-export([get_recipients/1, get_recipients/2]).
-export([post_plans/1, post_plans/2]).
-export([get_plans/1, get_plans/2]).
-export([post_customers_customer_balance_transactions/1,
         post_customers_customer_balance_transactions/2]).
-export([get_customers_customer_balance_transactions/1,
         get_customers_customer_balance_transactions/2]).
-export([post_reviews_review_approve/1, post_reviews_review_approve/2]).
-export([post_customers_customer_tax_ids/1, post_customers_customer_tax_ids/2]).
-export([get_customers_customer_tax_ids/1, get_customers_customer_tax_ids/2]).
-export([get_tokens_token/1, get_tokens_token/2]).
-export([get_balance_transactions/1, get_balance_transactions/2]).
-export([get_tax_codes_id/1, get_tax_codes_id/2]).
-export([post_accounts_account_reject/1, post_accounts_account_reject/2]).
-export([delete_subscriptions_subscription_exposed_id/1,
         delete_subscriptions_subscription_exposed_id/2]).
-export([post_subscriptions_subscription_exposed_id/1,
         post_subscriptions_subscription_exposed_id/2]).
-export([get_subscriptions_subscription_exposed_id/1,
         get_subscriptions_subscription_exposed_id/2]).
-export([get_country_specs_country/1, get_country_specs_country/2]).
-export([post_invoices_invoice_finalize/1, post_invoices_invoice_finalize/2]).
-export([delete_terminal_locations_location/1, delete_terminal_locations_location/2]).
-export([post_terminal_locations_location/1, post_terminal_locations_location/2]).
-export([get_terminal_locations_location/1, get_terminal_locations_location/2]).
-export([delete_account/1, delete_account/2]).
-export([post_account/1, post_account/2]).
-export([get_account/1, get_account/2]).
-export([post_shipping_rates_shipping_rate_token/1,
         post_shipping_rates_shipping_rate_token/2]).
-export([get_shipping_rates_shipping_rate_token/1,
         get_shipping_rates_shipping_rate_token/2]).
-export([get_invoices_upcoming_lines/1, get_invoices_upcoming_lines/2]).
-export([post_issuing_cardholders/1, post_issuing_cardholders/2]).
-export([get_issuing_cardholders/1, get_issuing_cardholders/2]).
-export([delete_customers_customer_sources_id/1, delete_customers_customer_sources_id/2]).
-export([post_customers_customer_sources_id/1, post_customers_customer_sources_id/2]).
-export([get_customers_customer_sources_id/1, get_customers_customer_sources_id/2]).
-export([get_application_fees/1, get_application_fees/2]).
-export([get_bitcoin_receivers/1, get_bitcoin_receivers/2]).
-export([post_refunds_refund/1, post_refunds_refund/2]).
-export([get_refunds_refund/1, get_refunds_refund/2]).
-export([post_account_login_links/1, post_account_login_links/2]).
-export([post_tax_rates/1, post_tax_rates/2]).
-export([get_tax_rates/1, get_tax_rates/2]).
-export([post_accounts_account_people/1, post_accounts_account_people/2]).
-export([get_accounts_account_people/1, get_accounts_account_people/2]).
-export([post_issuing_disputes_dispute_submit/1, post_issuing_disputes_dispute_submit/2]).
-export([post_sources_source/1, post_sources_source/2]).
-export([get_sources_source/1, get_sources_source/2]).
-export([get_checkout_sessions_session/1, get_checkout_sessions_session/2]).
-export([post_payment_methods_payment_method_detach/1,
         post_payment_methods_payment_method_detach/2]).
-export([post_customers/1, post_customers/2]).
-export([get_customers/1, get_customers/2]).
-export([post_account_bank_accounts/1, post_account_bank_accounts/2]).
-export([post_issuing_disputes_dispute/1, post_issuing_disputes_dispute/2]).
-export([get_issuing_disputes_dispute/1, get_issuing_disputes_dispute/2]).
-export([post_disputes_dispute_close/1, post_disputes_dispute_close/2]).
-export([post_quotes_quote_cancel/1, post_quotes_quote_cancel/2]).
-export([get_customers_customer_payment_methods/1,
         get_customers_customer_payment_methods/2]).
-export([post_refunds/1, post_refunds/2]).
-export([get_refunds/1, get_refunds/2]).
-export([post_credit_notes_id/1, post_credit_notes_id/2]).
-export([get_credit_notes_id/1, get_credit_notes_id/2]).
-export([get_bitcoin_transactions/1, get_bitcoin_transactions/2]).
-export([post_setup_intents/1, post_setup_intents/2]).
-export([get_setup_intents/1, get_setup_intents/2]).
-export([post_payouts_payout_cancel/1, post_payouts_payout_cancel/2]).
-export([post_issuing_authorizations_authorization_approve/1,
         post_issuing_authorizations_authorization_approve/2]).
-export([post_issuing_authorizations_authorization_decline/1,
         post_issuing_authorizations_authorization_decline/2]).
-export([post_reporting_report_runs/1, post_reporting_report_runs/2]).
-export([get_reporting_report_runs/1, get_reporting_report_runs/2]).
-export([post_invoices_invoice_void/1, post_invoices_invoice_void/2]).
-export([post_sources/1, post_sources/2]).
-export([post_billing_portal_configurations/1, post_billing_portal_configurations/2]).
-export([get_billing_portal_configurations/1, get_billing_portal_configurations/2]).
-export([post_quotes/1, post_quotes/2]).
-export([get_quotes/1, get_quotes/2]).
-export([post_transfers_transfer/1, post_transfers_transfer/2]).
-export([get_transfers_transfer/1, get_transfers_transfer/2]).
-export([get_quotes_quote_line_items/1, get_quotes_quote_line_items/2]).
-export([delete_invoiceitems_invoiceitem/1, delete_invoiceitems_invoiceitem/2]).
-export([post_invoiceitems_invoiceitem/1, post_invoiceitems_invoiceitem/2]).
-export([get_invoiceitems_invoiceitem/1, get_invoiceitems_invoiceitem/2]).
-export([post_payment_intents_intent_capture/1, post_payment_intents_intent_capture/2]).
-export([post_issuing_cards/1, post_issuing_cards/2]).
-export([get_issuing_cards/1, get_issuing_cards/2]).
-export([get_sources_source_source_transactions/1,
         get_sources_source_source_transactions/2]).
-export([post_subscription_schedules_schedule_release/1,
         post_subscription_schedules_schedule_release/2]).
-export([delete_customers_customer_cards_id/1, delete_customers_customer_cards_id/2]).
-export([post_customers_customer_cards_id/1, post_customers_customer_cards_id/2]).
-export([get_customers_customer_cards_id/1, get_customers_customer_cards_id/2]).
-export([post_charges_charge_dispute/1, post_charges_charge_dispute/2]).
-export([get_charges_charge_dispute/1, get_charges_charge_dispute/2]).
-export([post_quotes_quote_finalize/1, post_quotes_quote_finalize/2]).
-export([delete_skus_id/1, delete_skus_id/2]).
-export([post_skus_id/1, post_skus_id/2]).
-export([get_skus_id/1, get_skus_id/2]).
-export([post_disputes_dispute/1, post_disputes_dispute/2]).
-export([get_disputes_dispute/1, get_disputes_dispute/2]).
-export([post_terminal_locations/1, post_terminal_locations/2]).
-export([get_terminal_locations/1, get_terminal_locations/2]).
-export([post_subscription_schedules/1, post_subscription_schedules/2]).
-export([get_subscription_schedules/1, get_subscription_schedules/2]).
-export([post_payment_links/1, post_payment_links/2]).
-export([get_payment_links/1, get_payment_links/2]).
-export([post_tokens/1, post_tokens/2]).
-export([post_issuing_cardholders_cardholder/1, post_issuing_cardholders_cardholder/2]).
-export([get_issuing_cardholders_cardholder/1, get_issuing_cardholders_cardholder/2]).
-export([get_application_fees_id/1, get_application_fees_id/2]).
-export([get_exchange_rates_rate_id/1, get_exchange_rates_rate_id/2]).
-export([post_payment_intents_intent_confirm/1, post_payment_intents_intent_confirm/2]).
-export([get_credit_notes_preview/1, get_credit_notes_preview/2]).
-export([get_balance_history_id/1, get_balance_history_id/2]).
-export([post_payouts_payout_reverse/1, post_payouts_payout_reverse/2]).
-export([get_reporting_report_runs_report_run/1, get_reporting_report_runs_report_run/2]).
-export([get_sources_source_source_transactions_source_transaction/1,
         get_sources_source_source_transactions_source_transaction/2]).
-export([delete_customers_customer/1, delete_customers_customer/2]).
-export([post_customers_customer/1, post_customers_customer/2]).
-export([get_customers_customer/1, get_customers_customer/2]).
-export([post_billing_portal_sessions/1, post_billing_portal_sessions/2]).
-export([post_payment_links_payment_link/1, post_payment_links_payment_link/2]).
-export([get_payment_links_payment_link/1, get_payment_links_payment_link/2]).
-export([get_credit_notes_credit_note_lines/1, get_credit_notes_credit_note_lines/2]).
-export([get_sigma_scheduled_query_runs/1, get_sigma_scheduled_query_runs/2]).

-export_type([options/0, result/1, error_reason/0]).
-export_type([get_radar_early_fraud_warnings_request/0,
              get_radar_early_fraud_warnings_request_query/0,
              get_radar_early_fraud_warnings_request_header/0,
              get_radar_early_fraud_warnings_request_cookie/0,
              get_radar_early_fraud_warnings_request_body/0,
              get_radar_early_fraud_warnings_response/0]).
-export_type([post_charges_charge_refunds_request/0,
              post_charges_charge_refunds_request_query/0,
              post_charges_charge_refunds_request_header/0,
              post_charges_charge_refunds_request_cookie/0,
              post_charges_charge_refunds_request_body/0, post_charges_charge_refunds_response/0]).
-export_type([get_charges_charge_refunds_request/0,
              get_charges_charge_refunds_request_query/0,
              get_charges_charge_refunds_request_header/0,
              get_charges_charge_refunds_request_cookie/0,
              get_charges_charge_refunds_request_body/0, get_charges_charge_refunds_response/0]).
-export_type([post_identity_verification_sessions_session_redact_request/0,
              post_identity_verification_sessions_session_redact_request_query/0,
              post_identity_verification_sessions_session_redact_request_header/0,
              post_identity_verification_sessions_session_redact_request_cookie/0,
              post_identity_verification_sessions_session_redact_request_body/0,
              post_identity_verification_sessions_session_redact_response/0]).
-export_type([post_billing_portal_configurations_configuration_request/0,
              post_billing_portal_configurations_configuration_request_query/0,
              post_billing_portal_configurations_configuration_request_header/0,
              post_billing_portal_configurations_configuration_request_cookie/0,
              post_billing_portal_configurations_configuration_request_body/0,
              post_billing_portal_configurations_configuration_response/0]).
-export_type([get_billing_portal_configurations_configuration_request/0,
              get_billing_portal_configurations_configuration_request_query/0,
              get_billing_portal_configurations_configuration_request_header/0,
              get_billing_portal_configurations_configuration_request_cookie/0,
              get_billing_portal_configurations_configuration_request_body/0,
              get_billing_portal_configurations_configuration_response/0]).
-export_type([post_payment_methods_request/0, post_payment_methods_request_query/0,
              post_payment_methods_request_header/0, post_payment_methods_request_cookie/0,
              post_payment_methods_request_body/0, post_payment_methods_response/0]).
-export_type([get_payment_methods_request/0, get_payment_methods_request_query/0,
              get_payment_methods_request_header/0, get_payment_methods_request_cookie/0,
              get_payment_methods_request_body/0, get_payment_methods_response/0]).
-export_type([delete_radar_value_lists_value_list_request/0,
              delete_radar_value_lists_value_list_request_query/0,
              delete_radar_value_lists_value_list_request_header/0,
              delete_radar_value_lists_value_list_request_cookie/0,
              delete_radar_value_lists_value_list_request_body/0,
              delete_radar_value_lists_value_list_response/0]).
-export_type([post_radar_value_lists_value_list_request/0,
              post_radar_value_lists_value_list_request_query/0,
              post_radar_value_lists_value_list_request_header/0,
              post_radar_value_lists_value_list_request_cookie/0,
              post_radar_value_lists_value_list_request_body/0,
              post_radar_value_lists_value_list_response/0]).
-export_type([get_radar_value_lists_value_list_request/0,
              get_radar_value_lists_value_list_request_query/0,
              get_radar_value_lists_value_list_request_header/0,
              get_radar_value_lists_value_list_request_cookie/0,
              get_radar_value_lists_value_list_request_body/0,
              get_radar_value_lists_value_list_response/0]).
-export_type([post_charges_charge_capture_request/0,
              post_charges_charge_capture_request_query/0,
              post_charges_charge_capture_request_header/0,
              post_charges_charge_capture_request_cookie/0,
              post_charges_charge_capture_request_body/0, post_charges_charge_capture_response/0]).
-export_type([get_disputes_request/0, get_disputes_request_query/0,
              get_disputes_request_header/0, get_disputes_request_cookie/0,
              get_disputes_request_body/0, get_disputes_response/0]).
-export_type([post_prices_price_request/0, post_prices_price_request_query/0,
              post_prices_price_request_header/0, post_prices_price_request_cookie/0,
              post_prices_price_request_body/0, post_prices_price_response/0]).
-export_type([get_prices_price_request/0, get_prices_price_request_query/0,
              get_prices_price_request_header/0, get_prices_price_request_cookie/0,
              get_prices_price_request_body/0, get_prices_price_response/0]).
-export_type([post_accounts_request/0, post_accounts_request_query/0,
              post_accounts_request_header/0, post_accounts_request_cookie/0,
              post_accounts_request_body/0, post_accounts_response/0]).
-export_type([get_accounts_request/0, get_accounts_request_query/0,
              get_accounts_request_header/0, get_accounts_request_cookie/0,
              get_accounts_request_body/0, get_accounts_response/0]).
-export_type([post_identity_verification_sessions_session_cancel_request/0,
              post_identity_verification_sessions_session_cancel_request_query/0,
              post_identity_verification_sessions_session_cancel_request_header/0,
              post_identity_verification_sessions_session_cancel_request_cookie/0,
              post_identity_verification_sessions_session_cancel_request_body/0,
              post_identity_verification_sessions_session_cancel_response/0]).
-export_type([delete_account_persons_person_request/0,
              delete_account_persons_person_request_query/0,
              delete_account_persons_person_request_header/0,
              delete_account_persons_person_request_cookie/0,
              delete_account_persons_person_request_body/0,
              delete_account_persons_person_response/0]).
-export_type([post_account_persons_person_request/0,
              post_account_persons_person_request_query/0,
              post_account_persons_person_request_header/0,
              post_account_persons_person_request_cookie/0,
              post_account_persons_person_request_body/0, post_account_persons_person_response/0]).
-export_type([get_account_persons_person_request/0,
              get_account_persons_person_request_query/0,
              get_account_persons_person_request_header/0,
              get_account_persons_person_request_cookie/0,
              get_account_persons_person_request_body/0, get_account_persons_person_response/0]).
-export_type([post_issuing_authorizations_authorization_request/0,
              post_issuing_authorizations_authorization_request_query/0,
              post_issuing_authorizations_authorization_request_header/0,
              post_issuing_authorizations_authorization_request_cookie/0,
              post_issuing_authorizations_authorization_request_body/0,
              post_issuing_authorizations_authorization_response/0]).
-export_type([get_issuing_authorizations_authorization_request/0,
              get_issuing_authorizations_authorization_request_query/0,
              get_issuing_authorizations_authorization_request_header/0,
              get_issuing_authorizations_authorization_request_cookie/0,
              get_issuing_authorizations_authorization_request_body/0,
              get_issuing_authorizations_authorization_response/0]).
-export_type([get_files_file_request/0, get_files_file_request_query/0,
              get_files_file_request_header/0, get_files_file_request_cookie/0,
              get_files_file_request_body/0, get_files_file_response/0]).
-export_type([post_issuing_cards_card_request/0, post_issuing_cards_card_request_query/0,
              post_issuing_cards_card_request_header/0, post_issuing_cards_card_request_cookie/0,
              post_issuing_cards_card_request_body/0, post_issuing_cards_card_response/0]).
-export_type([get_issuing_cards_card_request/0, get_issuing_cards_card_request_query/0,
              get_issuing_cards_card_request_header/0, get_issuing_cards_card_request_cookie/0,
              get_issuing_cards_card_request_body/0, get_issuing_cards_card_response/0]).
-export_type([post_sources_source_verify_request/0,
              post_sources_source_verify_request_query/0,
              post_sources_source_verify_request_header/0,
              post_sources_source_verify_request_cookie/0,
              post_sources_source_verify_request_body/0, post_sources_source_verify_response/0]).
-export_type([post_invoiceitems_request/0, post_invoiceitems_request_query/0,
              post_invoiceitems_request_header/0, post_invoiceitems_request_cookie/0,
              post_invoiceitems_request_body/0, post_invoiceitems_response/0]).
-export_type([get_invoiceitems_request/0, get_invoiceitems_request_query/0,
              get_invoiceitems_request_header/0, get_invoiceitems_request_cookie/0,
              get_invoiceitems_request_body/0, get_invoiceitems_response/0]).
-export_type([delete_ephemeral_keys_key_request/0,
              delete_ephemeral_keys_key_request_query/0, delete_ephemeral_keys_key_request_header/0,
              delete_ephemeral_keys_key_request_cookie/0, delete_ephemeral_keys_key_request_body/0,
              delete_ephemeral_keys_key_response/0]).
-export_type([get_exchange_rates_request/0, get_exchange_rates_request_query/0,
              get_exchange_rates_request_header/0, get_exchange_rates_request_cookie/0,
              get_exchange_rates_request_body/0, get_exchange_rates_response/0]).
-export_type([post_setup_intents_intent_request/0,
              post_setup_intents_intent_request_query/0, post_setup_intents_intent_request_header/0,
              post_setup_intents_intent_request_cookie/0, post_setup_intents_intent_request_body/0,
              post_setup_intents_intent_response/0]).
-export_type([get_setup_intents_intent_request/0,
              get_setup_intents_intent_request_query/0, get_setup_intents_intent_request_header/0,
              get_setup_intents_intent_request_cookie/0, get_setup_intents_intent_request_body/0,
              get_setup_intents_intent_response/0]).
-export_type([post_files_request/0, post_files_request_query/0,
              post_files_request_header/0, post_files_request_cookie/0, post_files_request_body/0,
              post_files_response/0]).
-export_type([get_files_request/0, get_files_request_query/0, get_files_request_header/0,
              get_files_request_cookie/0, get_files_request_body/0, get_files_response/0]).
-export_type([delete_customers_customer_bank_accounts_id_request/0,
              delete_customers_customer_bank_accounts_id_request_query/0,
              delete_customers_customer_bank_accounts_id_request_header/0,
              delete_customers_customer_bank_accounts_id_request_cookie/0,
              delete_customers_customer_bank_accounts_id_request_body/0,
              delete_customers_customer_bank_accounts_id_response/0]).
-export_type([post_customers_customer_bank_accounts_id_request/0,
              post_customers_customer_bank_accounts_id_request_query/0,
              post_customers_customer_bank_accounts_id_request_header/0,
              post_customers_customer_bank_accounts_id_request_cookie/0,
              post_customers_customer_bank_accounts_id_request_body/0,
              post_customers_customer_bank_accounts_id_response/0]).
-export_type([get_customers_customer_bank_accounts_id_request/0,
              get_customers_customer_bank_accounts_id_request_query/0,
              get_customers_customer_bank_accounts_id_request_header/0,
              get_customers_customer_bank_accounts_id_request_cookie/0,
              get_customers_customer_bank_accounts_id_request_body/0,
              get_customers_customer_bank_accounts_id_response/0]).
-export_type([get_issuer_fraud_records_issuer_fraud_record_request/0,
              get_issuer_fraud_records_issuer_fraud_record_request_query/0,
              get_issuer_fraud_records_issuer_fraud_record_request_header/0,
              get_issuer_fraud_records_issuer_fraud_record_request_cookie/0,
              get_issuer_fraud_records_issuer_fraud_record_request_body/0,
              get_issuer_fraud_records_issuer_fraud_record_response/0]).
-export_type([delete_accounts_account_people_person_request/0,
              delete_accounts_account_people_person_request_query/0,
              delete_accounts_account_people_person_request_header/0,
              delete_accounts_account_people_person_request_cookie/0,
              delete_accounts_account_people_person_request_body/0,
              delete_accounts_account_people_person_response/0]).
-export_type([post_accounts_account_people_person_request/0,
              post_accounts_account_people_person_request_query/0,
              post_accounts_account_people_person_request_header/0,
              post_accounts_account_people_person_request_cookie/0,
              post_accounts_account_people_person_request_body/0,
              post_accounts_account_people_person_response/0]).
-export_type([get_accounts_account_people_person_request/0,
              get_accounts_account_people_person_request_query/0,
              get_accounts_account_people_person_request_header/0,
              get_accounts_account_people_person_request_cookie/0,
              get_accounts_account_people_person_request_body/0,
              get_accounts_account_people_person_response/0]).
-export_type([post_payouts_request/0, post_payouts_request_query/0,
              post_payouts_request_header/0, post_payouts_request_cookie/0,
              post_payouts_request_body/0, post_payouts_response/0]).
-export_type([get_payouts_request/0, get_payouts_request_query/0,
              get_payouts_request_header/0, get_payouts_request_cookie/0,
              get_payouts_request_body/0, get_payouts_response/0]).
-export_type([post_account_capabilities_capability_request/0,
              post_account_capabilities_capability_request_query/0,
              post_account_capabilities_capability_request_header/0,
              post_account_capabilities_capability_request_cookie/0,
              post_account_capabilities_capability_request_body/0,
              post_account_capabilities_capability_response/0]).
-export_type([get_account_capabilities_capability_request/0,
              get_account_capabilities_capability_request_query/0,
              get_account_capabilities_capability_request_header/0,
              get_account_capabilities_capability_request_cookie/0,
              get_account_capabilities_capability_request_body/0,
              get_account_capabilities_capability_response/0]).
-export_type([get_sources_source_mandate_notifications_mandate_notification_request/0,
              get_sources_source_mandate_notifications_mandate_notification_request_query/0,
              get_sources_source_mandate_notifications_mandate_notification_request_header/0,
              get_sources_source_mandate_notifications_mandate_notification_request_cookie/0,
              get_sources_source_mandate_notifications_mandate_notification_request_body/0,
              get_sources_source_mandate_notifications_mandate_notification_response/0]).
-export_type([post_application_fees_fee_refunds_id_request/0,
              post_application_fees_fee_refunds_id_request_query/0,
              post_application_fees_fee_refunds_id_request_header/0,
              post_application_fees_fee_refunds_id_request_cookie/0,
              post_application_fees_fee_refunds_id_request_body/0,
              post_application_fees_fee_refunds_id_response/0]).
-export_type([get_application_fees_fee_refunds_id_request/0,
              get_application_fees_fee_refunds_id_request_query/0,
              get_application_fees_fee_refunds_id_request_header/0,
              get_application_fees_fee_refunds_id_request_cookie/0,
              get_application_fees_fee_refunds_id_request_body/0,
              get_application_fees_fee_refunds_id_response/0]).
-export_type([delete_customers_customer_discount_request/0,
              delete_customers_customer_discount_request_query/0,
              delete_customers_customer_discount_request_header/0,
              delete_customers_customer_discount_request_cookie/0,
              delete_customers_customer_discount_request_body/0,
              delete_customers_customer_discount_response/0]).
-export_type([get_customers_customer_discount_request/0,
              get_customers_customer_discount_request_query/0,
              get_customers_customer_discount_request_header/0,
              get_customers_customer_discount_request_cookie/0,
              get_customers_customer_discount_request_body/0,
              get_customers_customer_discount_response/0]).
-export_type([post_coupons_request/0, post_coupons_request_query/0,
              post_coupons_request_header/0, post_coupons_request_cookie/0,
              post_coupons_request_body/0, post_coupons_response/0]).
-export_type([get_coupons_request/0, get_coupons_request_query/0,
              get_coupons_request_header/0, get_coupons_request_cookie/0,
              get_coupons_request_body/0, get_coupons_response/0]).
-export_type([post_charges_charge_dispute_close_request/0,
              post_charges_charge_dispute_close_request_query/0,
              post_charges_charge_dispute_close_request_header/0,
              post_charges_charge_dispute_close_request_cookie/0,
              post_charges_charge_dispute_close_request_body/0,
              post_charges_charge_dispute_close_response/0]).
-export_type([delete_plans_plan_request/0, delete_plans_plan_request_query/0,
              delete_plans_plan_request_header/0, delete_plans_plan_request_cookie/0,
              delete_plans_plan_request_body/0, delete_plans_plan_response/0]).
-export_type([post_plans_plan_request/0, post_plans_plan_request_query/0,
              post_plans_plan_request_header/0, post_plans_plan_request_cookie/0,
              post_plans_plan_request_body/0, post_plans_plan_response/0]).
-export_type([get_plans_plan_request/0, get_plans_plan_request_query/0,
              get_plans_plan_request_header/0, get_plans_plan_request_cookie/0,
              get_plans_plan_request_body/0, get_plans_plan_response/0]).
-export_type([post_customers_customer_bank_accounts_request/0,
              post_customers_customer_bank_accounts_request_query/0,
              post_customers_customer_bank_accounts_request_header/0,
              post_customers_customer_bank_accounts_request_cookie/0,
              post_customers_customer_bank_accounts_request_body/0,
              post_customers_customer_bank_accounts_response/0]).
-export_type([get_customers_customer_bank_accounts_request/0,
              get_customers_customer_bank_accounts_request_query/0,
              get_customers_customer_bank_accounts_request_header/0,
              get_customers_customer_bank_accounts_request_cookie/0,
              get_customers_customer_bank_accounts_request_body/0,
              get_customers_customer_bank_accounts_response/0]).
-export_type([delete_terminal_readers_reader_request/0,
              delete_terminal_readers_reader_request_query/0,
              delete_terminal_readers_reader_request_header/0,
              delete_terminal_readers_reader_request_cookie/0,
              delete_terminal_readers_reader_request_body/0,
              delete_terminal_readers_reader_response/0]).
-export_type([post_terminal_readers_reader_request/0,
              post_terminal_readers_reader_request_query/0,
              post_terminal_readers_reader_request_header/0,
              post_terminal_readers_reader_request_cookie/0,
              post_terminal_readers_reader_request_body/0,
              post_terminal_readers_reader_response/0]).
-export_type([get_terminal_readers_reader_request/0,
              get_terminal_readers_reader_request_query/0,
              get_terminal_readers_reader_request_header/0,
              get_terminal_readers_reader_request_cookie/0,
              get_terminal_readers_reader_request_body/0, get_terminal_readers_reader_response/0]).
-export_type([delete_accounts_account_persons_person_request/0,
              delete_accounts_account_persons_person_request_query/0,
              delete_accounts_account_persons_person_request_header/0,
              delete_accounts_account_persons_person_request_cookie/0,
              delete_accounts_account_persons_person_request_body/0,
              delete_accounts_account_persons_person_response/0]).
-export_type([post_accounts_account_persons_person_request/0,
              post_accounts_account_persons_person_request_query/0,
              post_accounts_account_persons_person_request_header/0,
              post_accounts_account_persons_person_request_cookie/0,
              post_accounts_account_persons_person_request_body/0,
              post_accounts_account_persons_person_response/0]).
-export_type([get_accounts_account_persons_person_request/0,
              get_accounts_account_persons_person_request_query/0,
              get_accounts_account_persons_person_request_header/0,
              get_accounts_account_persons_person_request_cookie/0,
              get_accounts_account_persons_person_request_body/0,
              get_accounts_account_persons_person_response/0]).
-export_type([post_credit_notes_id_void_request/0,
              post_credit_notes_id_void_request_query/0, post_credit_notes_id_void_request_header/0,
              post_credit_notes_id_void_request_cookie/0, post_credit_notes_id_void_request_body/0,
              post_credit_notes_id_void_response/0]).
-export_type([post_customers_customer_sources_request/0,
              post_customers_customer_sources_request_query/0,
              post_customers_customer_sources_request_header/0,
              post_customers_customer_sources_request_cookie/0,
              post_customers_customer_sources_request_body/0,
              post_customers_customer_sources_response/0]).
-export_type([get_customers_customer_sources_request/0,
              get_customers_customer_sources_request_query/0,
              get_customers_customer_sources_request_header/0,
              get_customers_customer_sources_request_cookie/0,
              get_customers_customer_sources_request_body/0,
              get_customers_customer_sources_response/0]).
-export_type([post_account_links_request/0, post_account_links_request_query/0,
              post_account_links_request_header/0, post_account_links_request_cookie/0,
              post_account_links_request_body/0, post_account_links_response/0]).
-export_type([post_payouts_payout_request/0, post_payouts_payout_request_query/0,
              post_payouts_payout_request_header/0, post_payouts_payout_request_cookie/0,
              post_payouts_payout_request_body/0, post_payouts_payout_response/0]).
-export_type([get_payouts_payout_request/0, get_payouts_payout_request_query/0,
              get_payouts_payout_request_header/0, get_payouts_payout_request_cookie/0,
              get_payouts_payout_request_body/0, get_payouts_payout_response/0]).
-export_type([delete_subscription_items_item_request/0,
              delete_subscription_items_item_request_query/0,
              delete_subscription_items_item_request_header/0,
              delete_subscription_items_item_request_cookie/0,
              delete_subscription_items_item_request_body/0,
              delete_subscription_items_item_response/0]).
-export_type([post_subscription_items_item_request/0,
              post_subscription_items_item_request_query/0,
              post_subscription_items_item_request_header/0,
              post_subscription_items_item_request_cookie/0,
              post_subscription_items_item_request_body/0,
              post_subscription_items_item_response/0]).
-export_type([get_subscription_items_item_request/0,
              get_subscription_items_item_request_query/0,
              get_subscription_items_item_request_header/0,
              get_subscription_items_item_request_cookie/0,
              get_subscription_items_item_request_body/0, get_subscription_items_item_response/0]).
-export_type([post_products_request/0, post_products_request_query/0,
              post_products_request_header/0, post_products_request_cookie/0,
              post_products_request_body/0, post_products_response/0]).
-export_type([get_products_request/0, get_products_request_query/0,
              get_products_request_header/0, get_products_request_cookie/0,
              get_products_request_body/0, get_products_response/0]).
-export_type([get_reporting_report_types_report_type_request/0,
              get_reporting_report_types_report_type_request_query/0,
              get_reporting_report_types_report_type_request_header/0,
              get_reporting_report_types_report_type_request_cookie/0,
              get_reporting_report_types_report_type_request_body/0,
              get_reporting_report_types_report_type_response/0]).
-export_type([post_quotes_quote_accept_request/0,
              post_quotes_quote_accept_request_query/0, post_quotes_quote_accept_request_header/0,
              post_quotes_quote_accept_request_cookie/0, post_quotes_quote_accept_request_body/0,
              post_quotes_quote_accept_response/0]).
-export_type([get_mandates_mandate_request/0, get_mandates_mandate_request_query/0,
              get_mandates_mandate_request_header/0, get_mandates_mandate_request_cookie/0,
              get_mandates_mandate_request_body/0, get_mandates_mandate_response/0]).
-export_type([post_customers_customer_subscriptions_request/0,
              post_customers_customer_subscriptions_request_query/0,
              post_customers_customer_subscriptions_request_header/0,
              post_customers_customer_subscriptions_request_cookie/0,
              post_customers_customer_subscriptions_request_body/0,
              post_customers_customer_subscriptions_response/0]).
-export_type([get_customers_customer_subscriptions_request/0,
              get_customers_customer_subscriptions_request_query/0,
              get_customers_customer_subscriptions_request_header/0,
              get_customers_customer_subscriptions_request_cookie/0,
              get_customers_customer_subscriptions_request_body/0,
              get_customers_customer_subscriptions_response/0]).
-export_type([get_order_returns_id_request/0, get_order_returns_id_request_query/0,
              get_order_returns_id_request_header/0, get_order_returns_id_request_cookie/0,
              get_order_returns_id_request_body/0, get_order_returns_id_response/0]).
-export_type([post_transfers_id_reversals_request/0,
              post_transfers_id_reversals_request_query/0,
              post_transfers_id_reversals_request_header/0,
              post_transfers_id_reversals_request_cookie/0,
              post_transfers_id_reversals_request_body/0, post_transfers_id_reversals_response/0]).
-export_type([get_transfers_id_reversals_request/0,
              get_transfers_id_reversals_request_query/0,
              get_transfers_id_reversals_request_header/0,
              get_transfers_id_reversals_request_cookie/0,
              get_transfers_id_reversals_request_body/0, get_transfers_id_reversals_response/0]).
-export_type([get_reviews_review_request/0, get_reviews_review_request_query/0,
              get_reviews_review_request_header/0, get_reviews_review_request_cookie/0,
              get_reviews_review_request_body/0, get_reviews_review_response/0]).
-export_type([delete_accounts_account_bank_accounts_id_request/0,
              delete_accounts_account_bank_accounts_id_request_query/0,
              delete_accounts_account_bank_accounts_id_request_header/0,
              delete_accounts_account_bank_accounts_id_request_cookie/0,
              delete_accounts_account_bank_accounts_id_request_body/0,
              delete_accounts_account_bank_accounts_id_response/0]).
-export_type([post_accounts_account_bank_accounts_id_request/0,
              post_accounts_account_bank_accounts_id_request_query/0,
              post_accounts_account_bank_accounts_id_request_header/0,
              post_accounts_account_bank_accounts_id_request_cookie/0,
              post_accounts_account_bank_accounts_id_request_body/0,
              post_accounts_account_bank_accounts_id_response/0]).
-export_type([get_accounts_account_bank_accounts_id_request/0,
              get_accounts_account_bank_accounts_id_request_query/0,
              get_accounts_account_bank_accounts_id_request_header/0,
              get_accounts_account_bank_accounts_id_request_cookie/0,
              get_accounts_account_bank_accounts_id_request_body/0,
              get_accounts_account_bank_accounts_id_response/0]).
-export_type([post_issuing_settlements_settlement_request/0,
              post_issuing_settlements_settlement_request_query/0,
              post_issuing_settlements_settlement_request_header/0,
              post_issuing_settlements_settlement_request_cookie/0,
              post_issuing_settlements_settlement_request_body/0,
              post_issuing_settlements_settlement_response/0]).
-export_type([get_issuing_settlements_settlement_request/0,
              get_issuing_settlements_settlement_request_query/0,
              get_issuing_settlements_settlement_request_header/0,
              get_issuing_settlements_settlement_request_cookie/0,
              get_issuing_settlements_settlement_request_body/0,
              get_issuing_settlements_settlement_response/0]).
-export_type([post_promotion_codes_promotion_code_request/0,
              post_promotion_codes_promotion_code_request_query/0,
              post_promotion_codes_promotion_code_request_header/0,
              post_promotion_codes_promotion_code_request_cookie/0,
              post_promotion_codes_promotion_code_request_body/0,
              post_promotion_codes_promotion_code_response/0]).
-export_type([get_promotion_codes_promotion_code_request/0,
              get_promotion_codes_promotion_code_request_query/0,
              get_promotion_codes_promotion_code_request_header/0,
              get_promotion_codes_promotion_code_request_cookie/0,
              get_promotion_codes_promotion_code_request_body/0,
              get_promotion_codes_promotion_code_response/0]).
-export_type([post_subscription_schedules_schedule_cancel_request/0,
              post_subscription_schedules_schedule_cancel_request_query/0,
              post_subscription_schedules_schedule_cancel_request_header/0,
              post_subscription_schedules_schedule_cancel_request_cookie/0,
              post_subscription_schedules_schedule_cancel_request_body/0,
              post_subscription_schedules_schedule_cancel_response/0]).
-export_type([post_identity_verification_sessions_request/0,
              post_identity_verification_sessions_request_query/0,
              post_identity_verification_sessions_request_header/0,
              post_identity_verification_sessions_request_cookie/0,
              post_identity_verification_sessions_request_body/0,
              post_identity_verification_sessions_response/0]).
-export_type([get_identity_verification_sessions_request/0,
              get_identity_verification_sessions_request_query/0,
              get_identity_verification_sessions_request_header/0,
              get_identity_verification_sessions_request_cookie/0,
              get_identity_verification_sessions_request_body/0,
              get_identity_verification_sessions_response/0]).
-export_type([post_radar_value_list_items_request/0,
              post_radar_value_list_items_request_query/0,
              post_radar_value_list_items_request_header/0,
              post_radar_value_list_items_request_cookie/0,
              post_radar_value_list_items_request_body/0, post_radar_value_list_items_response/0]).
-export_type([get_radar_value_list_items_request/0,
              get_radar_value_list_items_request_query/0,
              get_radar_value_list_items_request_header/0,
              get_radar_value_list_items_request_cookie/0,
              get_radar_value_list_items_request_body/0, get_radar_value_list_items_response/0]).
-export_type([get_events_id_request/0, get_events_id_request_query/0,
              get_events_id_request_header/0, get_events_id_request_cookie/0,
              get_events_id_request_body/0, get_events_id_response/0]).
-export_type([get_country_specs_request/0, get_country_specs_request_query/0,
              get_country_specs_request_header/0, get_country_specs_request_cookie/0,
              get_country_specs_request_body/0, get_country_specs_response/0]).
-export_type([post_payment_intents_intent_verify_microdeposits_request/0,
              post_payment_intents_intent_verify_microdeposits_request_query/0,
              post_payment_intents_intent_verify_microdeposits_request_header/0,
              post_payment_intents_intent_verify_microdeposits_request_cookie/0,
              post_payment_intents_intent_verify_microdeposits_request_body/0,
              post_payment_intents_intent_verify_microdeposits_response/0]).
-export_type([post_subscription_items_subscription_item_usage_records_request/0,
              post_subscription_items_subscription_item_usage_records_request_query/0,
              post_subscription_items_subscription_item_usage_records_request_header/0,
              post_subscription_items_subscription_item_usage_records_request_cookie/0,
              post_subscription_items_subscription_item_usage_records_request_body/0,
              post_subscription_items_subscription_item_usage_records_response/0]).
-export_type([get_balance_history_request/0, get_balance_history_request_query/0,
              get_balance_history_request_header/0, get_balance_history_request_cookie/0,
              get_balance_history_request_body/0, get_balance_history_response/0]).
-export_type([get_order_returns_request/0, get_order_returns_request_query/0,
              get_order_returns_request_header/0, get_order_returns_request_cookie/0,
              get_order_returns_request_body/0, get_order_returns_response/0]).
-export_type([delete_account_external_accounts_id_request/0,
              delete_account_external_accounts_id_request_query/0,
              delete_account_external_accounts_id_request_header/0,
              delete_account_external_accounts_id_request_cookie/0,
              delete_account_external_accounts_id_request_body/0,
              delete_account_external_accounts_id_response/0]).
-export_type([post_account_external_accounts_id_request/0,
              post_account_external_accounts_id_request_query/0,
              post_account_external_accounts_id_request_header/0,
              post_account_external_accounts_id_request_cookie/0,
              post_account_external_accounts_id_request_body/0,
              post_account_external_accounts_id_response/0]).
-export_type([get_account_external_accounts_id_request/0,
              get_account_external_accounts_id_request_query/0,
              get_account_external_accounts_id_request_header/0,
              get_account_external_accounts_id_request_cookie/0,
              get_account_external_accounts_id_request_body/0,
              get_account_external_accounts_id_response/0]).
-export_type([post_apple_pay_domains_request/0, post_apple_pay_domains_request_query/0,
              post_apple_pay_domains_request_header/0, post_apple_pay_domains_request_cookie/0,
              post_apple_pay_domains_request_body/0, post_apple_pay_domains_response/0]).
-export_type([get_apple_pay_domains_request/0, get_apple_pay_domains_request_query/0,
              get_apple_pay_domains_request_header/0, get_apple_pay_domains_request_cookie/0,
              get_apple_pay_domains_request_body/0, get_apple_pay_domains_response/0]).
-export_type([post_credit_notes_request/0, post_credit_notes_request_query/0,
              post_credit_notes_request_header/0, post_credit_notes_request_cookie/0,
              post_credit_notes_request_body/0, post_credit_notes_response/0]).
-export_type([get_credit_notes_request/0, get_credit_notes_request_query/0,
              get_credit_notes_request_header/0, get_credit_notes_request_cookie/0,
              get_credit_notes_request_body/0, get_credit_notes_response/0]).
-export_type([get_sigma_scheduled_query_runs_scheduled_query_run_request/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_request_query/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_request_header/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_request_cookie/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_request_body/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_response/0]).
-export_type([delete_coupons_coupon_request/0, delete_coupons_coupon_request_query/0,
              delete_coupons_coupon_request_header/0, delete_coupons_coupon_request_cookie/0,
              delete_coupons_coupon_request_body/0, delete_coupons_coupon_response/0]).
-export_type([post_coupons_coupon_request/0, post_coupons_coupon_request_query/0,
              post_coupons_coupon_request_header/0, post_coupons_coupon_request_cookie/0,
              post_coupons_coupon_request_body/0, post_coupons_coupon_response/0]).
-export_type([get_coupons_coupon_request/0, get_coupons_coupon_request_query/0,
              get_coupons_coupon_request_header/0, get_coupons_coupon_request_cookie/0,
              get_coupons_coupon_request_body/0, get_coupons_coupon_response/0]).
-export_type([delete_customers_customer_tax_ids_id_request/0,
              delete_customers_customer_tax_ids_id_request_query/0,
              delete_customers_customer_tax_ids_id_request_header/0,
              delete_customers_customer_tax_ids_id_request_cookie/0,
              delete_customers_customer_tax_ids_id_request_body/0,
              delete_customers_customer_tax_ids_id_response/0]).
-export_type([get_customers_customer_tax_ids_id_request/0,
              get_customers_customer_tax_ids_id_request_query/0,
              get_customers_customer_tax_ids_id_request_header/0,
              get_customers_customer_tax_ids_id_request_cookie/0,
              get_customers_customer_tax_ids_id_request_body/0,
              get_customers_customer_tax_ids_id_response/0]).
-export_type([get_radar_early_fraud_warnings_early_fraud_warning_request/0,
              get_radar_early_fraud_warnings_early_fraud_warning_request_query/0,
              get_radar_early_fraud_warnings_early_fraud_warning_request_header/0,
              get_radar_early_fraud_warnings_early_fraud_warning_request_cookie/0,
              get_radar_early_fraud_warnings_early_fraud_warning_request_body/0,
              get_radar_early_fraud_warnings_early_fraud_warning_response/0]).
-export_type([get_issuing_settlements_request/0, get_issuing_settlements_request_query/0,
              get_issuing_settlements_request_header/0, get_issuing_settlements_request_cookie/0,
              get_issuing_settlements_request_body/0, get_issuing_settlements_response/0]).
-export_type([post_file_links_request/0, post_file_links_request_query/0,
              post_file_links_request_header/0, post_file_links_request_cookie/0,
              post_file_links_request_body/0, post_file_links_response/0]).
-export_type([get_file_links_request/0, get_file_links_request_query/0,
              get_file_links_request_header/0, get_file_links_request_cookie/0,
              get_file_links_request_body/0, get_file_links_response/0]).
-export_type([get_identity_verification_reports_report_request/0,
              get_identity_verification_reports_report_request_query/0,
              get_identity_verification_reports_report_request_header/0,
              get_identity_verification_reports_report_request_cookie/0,
              get_identity_verification_reports_report_request_body/0,
              get_identity_verification_reports_report_response/0]).
-export_type([post_transfers_request/0, post_transfers_request_query/0,
              post_transfers_request_header/0, post_transfers_request_cookie/0,
              post_transfers_request_body/0, post_transfers_response/0]).
-export_type([get_transfers_request/0, get_transfers_request_query/0,
              get_transfers_request_header/0, get_transfers_request_cookie/0,
              get_transfers_request_body/0, get_transfers_response/0]).
-export_type([delete_subscriptions_subscription_exposed_id_discount_request/0,
              delete_subscriptions_subscription_exposed_id_discount_request_query/0,
              delete_subscriptions_subscription_exposed_id_discount_request_header/0,
              delete_subscriptions_subscription_exposed_id_discount_request_cookie/0,
              delete_subscriptions_subscription_exposed_id_discount_request_body/0,
              delete_subscriptions_subscription_exposed_id_discount_response/0]).
-export_type([post_application_fees_id_refunds_request/0,
              post_application_fees_id_refunds_request_query/0,
              post_application_fees_id_refunds_request_header/0,
              post_application_fees_id_refunds_request_cookie/0,
              post_application_fees_id_refunds_request_body/0,
              post_application_fees_id_refunds_response/0]).
-export_type([get_application_fees_id_refunds_request/0,
              get_application_fees_id_refunds_request_query/0,
              get_application_fees_id_refunds_request_header/0,
              get_application_fees_id_refunds_request_cookie/0,
              get_application_fees_id_refunds_request_body/0,
              get_application_fees_id_refunds_response/0]).
-export_type([post_accounts_account_bank_accounts_request/0,
              post_accounts_account_bank_accounts_request_query/0,
              post_accounts_account_bank_accounts_request_header/0,
              post_accounts_account_bank_accounts_request_cookie/0,
              post_accounts_account_bank_accounts_request_body/0,
              post_accounts_account_bank_accounts_response/0]).
-export_type([delete_accounts_account_request/0, delete_accounts_account_request_query/0,
              delete_accounts_account_request_header/0, delete_accounts_account_request_cookie/0,
              delete_accounts_account_request_body/0, delete_accounts_account_response/0]).
-export_type([post_accounts_account_request/0, post_accounts_account_request_query/0,
              post_accounts_account_request_header/0, post_accounts_account_request_cookie/0,
              post_accounts_account_request_body/0, post_accounts_account_response/0]).
-export_type([get_accounts_account_request/0, get_accounts_account_request_query/0,
              get_accounts_account_request_header/0, get_accounts_account_request_cookie/0,
              get_accounts_account_request_body/0, get_accounts_account_response/0]).
-export_type([post_subscription_schedules_schedule_request/0,
              post_subscription_schedules_schedule_request_query/0,
              post_subscription_schedules_schedule_request_header/0,
              post_subscription_schedules_schedule_request_cookie/0,
              post_subscription_schedules_schedule_request_body/0,
              post_subscription_schedules_schedule_response/0]).
-export_type([get_subscription_schedules_schedule_request/0,
              get_subscription_schedules_schedule_request_query/0,
              get_subscription_schedules_schedule_request_header/0,
              get_subscription_schedules_schedule_request_cookie/0,
              get_subscription_schedules_schedule_request_body/0,
              get_subscription_schedules_schedule_response/0]).
-export_type([post_invoices_invoice_pay_request/0,
              post_invoices_invoice_pay_request_query/0, post_invoices_invoice_pay_request_header/0,
              post_invoices_invoice_pay_request_cookie/0, post_invoices_invoice_pay_request_body/0,
              post_invoices_invoice_pay_response/0]).
-export_type([post_transfers_transfer_reversals_id_request/0,
              post_transfers_transfer_reversals_id_request_query/0,
              post_transfers_transfer_reversals_id_request_header/0,
              post_transfers_transfer_reversals_id_request_cookie/0,
              post_transfers_transfer_reversals_id_request_body/0,
              post_transfers_transfer_reversals_id_response/0]).
-export_type([get_transfers_transfer_reversals_id_request/0,
              get_transfers_transfer_reversals_id_request_query/0,
              get_transfers_transfer_reversals_id_request_header/0,
              get_transfers_transfer_reversals_id_request_cookie/0,
              get_transfers_transfer_reversals_id_request_body/0,
              get_transfers_transfer_reversals_id_response/0]).
-export_type([post_topups_topup_request/0, post_topups_topup_request_query/0,
              post_topups_topup_request_header/0, post_topups_topup_request_cookie/0,
              post_topups_topup_request_body/0, post_topups_topup_response/0]).
-export_type([get_topups_topup_request/0, get_topups_topup_request_query/0,
              get_topups_topup_request_header/0, get_topups_topup_request_cookie/0,
              get_topups_topup_request_body/0, get_topups_topup_response/0]).
-export_type([delete_recipients_id_request/0, delete_recipients_id_request_query/0,
              delete_recipients_id_request_header/0, delete_recipients_id_request_cookie/0,
              delete_recipients_id_request_body/0, delete_recipients_id_response/0]).
-export_type([post_recipients_id_request/0, post_recipients_id_request_query/0,
              post_recipients_id_request_header/0, post_recipients_id_request_cookie/0,
              post_recipients_id_request_body/0, post_recipients_id_response/0]).
-export_type([get_recipients_id_request/0, get_recipients_id_request_query/0,
              get_recipients_id_request_header/0, get_recipients_id_request_cookie/0,
              get_recipients_id_request_body/0, get_recipients_id_response/0]).
-export_type([get_invoices_invoice_lines_request/0,
              get_invoices_invoice_lines_request_query/0,
              get_invoices_invoice_lines_request_header/0,
              get_invoices_invoice_lines_request_cookie/0,
              get_invoices_invoice_lines_request_body/0, get_invoices_invoice_lines_response/0]).
-export_type([delete_accounts_account_external_accounts_id_request/0,
              delete_accounts_account_external_accounts_id_request_query/0,
              delete_accounts_account_external_accounts_id_request_header/0,
              delete_accounts_account_external_accounts_id_request_cookie/0,
              delete_accounts_account_external_accounts_id_request_body/0,
              delete_accounts_account_external_accounts_id_response/0]).
-export_type([post_accounts_account_external_accounts_id_request/0,
              post_accounts_account_external_accounts_id_request_query/0,
              post_accounts_account_external_accounts_id_request_header/0,
              post_accounts_account_external_accounts_id_request_cookie/0,
              post_accounts_account_external_accounts_id_request_body/0,
              post_accounts_account_external_accounts_id_response/0]).
-export_type([get_accounts_account_external_accounts_id_request/0,
              get_accounts_account_external_accounts_id_request_query/0,
              get_accounts_account_external_accounts_id_request_header/0,
              get_accounts_account_external_accounts_id_request_cookie/0,
              get_accounts_account_external_accounts_id_request_body/0,
              get_accounts_account_external_accounts_id_response/0]).
-export_type([post_topups_request/0, post_topups_request_query/0,
              post_topups_request_header/0, post_topups_request_cookie/0,
              post_topups_request_body/0, post_topups_response/0]).
-export_type([get_topups_request/0, get_topups_request_query/0,
              get_topups_request_header/0, get_topups_request_cookie/0, get_topups_request_body/0,
              get_topups_response/0]).
-export_type([post_orders_id_returns_request/0, post_orders_id_returns_request_query/0,
              post_orders_id_returns_request_header/0, post_orders_id_returns_request_cookie/0,
              post_orders_id_returns_request_body/0, post_orders_id_returns_response/0]).
-export_type([post_orders_id_request/0, post_orders_id_request_query/0,
              post_orders_id_request_header/0, post_orders_id_request_cookie/0,
              post_orders_id_request_body/0, post_orders_id_response/0]).
-export_type([get_orders_id_request/0, get_orders_id_request_query/0,
              get_orders_id_request_header/0, get_orders_id_request_cookie/0,
              get_orders_id_request_body/0, get_orders_id_response/0]).
-export_type([delete_apple_pay_domains_domain_request/0,
              delete_apple_pay_domains_domain_request_query/0,
              delete_apple_pay_domains_domain_request_header/0,
              delete_apple_pay_domains_domain_request_cookie/0,
              delete_apple_pay_domains_domain_request_body/0,
              delete_apple_pay_domains_domain_response/0]).
-export_type([get_apple_pay_domains_domain_request/0,
              get_apple_pay_domains_domain_request_query/0,
              get_apple_pay_domains_domain_request_header/0,
              get_apple_pay_domains_domain_request_cookie/0,
              get_apple_pay_domains_domain_request_body/0,
              get_apple_pay_domains_domain_response/0]).
-export_type([get_issuing_transactions_request/0,
              get_issuing_transactions_request_query/0, get_issuing_transactions_request_header/0,
              get_issuing_transactions_request_cookie/0, get_issuing_transactions_request_body/0,
              get_issuing_transactions_response/0]).
-export_type([post_charges_charge_refund_request/0,
              post_charges_charge_refund_request_query/0,
              post_charges_charge_refund_request_header/0,
              post_charges_charge_refund_request_cookie/0,
              post_charges_charge_refund_request_body/0, post_charges_charge_refund_response/0]).
-export_type([post_payment_methods_payment_method_attach_request/0,
              post_payment_methods_payment_method_attach_request_query/0,
              post_payment_methods_payment_method_attach_request_header/0,
              post_payment_methods_payment_method_attach_request_cookie/0,
              post_payment_methods_payment_method_attach_request_body/0,
              post_payment_methods_payment_method_attach_response/0]).
-export_type([post_payment_intents_intent_cancel_request/0,
              post_payment_intents_intent_cancel_request_query/0,
              post_payment_intents_intent_cancel_request_header/0,
              post_payment_intents_intent_cancel_request_cookie/0,
              post_payment_intents_intent_cancel_request_body/0,
              post_payment_intents_intent_cancel_response/0]).
-export_type([get_accounts_account_capabilities_request/0,
              get_accounts_account_capabilities_request_query/0,
              get_accounts_account_capabilities_request_header/0,
              get_accounts_account_capabilities_request_cookie/0,
              get_accounts_account_capabilities_request_body/0,
              get_accounts_account_capabilities_response/0]).
-export_type([get_credit_notes_preview_lines_request/0,
              get_credit_notes_preview_lines_request_query/0,
              get_credit_notes_preview_lines_request_header/0,
              get_credit_notes_preview_lines_request_cookie/0,
              get_credit_notes_preview_lines_request_body/0,
              get_credit_notes_preview_lines_response/0]).
-export_type([post_subscriptions_request/0, post_subscriptions_request_query/0,
              post_subscriptions_request_header/0, post_subscriptions_request_cookie/0,
              post_subscriptions_request_body/0, post_subscriptions_response/0]).
-export_type([get_subscriptions_request/0, get_subscriptions_request_query/0,
              get_subscriptions_request_header/0, get_subscriptions_request_cookie/0,
              get_subscriptions_request_body/0, get_subscriptions_response/0]).
-export_type([get_setup_attempts_request/0, get_setup_attempts_request_query/0,
              get_setup_attempts_request_header/0, get_setup_attempts_request_cookie/0,
              get_setup_attempts_request_body/0, get_setup_attempts_response/0]).
-export_type([delete_customers_customer_subscriptions_subscription_exposed_id_request/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_request_query/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_request_header/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_request_cookie/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_request_body/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_response/0]).
-export_type([post_customers_customer_subscriptions_subscription_exposed_id_request/0,
              post_customers_customer_subscriptions_subscription_exposed_id_request_query/0,
              post_customers_customer_subscriptions_subscription_exposed_id_request_header/0,
              post_customers_customer_subscriptions_subscription_exposed_id_request_cookie/0,
              post_customers_customer_subscriptions_subscription_exposed_id_request_body/0,
              post_customers_customer_subscriptions_subscription_exposed_id_response/0]).
-export_type([get_customers_customer_subscriptions_subscription_exposed_id_request/0,
              get_customers_customer_subscriptions_subscription_exposed_id_request_query/0,
              get_customers_customer_subscriptions_subscription_exposed_id_request_header/0,
              get_customers_customer_subscriptions_subscription_exposed_id_request_cookie/0,
              get_customers_customer_subscriptions_subscription_exposed_id_request_body/0,
              get_customers_customer_subscriptions_subscription_exposed_id_response/0]).
-export_type([get_bitcoin_receivers_id_request/0,
              get_bitcoin_receivers_id_request_query/0, get_bitcoin_receivers_id_request_header/0,
              get_bitcoin_receivers_id_request_cookie/0, get_bitcoin_receivers_id_request_body/0,
              get_bitcoin_receivers_id_response/0]).
-export_type([post_orders_request/0, post_orders_request_query/0,
              post_orders_request_header/0, post_orders_request_cookie/0,
              post_orders_request_body/0, post_orders_response/0]).
-export_type([get_orders_request/0, get_orders_request_query/0,
              get_orders_request_header/0, get_orders_request_cookie/0, get_orders_request_body/0,
              get_orders_response/0]).
-export_type([post_ephemeral_keys_request/0, post_ephemeral_keys_request_query/0,
              post_ephemeral_keys_request_header/0, post_ephemeral_keys_request_cookie/0,
              post_ephemeral_keys_request_body/0, post_ephemeral_keys_response/0]).
-export_type([delete_webhook_endpoints_webhook_endpoint_request/0,
              delete_webhook_endpoints_webhook_endpoint_request_query/0,
              delete_webhook_endpoints_webhook_endpoint_request_header/0,
              delete_webhook_endpoints_webhook_endpoint_request_cookie/0,
              delete_webhook_endpoints_webhook_endpoint_request_body/0,
              delete_webhook_endpoints_webhook_endpoint_response/0]).
-export_type([post_webhook_endpoints_webhook_endpoint_request/0,
              post_webhook_endpoints_webhook_endpoint_request_query/0,
              post_webhook_endpoints_webhook_endpoint_request_header/0,
              post_webhook_endpoints_webhook_endpoint_request_cookie/0,
              post_webhook_endpoints_webhook_endpoint_request_body/0,
              post_webhook_endpoints_webhook_endpoint_response/0]).
-export_type([get_webhook_endpoints_webhook_endpoint_request/0,
              get_webhook_endpoints_webhook_endpoint_request_query/0,
              get_webhook_endpoints_webhook_endpoint_request_header/0,
              get_webhook_endpoints_webhook_endpoint_request_cookie/0,
              get_webhook_endpoints_webhook_endpoint_request_body/0,
              get_webhook_endpoints_webhook_endpoint_response/0]).
-export_type([post_account_persons_request/0, post_account_persons_request_query/0,
              post_account_persons_request_header/0, post_account_persons_request_cookie/0,
              post_account_persons_request_body/0, post_account_persons_response/0]).
-export_type([get_account_persons_request/0, get_account_persons_request_query/0,
              get_account_persons_request_header/0, get_account_persons_request_cookie/0,
              get_account_persons_request_body/0, get_account_persons_response/0]).
-export_type([get_account_capabilities_request/0,
              get_account_capabilities_request_query/0, get_account_capabilities_request_header/0,
              get_account_capabilities_request_cookie/0, get_account_capabilities_request_body/0,
              get_account_capabilities_response/0]).
-export_type([post_checkout_sessions_session_expire_request/0,
              post_checkout_sessions_session_expire_request_query/0,
              post_checkout_sessions_session_expire_request_header/0,
              post_checkout_sessions_session_expire_request_cookie/0,
              post_checkout_sessions_session_expire_request_body/0,
              post_checkout_sessions_session_expire_response/0]).
-export_type([get_bitcoin_receivers_receiver_transactions_request/0,
              get_bitcoin_receivers_receiver_transactions_request_query/0,
              get_bitcoin_receivers_receiver_transactions_request_header/0,
              get_bitcoin_receivers_receiver_transactions_request_cookie/0,
              get_bitcoin_receivers_receiver_transactions_request_body/0,
              get_bitcoin_receivers_receiver_transactions_response/0]).
-export_type([post_quotes_quote_request/0, post_quotes_quote_request_query/0,
              post_quotes_quote_request_header/0, post_quotes_quote_request_cookie/0,
              post_quotes_quote_request_body/0, post_quotes_quote_response/0]).
-export_type([get_quotes_quote_request/0, get_quotes_quote_request_query/0,
              get_quotes_quote_request_header/0, get_quotes_quote_request_cookie/0,
              get_quotes_quote_request_body/0, get_quotes_quote_response/0]).
-export_type([post_account_people_request/0, post_account_people_request_query/0,
              post_account_people_request_header/0, post_account_people_request_cookie/0,
              post_account_people_request_body/0, post_account_people_response/0]).
-export_type([get_account_people_request/0, get_account_people_request_query/0,
              get_account_people_request_header/0, get_account_people_request_cookie/0,
              get_account_people_request_body/0, get_account_people_response/0]).
-export_type([post_setup_intents_intent_confirm_request/0,
              post_setup_intents_intent_confirm_request_query/0,
              post_setup_intents_intent_confirm_request_header/0,
              post_setup_intents_intent_confirm_request_cookie/0,
              post_setup_intents_intent_confirm_request_body/0,
              post_setup_intents_intent_confirm_response/0]).
-export_type([post_customers_customer_cards_request/0,
              post_customers_customer_cards_request_query/0,
              post_customers_customer_cards_request_header/0,
              post_customers_customer_cards_request_cookie/0,
              post_customers_customer_cards_request_body/0,
              post_customers_customer_cards_response/0]).
-export_type([get_customers_customer_cards_request/0,
              get_customers_customer_cards_request_query/0,
              get_customers_customer_cards_request_header/0,
              get_customers_customer_cards_request_cookie/0,
              get_customers_customer_cards_request_body/0,
              get_customers_customer_cards_response/0]).
-export_type([get_identity_verification_reports_request/0,
              get_identity_verification_reports_request_query/0,
              get_identity_verification_reports_request_header/0,
              get_identity_verification_reports_request_cookie/0,
              get_identity_verification_reports_request_body/0,
              get_identity_verification_reports_response/0]).
-export_type([post_accounts_account_persons_request/0,
              post_accounts_account_persons_request_query/0,
              post_accounts_account_persons_request_header/0,
              post_accounts_account_persons_request_cookie/0,
              post_accounts_account_persons_request_body/0,
              post_accounts_account_persons_response/0]).
-export_type([get_accounts_account_persons_request/0,
              get_accounts_account_persons_request_query/0,
              get_accounts_account_persons_request_header/0,
              get_accounts_account_persons_request_cookie/0,
              get_accounts_account_persons_request_body/0,
              get_accounts_account_persons_response/0]).
-export_type([post_application_fees_id_refund_request/0,
              post_application_fees_id_refund_request_query/0,
              post_application_fees_id_refund_request_header/0,
              post_application_fees_id_refund_request_cookie/0,
              post_application_fees_id_refund_request_body/0,
              post_application_fees_id_refund_response/0]).
-export_type([post_payment_intents_request/0, post_payment_intents_request_query/0,
              post_payment_intents_request_header/0, post_payment_intents_request_cookie/0,
              post_payment_intents_request_body/0, post_payment_intents_response/0]).
-export_type([get_payment_intents_request/0, get_payment_intents_request_query/0,
              get_payment_intents_request_header/0, get_payment_intents_request_cookie/0,
              get_payment_intents_request_body/0, get_payment_intents_response/0]).
-export_type([post_skus_request/0, post_skus_request_query/0, post_skus_request_header/0,
              post_skus_request_cookie/0, post_skus_request_body/0, post_skus_response/0]).
-export_type([get_skus_request/0, get_skus_request_query/0, get_skus_request_header/0,
              get_skus_request_cookie/0, get_skus_request_body/0, get_skus_response/0]).
-export_type([post_webhook_endpoints_request/0, post_webhook_endpoints_request_query/0,
              post_webhook_endpoints_request_header/0, post_webhook_endpoints_request_cookie/0,
              post_webhook_endpoints_request_body/0, post_webhook_endpoints_response/0]).
-export_type([get_webhook_endpoints_request/0, get_webhook_endpoints_request_query/0,
              get_webhook_endpoints_request_header/0, get_webhook_endpoints_request_cookie/0,
              get_webhook_endpoints_request_body/0, get_webhook_endpoints_response/0]).
-export_type([get_balance_request/0, get_balance_request_query/0,
              get_balance_request_header/0, get_balance_request_cookie/0,
              get_balance_request_body/0, get_balance_response/0]).
-export_type([post_customers_customer_balance_transactions_transaction_request/0,
              post_customers_customer_balance_transactions_transaction_request_query/0,
              post_customers_customer_balance_transactions_transaction_request_header/0,
              post_customers_customer_balance_transactions_transaction_request_cookie/0,
              post_customers_customer_balance_transactions_transaction_request_body/0,
              post_customers_customer_balance_transactions_transaction_response/0]).
-export_type([get_customers_customer_balance_transactions_transaction_request/0,
              get_customers_customer_balance_transactions_transaction_request_query/0,
              get_customers_customer_balance_transactions_transaction_request_header/0,
              get_customers_customer_balance_transactions_transaction_request_cookie/0,
              get_customers_customer_balance_transactions_transaction_request_body/0,
              get_customers_customer_balance_transactions_transaction_response/0]).
-export_type([post_payment_methods_payment_method_request/0,
              post_payment_methods_payment_method_request_query/0,
              post_payment_methods_payment_method_request_header/0,
              post_payment_methods_payment_method_request_cookie/0,
              post_payment_methods_payment_method_request_body/0,
              post_payment_methods_payment_method_response/0]).
-export_type([get_payment_methods_payment_method_request/0,
              get_payment_methods_payment_method_request_query/0,
              get_payment_methods_payment_method_request_header/0,
              get_payment_methods_payment_method_request_cookie/0,
              get_payment_methods_payment_method_request_body/0,
              get_payment_methods_payment_method_response/0]).
-export_type([post_topups_topup_cancel_request/0,
              post_topups_topup_cancel_request_query/0, post_topups_topup_cancel_request_header/0,
              post_topups_topup_cancel_request_cookie/0, post_topups_topup_cancel_request_body/0,
              post_topups_topup_cancel_response/0]).
-export_type([get_events_request/0, get_events_request_query/0,
              get_events_request_header/0, get_events_request_cookie/0, get_events_request_body/0,
              get_events_response/0]).
-export_type([post_charges_charge_refunds_refund_request/0,
              post_charges_charge_refunds_refund_request_query/0,
              post_charges_charge_refunds_refund_request_header/0,
              post_charges_charge_refunds_refund_request_cookie/0,
              post_charges_charge_refunds_refund_request_body/0,
              post_charges_charge_refunds_refund_response/0]).
-export_type([get_charges_charge_refunds_refund_request/0,
              get_charges_charge_refunds_refund_request_query/0,
              get_charges_charge_refunds_refund_request_header/0,
              get_charges_charge_refunds_refund_request_cookie/0,
              get_charges_charge_refunds_refund_request_body/0,
              get_charges_charge_refunds_refund_response/0]).
-export_type([post_accounts_account_capabilities_capability_request/0,
              post_accounts_account_capabilities_capability_request_query/0,
              post_accounts_account_capabilities_capability_request_header/0,
              post_accounts_account_capabilities_capability_request_cookie/0,
              post_accounts_account_capabilities_capability_request_body/0,
              post_accounts_account_capabilities_capability_response/0]).
-export_type([get_accounts_account_capabilities_capability_request/0,
              get_accounts_account_capabilities_capability_request_query/0,
              get_accounts_account_capabilities_capability_request_header/0,
              get_accounts_account_capabilities_capability_request_cookie/0,
              get_accounts_account_capabilities_capability_request_body/0,
              get_accounts_account_capabilities_capability_response/0]).
-export_type([post_subscription_items_request/0, post_subscription_items_request_query/0,
              post_subscription_items_request_header/0, post_subscription_items_request_cookie/0,
              post_subscription_items_request_body/0, post_subscription_items_response/0]).
-export_type([get_subscription_items_request/0, get_subscription_items_request_query/0,
              get_subscription_items_request_header/0, get_subscription_items_request_cookie/0,
              get_subscription_items_request_body/0, get_subscription_items_response/0]).
-export_type([get_quotes_quote_pdf_request/0, get_quotes_quote_pdf_request_query/0,
              get_quotes_quote_pdf_request_header/0, get_quotes_quote_pdf_request_cookie/0,
              get_quotes_quote_pdf_request_body/0, get_quotes_quote_pdf_response/0]).
-export_type([delete_account_bank_accounts_id_request/0,
              delete_account_bank_accounts_id_request_query/0,
              delete_account_bank_accounts_id_request_header/0,
              delete_account_bank_accounts_id_request_cookie/0,
              delete_account_bank_accounts_id_request_body/0,
              delete_account_bank_accounts_id_response/0]).
-export_type([post_account_bank_accounts_id_request/0,
              post_account_bank_accounts_id_request_query/0,
              post_account_bank_accounts_id_request_header/0,
              post_account_bank_accounts_id_request_cookie/0,
              post_account_bank_accounts_id_request_body/0,
              post_account_bank_accounts_id_response/0]).
-export_type([get_account_bank_accounts_id_request/0,
              get_account_bank_accounts_id_request_query/0,
              get_account_bank_accounts_id_request_header/0,
              get_account_bank_accounts_id_request_cookie/0,
              get_account_bank_accounts_id_request_body/0,
              get_account_bank_accounts_id_response/0]).
-export_type([get_payment_links_payment_link_line_items_request/0,
              get_payment_links_payment_link_line_items_request_query/0,
              get_payment_links_payment_link_line_items_request_header/0,
              get_payment_links_payment_link_line_items_request_cookie/0,
              get_payment_links_payment_link_line_items_request_body/0,
              get_payment_links_payment_link_line_items_response/0]).
-export_type([get_subscription_items_subscription_item_usage_record_summaries_request/0,
              get_subscription_items_subscription_item_usage_record_summaries_request_query/0,
              get_subscription_items_subscription_item_usage_record_summaries_request_header/0,
              get_subscription_items_subscription_item_usage_record_summaries_request_cookie/0,
              get_subscription_items_subscription_item_usage_record_summaries_request_body/0,
              get_subscription_items_subscription_item_usage_record_summaries_response/0]).
-export_type([post_payment_intents_intent_request/0,
              post_payment_intents_intent_request_query/0,
              post_payment_intents_intent_request_header/0,
              post_payment_intents_intent_request_cookie/0,
              post_payment_intents_intent_request_body/0, post_payment_intents_intent_response/0]).
-export_type([get_payment_intents_intent_request/0,
              get_payment_intents_intent_request_query/0,
              get_payment_intents_intent_request_header/0,
              get_payment_intents_intent_request_cookie/0,
              get_payment_intents_intent_request_body/0, get_payment_intents_intent_response/0]).
-export_type([post_charges_request/0, post_charges_request_query/0,
              post_charges_request_header/0, post_charges_request_cookie/0,
              post_charges_request_body/0, post_charges_response/0]).
-export_type([get_charges_request/0, get_charges_request_query/0,
              get_charges_request_header/0, get_charges_request_cookie/0,
              get_charges_request_body/0, get_charges_response/0]).
-export_type([post_accounts_account_external_accounts_request/0,
              post_accounts_account_external_accounts_request_query/0,
              post_accounts_account_external_accounts_request_header/0,
              post_accounts_account_external_accounts_request_cookie/0,
              post_accounts_account_external_accounts_request_body/0,
              post_accounts_account_external_accounts_response/0]).
-export_type([get_accounts_account_external_accounts_request/0,
              get_accounts_account_external_accounts_request_query/0,
              get_accounts_account_external_accounts_request_header/0,
              get_accounts_account_external_accounts_request_cookie/0,
              get_accounts_account_external_accounts_request_body/0,
              get_accounts_account_external_accounts_response/0]).
-export_type([get_issuing_authorizations_request/0,
              get_issuing_authorizations_request_query/0,
              get_issuing_authorizations_request_header/0,
              get_issuing_authorizations_request_cookie/0,
              get_issuing_authorizations_request_body/0, get_issuing_authorizations_response/0]).
-export_type([delete_products_id_request/0, delete_products_id_request_query/0,
              delete_products_id_request_header/0, delete_products_id_request_cookie/0,
              delete_products_id_request_body/0, delete_products_id_response/0]).
-export_type([post_products_id_request/0, post_products_id_request_query/0,
              post_products_id_request_header/0, post_products_id_request_cookie/0,
              post_products_id_request_body/0, post_products_id_response/0]).
-export_type([get_products_id_request/0, get_products_id_request_query/0,
              get_products_id_request_header/0, get_products_id_request_cookie/0,
              get_products_id_request_body/0, get_products_id_response/0]).
-export_type([post_setup_intents_intent_verify_microdeposits_request/0,
              post_setup_intents_intent_verify_microdeposits_request_query/0,
              post_setup_intents_intent_verify_microdeposits_request_header/0,
              post_setup_intents_intent_verify_microdeposits_request_cookie/0,
              post_setup_intents_intent_verify_microdeposits_request_body/0,
              post_setup_intents_intent_verify_microdeposits_response/0]).
-export_type([get_reporting_report_types_request/0,
              get_reporting_report_types_request_query/0,
              get_reporting_report_types_request_header/0,
              get_reporting_report_types_request_cookie/0,
              get_reporting_report_types_request_body/0, get_reporting_report_types_response/0]).
-export_type([post_account_external_accounts_request/0,
              post_account_external_accounts_request_query/0,
              post_account_external_accounts_request_header/0,
              post_account_external_accounts_request_cookie/0,
              post_account_external_accounts_request_body/0,
              post_account_external_accounts_response/0]).
-export_type([get_account_external_accounts_request/0,
              get_account_external_accounts_request_query/0,
              get_account_external_accounts_request_header/0,
              get_account_external_accounts_request_cookie/0,
              get_account_external_accounts_request_body/0,
              get_account_external_accounts_response/0]).
-export_type([post_radar_value_lists_request/0, post_radar_value_lists_request_query/0,
              post_radar_value_lists_request_header/0, post_radar_value_lists_request_cookie/0,
              post_radar_value_lists_request_body/0, post_radar_value_lists_response/0]).
-export_type([get_radar_value_lists_request/0, get_radar_value_lists_request_query/0,
              get_radar_value_lists_request_header/0, get_radar_value_lists_request_cookie/0,
              get_radar_value_lists_request_body/0, get_radar_value_lists_response/0]).
-export_type([post_shipping_rates_request/0, post_shipping_rates_request_query/0,
              post_shipping_rates_request_header/0, post_shipping_rates_request_cookie/0,
              post_shipping_rates_request_body/0, post_shipping_rates_response/0]).
-export_type([get_shipping_rates_request/0, get_shipping_rates_request_query/0,
              get_shipping_rates_request_header/0, get_shipping_rates_request_cookie/0,
              get_shipping_rates_request_body/0, get_shipping_rates_response/0]).
-export_type([post_file_links_link_request/0, post_file_links_link_request_query/0,
              post_file_links_link_request_header/0, post_file_links_link_request_cookie/0,
              post_file_links_link_request_body/0, post_file_links_link_response/0]).
-export_type([get_file_links_link_request/0, get_file_links_link_request_query/0,
              get_file_links_link_request_header/0, get_file_links_link_request_cookie/0,
              get_file_links_link_request_body/0, get_file_links_link_response/0]).
-export_type([get3d_secure_three_d_secure_request/0,
              get3d_secure_three_d_secure_request_query/0,
              get3d_secure_three_d_secure_request_header/0,
              get3d_secure_three_d_secure_request_cookie/0,
              get3d_secure_three_d_secure_request_body/0, get3d_secure_three_d_secure_response/0]).
-export_type([post_invoices_invoice_send_request/0,
              post_invoices_invoice_send_request_query/0,
              post_invoices_invoice_send_request_header/0,
              post_invoices_invoice_send_request_cookie/0,
              post_invoices_invoice_send_request_body/0, post_invoices_invoice_send_response/0]).
-export_type([get_invoices_upcoming_request/0, get_invoices_upcoming_request_query/0,
              get_invoices_upcoming_request_header/0, get_invoices_upcoming_request_cookie/0,
              get_invoices_upcoming_request_body/0, get_invoices_upcoming_response/0]).
-export_type([get_checkout_sessions_session_line_items_request/0,
              get_checkout_sessions_session_line_items_request_query/0,
              get_checkout_sessions_session_line_items_request_header/0,
              get_checkout_sessions_session_line_items_request_cookie/0,
              get_checkout_sessions_session_line_items_request_body/0,
              get_checkout_sessions_session_line_items_response/0]).
-export_type([get_tax_codes_request/0, get_tax_codes_request_query/0,
              get_tax_codes_request_header/0, get_tax_codes_request_cookie/0,
              get_tax_codes_request_body/0, get_tax_codes_response/0]).
-export_type([post_invoices_request/0, post_invoices_request_query/0,
              post_invoices_request_header/0, post_invoices_request_cookie/0,
              post_invoices_request_body/0, post_invoices_response/0]).
-export_type([get_invoices_request/0, get_invoices_request_query/0,
              get_invoices_request_header/0, get_invoices_request_cookie/0,
              get_invoices_request_body/0, get_invoices_response/0]).
-export_type([post_charges_charge_request/0, post_charges_charge_request_query/0,
              post_charges_charge_request_header/0, post_charges_charge_request_cookie/0,
              post_charges_charge_request_body/0, post_charges_charge_response/0]).
-export_type([get_charges_charge_request/0, get_charges_charge_request_query/0,
              get_charges_charge_request_header/0, get_charges_charge_request_cookie/0,
              get_charges_charge_request_body/0, get_charges_charge_response/0]).
-export_type([post_invoices_invoice_mark_uncollectible_request/0,
              post_invoices_invoice_mark_uncollectible_request_query/0,
              post_invoices_invoice_mark_uncollectible_request_header/0,
              post_invoices_invoice_mark_uncollectible_request_cookie/0,
              post_invoices_invoice_mark_uncollectible_request_body/0,
              post_invoices_invoice_mark_uncollectible_response/0]).
-export_type([post_customers_customer_sources_id_verify_request/0,
              post_customers_customer_sources_id_verify_request_query/0,
              post_customers_customer_sources_id_verify_request_header/0,
              post_customers_customer_sources_id_verify_request_cookie/0,
              post_customers_customer_sources_id_verify_request_body/0,
              post_customers_customer_sources_id_verify_response/0]).
-export_type([post_orders_id_pay_request/0, post_orders_id_pay_request_query/0,
              post_orders_id_pay_request_header/0, post_orders_id_pay_request_cookie/0,
              post_orders_id_pay_request_body/0, post_orders_id_pay_response/0]).
-export_type([post_customers_customer_bank_accounts_id_verify_request/0,
              post_customers_customer_bank_accounts_id_verify_request_query/0,
              post_customers_customer_bank_accounts_id_verify_request_header/0,
              post_customers_customer_bank_accounts_id_verify_request_cookie/0,
              post_customers_customer_bank_accounts_id_verify_request_body/0,
              post_customers_customer_bank_accounts_id_verify_response/0]).
-export_type([delete_account_people_person_request/0,
              delete_account_people_person_request_query/0,
              delete_account_people_person_request_header/0,
              delete_account_people_person_request_cookie/0,
              delete_account_people_person_request_body/0,
              delete_account_people_person_response/0]).
-export_type([post_account_people_person_request/0,
              post_account_people_person_request_query/0,
              post_account_people_person_request_header/0,
              post_account_people_person_request_cookie/0,
              post_account_people_person_request_body/0, post_account_people_person_response/0]).
-export_type([get_account_people_person_request/0,
              get_account_people_person_request_query/0, get_account_people_person_request_header/0,
              get_account_people_person_request_cookie/0, get_account_people_person_request_body/0,
              get_account_people_person_response/0]).
-export_type([post_checkout_sessions_request/0, post_checkout_sessions_request_query/0,
              post_checkout_sessions_request_header/0, post_checkout_sessions_request_cookie/0,
              post_checkout_sessions_request_body/0, post_checkout_sessions_response/0]).
-export_type([get_checkout_sessions_request/0, get_checkout_sessions_request_query/0,
              get_checkout_sessions_request_header/0, get_checkout_sessions_request_cookie/0,
              get_checkout_sessions_request_body/0, get_checkout_sessions_response/0]).
-export_type([post_accounts_account_login_links_request/0,
              post_accounts_account_login_links_request_query/0,
              post_accounts_account_login_links_request_header/0,
              post_accounts_account_login_links_request_cookie/0,
              post_accounts_account_login_links_request_body/0,
              post_accounts_account_login_links_response/0]).
-export_type([post_terminal_readers_request/0, post_terminal_readers_request_query/0,
              post_terminal_readers_request_header/0, post_terminal_readers_request_cookie/0,
              post_terminal_readers_request_body/0, post_terminal_readers_response/0]).
-export_type([get_terminal_readers_request/0, get_terminal_readers_request_query/0,
              get_terminal_readers_request_header/0, get_terminal_readers_request_cookie/0,
              get_terminal_readers_request_body/0, get_terminal_readers_response/0]).
-export_type([post_issuing_disputes_request/0, post_issuing_disputes_request_query/0,
              post_issuing_disputes_request_header/0, post_issuing_disputes_request_cookie/0,
              post_issuing_disputes_request_body/0, post_issuing_disputes_response/0]).
-export_type([get_issuing_disputes_request/0, get_issuing_disputes_request_query/0,
              get_issuing_disputes_request_header/0, get_issuing_disputes_request_cookie/0,
              get_issuing_disputes_request_body/0, get_issuing_disputes_response/0]).
-export_type([post3d_secure_request/0, post3d_secure_request_query/0,
              post3d_secure_request_header/0, post3d_secure_request_cookie/0,
              post3d_secure_request_body/0, post3d_secure_response/0]).
-export_type([post_prices_request/0, post_prices_request_query/0,
              post_prices_request_header/0, post_prices_request_cookie/0,
              post_prices_request_body/0, post_prices_response/0]).
-export_type([get_prices_request/0, get_prices_request_query/0,
              get_prices_request_header/0, get_prices_request_cookie/0, get_prices_request_body/0,
              get_prices_response/0]).
-export_type([delete_invoices_invoice_request/0, delete_invoices_invoice_request_query/0,
              delete_invoices_invoice_request_header/0, delete_invoices_invoice_request_cookie/0,
              delete_invoices_invoice_request_body/0, delete_invoices_invoice_response/0]).
-export_type([post_invoices_invoice_request/0, post_invoices_invoice_request_query/0,
              post_invoices_invoice_request_header/0, post_invoices_invoice_request_cookie/0,
              post_invoices_invoice_request_body/0, post_invoices_invoice_response/0]).
-export_type([get_invoices_invoice_request/0, get_invoices_invoice_request_query/0,
              get_invoices_invoice_request_header/0, get_invoices_invoice_request_cookie/0,
              get_invoices_invoice_request_body/0, get_invoices_invoice_response/0]).
-export_type([post_identity_verification_sessions_session_request/0,
              post_identity_verification_sessions_session_request_query/0,
              post_identity_verification_sessions_session_request_header/0,
              post_identity_verification_sessions_session_request_cookie/0,
              post_identity_verification_sessions_session_request_body/0,
              post_identity_verification_sessions_session_response/0]).
-export_type([get_identity_verification_sessions_session_request/0,
              get_identity_verification_sessions_session_request_query/0,
              get_identity_verification_sessions_session_request_header/0,
              get_identity_verification_sessions_session_request_cookie/0,
              get_identity_verification_sessions_session_request_body/0,
              get_identity_verification_sessions_session_response/0]).
-export_type([get_balance_transactions_id_request/0,
              get_balance_transactions_id_request_query/0,
              get_balance_transactions_id_request_header/0,
              get_balance_transactions_id_request_cookie/0,
              get_balance_transactions_id_request_body/0, get_balance_transactions_id_response/0]).
-export_type([post_setup_intents_intent_cancel_request/0,
              post_setup_intents_intent_cancel_request_query/0,
              post_setup_intents_intent_cancel_request_header/0,
              post_setup_intents_intent_cancel_request_cookie/0,
              post_setup_intents_intent_cancel_request_body/0,
              post_setup_intents_intent_cancel_response/0]).
-export_type([post_issuing_transactions_transaction_request/0,
              post_issuing_transactions_transaction_request_query/0,
              post_issuing_transactions_transaction_request_header/0,
              post_issuing_transactions_transaction_request_cookie/0,
              post_issuing_transactions_transaction_request_body/0,
              post_issuing_transactions_transaction_response/0]).
-export_type([get_issuing_transactions_transaction_request/0,
              get_issuing_transactions_transaction_request_query/0,
              get_issuing_transactions_transaction_request_header/0,
              get_issuing_transactions_transaction_request_cookie/0,
              get_issuing_transactions_transaction_request_body/0,
              get_issuing_transactions_transaction_response/0]).
-export_type([post_terminal_connection_tokens_request/0,
              post_terminal_connection_tokens_request_query/0,
              post_terminal_connection_tokens_request_header/0,
              post_terminal_connection_tokens_request_cookie/0,
              post_terminal_connection_tokens_request_body/0,
              post_terminal_connection_tokens_response/0]).
-export_type([get_reviews_request/0, get_reviews_request_query/0,
              get_reviews_request_header/0, get_reviews_request_cookie/0,
              get_reviews_request_body/0, get_reviews_response/0]).
-export_type([post_promotion_codes_request/0, post_promotion_codes_request_query/0,
              post_promotion_codes_request_header/0, post_promotion_codes_request_cookie/0,
              post_promotion_codes_request_body/0, post_promotion_codes_response/0]).
-export_type([get_promotion_codes_request/0, get_promotion_codes_request_query/0,
              get_promotion_codes_request_header/0, get_promotion_codes_request_cookie/0,
              get_promotion_codes_request_body/0, get_promotion_codes_response/0]).
-export_type([delete_customers_customer_subscriptions_subscription_exposed_id_discount_request/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_query/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_header/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_body/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_response/0]).
-export_type([get_customers_customer_subscriptions_subscription_exposed_id_discount_request/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_request_query/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_request_header/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_request_body/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_response/0]).
-export_type([get_quotes_quote_computed_upfront_line_items_request/0,
              get_quotes_quote_computed_upfront_line_items_request_query/0,
              get_quotes_quote_computed_upfront_line_items_request_header/0,
              get_quotes_quote_computed_upfront_line_items_request_cookie/0,
              get_quotes_quote_computed_upfront_line_items_request_body/0,
              get_quotes_quote_computed_upfront_line_items_response/0]).
-export_type([delete_radar_value_list_items_item_request/0,
              delete_radar_value_list_items_item_request_query/0,
              delete_radar_value_list_items_item_request_header/0,
              delete_radar_value_list_items_item_request_cookie/0,
              delete_radar_value_list_items_item_request_body/0,
              delete_radar_value_list_items_item_response/0]).
-export_type([get_radar_value_list_items_item_request/0,
              get_radar_value_list_items_item_request_query/0,
              get_radar_value_list_items_item_request_header/0,
              get_radar_value_list_items_item_request_cookie/0,
              get_radar_value_list_items_item_request_body/0,
              get_radar_value_list_items_item_response/0]).
-export_type([get_issuer_fraud_records_request/0,
              get_issuer_fraud_records_request_query/0, get_issuer_fraud_records_request_header/0,
              get_issuer_fraud_records_request_cookie/0, get_issuer_fraud_records_request_body/0,
              get_issuer_fraud_records_response/0]).
-export_type([post_tax_rates_tax_rate_request/0, post_tax_rates_tax_rate_request_query/0,
              post_tax_rates_tax_rate_request_header/0, post_tax_rates_tax_rate_request_cookie/0,
              post_tax_rates_tax_rate_request_body/0, post_tax_rates_tax_rate_response/0]).
-export_type([get_tax_rates_tax_rate_request/0, get_tax_rates_tax_rate_request_query/0,
              get_tax_rates_tax_rate_request_header/0, get_tax_rates_tax_rate_request_cookie/0,
              get_tax_rates_tax_rate_request_body/0, get_tax_rates_tax_rate_response/0]).
-export_type([post_recipients_request/0, post_recipients_request_query/0,
              post_recipients_request_header/0, post_recipients_request_cookie/0,
              post_recipients_request_body/0, post_recipients_response/0]).
-export_type([get_recipients_request/0, get_recipients_request_query/0,
              get_recipients_request_header/0, get_recipients_request_cookie/0,
              get_recipients_request_body/0, get_recipients_response/0]).
-export_type([post_plans_request/0, post_plans_request_query/0,
              post_plans_request_header/0, post_plans_request_cookie/0, post_plans_request_body/0,
              post_plans_response/0]).
-export_type([get_plans_request/0, get_plans_request_query/0, get_plans_request_header/0,
              get_plans_request_cookie/0, get_plans_request_body/0, get_plans_response/0]).
-export_type([post_customers_customer_balance_transactions_request/0,
              post_customers_customer_balance_transactions_request_query/0,
              post_customers_customer_balance_transactions_request_header/0,
              post_customers_customer_balance_transactions_request_cookie/0,
              post_customers_customer_balance_transactions_request_body/0,
              post_customers_customer_balance_transactions_response/0]).
-export_type([get_customers_customer_balance_transactions_request/0,
              get_customers_customer_balance_transactions_request_query/0,
              get_customers_customer_balance_transactions_request_header/0,
              get_customers_customer_balance_transactions_request_cookie/0,
              get_customers_customer_balance_transactions_request_body/0,
              get_customers_customer_balance_transactions_response/0]).
-export_type([post_reviews_review_approve_request/0,
              post_reviews_review_approve_request_query/0,
              post_reviews_review_approve_request_header/0,
              post_reviews_review_approve_request_cookie/0,
              post_reviews_review_approve_request_body/0, post_reviews_review_approve_response/0]).
-export_type([post_customers_customer_tax_ids_request/0,
              post_customers_customer_tax_ids_request_query/0,
              post_customers_customer_tax_ids_request_header/0,
              post_customers_customer_tax_ids_request_cookie/0,
              post_customers_customer_tax_ids_request_body/0,
              post_customers_customer_tax_ids_response/0]).
-export_type([get_customers_customer_tax_ids_request/0,
              get_customers_customer_tax_ids_request_query/0,
              get_customers_customer_tax_ids_request_header/0,
              get_customers_customer_tax_ids_request_cookie/0,
              get_customers_customer_tax_ids_request_body/0,
              get_customers_customer_tax_ids_response/0]).
-export_type([get_tokens_token_request/0, get_tokens_token_request_query/0,
              get_tokens_token_request_header/0, get_tokens_token_request_cookie/0,
              get_tokens_token_request_body/0, get_tokens_token_response/0]).
-export_type([get_balance_transactions_request/0,
              get_balance_transactions_request_query/0, get_balance_transactions_request_header/0,
              get_balance_transactions_request_cookie/0, get_balance_transactions_request_body/0,
              get_balance_transactions_response/0]).
-export_type([get_tax_codes_id_request/0, get_tax_codes_id_request_query/0,
              get_tax_codes_id_request_header/0, get_tax_codes_id_request_cookie/0,
              get_tax_codes_id_request_body/0, get_tax_codes_id_response/0]).
-export_type([post_accounts_account_reject_request/0,
              post_accounts_account_reject_request_query/0,
              post_accounts_account_reject_request_header/0,
              post_accounts_account_reject_request_cookie/0,
              post_accounts_account_reject_request_body/0,
              post_accounts_account_reject_response/0]).
-export_type([delete_subscriptions_subscription_exposed_id_request/0,
              delete_subscriptions_subscription_exposed_id_request_query/0,
              delete_subscriptions_subscription_exposed_id_request_header/0,
              delete_subscriptions_subscription_exposed_id_request_cookie/0,
              delete_subscriptions_subscription_exposed_id_request_body/0,
              delete_subscriptions_subscription_exposed_id_response/0]).
-export_type([post_subscriptions_subscription_exposed_id_request/0,
              post_subscriptions_subscription_exposed_id_request_query/0,
              post_subscriptions_subscription_exposed_id_request_header/0,
              post_subscriptions_subscription_exposed_id_request_cookie/0,
              post_subscriptions_subscription_exposed_id_request_body/0,
              post_subscriptions_subscription_exposed_id_response/0]).
-export_type([get_subscriptions_subscription_exposed_id_request/0,
              get_subscriptions_subscription_exposed_id_request_query/0,
              get_subscriptions_subscription_exposed_id_request_header/0,
              get_subscriptions_subscription_exposed_id_request_cookie/0,
              get_subscriptions_subscription_exposed_id_request_body/0,
              get_subscriptions_subscription_exposed_id_response/0]).
-export_type([get_country_specs_country_request/0,
              get_country_specs_country_request_query/0, get_country_specs_country_request_header/0,
              get_country_specs_country_request_cookie/0, get_country_specs_country_request_body/0,
              get_country_specs_country_response/0]).
-export_type([post_invoices_invoice_finalize_request/0,
              post_invoices_invoice_finalize_request_query/0,
              post_invoices_invoice_finalize_request_header/0,
              post_invoices_invoice_finalize_request_cookie/0,
              post_invoices_invoice_finalize_request_body/0,
              post_invoices_invoice_finalize_response/0]).
-export_type([delete_terminal_locations_location_request/0,
              delete_terminal_locations_location_request_query/0,
              delete_terminal_locations_location_request_header/0,
              delete_terminal_locations_location_request_cookie/0,
              delete_terminal_locations_location_request_body/0,
              delete_terminal_locations_location_response/0]).
-export_type([post_terminal_locations_location_request/0,
              post_terminal_locations_location_request_query/0,
              post_terminal_locations_location_request_header/0,
              post_terminal_locations_location_request_cookie/0,
              post_terminal_locations_location_request_body/0,
              post_terminal_locations_location_response/0]).
-export_type([get_terminal_locations_location_request/0,
              get_terminal_locations_location_request_query/0,
              get_terminal_locations_location_request_header/0,
              get_terminal_locations_location_request_cookie/0,
              get_terminal_locations_location_request_body/0,
              get_terminal_locations_location_response/0]).
-export_type([delete_account_request/0, delete_account_request_query/0,
              delete_account_request_header/0, delete_account_request_cookie/0,
              delete_account_request_body/0, delete_account_response/0]).
-export_type([post_account_request/0, post_account_request_query/0,
              post_account_request_header/0, post_account_request_cookie/0,
              post_account_request_body/0, post_account_response/0]).
-export_type([get_account_request/0, get_account_request_query/0,
              get_account_request_header/0, get_account_request_cookie/0,
              get_account_request_body/0, get_account_response/0]).
-export_type([post_shipping_rates_shipping_rate_token_request/0,
              post_shipping_rates_shipping_rate_token_request_query/0,
              post_shipping_rates_shipping_rate_token_request_header/0,
              post_shipping_rates_shipping_rate_token_request_cookie/0,
              post_shipping_rates_shipping_rate_token_request_body/0,
              post_shipping_rates_shipping_rate_token_response/0]).
-export_type([get_shipping_rates_shipping_rate_token_request/0,
              get_shipping_rates_shipping_rate_token_request_query/0,
              get_shipping_rates_shipping_rate_token_request_header/0,
              get_shipping_rates_shipping_rate_token_request_cookie/0,
              get_shipping_rates_shipping_rate_token_request_body/0,
              get_shipping_rates_shipping_rate_token_response/0]).
-export_type([get_invoices_upcoming_lines_request/0,
              get_invoices_upcoming_lines_request_query/0,
              get_invoices_upcoming_lines_request_header/0,
              get_invoices_upcoming_lines_request_cookie/0,
              get_invoices_upcoming_lines_request_body/0, get_invoices_upcoming_lines_response/0]).
-export_type([post_issuing_cardholders_request/0,
              post_issuing_cardholders_request_query/0, post_issuing_cardholders_request_header/0,
              post_issuing_cardholders_request_cookie/0, post_issuing_cardholders_request_body/0,
              post_issuing_cardholders_response/0]).
-export_type([get_issuing_cardholders_request/0, get_issuing_cardholders_request_query/0,
              get_issuing_cardholders_request_header/0, get_issuing_cardholders_request_cookie/0,
              get_issuing_cardholders_request_body/0, get_issuing_cardholders_response/0]).
-export_type([delete_customers_customer_sources_id_request/0,
              delete_customers_customer_sources_id_request_query/0,
              delete_customers_customer_sources_id_request_header/0,
              delete_customers_customer_sources_id_request_cookie/0,
              delete_customers_customer_sources_id_request_body/0,
              delete_customers_customer_sources_id_response/0]).
-export_type([post_customers_customer_sources_id_request/0,
              post_customers_customer_sources_id_request_query/0,
              post_customers_customer_sources_id_request_header/0,
              post_customers_customer_sources_id_request_cookie/0,
              post_customers_customer_sources_id_request_body/0,
              post_customers_customer_sources_id_response/0]).
-export_type([get_customers_customer_sources_id_request/0,
              get_customers_customer_sources_id_request_query/0,
              get_customers_customer_sources_id_request_header/0,
              get_customers_customer_sources_id_request_cookie/0,
              get_customers_customer_sources_id_request_body/0,
              get_customers_customer_sources_id_response/0]).
-export_type([get_application_fees_request/0, get_application_fees_request_query/0,
              get_application_fees_request_header/0, get_application_fees_request_cookie/0,
              get_application_fees_request_body/0, get_application_fees_response/0]).
-export_type([get_bitcoin_receivers_request/0, get_bitcoin_receivers_request_query/0,
              get_bitcoin_receivers_request_header/0, get_bitcoin_receivers_request_cookie/0,
              get_bitcoin_receivers_request_body/0, get_bitcoin_receivers_response/0]).
-export_type([post_refunds_refund_request/0, post_refunds_refund_request_query/0,
              post_refunds_refund_request_header/0, post_refunds_refund_request_cookie/0,
              post_refunds_refund_request_body/0, post_refunds_refund_response/0]).
-export_type([get_refunds_refund_request/0, get_refunds_refund_request_query/0,
              get_refunds_refund_request_header/0, get_refunds_refund_request_cookie/0,
              get_refunds_refund_request_body/0, get_refunds_refund_response/0]).
-export_type([post_account_login_links_request/0,
              post_account_login_links_request_query/0, post_account_login_links_request_header/0,
              post_account_login_links_request_cookie/0, post_account_login_links_request_body/0,
              post_account_login_links_response/0]).
-export_type([post_tax_rates_request/0, post_tax_rates_request_query/0,
              post_tax_rates_request_header/0, post_tax_rates_request_cookie/0,
              post_tax_rates_request_body/0, post_tax_rates_response/0]).
-export_type([get_tax_rates_request/0, get_tax_rates_request_query/0,
              get_tax_rates_request_header/0, get_tax_rates_request_cookie/0,
              get_tax_rates_request_body/0, get_tax_rates_response/0]).
-export_type([post_accounts_account_people_request/0,
              post_accounts_account_people_request_query/0,
              post_accounts_account_people_request_header/0,
              post_accounts_account_people_request_cookie/0,
              post_accounts_account_people_request_body/0,
              post_accounts_account_people_response/0]).
-export_type([get_accounts_account_people_request/0,
              get_accounts_account_people_request_query/0,
              get_accounts_account_people_request_header/0,
              get_accounts_account_people_request_cookie/0,
              get_accounts_account_people_request_body/0, get_accounts_account_people_response/0]).
-export_type([post_issuing_disputes_dispute_submit_request/0,
              post_issuing_disputes_dispute_submit_request_query/0,
              post_issuing_disputes_dispute_submit_request_header/0,
              post_issuing_disputes_dispute_submit_request_cookie/0,
              post_issuing_disputes_dispute_submit_request_body/0,
              post_issuing_disputes_dispute_submit_response/0]).
-export_type([post_sources_source_request/0, post_sources_source_request_query/0,
              post_sources_source_request_header/0, post_sources_source_request_cookie/0,
              post_sources_source_request_body/0, post_sources_source_response/0]).
-export_type([get_sources_source_request/0, get_sources_source_request_query/0,
              get_sources_source_request_header/0, get_sources_source_request_cookie/0,
              get_sources_source_request_body/0, get_sources_source_response/0]).
-export_type([get_checkout_sessions_session_request/0,
              get_checkout_sessions_session_request_query/0,
              get_checkout_sessions_session_request_header/0,
              get_checkout_sessions_session_request_cookie/0,
              get_checkout_sessions_session_request_body/0,
              get_checkout_sessions_session_response/0]).
-export_type([post_payment_methods_payment_method_detach_request/0,
              post_payment_methods_payment_method_detach_request_query/0,
              post_payment_methods_payment_method_detach_request_header/0,
              post_payment_methods_payment_method_detach_request_cookie/0,
              post_payment_methods_payment_method_detach_request_body/0,
              post_payment_methods_payment_method_detach_response/0]).
-export_type([post_customers_request/0, post_customers_request_query/0,
              post_customers_request_header/0, post_customers_request_cookie/0,
              post_customers_request_body/0, post_customers_response/0]).
-export_type([get_customers_request/0, get_customers_request_query/0,
              get_customers_request_header/0, get_customers_request_cookie/0,
              get_customers_request_body/0, get_customers_response/0]).
-export_type([post_account_bank_accounts_request/0,
              post_account_bank_accounts_request_query/0,
              post_account_bank_accounts_request_header/0,
              post_account_bank_accounts_request_cookie/0,
              post_account_bank_accounts_request_body/0, post_account_bank_accounts_response/0]).
-export_type([post_issuing_disputes_dispute_request/0,
              post_issuing_disputes_dispute_request_query/0,
              post_issuing_disputes_dispute_request_header/0,
              post_issuing_disputes_dispute_request_cookie/0,
              post_issuing_disputes_dispute_request_body/0,
              post_issuing_disputes_dispute_response/0]).
-export_type([get_issuing_disputes_dispute_request/0,
              get_issuing_disputes_dispute_request_query/0,
              get_issuing_disputes_dispute_request_header/0,
              get_issuing_disputes_dispute_request_cookie/0,
              get_issuing_disputes_dispute_request_body/0,
              get_issuing_disputes_dispute_response/0]).
-export_type([post_disputes_dispute_close_request/0,
              post_disputes_dispute_close_request_query/0,
              post_disputes_dispute_close_request_header/0,
              post_disputes_dispute_close_request_cookie/0,
              post_disputes_dispute_close_request_body/0, post_disputes_dispute_close_response/0]).
-export_type([post_quotes_quote_cancel_request/0,
              post_quotes_quote_cancel_request_query/0, post_quotes_quote_cancel_request_header/0,
              post_quotes_quote_cancel_request_cookie/0, post_quotes_quote_cancel_request_body/0,
              post_quotes_quote_cancel_response/0]).
-export_type([get_customers_customer_payment_methods_request/0,
              get_customers_customer_payment_methods_request_query/0,
              get_customers_customer_payment_methods_request_header/0,
              get_customers_customer_payment_methods_request_cookie/0,
              get_customers_customer_payment_methods_request_body/0,
              get_customers_customer_payment_methods_response/0]).
-export_type([post_refunds_request/0, post_refunds_request_query/0,
              post_refunds_request_header/0, post_refunds_request_cookie/0,
              post_refunds_request_body/0, post_refunds_response/0]).
-export_type([get_refunds_request/0, get_refunds_request_query/0,
              get_refunds_request_header/0, get_refunds_request_cookie/0,
              get_refunds_request_body/0, get_refunds_response/0]).
-export_type([post_credit_notes_id_request/0, post_credit_notes_id_request_query/0,
              post_credit_notes_id_request_header/0, post_credit_notes_id_request_cookie/0,
              post_credit_notes_id_request_body/0, post_credit_notes_id_response/0]).
-export_type([get_credit_notes_id_request/0, get_credit_notes_id_request_query/0,
              get_credit_notes_id_request_header/0, get_credit_notes_id_request_cookie/0,
              get_credit_notes_id_request_body/0, get_credit_notes_id_response/0]).
-export_type([get_bitcoin_transactions_request/0,
              get_bitcoin_transactions_request_query/0, get_bitcoin_transactions_request_header/0,
              get_bitcoin_transactions_request_cookie/0, get_bitcoin_transactions_request_body/0,
              get_bitcoin_transactions_response/0]).
-export_type([post_setup_intents_request/0, post_setup_intents_request_query/0,
              post_setup_intents_request_header/0, post_setup_intents_request_cookie/0,
              post_setup_intents_request_body/0, post_setup_intents_response/0]).
-export_type([get_setup_intents_request/0, get_setup_intents_request_query/0,
              get_setup_intents_request_header/0, get_setup_intents_request_cookie/0,
              get_setup_intents_request_body/0, get_setup_intents_response/0]).
-export_type([post_payouts_payout_cancel_request/0,
              post_payouts_payout_cancel_request_query/0,
              post_payouts_payout_cancel_request_header/0,
              post_payouts_payout_cancel_request_cookie/0,
              post_payouts_payout_cancel_request_body/0, post_payouts_payout_cancel_response/0]).
-export_type([post_issuing_authorizations_authorization_approve_request/0,
              post_issuing_authorizations_authorization_approve_request_query/0,
              post_issuing_authorizations_authorization_approve_request_header/0,
              post_issuing_authorizations_authorization_approve_request_cookie/0,
              post_issuing_authorizations_authorization_approve_request_body/0,
              post_issuing_authorizations_authorization_approve_response/0]).
-export_type([post_issuing_authorizations_authorization_decline_request/0,
              post_issuing_authorizations_authorization_decline_request_query/0,
              post_issuing_authorizations_authorization_decline_request_header/0,
              post_issuing_authorizations_authorization_decline_request_cookie/0,
              post_issuing_authorizations_authorization_decline_request_body/0,
              post_issuing_authorizations_authorization_decline_response/0]).
-export_type([post_reporting_report_runs_request/0,
              post_reporting_report_runs_request_query/0,
              post_reporting_report_runs_request_header/0,
              post_reporting_report_runs_request_cookie/0,
              post_reporting_report_runs_request_body/0, post_reporting_report_runs_response/0]).
-export_type([get_reporting_report_runs_request/0,
              get_reporting_report_runs_request_query/0, get_reporting_report_runs_request_header/0,
              get_reporting_report_runs_request_cookie/0, get_reporting_report_runs_request_body/0,
              get_reporting_report_runs_response/0]).
-export_type([post_invoices_invoice_void_request/0,
              post_invoices_invoice_void_request_query/0,
              post_invoices_invoice_void_request_header/0,
              post_invoices_invoice_void_request_cookie/0,
              post_invoices_invoice_void_request_body/0, post_invoices_invoice_void_response/0]).
-export_type([post_sources_request/0, post_sources_request_query/0,
              post_sources_request_header/0, post_sources_request_cookie/0,
              post_sources_request_body/0, post_sources_response/0]).
-export_type([post_billing_portal_configurations_request/0,
              post_billing_portal_configurations_request_query/0,
              post_billing_portal_configurations_request_header/0,
              post_billing_portal_configurations_request_cookie/0,
              post_billing_portal_configurations_request_body/0,
              post_billing_portal_configurations_response/0]).
-export_type([get_billing_portal_configurations_request/0,
              get_billing_portal_configurations_request_query/0,
              get_billing_portal_configurations_request_header/0,
              get_billing_portal_configurations_request_cookie/0,
              get_billing_portal_configurations_request_body/0,
              get_billing_portal_configurations_response/0]).
-export_type([post_quotes_request/0, post_quotes_request_query/0,
              post_quotes_request_header/0, post_quotes_request_cookie/0,
              post_quotes_request_body/0, post_quotes_response/0]).
-export_type([get_quotes_request/0, get_quotes_request_query/0,
              get_quotes_request_header/0, get_quotes_request_cookie/0, get_quotes_request_body/0,
              get_quotes_response/0]).
-export_type([post_transfers_transfer_request/0, post_transfers_transfer_request_query/0,
              post_transfers_transfer_request_header/0, post_transfers_transfer_request_cookie/0,
              post_transfers_transfer_request_body/0, post_transfers_transfer_response/0]).
-export_type([get_transfers_transfer_request/0, get_transfers_transfer_request_query/0,
              get_transfers_transfer_request_header/0, get_transfers_transfer_request_cookie/0,
              get_transfers_transfer_request_body/0, get_transfers_transfer_response/0]).
-export_type([get_quotes_quote_line_items_request/0,
              get_quotes_quote_line_items_request_query/0,
              get_quotes_quote_line_items_request_header/0,
              get_quotes_quote_line_items_request_cookie/0,
              get_quotes_quote_line_items_request_body/0, get_quotes_quote_line_items_response/0]).
-export_type([delete_invoiceitems_invoiceitem_request/0,
              delete_invoiceitems_invoiceitem_request_query/0,
              delete_invoiceitems_invoiceitem_request_header/0,
              delete_invoiceitems_invoiceitem_request_cookie/0,
              delete_invoiceitems_invoiceitem_request_body/0,
              delete_invoiceitems_invoiceitem_response/0]).
-export_type([post_invoiceitems_invoiceitem_request/0,
              post_invoiceitems_invoiceitem_request_query/0,
              post_invoiceitems_invoiceitem_request_header/0,
              post_invoiceitems_invoiceitem_request_cookie/0,
              post_invoiceitems_invoiceitem_request_body/0,
              post_invoiceitems_invoiceitem_response/0]).
-export_type([get_invoiceitems_invoiceitem_request/0,
              get_invoiceitems_invoiceitem_request_query/0,
              get_invoiceitems_invoiceitem_request_header/0,
              get_invoiceitems_invoiceitem_request_cookie/0,
              get_invoiceitems_invoiceitem_request_body/0,
              get_invoiceitems_invoiceitem_response/0]).
-export_type([post_payment_intents_intent_capture_request/0,
              post_payment_intents_intent_capture_request_query/0,
              post_payment_intents_intent_capture_request_header/0,
              post_payment_intents_intent_capture_request_cookie/0,
              post_payment_intents_intent_capture_request_body/0,
              post_payment_intents_intent_capture_response/0]).
-export_type([post_issuing_cards_request/0, post_issuing_cards_request_query/0,
              post_issuing_cards_request_header/0, post_issuing_cards_request_cookie/0,
              post_issuing_cards_request_body/0, post_issuing_cards_response/0]).
-export_type([get_issuing_cards_request/0, get_issuing_cards_request_query/0,
              get_issuing_cards_request_header/0, get_issuing_cards_request_cookie/0,
              get_issuing_cards_request_body/0, get_issuing_cards_response/0]).
-export_type([get_sources_source_source_transactions_request/0,
              get_sources_source_source_transactions_request_query/0,
              get_sources_source_source_transactions_request_header/0,
              get_sources_source_source_transactions_request_cookie/0,
              get_sources_source_source_transactions_request_body/0,
              get_sources_source_source_transactions_response/0]).
-export_type([post_subscription_schedules_schedule_release_request/0,
              post_subscription_schedules_schedule_release_request_query/0,
              post_subscription_schedules_schedule_release_request_header/0,
              post_subscription_schedules_schedule_release_request_cookie/0,
              post_subscription_schedules_schedule_release_request_body/0,
              post_subscription_schedules_schedule_release_response/0]).
-export_type([delete_customers_customer_cards_id_request/0,
              delete_customers_customer_cards_id_request_query/0,
              delete_customers_customer_cards_id_request_header/0,
              delete_customers_customer_cards_id_request_cookie/0,
              delete_customers_customer_cards_id_request_body/0,
              delete_customers_customer_cards_id_response/0]).
-export_type([post_customers_customer_cards_id_request/0,
              post_customers_customer_cards_id_request_query/0,
              post_customers_customer_cards_id_request_header/0,
              post_customers_customer_cards_id_request_cookie/0,
              post_customers_customer_cards_id_request_body/0,
              post_customers_customer_cards_id_response/0]).
-export_type([get_customers_customer_cards_id_request/0,
              get_customers_customer_cards_id_request_query/0,
              get_customers_customer_cards_id_request_header/0,
              get_customers_customer_cards_id_request_cookie/0,
              get_customers_customer_cards_id_request_body/0,
              get_customers_customer_cards_id_response/0]).
-export_type([post_charges_charge_dispute_request/0,
              post_charges_charge_dispute_request_query/0,
              post_charges_charge_dispute_request_header/0,
              post_charges_charge_dispute_request_cookie/0,
              post_charges_charge_dispute_request_body/0, post_charges_charge_dispute_response/0]).
-export_type([get_charges_charge_dispute_request/0,
              get_charges_charge_dispute_request_query/0,
              get_charges_charge_dispute_request_header/0,
              get_charges_charge_dispute_request_cookie/0,
              get_charges_charge_dispute_request_body/0, get_charges_charge_dispute_response/0]).
-export_type([post_quotes_quote_finalize_request/0,
              post_quotes_quote_finalize_request_query/0,
              post_quotes_quote_finalize_request_header/0,
              post_quotes_quote_finalize_request_cookie/0,
              post_quotes_quote_finalize_request_body/0, post_quotes_quote_finalize_response/0]).
-export_type([delete_skus_id_request/0, delete_skus_id_request_query/0,
              delete_skus_id_request_header/0, delete_skus_id_request_cookie/0,
              delete_skus_id_request_body/0, delete_skus_id_response/0]).
-export_type([post_skus_id_request/0, post_skus_id_request_query/0,
              post_skus_id_request_header/0, post_skus_id_request_cookie/0,
              post_skus_id_request_body/0, post_skus_id_response/0]).
-export_type([get_skus_id_request/0, get_skus_id_request_query/0,
              get_skus_id_request_header/0, get_skus_id_request_cookie/0,
              get_skus_id_request_body/0, get_skus_id_response/0]).
-export_type([post_disputes_dispute_request/0, post_disputes_dispute_request_query/0,
              post_disputes_dispute_request_header/0, post_disputes_dispute_request_cookie/0,
              post_disputes_dispute_request_body/0, post_disputes_dispute_response/0]).
-export_type([get_disputes_dispute_request/0, get_disputes_dispute_request_query/0,
              get_disputes_dispute_request_header/0, get_disputes_dispute_request_cookie/0,
              get_disputes_dispute_request_body/0, get_disputes_dispute_response/0]).
-export_type([post_terminal_locations_request/0, post_terminal_locations_request_query/0,
              post_terminal_locations_request_header/0, post_terminal_locations_request_cookie/0,
              post_terminal_locations_request_body/0, post_terminal_locations_response/0]).
-export_type([get_terminal_locations_request/0, get_terminal_locations_request_query/0,
              get_terminal_locations_request_header/0, get_terminal_locations_request_cookie/0,
              get_terminal_locations_request_body/0, get_terminal_locations_response/0]).
-export_type([post_subscription_schedules_request/0,
              post_subscription_schedules_request_query/0,
              post_subscription_schedules_request_header/0,
              post_subscription_schedules_request_cookie/0,
              post_subscription_schedules_request_body/0, post_subscription_schedules_response/0]).
-export_type([get_subscription_schedules_request/0,
              get_subscription_schedules_request_query/0,
              get_subscription_schedules_request_header/0,
              get_subscription_schedules_request_cookie/0,
              get_subscription_schedules_request_body/0, get_subscription_schedules_response/0]).
-export_type([post_payment_links_request/0, post_payment_links_request_query/0,
              post_payment_links_request_header/0, post_payment_links_request_cookie/0,
              post_payment_links_request_body/0, post_payment_links_response/0]).
-export_type([get_payment_links_request/0, get_payment_links_request_query/0,
              get_payment_links_request_header/0, get_payment_links_request_cookie/0,
              get_payment_links_request_body/0, get_payment_links_response/0]).
-export_type([post_tokens_request/0, post_tokens_request_query/0,
              post_tokens_request_header/0, post_tokens_request_cookie/0,
              post_tokens_request_body/0, post_tokens_response/0]).
-export_type([post_issuing_cardholders_cardholder_request/0,
              post_issuing_cardholders_cardholder_request_query/0,
              post_issuing_cardholders_cardholder_request_header/0,
              post_issuing_cardholders_cardholder_request_cookie/0,
              post_issuing_cardholders_cardholder_request_body/0,
              post_issuing_cardholders_cardholder_response/0]).
-export_type([get_issuing_cardholders_cardholder_request/0,
              get_issuing_cardholders_cardholder_request_query/0,
              get_issuing_cardholders_cardholder_request_header/0,
              get_issuing_cardholders_cardholder_request_cookie/0,
              get_issuing_cardholders_cardholder_request_body/0,
              get_issuing_cardholders_cardholder_response/0]).
-export_type([get_application_fees_id_request/0, get_application_fees_id_request_query/0,
              get_application_fees_id_request_header/0, get_application_fees_id_request_cookie/0,
              get_application_fees_id_request_body/0, get_application_fees_id_response/0]).
-export_type([get_exchange_rates_rate_id_request/0,
              get_exchange_rates_rate_id_request_query/0,
              get_exchange_rates_rate_id_request_header/0,
              get_exchange_rates_rate_id_request_cookie/0,
              get_exchange_rates_rate_id_request_body/0, get_exchange_rates_rate_id_response/0]).
-export_type([post_payment_intents_intent_confirm_request/0,
              post_payment_intents_intent_confirm_request_query/0,
              post_payment_intents_intent_confirm_request_header/0,
              post_payment_intents_intent_confirm_request_cookie/0,
              post_payment_intents_intent_confirm_request_body/0,
              post_payment_intents_intent_confirm_response/0]).
-export_type([get_credit_notes_preview_request/0,
              get_credit_notes_preview_request_query/0, get_credit_notes_preview_request_header/0,
              get_credit_notes_preview_request_cookie/0, get_credit_notes_preview_request_body/0,
              get_credit_notes_preview_response/0]).
-export_type([get_balance_history_id_request/0, get_balance_history_id_request_query/0,
              get_balance_history_id_request_header/0, get_balance_history_id_request_cookie/0,
              get_balance_history_id_request_body/0, get_balance_history_id_response/0]).
-export_type([post_payouts_payout_reverse_request/0,
              post_payouts_payout_reverse_request_query/0,
              post_payouts_payout_reverse_request_header/0,
              post_payouts_payout_reverse_request_cookie/0,
              post_payouts_payout_reverse_request_body/0, post_payouts_payout_reverse_response/0]).
-export_type([get_reporting_report_runs_report_run_request/0,
              get_reporting_report_runs_report_run_request_query/0,
              get_reporting_report_runs_report_run_request_header/0,
              get_reporting_report_runs_report_run_request_cookie/0,
              get_reporting_report_runs_report_run_request_body/0,
              get_reporting_report_runs_report_run_response/0]).
-export_type([get_sources_source_source_transactions_source_transaction_request/0,
              get_sources_source_source_transactions_source_transaction_request_query/0,
              get_sources_source_source_transactions_source_transaction_request_header/0,
              get_sources_source_source_transactions_source_transaction_request_cookie/0,
              get_sources_source_source_transactions_source_transaction_request_body/0,
              get_sources_source_source_transactions_source_transaction_response/0]).
-export_type([delete_customers_customer_request/0,
              delete_customers_customer_request_query/0, delete_customers_customer_request_header/0,
              delete_customers_customer_request_cookie/0, delete_customers_customer_request_body/0,
              delete_customers_customer_response/0]).
-export_type([post_customers_customer_request/0, post_customers_customer_request_query/0,
              post_customers_customer_request_header/0, post_customers_customer_request_cookie/0,
              post_customers_customer_request_body/0, post_customers_customer_response/0]).
-export_type([get_customers_customer_request/0, get_customers_customer_request_query/0,
              get_customers_customer_request_header/0, get_customers_customer_request_cookie/0,
              get_customers_customer_request_body/0, get_customers_customer_response/0]).
-export_type([post_billing_portal_sessions_request/0,
              post_billing_portal_sessions_request_query/0,
              post_billing_portal_sessions_request_header/0,
              post_billing_portal_sessions_request_cookie/0,
              post_billing_portal_sessions_request_body/0,
              post_billing_portal_sessions_response/0]).
-export_type([post_payment_links_payment_link_request/0,
              post_payment_links_payment_link_request_query/0,
              post_payment_links_payment_link_request_header/0,
              post_payment_links_payment_link_request_cookie/0,
              post_payment_links_payment_link_request_body/0,
              post_payment_links_payment_link_response/0]).
-export_type([get_payment_links_payment_link_request/0,
              get_payment_links_payment_link_request_query/0,
              get_payment_links_payment_link_request_header/0,
              get_payment_links_payment_link_request_cookie/0,
              get_payment_links_payment_link_request_body/0,
              get_payment_links_payment_link_response/0]).
-export_type([get_credit_notes_credit_note_lines_request/0,
              get_credit_notes_credit_note_lines_request_query/0,
              get_credit_notes_credit_note_lines_request_header/0,
              get_credit_notes_credit_note_lines_request_cookie/0,
              get_credit_notes_credit_note_lines_request_body/0,
              get_credit_notes_credit_note_lines_response/0]).
-export_type([get_sigma_scheduled_query_runs_request/0,
              get_sigma_scheduled_query_runs_request_query/0,
              get_sigma_scheduled_query_runs_request_header/0,
              get_sigma_scheduled_query_runs_request_cookie/0,
              get_sigma_scheduled_query_runs_request_body/0,
              get_sigma_scheduled_query_runs_response/0]).

-type options() ::
    #{http => mhttp:request_options(),
      host => uri:host(),
      scheme => uri:scheme(),
      port => uri:port_number()}.
-type result(T) ::
    {ok, T, mhttp:response()} |
    {error, error_reason()} |
    {error, error_reason(), mhttp:response()}.
-type error_reason() ::
    {mhttp, mhttp:error_reason()} |
    missing_content_type |
    unknown_content_type |
    {invalid_content_type, mhttp_media_type:error_reason()} |
    {invalid_json, json:error_reason()} |
    {invalid_payload, jsv:validation_error() | [jsv:validation_error()]}.
-type get_radar_early_fraud_warnings_request() ::
    #{query => get_radar_early_fraud_warnings_request_query(),
      header => get_radar_early_fraud_warnings_request_header(),
      cookie => get_radar_early_fraud_warnings_request_cookie(),
      body => get_radar_early_fraud_warnings_request_body()}.
-type get_radar_early_fraud_warnings_request_query() ::
    #{charge => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary()}.
-type get_radar_early_fraud_warnings_request_header() :: map().
-type get_radar_early_fraud_warnings_request_cookie() :: map().
-type get_radar_early_fraud_warnings_request_body() :: map().
-type get_radar_early_fraud_warnings_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:radar_early_fraud_warning()]}.
-type post_charges_charge_refunds_request() ::
    #{charge := binary(),
      query => post_charges_charge_refunds_request_query(),
      header => post_charges_charge_refunds_request_header(),
      cookie => post_charges_charge_refunds_request_cookie(),
      body => post_charges_charge_refunds_request_body()}.
-type post_charges_charge_refunds_request_query() :: map().
-type post_charges_charge_refunds_request_header() :: map().
-type post_charges_charge_refunds_request_cookie() :: map().
-type post_charges_charge_refunds_request_body() :: map().
-type post_charges_charge_refunds_response() ::
    stripe_model:error() | stripe_model:refund().
-type get_charges_charge_refunds_request() ::
    #{charge := binary(),
      query => get_charges_charge_refunds_request_query(),
      header => get_charges_charge_refunds_request_header(),
      cookie => get_charges_charge_refunds_request_cookie(),
      body => get_charges_charge_refunds_request_body()}.
-type get_charges_charge_refunds_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_charges_charge_refunds_request_header() :: map().
-type get_charges_charge_refunds_request_cookie() :: map().
-type get_charges_charge_refunds_request_body() :: map().
-type get_charges_charge_refunds_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:refund()]}.
-type post_identity_verification_sessions_session_redact_request() ::
    #{session := binary(),
      query => post_identity_verification_sessions_session_redact_request_query(),
      header => post_identity_verification_sessions_session_redact_request_header(),
      cookie => post_identity_verification_sessions_session_redact_request_cookie(),
      body => post_identity_verification_sessions_session_redact_request_body()}.
-type post_identity_verification_sessions_session_redact_request_query() :: map().
-type post_identity_verification_sessions_session_redact_request_header() :: map().
-type post_identity_verification_sessions_session_redact_request_cookie() :: map().
-type post_identity_verification_sessions_session_redact_request_body() :: map().
-type post_identity_verification_sessions_session_redact_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type post_billing_portal_configurations_configuration_request() ::
    #{configuration := binary(),
      query => post_billing_portal_configurations_configuration_request_query(),
      header => post_billing_portal_configurations_configuration_request_header(),
      cookie => post_billing_portal_configurations_configuration_request_cookie(),
      body => post_billing_portal_configurations_configuration_request_body()}.
-type post_billing_portal_configurations_configuration_request_query() :: map().
-type post_billing_portal_configurations_configuration_request_header() :: map().
-type post_billing_portal_configurations_configuration_request_cookie() :: map().
-type post_billing_portal_configurations_configuration_request_body() :: map().
-type post_billing_portal_configurations_configuration_response() ::
    stripe_model:error() | stripe_model:billing_portal_configuration().
-type get_billing_portal_configurations_configuration_request() ::
    #{configuration := binary(),
      query => get_billing_portal_configurations_configuration_request_query(),
      header => get_billing_portal_configurations_configuration_request_header(),
      cookie => get_billing_portal_configurations_configuration_request_cookie(),
      body => get_billing_portal_configurations_configuration_request_body()}.
-type get_billing_portal_configurations_configuration_request_query() ::
    #{expand => [binary()]}.
-type get_billing_portal_configurations_configuration_request_header() :: map().
-type get_billing_portal_configurations_configuration_request_cookie() :: map().
-type get_billing_portal_configurations_configuration_request_body() :: map().
-type get_billing_portal_configurations_configuration_response() ::
    stripe_model:error() | stripe_model:billing_portal_configuration().
-type post_payment_methods_request() ::
    #{query => post_payment_methods_request_query(),
      header => post_payment_methods_request_header(),
      cookie => post_payment_methods_request_cookie(),
      body => post_payment_methods_request_body()}.
-type post_payment_methods_request_query() :: map().
-type post_payment_methods_request_header() :: map().
-type post_payment_methods_request_cookie() :: map().
-type post_payment_methods_request_body() :: map().
-type post_payment_methods_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type get_payment_methods_request() ::
    #{query => get_payment_methods_request_query(),
      header => get_payment_methods_request_header(),
      cookie => get_payment_methods_request_cookie(),
      body => get_payment_methods_request_body()}.
-type get_payment_methods_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type :=
          acss_debit |
          afterpay_clearpay |
          alipay |
          au_becs_debit |
          bacs_debit |
          bancontact |
          boleto |
          card |
          eps |
          fpx |
          giropay |
          grabpay |
          ideal |
          klarna |
          oxxo |
          p24 |
          sepa_debit |
          sofort |
          wechat_pay}.
-type get_payment_methods_request_header() :: map().
-type get_payment_methods_request_cookie() :: map().
-type get_payment_methods_request_body() :: map().
-type get_payment_methods_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payment_method()]}.
-type delete_radar_value_lists_value_list_request() ::
    #{value_list := binary(),
      query => delete_radar_value_lists_value_list_request_query(),
      header => delete_radar_value_lists_value_list_request_header(),
      cookie => delete_radar_value_lists_value_list_request_cookie(),
      body => delete_radar_value_lists_value_list_request_body()}.
-type delete_radar_value_lists_value_list_request_query() :: map().
-type delete_radar_value_lists_value_list_request_header() :: map().
-type delete_radar_value_lists_value_list_request_cookie() :: map().
-type delete_radar_value_lists_value_list_request_body() :: map().
-type delete_radar_value_lists_value_list_response() ::
    stripe_model:error() | stripe_model:deleted_radar_value_list().
-type post_radar_value_lists_value_list_request() ::
    #{value_list := binary(),
      query => post_radar_value_lists_value_list_request_query(),
      header => post_radar_value_lists_value_list_request_header(),
      cookie => post_radar_value_lists_value_list_request_cookie(),
      body => post_radar_value_lists_value_list_request_body()}.
-type post_radar_value_lists_value_list_request_query() :: map().
-type post_radar_value_lists_value_list_request_header() :: map().
-type post_radar_value_lists_value_list_request_cookie() :: map().
-type post_radar_value_lists_value_list_request_body() :: map().
-type post_radar_value_lists_value_list_response() ::
    stripe_model:error() | stripe_model:radar_value_list().
-type get_radar_value_lists_value_list_request() ::
    #{value_list := binary(),
      query => get_radar_value_lists_value_list_request_query(),
      header => get_radar_value_lists_value_list_request_header(),
      cookie => get_radar_value_lists_value_list_request_cookie(),
      body => get_radar_value_lists_value_list_request_body()}.
-type get_radar_value_lists_value_list_request_query() :: #{expand => [binary()]}.
-type get_radar_value_lists_value_list_request_header() :: map().
-type get_radar_value_lists_value_list_request_cookie() :: map().
-type get_radar_value_lists_value_list_request_body() :: map().
-type get_radar_value_lists_value_list_response() ::
    stripe_model:error() | stripe_model:radar_value_list().
-type post_charges_charge_capture_request() ::
    #{charge := binary(),
      query => post_charges_charge_capture_request_query(),
      header => post_charges_charge_capture_request_header(),
      cookie => post_charges_charge_capture_request_cookie(),
      body => post_charges_charge_capture_request_body()}.
-type post_charges_charge_capture_request_query() :: map().
-type post_charges_charge_capture_request_header() :: map().
-type post_charges_charge_capture_request_cookie() :: map().
-type post_charges_charge_capture_request_body() :: map().
-type post_charges_charge_capture_response() ::
    stripe_model:error() | stripe_model:charge().
-type get_disputes_request() ::
    #{query => get_disputes_request_query(),
      header => get_disputes_request_header(),
      cookie => get_disputes_request_cookie(),
      body => get_disputes_request_body()}.
-type get_disputes_request_query() ::
    #{charge => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary()}.
-type get_disputes_request_header() :: map().
-type get_disputes_request_cookie() :: map().
-type get_disputes_request_body() :: map().
-type get_disputes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:dispute()]}.
-type post_prices_price_request() ::
    #{price := binary(),
      query => post_prices_price_request_query(),
      header => post_prices_price_request_header(),
      cookie => post_prices_price_request_cookie(),
      body => post_prices_price_request_body()}.
-type post_prices_price_request_query() :: map().
-type post_prices_price_request_header() :: map().
-type post_prices_price_request_cookie() :: map().
-type post_prices_price_request_body() :: map().
-type post_prices_price_response() :: stripe_model:error() | stripe_model:price().
-type get_prices_price_request() ::
    #{price := binary(),
      query => get_prices_price_request_query(),
      header => get_prices_price_request_header(),
      cookie => get_prices_price_request_cookie(),
      body => get_prices_price_request_body()}.
-type get_prices_price_request_query() :: #{expand => [binary()]}.
-type get_prices_price_request_header() :: map().
-type get_prices_price_request_cookie() :: map().
-type get_prices_price_request_body() :: map().
-type get_prices_price_response() :: stripe_model:error() | stripe_model:price().
-type post_accounts_request() ::
    #{query => post_accounts_request_query(),
      header => post_accounts_request_header(),
      cookie => post_accounts_request_cookie(),
      body => post_accounts_request_body()}.
-type post_accounts_request_query() :: map().
-type post_accounts_request_header() :: map().
-type post_accounts_request_cookie() :: map().
-type post_accounts_request_body() :: map().
-type post_accounts_response() :: stripe_model:error() | stripe_model:account().
-type get_accounts_request() ::
    #{query => get_accounts_request_query(),
      header => get_accounts_request_header(),
      cookie => get_accounts_request_cookie(),
      body => get_accounts_request_body()}.
-type get_accounts_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_accounts_request_header() :: map().
-type get_accounts_request_cookie() :: map().
-type get_accounts_request_body() :: map().
-type get_accounts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:account()]}.
-type post_identity_verification_sessions_session_cancel_request() ::
    #{session := binary(),
      query => post_identity_verification_sessions_session_cancel_request_query(),
      header => post_identity_verification_sessions_session_cancel_request_header(),
      cookie => post_identity_verification_sessions_session_cancel_request_cookie(),
      body => post_identity_verification_sessions_session_cancel_request_body()}.
-type post_identity_verification_sessions_session_cancel_request_query() :: map().
-type post_identity_verification_sessions_session_cancel_request_header() :: map().
-type post_identity_verification_sessions_session_cancel_request_cookie() :: map().
-type post_identity_verification_sessions_session_cancel_request_body() :: map().
-type post_identity_verification_sessions_session_cancel_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type delete_account_persons_person_request() ::
    #{person := binary(),
      query => delete_account_persons_person_request_query(),
      header => delete_account_persons_person_request_header(),
      cookie => delete_account_persons_person_request_cookie(),
      body => delete_account_persons_person_request_body()}.
-type delete_account_persons_person_request_query() :: map().
-type delete_account_persons_person_request_header() :: map().
-type delete_account_persons_person_request_cookie() :: map().
-type delete_account_persons_person_request_body() :: map().
-type delete_account_persons_person_response() ::
    stripe_model:error() | stripe_model:deleted_person().
-type post_account_persons_person_request() ::
    #{person := binary(),
      query => post_account_persons_person_request_query(),
      header => post_account_persons_person_request_header(),
      cookie => post_account_persons_person_request_cookie(),
      body => post_account_persons_person_request_body()}.
-type post_account_persons_person_request_query() :: map().
-type post_account_persons_person_request_header() :: map().
-type post_account_persons_person_request_cookie() :: map().
-type post_account_persons_person_request_body() :: map().
-type post_account_persons_person_response() ::
    stripe_model:error() | stripe_model:person().
-type get_account_persons_person_request() ::
    #{person := binary(),
      query => get_account_persons_person_request_query(),
      header => get_account_persons_person_request_header(),
      cookie => get_account_persons_person_request_cookie(),
      body => get_account_persons_person_request_body()}.
-type get_account_persons_person_request_query() :: #{expand => [binary()]}.
-type get_account_persons_person_request_header() :: map().
-type get_account_persons_person_request_cookie() :: map().
-type get_account_persons_person_request_body() :: map().
-type get_account_persons_person_response() ::
    stripe_model:error() | stripe_model:person().
-type post_issuing_authorizations_authorization_request() ::
    #{authorization := binary(),
      query => post_issuing_authorizations_authorization_request_query(),
      header => post_issuing_authorizations_authorization_request_header(),
      cookie => post_issuing_authorizations_authorization_request_cookie(),
      body => post_issuing_authorizations_authorization_request_body()}.
-type post_issuing_authorizations_authorization_request_query() :: map().
-type post_issuing_authorizations_authorization_request_header() :: map().
-type post_issuing_authorizations_authorization_request_cookie() :: map().
-type post_issuing_authorizations_authorization_request_body() :: map().
-type post_issuing_authorizations_authorization_response() ::
    stripe_model:error() | stripe_model:issuing_authorization().
-type get_issuing_authorizations_authorization_request() ::
    #{authorization := binary(),
      query => get_issuing_authorizations_authorization_request_query(),
      header => get_issuing_authorizations_authorization_request_header(),
      cookie => get_issuing_authorizations_authorization_request_cookie(),
      body => get_issuing_authorizations_authorization_request_body()}.
-type get_issuing_authorizations_authorization_request_query() :: #{expand => [binary()]}.
-type get_issuing_authorizations_authorization_request_header() :: map().
-type get_issuing_authorizations_authorization_request_cookie() :: map().
-type get_issuing_authorizations_authorization_request_body() :: map().
-type get_issuing_authorizations_authorization_response() ::
    stripe_model:error() | stripe_model:issuing_authorization().
-type get_files_file_request() ::
    #{file := binary(),
      query => get_files_file_request_query(),
      header => get_files_file_request_header(),
      cookie => get_files_file_request_cookie(),
      body => get_files_file_request_body()}.
-type get_files_file_request_query() :: #{expand => [binary()]}.
-type get_files_file_request_header() :: map().
-type get_files_file_request_cookie() :: map().
-type get_files_file_request_body() :: map().
-type get_files_file_response() :: stripe_model:error() | stripe_model:file().
-type post_issuing_cards_card_request() ::
    #{card := binary(),
      query => post_issuing_cards_card_request_query(),
      header => post_issuing_cards_card_request_header(),
      cookie => post_issuing_cards_card_request_cookie(),
      body => post_issuing_cards_card_request_body()}.
-type post_issuing_cards_card_request_query() :: map().
-type post_issuing_cards_card_request_header() :: map().
-type post_issuing_cards_card_request_cookie() :: map().
-type post_issuing_cards_card_request_body() :: map().
-type post_issuing_cards_card_response() ::
    stripe_model:error() | stripe_model:issuing_card().
-type get_issuing_cards_card_request() ::
    #{card := binary(),
      query => get_issuing_cards_card_request_query(),
      header => get_issuing_cards_card_request_header(),
      cookie => get_issuing_cards_card_request_cookie(),
      body => get_issuing_cards_card_request_body()}.
-type get_issuing_cards_card_request_query() :: #{expand => [binary()]}.
-type get_issuing_cards_card_request_header() :: map().
-type get_issuing_cards_card_request_cookie() :: map().
-type get_issuing_cards_card_request_body() :: map().
-type get_issuing_cards_card_response() ::
    stripe_model:error() | stripe_model:issuing_card().
-type post_sources_source_verify_request() ::
    #{source := binary(),
      query => post_sources_source_verify_request_query(),
      header => post_sources_source_verify_request_header(),
      cookie => post_sources_source_verify_request_cookie(),
      body => post_sources_source_verify_request_body()}.
-type post_sources_source_verify_request_query() :: map().
-type post_sources_source_verify_request_header() :: map().
-type post_sources_source_verify_request_cookie() :: map().
-type post_sources_source_verify_request_body() :: map().
-type post_sources_source_verify_response() ::
    stripe_model:error() | stripe_model:source().
-type post_invoiceitems_request() ::
    #{query => post_invoiceitems_request_query(),
      header => post_invoiceitems_request_header(),
      cookie => post_invoiceitems_request_cookie(),
      body => post_invoiceitems_request_body()}.
-type post_invoiceitems_request_query() :: map().
-type post_invoiceitems_request_header() :: map().
-type post_invoiceitems_request_cookie() :: map().
-type post_invoiceitems_request_body() :: map().
-type post_invoiceitems_response() :: stripe_model:error() | stripe_model:invoiceitem().
-type get_invoiceitems_request() ::
    #{query => get_invoiceitems_request_query(),
      header => get_invoiceitems_request_header(),
      cookie => get_invoiceitems_request_cookie(),
      body => get_invoiceitems_request_body()}.
-type get_invoiceitems_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      invoice => binary(),
      limit => integer(),
      pending => boolean(),
      starting_after => binary()}.
-type get_invoiceitems_request_header() :: map().
-type get_invoiceitems_request_cookie() :: map().
-type get_invoiceitems_request_body() :: map().
-type get_invoiceitems_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:invoiceitem()]}.
-type delete_ephemeral_keys_key_request() ::
    #{key := binary(),
      query => delete_ephemeral_keys_key_request_query(),
      header => delete_ephemeral_keys_key_request_header(),
      cookie => delete_ephemeral_keys_key_request_cookie(),
      body => delete_ephemeral_keys_key_request_body()}.
-type delete_ephemeral_keys_key_request_query() :: map().
-type delete_ephemeral_keys_key_request_header() :: map().
-type delete_ephemeral_keys_key_request_cookie() :: map().
-type delete_ephemeral_keys_key_request_body() :: map().
-type delete_ephemeral_keys_key_response() ::
    stripe_model:error() | stripe_model:ephemeral_key().
-type get_exchange_rates_request() ::
    #{query => get_exchange_rates_request_query(),
      header => get_exchange_rates_request_header(),
      cookie => get_exchange_rates_request_cookie(),
      body => get_exchange_rates_request_body()}.
-type get_exchange_rates_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_exchange_rates_request_header() :: map().
-type get_exchange_rates_request_cookie() :: map().
-type get_exchange_rates_request_body() :: map().
-type get_exchange_rates_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:exchange_rate()]}.
-type post_setup_intents_intent_request() ::
    #{intent := binary(),
      query => post_setup_intents_intent_request_query(),
      header => post_setup_intents_intent_request_header(),
      cookie => post_setup_intents_intent_request_cookie(),
      body => post_setup_intents_intent_request_body()}.
-type post_setup_intents_intent_request_query() :: map().
-type post_setup_intents_intent_request_header() :: map().
-type post_setup_intents_intent_request_cookie() :: map().
-type post_setup_intents_intent_request_body() :: map().
-type post_setup_intents_intent_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type get_setup_intents_intent_request() ::
    #{intent := binary(),
      query => get_setup_intents_intent_request_query(),
      header => get_setup_intents_intent_request_header(),
      cookie => get_setup_intents_intent_request_cookie(),
      body => get_setup_intents_intent_request_body()}.
-type get_setup_intents_intent_request_query() ::
    #{client_secret => binary(), expand => [binary()]}.
-type get_setup_intents_intent_request_header() :: map().
-type get_setup_intents_intent_request_cookie() :: map().
-type get_setup_intents_intent_request_body() :: map().
-type get_setup_intents_intent_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type post_files_request() ::
    #{query => post_files_request_query(),
      header => post_files_request_header(),
      cookie => post_files_request_cookie(),
      body => post_files_request_body()}.
-type post_files_request_query() :: map().
-type post_files_request_header() :: map().
-type post_files_request_cookie() :: map().
-type post_files_request_body() :: map().
-type post_files_response() :: stripe_model:error() | stripe_model:file().
-type get_files_request() ::
    #{query => get_files_request_query(),
      header => get_files_request_header(),
      cookie => get_files_request_cookie(),
      body => get_files_request_body()}.
-type get_files_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      purpose =>
          account_requirement |
          additional_verification |
          business_icon |
          business_logo |
          customer_signature |
          dispute_evidence |
          document_provider_identity_document |
          finance_report_run |
          identity_document |
          identity_document_downloadable |
          pci_document |
          selfie |
          sigma_scheduled_query |
          tax_document_user_upload,
      starting_after => binary()}.
-type get_files_request_header() :: map().
-type get_files_request_cookie() :: map().
-type get_files_request_body() :: map().
-type get_files_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:file()]}.
-type delete_customers_customer_bank_accounts_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => delete_customers_customer_bank_accounts_id_request_query(),
      header => delete_customers_customer_bank_accounts_id_request_header(),
      cookie => delete_customers_customer_bank_accounts_id_request_cookie(),
      body => delete_customers_customer_bank_accounts_id_request_body()}.
-type delete_customers_customer_bank_accounts_id_request_query() :: map().
-type delete_customers_customer_bank_accounts_id_request_header() :: map().
-type delete_customers_customer_bank_accounts_id_request_cookie() :: map().
-type delete_customers_customer_bank_accounts_id_request_body() :: map().
-type delete_customers_customer_bank_accounts_id_response() ::
    stripe_model:error() |
    stripe_model:payment_source() |
    stripe_model:deleted_payment_source().
-type post_customers_customer_bank_accounts_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_bank_accounts_id_request_query(),
      header => post_customers_customer_bank_accounts_id_request_header(),
      cookie => post_customers_customer_bank_accounts_id_request_cookie(),
      body => post_customers_customer_bank_accounts_id_request_body()}.
-type post_customers_customer_bank_accounts_id_request_query() :: map().
-type post_customers_customer_bank_accounts_id_request_header() :: map().
-type post_customers_customer_bank_accounts_id_request_cookie() :: map().
-type post_customers_customer_bank_accounts_id_request_body() :: map().
-type post_customers_customer_bank_accounts_id_response() ::
    stripe_model:error() |
    stripe_model:card() |
    stripe_model:bank_account() |
    stripe_model:source().
-type get_customers_customer_bank_accounts_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => get_customers_customer_bank_accounts_id_request_query(),
      header => get_customers_customer_bank_accounts_id_request_header(),
      cookie => get_customers_customer_bank_accounts_id_request_cookie(),
      body => get_customers_customer_bank_accounts_id_request_body()}.
-type get_customers_customer_bank_accounts_id_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_bank_accounts_id_request_header() :: map().
-type get_customers_customer_bank_accounts_id_request_cookie() :: map().
-type get_customers_customer_bank_accounts_id_request_body() :: map().
-type get_customers_customer_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:bank_account().
-type get_issuer_fraud_records_issuer_fraud_record_request() ::
    #{issuer_fraud_record := binary(),
      query => get_issuer_fraud_records_issuer_fraud_record_request_query(),
      header => get_issuer_fraud_records_issuer_fraud_record_request_header(),
      cookie => get_issuer_fraud_records_issuer_fraud_record_request_cookie(),
      body => get_issuer_fraud_records_issuer_fraud_record_request_body()}.
-type get_issuer_fraud_records_issuer_fraud_record_request_query() ::
    #{expand => [binary()]}.
-type get_issuer_fraud_records_issuer_fraud_record_request_header() :: map().
-type get_issuer_fraud_records_issuer_fraud_record_request_cookie() :: map().
-type get_issuer_fraud_records_issuer_fraud_record_request_body() :: map().
-type get_issuer_fraud_records_issuer_fraud_record_response() ::
    stripe_model:error() | stripe_model:issuer_fraud_record().
-type delete_accounts_account_people_person_request() ::
    #{account := binary(),
      person := binary(),
      query => delete_accounts_account_people_person_request_query(),
      header => delete_accounts_account_people_person_request_header(),
      cookie => delete_accounts_account_people_person_request_cookie(),
      body => delete_accounts_account_people_person_request_body()}.
-type delete_accounts_account_people_person_request_query() :: map().
-type delete_accounts_account_people_person_request_header() :: map().
-type delete_accounts_account_people_person_request_cookie() :: map().
-type delete_accounts_account_people_person_request_body() :: map().
-type delete_accounts_account_people_person_response() ::
    stripe_model:error() | stripe_model:deleted_person().
-type post_accounts_account_people_person_request() ::
    #{account := binary(),
      person := binary(),
      query => post_accounts_account_people_person_request_query(),
      header => post_accounts_account_people_person_request_header(),
      cookie => post_accounts_account_people_person_request_cookie(),
      body => post_accounts_account_people_person_request_body()}.
-type post_accounts_account_people_person_request_query() :: map().
-type post_accounts_account_people_person_request_header() :: map().
-type post_accounts_account_people_person_request_cookie() :: map().
-type post_accounts_account_people_person_request_body() :: map().
-type post_accounts_account_people_person_response() ::
    stripe_model:error() | stripe_model:person().
-type get_accounts_account_people_person_request() ::
    #{account := binary(),
      person := binary(),
      query => get_accounts_account_people_person_request_query(),
      header => get_accounts_account_people_person_request_header(),
      cookie => get_accounts_account_people_person_request_cookie(),
      body => get_accounts_account_people_person_request_body()}.
-type get_accounts_account_people_person_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_people_person_request_header() :: map().
-type get_accounts_account_people_person_request_cookie() :: map().
-type get_accounts_account_people_person_request_body() :: map().
-type get_accounts_account_people_person_response() ::
    stripe_model:error() | stripe_model:person().
-type post_payouts_request() ::
    #{query => post_payouts_request_query(),
      header => post_payouts_request_header(),
      cookie => post_payouts_request_cookie(),
      body => post_payouts_request_body()}.
-type post_payouts_request_query() :: map().
-type post_payouts_request_header() :: map().
-type post_payouts_request_cookie() :: map().
-type post_payouts_request_body() :: map().
-type post_payouts_response() :: stripe_model:error() | stripe_model:payout().
-type get_payouts_request() ::
    #{query => get_payouts_request_query(),
      header => get_payouts_request_header(),
      cookie => get_payouts_request_cookie(),
      body => get_payouts_request_body()}.
-type get_payouts_request_query() ::
    #{arrival_date =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      destination => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => binary()}.
-type get_payouts_request_header() :: map().
-type get_payouts_request_cookie() :: map().
-type get_payouts_request_body() :: map().
-type get_payouts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payout()]}.
-type post_account_capabilities_capability_request() ::
    #{capability := binary(),
      query => post_account_capabilities_capability_request_query(),
      header => post_account_capabilities_capability_request_header(),
      cookie => post_account_capabilities_capability_request_cookie(),
      body => post_account_capabilities_capability_request_body()}.
-type post_account_capabilities_capability_request_query() :: map().
-type post_account_capabilities_capability_request_header() :: map().
-type post_account_capabilities_capability_request_cookie() :: map().
-type post_account_capabilities_capability_request_body() :: map().
-type post_account_capabilities_capability_response() ::
    stripe_model:error() | stripe_model:capability().
-type get_account_capabilities_capability_request() ::
    #{capability := binary(),
      query => get_account_capabilities_capability_request_query(),
      header => get_account_capabilities_capability_request_header(),
      cookie => get_account_capabilities_capability_request_cookie(),
      body => get_account_capabilities_capability_request_body()}.
-type get_account_capabilities_capability_request_query() :: #{expand => [binary()]}.
-type get_account_capabilities_capability_request_header() :: map().
-type get_account_capabilities_capability_request_cookie() :: map().
-type get_account_capabilities_capability_request_body() :: map().
-type get_account_capabilities_capability_response() ::
    stripe_model:error() | stripe_model:capability().
-type get_sources_source_mandate_notifications_mandate_notification_request() ::
    #{mandate_notification := binary(),
      source := binary(),
      query => get_sources_source_mandate_notifications_mandate_notification_request_query(),
      header => get_sources_source_mandate_notifications_mandate_notification_request_header(),
      cookie => get_sources_source_mandate_notifications_mandate_notification_request_cookie(),
      body => get_sources_source_mandate_notifications_mandate_notification_request_body()}.
-type get_sources_source_mandate_notifications_mandate_notification_request_query() ::
    #{expand => [binary()]}.
-type get_sources_source_mandate_notifications_mandate_notification_request_header() ::
    map().
-type get_sources_source_mandate_notifications_mandate_notification_request_cookie() ::
    map().
-type get_sources_source_mandate_notifications_mandate_notification_request_body() ::
    map().
-type get_sources_source_mandate_notifications_mandate_notification_response() ::
    stripe_model:error() | stripe_model:source_mandate_notification().
-type post_application_fees_fee_refunds_id_request() ::
    #{fee := binary(),
      id := binary(),
      query => post_application_fees_fee_refunds_id_request_query(),
      header => post_application_fees_fee_refunds_id_request_header(),
      cookie => post_application_fees_fee_refunds_id_request_cookie(),
      body => post_application_fees_fee_refunds_id_request_body()}.
-type post_application_fees_fee_refunds_id_request_query() :: map().
-type post_application_fees_fee_refunds_id_request_header() :: map().
-type post_application_fees_fee_refunds_id_request_cookie() :: map().
-type post_application_fees_fee_refunds_id_request_body() :: map().
-type post_application_fees_fee_refunds_id_response() ::
    stripe_model:error() | stripe_model:fee_refund().
-type get_application_fees_fee_refunds_id_request() ::
    #{fee := binary(),
      id := binary(),
      query => get_application_fees_fee_refunds_id_request_query(),
      header => get_application_fees_fee_refunds_id_request_header(),
      cookie => get_application_fees_fee_refunds_id_request_cookie(),
      body => get_application_fees_fee_refunds_id_request_body()}.
-type get_application_fees_fee_refunds_id_request_query() :: #{expand => [binary()]}.
-type get_application_fees_fee_refunds_id_request_header() :: map().
-type get_application_fees_fee_refunds_id_request_cookie() :: map().
-type get_application_fees_fee_refunds_id_request_body() :: map().
-type get_application_fees_fee_refunds_id_response() ::
    stripe_model:error() | stripe_model:fee_refund().
-type delete_customers_customer_discount_request() ::
    #{customer := binary(),
      query => delete_customers_customer_discount_request_query(),
      header => delete_customers_customer_discount_request_header(),
      cookie => delete_customers_customer_discount_request_cookie(),
      body => delete_customers_customer_discount_request_body()}.
-type delete_customers_customer_discount_request_query() :: map().
-type delete_customers_customer_discount_request_header() :: map().
-type delete_customers_customer_discount_request_cookie() :: map().
-type delete_customers_customer_discount_request_body() :: map().
-type delete_customers_customer_discount_response() ::
    stripe_model:error() | stripe_model:deleted_discount().
-type get_customers_customer_discount_request() ::
    #{customer := binary(),
      query => get_customers_customer_discount_request_query(),
      header => get_customers_customer_discount_request_header(),
      cookie => get_customers_customer_discount_request_cookie(),
      body => get_customers_customer_discount_request_body()}.
-type get_customers_customer_discount_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_discount_request_header() :: map().
-type get_customers_customer_discount_request_cookie() :: map().
-type get_customers_customer_discount_request_body() :: map().
-type get_customers_customer_discount_response() ::
    stripe_model:error() | stripe_model:discount().
-type post_coupons_request() ::
    #{query => post_coupons_request_query(),
      header => post_coupons_request_header(),
      cookie => post_coupons_request_cookie(),
      body => post_coupons_request_body()}.
-type post_coupons_request_query() :: map().
-type post_coupons_request_header() :: map().
-type post_coupons_request_cookie() :: map().
-type post_coupons_request_body() :: map().
-type post_coupons_response() :: stripe_model:error() | stripe_model:coupon().
-type get_coupons_request() ::
    #{query => get_coupons_request_query(),
      header => get_coupons_request_header(),
      cookie => get_coupons_request_cookie(),
      body => get_coupons_request_body()}.
-type get_coupons_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_coupons_request_header() :: map().
-type get_coupons_request_cookie() :: map().
-type get_coupons_request_body() :: map().
-type get_coupons_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:coupon()]}.
-type post_charges_charge_dispute_close_request() ::
    #{charge := binary(),
      query => post_charges_charge_dispute_close_request_query(),
      header => post_charges_charge_dispute_close_request_header(),
      cookie => post_charges_charge_dispute_close_request_cookie(),
      body => post_charges_charge_dispute_close_request_body()}.
-type post_charges_charge_dispute_close_request_query() :: map().
-type post_charges_charge_dispute_close_request_header() :: map().
-type post_charges_charge_dispute_close_request_cookie() :: map().
-type post_charges_charge_dispute_close_request_body() :: map().
-type post_charges_charge_dispute_close_response() ::
    stripe_model:error() | stripe_model:dispute().
-type delete_plans_plan_request() ::
    #{plan := binary(),
      query => delete_plans_plan_request_query(),
      header => delete_plans_plan_request_header(),
      cookie => delete_plans_plan_request_cookie(),
      body => delete_plans_plan_request_body()}.
-type delete_plans_plan_request_query() :: map().
-type delete_plans_plan_request_header() :: map().
-type delete_plans_plan_request_cookie() :: map().
-type delete_plans_plan_request_body() :: map().
-type delete_plans_plan_response() :: stripe_model:error() | stripe_model:deleted_plan().
-type post_plans_plan_request() ::
    #{plan := binary(),
      query => post_plans_plan_request_query(),
      header => post_plans_plan_request_header(),
      cookie => post_plans_plan_request_cookie(),
      body => post_plans_plan_request_body()}.
-type post_plans_plan_request_query() :: map().
-type post_plans_plan_request_header() :: map().
-type post_plans_plan_request_cookie() :: map().
-type post_plans_plan_request_body() :: map().
-type post_plans_plan_response() :: stripe_model:error() | stripe_model:plan().
-type get_plans_plan_request() ::
    #{plan := binary(),
      query => get_plans_plan_request_query(),
      header => get_plans_plan_request_header(),
      cookie => get_plans_plan_request_cookie(),
      body => get_plans_plan_request_body()}.
-type get_plans_plan_request_query() :: #{expand => [binary()]}.
-type get_plans_plan_request_header() :: map().
-type get_plans_plan_request_cookie() :: map().
-type get_plans_plan_request_body() :: map().
-type get_plans_plan_response() :: stripe_model:error() | stripe_model:plan().
-type post_customers_customer_bank_accounts_request() ::
    #{customer := binary(),
      query => post_customers_customer_bank_accounts_request_query(),
      header => post_customers_customer_bank_accounts_request_header(),
      cookie => post_customers_customer_bank_accounts_request_cookie(),
      body => post_customers_customer_bank_accounts_request_body()}.
-type post_customers_customer_bank_accounts_request_query() :: map().
-type post_customers_customer_bank_accounts_request_header() :: map().
-type post_customers_customer_bank_accounts_request_cookie() :: map().
-type post_customers_customer_bank_accounts_request_body() :: map().
-type post_customers_customer_bank_accounts_response() ::
    stripe_model:error() | stripe_model:payment_source().
-type get_customers_customer_bank_accounts_request() ::
    #{customer := binary(),
      query => get_customers_customer_bank_accounts_request_query(),
      header => get_customers_customer_bank_accounts_request_header(),
      cookie => get_customers_customer_bank_accounts_request_cookie(),
      body => get_customers_customer_bank_accounts_request_body()}.
-type get_customers_customer_bank_accounts_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_bank_accounts_request_header() :: map().
-type get_customers_customer_bank_accounts_request_cookie() :: map().
-type get_customers_customer_bank_accounts_request_body() :: map().
-type get_customers_customer_bank_accounts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bank_account()]}.
-type delete_terminal_readers_reader_request() ::
    #{reader := binary(),
      query => delete_terminal_readers_reader_request_query(),
      header => delete_terminal_readers_reader_request_header(),
      cookie => delete_terminal_readers_reader_request_cookie(),
      body => delete_terminal_readers_reader_request_body()}.
-type delete_terminal_readers_reader_request_query() :: map().
-type delete_terminal_readers_reader_request_header() :: map().
-type delete_terminal_readers_reader_request_cookie() :: map().
-type delete_terminal_readers_reader_request_body() :: map().
-type delete_terminal_readers_reader_response() ::
    stripe_model:error() | stripe_model:deleted_terminal_reader().
-type post_terminal_readers_reader_request() ::
    #{reader := binary(),
      query => post_terminal_readers_reader_request_query(),
      header => post_terminal_readers_reader_request_header(),
      cookie => post_terminal_readers_reader_request_cookie(),
      body => post_terminal_readers_reader_request_body()}.
-type post_terminal_readers_reader_request_query() :: map().
-type post_terminal_readers_reader_request_header() :: map().
-type post_terminal_readers_reader_request_cookie() :: map().
-type post_terminal_readers_reader_request_body() :: map().
-type post_terminal_readers_reader_response() ::
    stripe_model:error() |
    stripe_model:terminal_reader() |
    stripe_model:deleted_terminal_reader().
-type get_terminal_readers_reader_request() ::
    #{reader := binary(),
      query => get_terminal_readers_reader_request_query(),
      header => get_terminal_readers_reader_request_header(),
      cookie => get_terminal_readers_reader_request_cookie(),
      body => get_terminal_readers_reader_request_body()}.
-type get_terminal_readers_reader_request_query() :: #{expand => [binary()]}.
-type get_terminal_readers_reader_request_header() :: map().
-type get_terminal_readers_reader_request_cookie() :: map().
-type get_terminal_readers_reader_request_body() :: map().
-type get_terminal_readers_reader_response() ::
    stripe_model:error() |
    stripe_model:terminal_reader() |
    stripe_model:deleted_terminal_reader().
-type delete_accounts_account_persons_person_request() ::
    #{account := binary(),
      person := binary(),
      query => delete_accounts_account_persons_person_request_query(),
      header => delete_accounts_account_persons_person_request_header(),
      cookie => delete_accounts_account_persons_person_request_cookie(),
      body => delete_accounts_account_persons_person_request_body()}.
-type delete_accounts_account_persons_person_request_query() :: map().
-type delete_accounts_account_persons_person_request_header() :: map().
-type delete_accounts_account_persons_person_request_cookie() :: map().
-type delete_accounts_account_persons_person_request_body() :: map().
-type delete_accounts_account_persons_person_response() ::
    stripe_model:error() | stripe_model:deleted_person().
-type post_accounts_account_persons_person_request() ::
    #{account := binary(),
      person := binary(),
      query => post_accounts_account_persons_person_request_query(),
      header => post_accounts_account_persons_person_request_header(),
      cookie => post_accounts_account_persons_person_request_cookie(),
      body => post_accounts_account_persons_person_request_body()}.
-type post_accounts_account_persons_person_request_query() :: map().
-type post_accounts_account_persons_person_request_header() :: map().
-type post_accounts_account_persons_person_request_cookie() :: map().
-type post_accounts_account_persons_person_request_body() :: map().
-type post_accounts_account_persons_person_response() ::
    stripe_model:error() | stripe_model:person().
-type get_accounts_account_persons_person_request() ::
    #{account := binary(),
      person := binary(),
      query => get_accounts_account_persons_person_request_query(),
      header => get_accounts_account_persons_person_request_header(),
      cookie => get_accounts_account_persons_person_request_cookie(),
      body => get_accounts_account_persons_person_request_body()}.
-type get_accounts_account_persons_person_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_persons_person_request_header() :: map().
-type get_accounts_account_persons_person_request_cookie() :: map().
-type get_accounts_account_persons_person_request_body() :: map().
-type get_accounts_account_persons_person_response() ::
    stripe_model:error() | stripe_model:person().
-type post_credit_notes_id_void_request() ::
    #{id := binary(),
      query => post_credit_notes_id_void_request_query(),
      header => post_credit_notes_id_void_request_header(),
      cookie => post_credit_notes_id_void_request_cookie(),
      body => post_credit_notes_id_void_request_body()}.
-type post_credit_notes_id_void_request_query() :: map().
-type post_credit_notes_id_void_request_header() :: map().
-type post_credit_notes_id_void_request_cookie() :: map().
-type post_credit_notes_id_void_request_body() :: map().
-type post_credit_notes_id_void_response() ::
    stripe_model:error() | stripe_model:credit_note().
-type post_customers_customer_sources_request() ::
    #{customer := binary(),
      query => post_customers_customer_sources_request_query(),
      header => post_customers_customer_sources_request_header(),
      cookie => post_customers_customer_sources_request_cookie(),
      body => post_customers_customer_sources_request_body()}.
-type post_customers_customer_sources_request_query() :: map().
-type post_customers_customer_sources_request_header() :: map().
-type post_customers_customer_sources_request_cookie() :: map().
-type post_customers_customer_sources_request_body() :: map().
-type post_customers_customer_sources_response() ::
    stripe_model:error() | stripe_model:payment_source().
-type get_customers_customer_sources_request() ::
    #{customer := binary(),
      query => get_customers_customer_sources_request_query(),
      header => get_customers_customer_sources_request_header(),
      cookie => get_customers_customer_sources_request_cookie(),
      body => get_customers_customer_sources_request_body()}.
-type get_customers_customer_sources_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      object => binary(),
      starting_after => binary()}.
-type get_customers_customer_sources_request_header() :: map().
-type get_customers_customer_sources_request_cookie() :: map().
-type get_customers_customer_sources_request_body() :: map().
-type get_customers_customer_sources_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data :=
          [stripe_model:alipay_account() |
           stripe_model:bank_account() |
           stripe_model:bitcoin_receiver() |
           stripe_model:card() |
           stripe_model:source()]}.
-type post_account_links_request() ::
    #{query => post_account_links_request_query(),
      header => post_account_links_request_header(),
      cookie => post_account_links_request_cookie(),
      body => post_account_links_request_body()}.
-type post_account_links_request_query() :: map().
-type post_account_links_request_header() :: map().
-type post_account_links_request_cookie() :: map().
-type post_account_links_request_body() :: map().
-type post_account_links_response() :: stripe_model:error() | stripe_model:account_link().
-type post_payouts_payout_request() ::
    #{payout := binary(),
      query => post_payouts_payout_request_query(),
      header => post_payouts_payout_request_header(),
      cookie => post_payouts_payout_request_cookie(),
      body => post_payouts_payout_request_body()}.
-type post_payouts_payout_request_query() :: map().
-type post_payouts_payout_request_header() :: map().
-type post_payouts_payout_request_cookie() :: map().
-type post_payouts_payout_request_body() :: map().
-type post_payouts_payout_response() :: stripe_model:error() | stripe_model:payout().
-type get_payouts_payout_request() ::
    #{payout := binary(),
      query => get_payouts_payout_request_query(),
      header => get_payouts_payout_request_header(),
      cookie => get_payouts_payout_request_cookie(),
      body => get_payouts_payout_request_body()}.
-type get_payouts_payout_request_query() :: #{expand => [binary()]}.
-type get_payouts_payout_request_header() :: map().
-type get_payouts_payout_request_cookie() :: map().
-type get_payouts_payout_request_body() :: map().
-type get_payouts_payout_response() :: stripe_model:error() | stripe_model:payout().
-type delete_subscription_items_item_request() ::
    #{item := binary(),
      query => delete_subscription_items_item_request_query(),
      header => delete_subscription_items_item_request_header(),
      cookie => delete_subscription_items_item_request_cookie(),
      body => delete_subscription_items_item_request_body()}.
-type delete_subscription_items_item_request_query() :: map().
-type delete_subscription_items_item_request_header() :: map().
-type delete_subscription_items_item_request_cookie() :: map().
-type delete_subscription_items_item_request_body() :: map().
-type delete_subscription_items_item_response() ::
    stripe_model:error() | stripe_model:deleted_subscription_item().
-type post_subscription_items_item_request() ::
    #{item := binary(),
      query => post_subscription_items_item_request_query(),
      header => post_subscription_items_item_request_header(),
      cookie => post_subscription_items_item_request_cookie(),
      body => post_subscription_items_item_request_body()}.
-type post_subscription_items_item_request_query() :: map().
-type post_subscription_items_item_request_header() :: map().
-type post_subscription_items_item_request_cookie() :: map().
-type post_subscription_items_item_request_body() :: map().
-type post_subscription_items_item_response() ::
    stripe_model:error() | stripe_model:subscription_item().
-type get_subscription_items_item_request() ::
    #{item := binary(),
      query => get_subscription_items_item_request_query(),
      header => get_subscription_items_item_request_header(),
      cookie => get_subscription_items_item_request_cookie(),
      body => get_subscription_items_item_request_body()}.
-type get_subscription_items_item_request_query() :: #{expand => [binary()]}.
-type get_subscription_items_item_request_header() :: map().
-type get_subscription_items_item_request_cookie() :: map().
-type get_subscription_items_item_request_body() :: map().
-type get_subscription_items_item_response() ::
    stripe_model:error() | stripe_model:subscription_item().
-type post_products_request() ::
    #{query => post_products_request_query(),
      header => post_products_request_header(),
      cookie => post_products_request_cookie(),
      body => post_products_request_body()}.
-type post_products_request_query() :: map().
-type post_products_request_header() :: map().
-type post_products_request_cookie() :: map().
-type post_products_request_body() :: map().
-type post_products_response() :: stripe_model:error() | stripe_model:product().
-type get_products_request() ::
    #{query => get_products_request_query(),
      header => get_products_request_header(),
      cookie => get_products_request_cookie(),
      body => get_products_request_body()}.
-type get_products_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      ids => [binary()],
      limit => integer(),
      shippable => boolean(),
      starting_after => binary(),
      url => binary()}.
-type get_products_request_header() :: map().
-type get_products_request_cookie() :: map().
-type get_products_request_body() :: map().
-type get_products_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:product()]}.
-type get_reporting_report_types_report_type_request() ::
    #{report_type := binary(),
      query => get_reporting_report_types_report_type_request_query(),
      header => get_reporting_report_types_report_type_request_header(),
      cookie => get_reporting_report_types_report_type_request_cookie(),
      body => get_reporting_report_types_report_type_request_body()}.
-type get_reporting_report_types_report_type_request_query() :: #{expand => [binary()]}.
-type get_reporting_report_types_report_type_request_header() :: map().
-type get_reporting_report_types_report_type_request_cookie() :: map().
-type get_reporting_report_types_report_type_request_body() :: map().
-type get_reporting_report_types_report_type_response() ::
    stripe_model:error() | stripe_model:reporting_report_type().
-type post_quotes_quote_accept_request() ::
    #{quote := binary(),
      query => post_quotes_quote_accept_request_query(),
      header => post_quotes_quote_accept_request_header(),
      cookie => post_quotes_quote_accept_request_cookie(),
      body => post_quotes_quote_accept_request_body()}.
-type post_quotes_quote_accept_request_query() :: map().
-type post_quotes_quote_accept_request_header() :: map().
-type post_quotes_quote_accept_request_cookie() :: map().
-type post_quotes_quote_accept_request_body() :: map().
-type post_quotes_quote_accept_response() :: stripe_model:error() | stripe_model:quote().
-type get_mandates_mandate_request() ::
    #{mandate := binary(),
      query => get_mandates_mandate_request_query(),
      header => get_mandates_mandate_request_header(),
      cookie => get_mandates_mandate_request_cookie(),
      body => get_mandates_mandate_request_body()}.
-type get_mandates_mandate_request_query() :: #{expand => [binary()]}.
-type get_mandates_mandate_request_header() :: map().
-type get_mandates_mandate_request_cookie() :: map().
-type get_mandates_mandate_request_body() :: map().
-type get_mandates_mandate_response() :: stripe_model:error() | stripe_model:mandate().
-type post_customers_customer_subscriptions_request() ::
    #{customer := binary(),
      query => post_customers_customer_subscriptions_request_query(),
      header => post_customers_customer_subscriptions_request_header(),
      cookie => post_customers_customer_subscriptions_request_cookie(),
      body => post_customers_customer_subscriptions_request_body()}.
-type post_customers_customer_subscriptions_request_query() :: map().
-type post_customers_customer_subscriptions_request_header() :: map().
-type post_customers_customer_subscriptions_request_cookie() :: map().
-type post_customers_customer_subscriptions_request_body() :: map().
-type post_customers_customer_subscriptions_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_customers_customer_subscriptions_request() ::
    #{customer := binary(),
      query => get_customers_customer_subscriptions_request_query(),
      header => get_customers_customer_subscriptions_request_header(),
      cookie => get_customers_customer_subscriptions_request_cookie(),
      body => get_customers_customer_subscriptions_request_body()}.
-type get_customers_customer_subscriptions_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_subscriptions_request_header() :: map().
-type get_customers_customer_subscriptions_request_cookie() :: map().
-type get_customers_customer_subscriptions_request_body() :: map().
-type get_customers_customer_subscriptions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:subscription()]}.
-type get_order_returns_id_request() ::
    #{id := binary(),
      query => get_order_returns_id_request_query(),
      header => get_order_returns_id_request_header(),
      cookie => get_order_returns_id_request_cookie(),
      body => get_order_returns_id_request_body()}.
-type get_order_returns_id_request_query() :: #{expand => [binary()]}.
-type get_order_returns_id_request_header() :: map().
-type get_order_returns_id_request_cookie() :: map().
-type get_order_returns_id_request_body() :: map().
-type get_order_returns_id_response() ::
    stripe_model:error() | stripe_model:order_return().
-type post_transfers_id_reversals_request() ::
    #{id := binary(),
      query => post_transfers_id_reversals_request_query(),
      header => post_transfers_id_reversals_request_header(),
      cookie => post_transfers_id_reversals_request_cookie(),
      body => post_transfers_id_reversals_request_body()}.
-type post_transfers_id_reversals_request_query() :: map().
-type post_transfers_id_reversals_request_header() :: map().
-type post_transfers_id_reversals_request_cookie() :: map().
-type post_transfers_id_reversals_request_body() :: map().
-type post_transfers_id_reversals_response() ::
    stripe_model:error() | stripe_model:transfer_reversal().
-type get_transfers_id_reversals_request() ::
    #{id := binary(),
      query => get_transfers_id_reversals_request_query(),
      header => get_transfers_id_reversals_request_header(),
      cookie => get_transfers_id_reversals_request_cookie(),
      body => get_transfers_id_reversals_request_body()}.
-type get_transfers_id_reversals_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_transfers_id_reversals_request_header() :: map().
-type get_transfers_id_reversals_request_cookie() :: map().
-type get_transfers_id_reversals_request_body() :: map().
-type get_transfers_id_reversals_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:transfer_reversal()]}.
-type get_reviews_review_request() ::
    #{review := binary(),
      query => get_reviews_review_request_query(),
      header => get_reviews_review_request_header(),
      cookie => get_reviews_review_request_cookie(),
      body => get_reviews_review_request_body()}.
-type get_reviews_review_request_query() :: #{expand => [binary()]}.
-type get_reviews_review_request_header() :: map().
-type get_reviews_review_request_cookie() :: map().
-type get_reviews_review_request_body() :: map().
-type get_reviews_review_response() :: stripe_model:error() | stripe_model:review().
-type delete_accounts_account_bank_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => delete_accounts_account_bank_accounts_id_request_query(),
      header => delete_accounts_account_bank_accounts_id_request_header(),
      cookie => delete_accounts_account_bank_accounts_id_request_cookie(),
      body => delete_accounts_account_bank_accounts_id_request_body()}.
-type delete_accounts_account_bank_accounts_id_request_query() :: map().
-type delete_accounts_account_bank_accounts_id_request_header() :: map().
-type delete_accounts_account_bank_accounts_id_request_cookie() :: map().
-type delete_accounts_account_bank_accounts_id_request_body() :: map().
-type delete_accounts_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:deleted_external_account().
-type post_accounts_account_bank_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => post_accounts_account_bank_accounts_id_request_query(),
      header => post_accounts_account_bank_accounts_id_request_header(),
      cookie => post_accounts_account_bank_accounts_id_request_cookie(),
      body => post_accounts_account_bank_accounts_id_request_body()}.
-type post_accounts_account_bank_accounts_id_request_query() :: map().
-type post_accounts_account_bank_accounts_id_request_header() :: map().
-type post_accounts_account_bank_accounts_id_request_cookie() :: map().
-type post_accounts_account_bank_accounts_id_request_body() :: map().
-type post_accounts_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_accounts_account_bank_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => get_accounts_account_bank_accounts_id_request_query(),
      header => get_accounts_account_bank_accounts_id_request_header(),
      cookie => get_accounts_account_bank_accounts_id_request_cookie(),
      body => get_accounts_account_bank_accounts_id_request_body()}.
-type get_accounts_account_bank_accounts_id_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_bank_accounts_id_request_header() :: map().
-type get_accounts_account_bank_accounts_id_request_cookie() :: map().
-type get_accounts_account_bank_accounts_id_request_body() :: map().
-type get_accounts_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type post_issuing_settlements_settlement_request() ::
    #{settlement := binary(),
      query => post_issuing_settlements_settlement_request_query(),
      header => post_issuing_settlements_settlement_request_header(),
      cookie => post_issuing_settlements_settlement_request_cookie(),
      body => post_issuing_settlements_settlement_request_body()}.
-type post_issuing_settlements_settlement_request_query() :: map().
-type post_issuing_settlements_settlement_request_header() :: map().
-type post_issuing_settlements_settlement_request_cookie() :: map().
-type post_issuing_settlements_settlement_request_body() :: map().
-type post_issuing_settlements_settlement_response() ::
    stripe_model:error() | stripe_model:issuing_settlement().
-type get_issuing_settlements_settlement_request() ::
    #{settlement := binary(),
      query => get_issuing_settlements_settlement_request_query(),
      header => get_issuing_settlements_settlement_request_header(),
      cookie => get_issuing_settlements_settlement_request_cookie(),
      body => get_issuing_settlements_settlement_request_body()}.
-type get_issuing_settlements_settlement_request_query() :: #{expand => [binary()]}.
-type get_issuing_settlements_settlement_request_header() :: map().
-type get_issuing_settlements_settlement_request_cookie() :: map().
-type get_issuing_settlements_settlement_request_body() :: map().
-type get_issuing_settlements_settlement_response() ::
    stripe_model:error() | stripe_model:issuing_settlement().
-type post_promotion_codes_promotion_code_request() ::
    #{promotion_code := binary(),
      query => post_promotion_codes_promotion_code_request_query(),
      header => post_promotion_codes_promotion_code_request_header(),
      cookie => post_promotion_codes_promotion_code_request_cookie(),
      body => post_promotion_codes_promotion_code_request_body()}.
-type post_promotion_codes_promotion_code_request_query() :: map().
-type post_promotion_codes_promotion_code_request_header() :: map().
-type post_promotion_codes_promotion_code_request_cookie() :: map().
-type post_promotion_codes_promotion_code_request_body() :: map().
-type post_promotion_codes_promotion_code_response() ::
    stripe_model:error() | stripe_model:promotion_code().
-type get_promotion_codes_promotion_code_request() ::
    #{promotion_code := binary(),
      query => get_promotion_codes_promotion_code_request_query(),
      header => get_promotion_codes_promotion_code_request_header(),
      cookie => get_promotion_codes_promotion_code_request_cookie(),
      body => get_promotion_codes_promotion_code_request_body()}.
-type get_promotion_codes_promotion_code_request_query() :: #{expand => [binary()]}.
-type get_promotion_codes_promotion_code_request_header() :: map().
-type get_promotion_codes_promotion_code_request_cookie() :: map().
-type get_promotion_codes_promotion_code_request_body() :: map().
-type get_promotion_codes_promotion_code_response() ::
    stripe_model:error() | stripe_model:promotion_code().
-type post_subscription_schedules_schedule_cancel_request() ::
    #{schedule := binary(),
      query => post_subscription_schedules_schedule_cancel_request_query(),
      header => post_subscription_schedules_schedule_cancel_request_header(),
      cookie => post_subscription_schedules_schedule_cancel_request_cookie(),
      body => post_subscription_schedules_schedule_cancel_request_body()}.
-type post_subscription_schedules_schedule_cancel_request_query() :: map().
-type post_subscription_schedules_schedule_cancel_request_header() :: map().
-type post_subscription_schedules_schedule_cancel_request_cookie() :: map().
-type post_subscription_schedules_schedule_cancel_request_body() :: map().
-type post_subscription_schedules_schedule_cancel_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type post_identity_verification_sessions_request() ::
    #{query => post_identity_verification_sessions_request_query(),
      header => post_identity_verification_sessions_request_header(),
      cookie => post_identity_verification_sessions_request_cookie(),
      body => post_identity_verification_sessions_request_body()}.
-type post_identity_verification_sessions_request_query() :: map().
-type post_identity_verification_sessions_request_header() :: map().
-type post_identity_verification_sessions_request_cookie() :: map().
-type post_identity_verification_sessions_request_body() :: map().
-type post_identity_verification_sessions_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type get_identity_verification_sessions_request() ::
    #{query => get_identity_verification_sessions_request_query(),
      header => get_identity_verification_sessions_request_header(),
      cookie => get_identity_verification_sessions_request_cookie(),
      body => get_identity_verification_sessions_request_body()}.
-type get_identity_verification_sessions_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => canceled | processing | requires_input | verified}.
-type get_identity_verification_sessions_request_header() :: map().
-type get_identity_verification_sessions_request_cookie() :: map().
-type get_identity_verification_sessions_request_body() :: map().
-type get_identity_verification_sessions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:identity_verification_session()]}.
-type post_radar_value_list_items_request() ::
    #{query => post_radar_value_list_items_request_query(),
      header => post_radar_value_list_items_request_header(),
      cookie => post_radar_value_list_items_request_cookie(),
      body => post_radar_value_list_items_request_body()}.
-type post_radar_value_list_items_request_query() :: map().
-type post_radar_value_list_items_request_header() :: map().
-type post_radar_value_list_items_request_cookie() :: map().
-type post_radar_value_list_items_request_body() :: map().
-type post_radar_value_list_items_response() ::
    stripe_model:error() | stripe_model:radar_value_list_item().
-type get_radar_value_list_items_request() ::
    #{query => get_radar_value_list_items_request_query(),
      header => get_radar_value_list_items_request_header(),
      cookie => get_radar_value_list_items_request_cookie(),
      body => get_radar_value_list_items_request_body()}.
-type get_radar_value_list_items_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      value => binary(),
      value_list := binary()}.
-type get_radar_value_list_items_request_header() :: map().
-type get_radar_value_list_items_request_cookie() :: map().
-type get_radar_value_list_items_request_body() :: map().
-type get_radar_value_list_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:radar_value_list_item()]}.
-type get_events_id_request() ::
    #{id := binary(),
      query => get_events_id_request_query(),
      header => get_events_id_request_header(),
      cookie => get_events_id_request_cookie(),
      body => get_events_id_request_body()}.
-type get_events_id_request_query() :: #{expand => [binary()]}.
-type get_events_id_request_header() :: map().
-type get_events_id_request_cookie() :: map().
-type get_events_id_request_body() :: map().
-type get_events_id_response() :: stripe_model:error() | stripe_model:event().
-type get_country_specs_request() ::
    #{query => get_country_specs_request_query(),
      header => get_country_specs_request_header(),
      cookie => get_country_specs_request_cookie(),
      body => get_country_specs_request_body()}.
-type get_country_specs_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_country_specs_request_header() :: map().
-type get_country_specs_request_cookie() :: map().
-type get_country_specs_request_body() :: map().
-type get_country_specs_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:country_spec()]}.
-type post_payment_intents_intent_verify_microdeposits_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_verify_microdeposits_request_query(),
      header => post_payment_intents_intent_verify_microdeposits_request_header(),
      cookie => post_payment_intents_intent_verify_microdeposits_request_cookie(),
      body => post_payment_intents_intent_verify_microdeposits_request_body()}.
-type post_payment_intents_intent_verify_microdeposits_request_query() :: map().
-type post_payment_intents_intent_verify_microdeposits_request_header() :: map().
-type post_payment_intents_intent_verify_microdeposits_request_cookie() :: map().
-type post_payment_intents_intent_verify_microdeposits_request_body() :: map().
-type post_payment_intents_intent_verify_microdeposits_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type post_subscription_items_subscription_item_usage_records_request() ::
    #{subscription_item := binary(),
      query => post_subscription_items_subscription_item_usage_records_request_query(),
      header => post_subscription_items_subscription_item_usage_records_request_header(),
      cookie => post_subscription_items_subscription_item_usage_records_request_cookie(),
      body => post_subscription_items_subscription_item_usage_records_request_body()}.
-type post_subscription_items_subscription_item_usage_records_request_query() :: map().
-type post_subscription_items_subscription_item_usage_records_request_header() :: map().
-type post_subscription_items_subscription_item_usage_records_request_cookie() :: map().
-type post_subscription_items_subscription_item_usage_records_request_body() :: map().
-type post_subscription_items_subscription_item_usage_records_response() ::
    stripe_model:error() | stripe_model:usage_record().
-type get_balance_history_request() ::
    #{query => get_balance_history_request_query(),
      header => get_balance_history_request_header(),
      cookie => get_balance_history_request_cookie(),
      body => get_balance_history_request_body()}.
-type get_balance_history_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      currency => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payout => binary(),
      source => binary(),
      starting_after => binary(),
      type => binary()}.
-type get_balance_history_request_header() :: map().
-type get_balance_history_request_cookie() :: map().
-type get_balance_history_request_body() :: map().
-type get_balance_history_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:balance_transaction()]}.
-type get_order_returns_request() ::
    #{query => get_order_returns_request_query(),
      header => get_order_returns_request_header(),
      cookie => get_order_returns_request_cookie(),
      body => get_order_returns_request_body()}.
-type get_order_returns_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      order => binary(),
      starting_after => binary()}.
-type get_order_returns_request_header() :: map().
-type get_order_returns_request_cookie() :: map().
-type get_order_returns_request_body() :: map().
-type get_order_returns_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:order_return()]}.
-type delete_account_external_accounts_id_request() ::
    #{id := binary(),
      query => delete_account_external_accounts_id_request_query(),
      header => delete_account_external_accounts_id_request_header(),
      cookie => delete_account_external_accounts_id_request_cookie(),
      body => delete_account_external_accounts_id_request_body()}.
-type delete_account_external_accounts_id_request_query() :: map().
-type delete_account_external_accounts_id_request_header() :: map().
-type delete_account_external_accounts_id_request_cookie() :: map().
-type delete_account_external_accounts_id_request_body() :: map().
-type delete_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:deleted_external_account().
-type post_account_external_accounts_id_request() ::
    #{id := binary(),
      query => post_account_external_accounts_id_request_query(),
      header => post_account_external_accounts_id_request_header(),
      cookie => post_account_external_accounts_id_request_cookie(),
      body => post_account_external_accounts_id_request_body()}.
-type post_account_external_accounts_id_request_query() :: map().
-type post_account_external_accounts_id_request_header() :: map().
-type post_account_external_accounts_id_request_cookie() :: map().
-type post_account_external_accounts_id_request_body() :: map().
-type post_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_account_external_accounts_id_request() ::
    #{id := binary(),
      query => get_account_external_accounts_id_request_query(),
      header => get_account_external_accounts_id_request_header(),
      cookie => get_account_external_accounts_id_request_cookie(),
      body => get_account_external_accounts_id_request_body()}.
-type get_account_external_accounts_id_request_query() :: #{expand => [binary()]}.
-type get_account_external_accounts_id_request_header() :: map().
-type get_account_external_accounts_id_request_cookie() :: map().
-type get_account_external_accounts_id_request_body() :: map().
-type get_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type post_apple_pay_domains_request() ::
    #{query => post_apple_pay_domains_request_query(),
      header => post_apple_pay_domains_request_header(),
      cookie => post_apple_pay_domains_request_cookie(),
      body => post_apple_pay_domains_request_body()}.
-type post_apple_pay_domains_request_query() :: map().
-type post_apple_pay_domains_request_header() :: map().
-type post_apple_pay_domains_request_cookie() :: map().
-type post_apple_pay_domains_request_body() :: map().
-type post_apple_pay_domains_response() ::
    stripe_model:error() | stripe_model:apple_pay_domain().
-type get_apple_pay_domains_request() ::
    #{query => get_apple_pay_domains_request_query(),
      header => get_apple_pay_domains_request_header(),
      cookie => get_apple_pay_domains_request_cookie(),
      body => get_apple_pay_domains_request_body()}.
-type get_apple_pay_domains_request_query() ::
    #{domain_name => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_apple_pay_domains_request_header() :: map().
-type get_apple_pay_domains_request_cookie() :: map().
-type get_apple_pay_domains_request_body() :: map().
-type get_apple_pay_domains_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:apple_pay_domain()]}.
-type post_credit_notes_request() ::
    #{query => post_credit_notes_request_query(),
      header => post_credit_notes_request_header(),
      cookie => post_credit_notes_request_cookie(),
      body => post_credit_notes_request_body()}.
-type post_credit_notes_request_query() :: map().
-type post_credit_notes_request_header() :: map().
-type post_credit_notes_request_cookie() :: map().
-type post_credit_notes_request_body() :: map().
-type post_credit_notes_response() :: stripe_model:error() | stripe_model:credit_note().
-type get_credit_notes_request() ::
    #{query => get_credit_notes_request_query(),
      header => get_credit_notes_request_header(),
      cookie => get_credit_notes_request_cookie(),
      body => get_credit_notes_request_body()}.
-type get_credit_notes_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      invoice => binary(),
      limit => integer(),
      starting_after => binary()}.
-type get_credit_notes_request_header() :: map().
-type get_credit_notes_request_cookie() :: map().
-type get_credit_notes_request_body() :: map().
-type get_credit_notes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:credit_note()]}.
-type get_sigma_scheduled_query_runs_scheduled_query_run_request() ::
    #{scheduled_query_run := binary(),
      query => get_sigma_scheduled_query_runs_scheduled_query_run_request_query(),
      header => get_sigma_scheduled_query_runs_scheduled_query_run_request_header(),
      cookie => get_sigma_scheduled_query_runs_scheduled_query_run_request_cookie(),
      body => get_sigma_scheduled_query_runs_scheduled_query_run_request_body()}.
-type get_sigma_scheduled_query_runs_scheduled_query_run_request_query() ::
    #{expand => [binary()]}.
-type get_sigma_scheduled_query_runs_scheduled_query_run_request_header() :: map().
-type get_sigma_scheduled_query_runs_scheduled_query_run_request_cookie() :: map().
-type get_sigma_scheduled_query_runs_scheduled_query_run_request_body() :: map().
-type get_sigma_scheduled_query_runs_scheduled_query_run_response() ::
    stripe_model:error() | stripe_model:scheduled_query_run().
-type delete_coupons_coupon_request() ::
    #{coupon := binary(),
      query => delete_coupons_coupon_request_query(),
      header => delete_coupons_coupon_request_header(),
      cookie => delete_coupons_coupon_request_cookie(),
      body => delete_coupons_coupon_request_body()}.
-type delete_coupons_coupon_request_query() :: map().
-type delete_coupons_coupon_request_header() :: map().
-type delete_coupons_coupon_request_cookie() :: map().
-type delete_coupons_coupon_request_body() :: map().
-type delete_coupons_coupon_response() ::
    stripe_model:error() | stripe_model:deleted_coupon().
-type post_coupons_coupon_request() ::
    #{coupon := binary(),
      query => post_coupons_coupon_request_query(),
      header => post_coupons_coupon_request_header(),
      cookie => post_coupons_coupon_request_cookie(),
      body => post_coupons_coupon_request_body()}.
-type post_coupons_coupon_request_query() :: map().
-type post_coupons_coupon_request_header() :: map().
-type post_coupons_coupon_request_cookie() :: map().
-type post_coupons_coupon_request_body() :: map().
-type post_coupons_coupon_response() :: stripe_model:error() | stripe_model:coupon().
-type get_coupons_coupon_request() ::
    #{coupon := binary(),
      query => get_coupons_coupon_request_query(),
      header => get_coupons_coupon_request_header(),
      cookie => get_coupons_coupon_request_cookie(),
      body => get_coupons_coupon_request_body()}.
-type get_coupons_coupon_request_query() :: #{expand => [binary()]}.
-type get_coupons_coupon_request_header() :: map().
-type get_coupons_coupon_request_cookie() :: map().
-type get_coupons_coupon_request_body() :: map().
-type get_coupons_coupon_response() :: stripe_model:error() | stripe_model:coupon().
-type delete_customers_customer_tax_ids_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => delete_customers_customer_tax_ids_id_request_query(),
      header => delete_customers_customer_tax_ids_id_request_header(),
      cookie => delete_customers_customer_tax_ids_id_request_cookie(),
      body => delete_customers_customer_tax_ids_id_request_body()}.
-type delete_customers_customer_tax_ids_id_request_query() :: map().
-type delete_customers_customer_tax_ids_id_request_header() :: map().
-type delete_customers_customer_tax_ids_id_request_cookie() :: map().
-type delete_customers_customer_tax_ids_id_request_body() :: map().
-type delete_customers_customer_tax_ids_id_response() ::
    stripe_model:error() | stripe_model:deleted_tax_id().
-type get_customers_customer_tax_ids_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => get_customers_customer_tax_ids_id_request_query(),
      header => get_customers_customer_tax_ids_id_request_header(),
      cookie => get_customers_customer_tax_ids_id_request_cookie(),
      body => get_customers_customer_tax_ids_id_request_body()}.
-type get_customers_customer_tax_ids_id_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_tax_ids_id_request_header() :: map().
-type get_customers_customer_tax_ids_id_request_cookie() :: map().
-type get_customers_customer_tax_ids_id_request_body() :: map().
-type get_customers_customer_tax_ids_id_response() ::
    stripe_model:error() | stripe_model:tax_id().
-type get_radar_early_fraud_warnings_early_fraud_warning_request() ::
    #{early_fraud_warning := binary(),
      query => get_radar_early_fraud_warnings_early_fraud_warning_request_query(),
      header => get_radar_early_fraud_warnings_early_fraud_warning_request_header(),
      cookie => get_radar_early_fraud_warnings_early_fraud_warning_request_cookie(),
      body => get_radar_early_fraud_warnings_early_fraud_warning_request_body()}.
-type get_radar_early_fraud_warnings_early_fraud_warning_request_query() ::
    #{expand => [binary()]}.
-type get_radar_early_fraud_warnings_early_fraud_warning_request_header() :: map().
-type get_radar_early_fraud_warnings_early_fraud_warning_request_cookie() :: map().
-type get_radar_early_fraud_warnings_early_fraud_warning_request_body() :: map().
-type get_radar_early_fraud_warnings_early_fraud_warning_response() ::
    stripe_model:error() | stripe_model:radar_early_fraud_warning().
-type get_issuing_settlements_request() ::
    #{query => get_issuing_settlements_request_query(),
      header => get_issuing_settlements_request_header(),
      cookie => get_issuing_settlements_request_cookie(),
      body => get_issuing_settlements_request_body()}.
-type get_issuing_settlements_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_issuing_settlements_request_header() :: map().
-type get_issuing_settlements_request_cookie() :: map().
-type get_issuing_settlements_request_body() :: map().
-type get_issuing_settlements_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_settlement()]}.
-type post_file_links_request() ::
    #{query => post_file_links_request_query(),
      header => post_file_links_request_header(),
      cookie => post_file_links_request_cookie(),
      body => post_file_links_request_body()}.
-type post_file_links_request_query() :: map().
-type post_file_links_request_header() :: map().
-type post_file_links_request_cookie() :: map().
-type post_file_links_request_body() :: map().
-type post_file_links_response() :: stripe_model:error() | stripe_model:file_link().
-type get_file_links_request() ::
    #{query => get_file_links_request_query(),
      header => get_file_links_request_header(),
      cookie => get_file_links_request_cookie(),
      body => get_file_links_request_body()}.
-type get_file_links_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      expired => boolean(),
      file => binary(),
      limit => integer(),
      starting_after => binary()}.
-type get_file_links_request_header() :: map().
-type get_file_links_request_cookie() :: map().
-type get_file_links_request_body() :: map().
-type get_file_links_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:file_link()]}.
-type get_identity_verification_reports_report_request() ::
    #{report := binary(),
      query => get_identity_verification_reports_report_request_query(),
      header => get_identity_verification_reports_report_request_header(),
      cookie => get_identity_verification_reports_report_request_cookie(),
      body => get_identity_verification_reports_report_request_body()}.
-type get_identity_verification_reports_report_request_query() :: #{expand => [binary()]}.
-type get_identity_verification_reports_report_request_header() :: map().
-type get_identity_verification_reports_report_request_cookie() :: map().
-type get_identity_verification_reports_report_request_body() :: map().
-type get_identity_verification_reports_report_response() ::
    stripe_model:error() | stripe_model:identity_verification_report().
-type post_transfers_request() ::
    #{query => post_transfers_request_query(),
      header => post_transfers_request_header(),
      cookie => post_transfers_request_cookie(),
      body => post_transfers_request_body()}.
-type post_transfers_request_query() :: map().
-type post_transfers_request_header() :: map().
-type post_transfers_request_cookie() :: map().
-type post_transfers_request_body() :: map().
-type post_transfers_response() :: stripe_model:error() | stripe_model:transfer().
-type get_transfers_request() ::
    #{query => get_transfers_request_query(),
      header => get_transfers_request_header(),
      cookie => get_transfers_request_cookie(),
      body => get_transfers_request_body()}.
-type get_transfers_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      destination => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      transfer_group => binary()}.
-type get_transfers_request_header() :: map().
-type get_transfers_request_cookie() :: map().
-type get_transfers_request_body() :: map().
-type get_transfers_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:transfer()]}.
-type delete_subscriptions_subscription_exposed_id_discount_request() ::
    #{subscription_exposed_id := binary(),
      query => delete_subscriptions_subscription_exposed_id_discount_request_query(),
      header => delete_subscriptions_subscription_exposed_id_discount_request_header(),
      cookie => delete_subscriptions_subscription_exposed_id_discount_request_cookie(),
      body => delete_subscriptions_subscription_exposed_id_discount_request_body()}.
-type delete_subscriptions_subscription_exposed_id_discount_request_query() :: map().
-type delete_subscriptions_subscription_exposed_id_discount_request_header() :: map().
-type delete_subscriptions_subscription_exposed_id_discount_request_cookie() :: map().
-type delete_subscriptions_subscription_exposed_id_discount_request_body() :: map().
-type delete_subscriptions_subscription_exposed_id_discount_response() ::
    stripe_model:error() | stripe_model:deleted_discount().
-type post_application_fees_id_refunds_request() ::
    #{id := binary(),
      query => post_application_fees_id_refunds_request_query(),
      header => post_application_fees_id_refunds_request_header(),
      cookie => post_application_fees_id_refunds_request_cookie(),
      body => post_application_fees_id_refunds_request_body()}.
-type post_application_fees_id_refunds_request_query() :: map().
-type post_application_fees_id_refunds_request_header() :: map().
-type post_application_fees_id_refunds_request_cookie() :: map().
-type post_application_fees_id_refunds_request_body() :: map().
-type post_application_fees_id_refunds_response() ::
    stripe_model:error() | stripe_model:fee_refund().
-type get_application_fees_id_refunds_request() ::
    #{id := binary(),
      query => get_application_fees_id_refunds_request_query(),
      header => get_application_fees_id_refunds_request_header(),
      cookie => get_application_fees_id_refunds_request_cookie(),
      body => get_application_fees_id_refunds_request_body()}.
-type get_application_fees_id_refunds_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_application_fees_id_refunds_request_header() :: map().
-type get_application_fees_id_refunds_request_cookie() :: map().
-type get_application_fees_id_refunds_request_body() :: map().
-type get_application_fees_id_refunds_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:fee_refund()]}.
-type post_accounts_account_bank_accounts_request() ::
    #{account := binary(),
      query => post_accounts_account_bank_accounts_request_query(),
      header => post_accounts_account_bank_accounts_request_header(),
      cookie => post_accounts_account_bank_accounts_request_cookie(),
      body => post_accounts_account_bank_accounts_request_body()}.
-type post_accounts_account_bank_accounts_request_query() :: map().
-type post_accounts_account_bank_accounts_request_header() :: map().
-type post_accounts_account_bank_accounts_request_cookie() :: map().
-type post_accounts_account_bank_accounts_request_body() :: map().
-type post_accounts_account_bank_accounts_response() ::
    stripe_model:error() | stripe_model:external_account().
-type delete_accounts_account_request() ::
    #{account := binary(),
      query => delete_accounts_account_request_query(),
      header => delete_accounts_account_request_header(),
      cookie => delete_accounts_account_request_cookie(),
      body => delete_accounts_account_request_body()}.
-type delete_accounts_account_request_query() :: map().
-type delete_accounts_account_request_header() :: map().
-type delete_accounts_account_request_cookie() :: map().
-type delete_accounts_account_request_body() :: map().
-type delete_accounts_account_response() ::
    stripe_model:error() | stripe_model:deleted_account().
-type post_accounts_account_request() ::
    #{account := binary(),
      query => post_accounts_account_request_query(),
      header => post_accounts_account_request_header(),
      cookie => post_accounts_account_request_cookie(),
      body => post_accounts_account_request_body()}.
-type post_accounts_account_request_query() :: map().
-type post_accounts_account_request_header() :: map().
-type post_accounts_account_request_cookie() :: map().
-type post_accounts_account_request_body() :: map().
-type post_accounts_account_response() :: stripe_model:error() | stripe_model:account().
-type get_accounts_account_request() ::
    #{account := binary(),
      query => get_accounts_account_request_query(),
      header => get_accounts_account_request_header(),
      cookie => get_accounts_account_request_cookie(),
      body => get_accounts_account_request_body()}.
-type get_accounts_account_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_request_header() :: map().
-type get_accounts_account_request_cookie() :: map().
-type get_accounts_account_request_body() :: map().
-type get_accounts_account_response() :: stripe_model:error() | stripe_model:account().
-type post_subscription_schedules_schedule_request() ::
    #{schedule := binary(),
      query => post_subscription_schedules_schedule_request_query(),
      header => post_subscription_schedules_schedule_request_header(),
      cookie => post_subscription_schedules_schedule_request_cookie(),
      body => post_subscription_schedules_schedule_request_body()}.
-type post_subscription_schedules_schedule_request_query() :: map().
-type post_subscription_schedules_schedule_request_header() :: map().
-type post_subscription_schedules_schedule_request_cookie() :: map().
-type post_subscription_schedules_schedule_request_body() :: map().
-type post_subscription_schedules_schedule_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type get_subscription_schedules_schedule_request() ::
    #{schedule := binary(),
      query => get_subscription_schedules_schedule_request_query(),
      header => get_subscription_schedules_schedule_request_header(),
      cookie => get_subscription_schedules_schedule_request_cookie(),
      body => get_subscription_schedules_schedule_request_body()}.
-type get_subscription_schedules_schedule_request_query() :: #{expand => [binary()]}.
-type get_subscription_schedules_schedule_request_header() :: map().
-type get_subscription_schedules_schedule_request_cookie() :: map().
-type get_subscription_schedules_schedule_request_body() :: map().
-type get_subscription_schedules_schedule_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type post_invoices_invoice_pay_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_pay_request_query(),
      header => post_invoices_invoice_pay_request_header(),
      cookie => post_invoices_invoice_pay_request_cookie(),
      body => post_invoices_invoice_pay_request_body()}.
-type post_invoices_invoice_pay_request_query() :: map().
-type post_invoices_invoice_pay_request_header() :: map().
-type post_invoices_invoice_pay_request_cookie() :: map().
-type post_invoices_invoice_pay_request_body() :: map().
-type post_invoices_invoice_pay_response() ::
    stripe_model:error() | stripe_model:invoice().
-type post_transfers_transfer_reversals_id_request() ::
    #{id := binary(),
      transfer := binary(),
      query => post_transfers_transfer_reversals_id_request_query(),
      header => post_transfers_transfer_reversals_id_request_header(),
      cookie => post_transfers_transfer_reversals_id_request_cookie(),
      body => post_transfers_transfer_reversals_id_request_body()}.
-type post_transfers_transfer_reversals_id_request_query() :: map().
-type post_transfers_transfer_reversals_id_request_header() :: map().
-type post_transfers_transfer_reversals_id_request_cookie() :: map().
-type post_transfers_transfer_reversals_id_request_body() :: map().
-type post_transfers_transfer_reversals_id_response() ::
    stripe_model:error() | stripe_model:transfer_reversal().
-type get_transfers_transfer_reversals_id_request() ::
    #{id := binary(),
      transfer := binary(),
      query => get_transfers_transfer_reversals_id_request_query(),
      header => get_transfers_transfer_reversals_id_request_header(),
      cookie => get_transfers_transfer_reversals_id_request_cookie(),
      body => get_transfers_transfer_reversals_id_request_body()}.
-type get_transfers_transfer_reversals_id_request_query() :: #{expand => [binary()]}.
-type get_transfers_transfer_reversals_id_request_header() :: map().
-type get_transfers_transfer_reversals_id_request_cookie() :: map().
-type get_transfers_transfer_reversals_id_request_body() :: map().
-type get_transfers_transfer_reversals_id_response() ::
    stripe_model:error() | stripe_model:transfer_reversal().
-type post_topups_topup_request() ::
    #{topup := binary(),
      query => post_topups_topup_request_query(),
      header => post_topups_topup_request_header(),
      cookie => post_topups_topup_request_cookie(),
      body => post_topups_topup_request_body()}.
-type post_topups_topup_request_query() :: map().
-type post_topups_topup_request_header() :: map().
-type post_topups_topup_request_cookie() :: map().
-type post_topups_topup_request_body() :: map().
-type post_topups_topup_response() :: stripe_model:error() | stripe_model:topup().
-type get_topups_topup_request() ::
    #{topup := binary(),
      query => get_topups_topup_request_query(),
      header => get_topups_topup_request_header(),
      cookie => get_topups_topup_request_cookie(),
      body => get_topups_topup_request_body()}.
-type get_topups_topup_request_query() :: #{expand => [binary()]}.
-type get_topups_topup_request_header() :: map().
-type get_topups_topup_request_cookie() :: map().
-type get_topups_topup_request_body() :: map().
-type get_topups_topup_response() :: stripe_model:error() | stripe_model:topup().
-type delete_recipients_id_request() ::
    #{id := binary(),
      query => delete_recipients_id_request_query(),
      header => delete_recipients_id_request_header(),
      cookie => delete_recipients_id_request_cookie(),
      body => delete_recipients_id_request_body()}.
-type delete_recipients_id_request_query() :: map().
-type delete_recipients_id_request_header() :: map().
-type delete_recipients_id_request_cookie() :: map().
-type delete_recipients_id_request_body() :: map().
-type delete_recipients_id_response() ::
    stripe_model:error() | stripe_model:deleted_recipient().
-type post_recipients_id_request() ::
    #{id := binary(),
      query => post_recipients_id_request_query(),
      header => post_recipients_id_request_header(),
      cookie => post_recipients_id_request_cookie(),
      body => post_recipients_id_request_body()}.
-type post_recipients_id_request_query() :: map().
-type post_recipients_id_request_header() :: map().
-type post_recipients_id_request_cookie() :: map().
-type post_recipients_id_request_body() :: map().
-type post_recipients_id_response() :: stripe_model:error() | stripe_model:recipient().
-type get_recipients_id_request() ::
    #{id := binary(),
      query => get_recipients_id_request_query(),
      header => get_recipients_id_request_header(),
      cookie => get_recipients_id_request_cookie(),
      body => get_recipients_id_request_body()}.
-type get_recipients_id_request_query() :: #{expand => [binary()]}.
-type get_recipients_id_request_header() :: map().
-type get_recipients_id_request_cookie() :: map().
-type get_recipients_id_request_body() :: map().
-type get_recipients_id_response() ::
    stripe_model:error() | stripe_model:recipient() | stripe_model:deleted_recipient().
-type get_invoices_invoice_lines_request() ::
    #{invoice := binary(),
      query => get_invoices_invoice_lines_request_query(),
      header => get_invoices_invoice_lines_request_header(),
      cookie => get_invoices_invoice_lines_request_cookie(),
      body => get_invoices_invoice_lines_request_body()}.
-type get_invoices_invoice_lines_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_invoices_invoice_lines_request_header() :: map().
-type get_invoices_invoice_lines_request_cookie() :: map().
-type get_invoices_invoice_lines_request_body() :: map().
-type get_invoices_invoice_lines_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:line_item()]}.
-type delete_accounts_account_external_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => delete_accounts_account_external_accounts_id_request_query(),
      header => delete_accounts_account_external_accounts_id_request_header(),
      cookie => delete_accounts_account_external_accounts_id_request_cookie(),
      body => delete_accounts_account_external_accounts_id_request_body()}.
-type delete_accounts_account_external_accounts_id_request_query() :: map().
-type delete_accounts_account_external_accounts_id_request_header() :: map().
-type delete_accounts_account_external_accounts_id_request_cookie() :: map().
-type delete_accounts_account_external_accounts_id_request_body() :: map().
-type delete_accounts_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:deleted_external_account().
-type post_accounts_account_external_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => post_accounts_account_external_accounts_id_request_query(),
      header => post_accounts_account_external_accounts_id_request_header(),
      cookie => post_accounts_account_external_accounts_id_request_cookie(),
      body => post_accounts_account_external_accounts_id_request_body()}.
-type post_accounts_account_external_accounts_id_request_query() :: map().
-type post_accounts_account_external_accounts_id_request_header() :: map().
-type post_accounts_account_external_accounts_id_request_cookie() :: map().
-type post_accounts_account_external_accounts_id_request_body() :: map().
-type post_accounts_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_accounts_account_external_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => get_accounts_account_external_accounts_id_request_query(),
      header => get_accounts_account_external_accounts_id_request_header(),
      cookie => get_accounts_account_external_accounts_id_request_cookie(),
      body => get_accounts_account_external_accounts_id_request_body()}.
-type get_accounts_account_external_accounts_id_request_query() ::
    #{expand => [binary()]}.
-type get_accounts_account_external_accounts_id_request_header() :: map().
-type get_accounts_account_external_accounts_id_request_cookie() :: map().
-type get_accounts_account_external_accounts_id_request_body() :: map().
-type get_accounts_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type post_topups_request() ::
    #{query => post_topups_request_query(),
      header => post_topups_request_header(),
      cookie => post_topups_request_cookie(),
      body => post_topups_request_body()}.
-type post_topups_request_query() :: map().
-type post_topups_request_header() :: map().
-type post_topups_request_cookie() :: map().
-type post_topups_request_body() :: map().
-type post_topups_response() :: stripe_model:error() | stripe_model:topup().
-type get_topups_request() ::
    #{query => get_topups_request_query(),
      header => get_topups_request_header(),
      cookie => get_topups_request_cookie(),
      body => get_topups_request_body()}.
-type get_topups_request_query() ::
    #{amount =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => canceled | failed | pending | succeeded}.
-type get_topups_request_header() :: map().
-type get_topups_request_cookie() :: map().
-type get_topups_request_body() :: map().
-type get_topups_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:topup()]}.
-type post_orders_id_returns_request() ::
    #{id := binary(),
      query => post_orders_id_returns_request_query(),
      header => post_orders_id_returns_request_header(),
      cookie => post_orders_id_returns_request_cookie(),
      body => post_orders_id_returns_request_body()}.
-type post_orders_id_returns_request_query() :: map().
-type post_orders_id_returns_request_header() :: map().
-type post_orders_id_returns_request_cookie() :: map().
-type post_orders_id_returns_request_body() :: map().
-type post_orders_id_returns_response() ::
    stripe_model:error() | stripe_model:order_return().
-type post_orders_id_request() ::
    #{id := binary(),
      query => post_orders_id_request_query(),
      header => post_orders_id_request_header(),
      cookie => post_orders_id_request_cookie(),
      body => post_orders_id_request_body()}.
-type post_orders_id_request_query() :: map().
-type post_orders_id_request_header() :: map().
-type post_orders_id_request_cookie() :: map().
-type post_orders_id_request_body() :: map().
-type post_orders_id_response() :: stripe_model:error() | stripe_model:order().
-type get_orders_id_request() ::
    #{id := binary(),
      query => get_orders_id_request_query(),
      header => get_orders_id_request_header(),
      cookie => get_orders_id_request_cookie(),
      body => get_orders_id_request_body()}.
-type get_orders_id_request_query() :: #{expand => [binary()]}.
-type get_orders_id_request_header() :: map().
-type get_orders_id_request_cookie() :: map().
-type get_orders_id_request_body() :: map().
-type get_orders_id_response() :: stripe_model:error() | stripe_model:order().
-type delete_apple_pay_domains_domain_request() ::
    #{domain := binary(),
      query => delete_apple_pay_domains_domain_request_query(),
      header => delete_apple_pay_domains_domain_request_header(),
      cookie => delete_apple_pay_domains_domain_request_cookie(),
      body => delete_apple_pay_domains_domain_request_body()}.
-type delete_apple_pay_domains_domain_request_query() :: map().
-type delete_apple_pay_domains_domain_request_header() :: map().
-type delete_apple_pay_domains_domain_request_cookie() :: map().
-type delete_apple_pay_domains_domain_request_body() :: map().
-type delete_apple_pay_domains_domain_response() ::
    stripe_model:error() | stripe_model:deleted_apple_pay_domain().
-type get_apple_pay_domains_domain_request() ::
    #{domain := binary(),
      query => get_apple_pay_domains_domain_request_query(),
      header => get_apple_pay_domains_domain_request_header(),
      cookie => get_apple_pay_domains_domain_request_cookie(),
      body => get_apple_pay_domains_domain_request_body()}.
-type get_apple_pay_domains_domain_request_query() :: #{expand => [binary()]}.
-type get_apple_pay_domains_domain_request_header() :: map().
-type get_apple_pay_domains_domain_request_cookie() :: map().
-type get_apple_pay_domains_domain_request_body() :: map().
-type get_apple_pay_domains_domain_response() ::
    stripe_model:error() | stripe_model:apple_pay_domain().
-type get_issuing_transactions_request() ::
    #{query => get_issuing_transactions_request_query(),
      header => get_issuing_transactions_request_header(),
      cookie => get_issuing_transactions_request_cookie(),
      body => get_issuing_transactions_request_body()}.
-type get_issuing_transactions_request_query() ::
    #{card => binary(),
      cardholder => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type => capture | refund}.
-type get_issuing_transactions_request_header() :: map().
-type get_issuing_transactions_request_cookie() :: map().
-type get_issuing_transactions_request_body() :: map().
-type get_issuing_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_transaction()]}.
-type post_charges_charge_refund_request() ::
    #{charge := binary(),
      query => post_charges_charge_refund_request_query(),
      header => post_charges_charge_refund_request_header(),
      cookie => post_charges_charge_refund_request_cookie(),
      body => post_charges_charge_refund_request_body()}.
-type post_charges_charge_refund_request_query() :: map().
-type post_charges_charge_refund_request_header() :: map().
-type post_charges_charge_refund_request_cookie() :: map().
-type post_charges_charge_refund_request_body() :: map().
-type post_charges_charge_refund_response() ::
    stripe_model:error() | stripe_model:charge().
-type post_payment_methods_payment_method_attach_request() ::
    #{payment_method := binary(),
      query => post_payment_methods_payment_method_attach_request_query(),
      header => post_payment_methods_payment_method_attach_request_header(),
      cookie => post_payment_methods_payment_method_attach_request_cookie(),
      body => post_payment_methods_payment_method_attach_request_body()}.
-type post_payment_methods_payment_method_attach_request_query() :: map().
-type post_payment_methods_payment_method_attach_request_header() :: map().
-type post_payment_methods_payment_method_attach_request_cookie() :: map().
-type post_payment_methods_payment_method_attach_request_body() :: map().
-type post_payment_methods_payment_method_attach_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type post_payment_intents_intent_cancel_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_cancel_request_query(),
      header => post_payment_intents_intent_cancel_request_header(),
      cookie => post_payment_intents_intent_cancel_request_cookie(),
      body => post_payment_intents_intent_cancel_request_body()}.
-type post_payment_intents_intent_cancel_request_query() :: map().
-type post_payment_intents_intent_cancel_request_header() :: map().
-type post_payment_intents_intent_cancel_request_cookie() :: map().
-type post_payment_intents_intent_cancel_request_body() :: map().
-type post_payment_intents_intent_cancel_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type get_accounts_account_capabilities_request() ::
    #{account := binary(),
      query => get_accounts_account_capabilities_request_query(),
      header => get_accounts_account_capabilities_request_header(),
      cookie => get_accounts_account_capabilities_request_cookie(),
      body => get_accounts_account_capabilities_request_body()}.
-type get_accounts_account_capabilities_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_capabilities_request_header() :: map().
-type get_accounts_account_capabilities_request_cookie() :: map().
-type get_accounts_account_capabilities_request_body() :: map().
-type get_accounts_account_capabilities_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:capability()]}.
-type get_credit_notes_preview_lines_request() ::
    #{query => get_credit_notes_preview_lines_request_query(),
      header => get_credit_notes_preview_lines_request_header(),
      cookie => get_credit_notes_preview_lines_request_cookie(),
      body => get_credit_notes_preview_lines_request_body()}.
-type get_credit_notes_preview_lines_request_query() ::
    #{amount => integer(),
      credit_amount => integer(),
      ending_before => binary(),
      expand => [binary()],
      invoice := binary(),
      limit => integer(),
      lines =>
          [#{unit_amount_decimal => binary(),
             unit_amount => integer(),
             type := custom_line_item | invoice_line_item,
             tax_rates => [binary()] | '',
             quantity => integer(),
             invoice_line_item => binary(),
             description => binary(),
             amount => integer()}],
      memo => binary(),
      metadata => json:value(),
      out_of_band_amount => integer(),
      reason => duplicate | fraudulent | order_change | product_unsatisfactory,
      refund => binary(),
      refund_amount => integer(),
      starting_after => binary()}.
-type get_credit_notes_preview_lines_request_header() :: map().
-type get_credit_notes_preview_lines_request_cookie() :: map().
-type get_credit_notes_preview_lines_request_body() :: map().
-type get_credit_notes_preview_lines_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:credit_note_line_item()]}.
-type post_subscriptions_request() ::
    #{query => post_subscriptions_request_query(),
      header => post_subscriptions_request_header(),
      cookie => post_subscriptions_request_cookie(),
      body => post_subscriptions_request_body()}.
-type post_subscriptions_request_query() :: map().
-type post_subscriptions_request_header() :: map().
-type post_subscriptions_request_cookie() :: map().
-type post_subscriptions_request_body() :: map().
-type post_subscriptions_response() :: stripe_model:error() | stripe_model:subscription().
-type get_subscriptions_request() ::
    #{query => get_subscriptions_request_query(),
      header => get_subscriptions_request_header(),
      cookie => get_subscriptions_request_cookie(),
      body => get_subscriptions_request_body()}.
-type get_subscriptions_request_query() ::
    #{collection_method => charge_automatically | send_invoice,
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      current_period_end =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      current_period_start =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      price => binary(),
      starting_after => binary(),
      status =>
          active |
          all |
          canceled |
          ended |
          incomplete |
          incomplete_expired |
          past_due |
          trialing |
          unpaid}.
-type get_subscriptions_request_header() :: map().
-type get_subscriptions_request_cookie() :: map().
-type get_subscriptions_request_body() :: map().
-type get_subscriptions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:subscription()]}.
-type get_setup_attempts_request() ::
    #{query => get_setup_attempts_request_query(),
      header => get_setup_attempts_request_header(),
      cookie => get_setup_attempts_request_cookie(),
      body => get_setup_attempts_request_body()}.
-type get_setup_attempts_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      setup_intent := binary(),
      starting_after => binary()}.
-type get_setup_attempts_request_header() :: map().
-type get_setup_attempts_request_cookie() :: map().
-type get_setup_attempts_request_body() :: map().
-type get_setup_attempts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:setup_attempt()]}.
-type delete_customers_customer_subscriptions_subscription_exposed_id_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query => delete_customers_customer_subscriptions_subscription_exposed_id_request_query(),
      header =>
          delete_customers_customer_subscriptions_subscription_exposed_id_request_header(),
      cookie =>
          delete_customers_customer_subscriptions_subscription_exposed_id_request_cookie(),
      body => delete_customers_customer_subscriptions_subscription_exposed_id_request_body()}.
-type delete_customers_customer_subscriptions_subscription_exposed_id_request_query() ::
    map().
-type delete_customers_customer_subscriptions_subscription_exposed_id_request_header() ::
    map().
-type delete_customers_customer_subscriptions_subscription_exposed_id_request_cookie() ::
    map().
-type delete_customers_customer_subscriptions_subscription_exposed_id_request_body() ::
    map().
-type delete_customers_customer_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type post_customers_customer_subscriptions_subscription_exposed_id_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query => post_customers_customer_subscriptions_subscription_exposed_id_request_query(),
      header => post_customers_customer_subscriptions_subscription_exposed_id_request_header(),
      cookie => post_customers_customer_subscriptions_subscription_exposed_id_request_cookie(),
      body => post_customers_customer_subscriptions_subscription_exposed_id_request_body()}.
-type post_customers_customer_subscriptions_subscription_exposed_id_request_query() ::
    map().
-type post_customers_customer_subscriptions_subscription_exposed_id_request_header() ::
    map().
-type post_customers_customer_subscriptions_subscription_exposed_id_request_cookie() ::
    map().
-type post_customers_customer_subscriptions_subscription_exposed_id_request_body() ::
    map().
-type post_customers_customer_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_customers_customer_subscriptions_subscription_exposed_id_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query => get_customers_customer_subscriptions_subscription_exposed_id_request_query(),
      header => get_customers_customer_subscriptions_subscription_exposed_id_request_header(),
      cookie => get_customers_customer_subscriptions_subscription_exposed_id_request_cookie(),
      body => get_customers_customer_subscriptions_subscription_exposed_id_request_body()}.
-type get_customers_customer_subscriptions_subscription_exposed_id_request_query() ::
    #{expand => [binary()]}.
-type get_customers_customer_subscriptions_subscription_exposed_id_request_header() ::
    map().
-type get_customers_customer_subscriptions_subscription_exposed_id_request_cookie() ::
    map().
-type get_customers_customer_subscriptions_subscription_exposed_id_request_body() ::
    map().
-type get_customers_customer_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_bitcoin_receivers_id_request() ::
    #{id := binary(),
      query => get_bitcoin_receivers_id_request_query(),
      header => get_bitcoin_receivers_id_request_header(),
      cookie => get_bitcoin_receivers_id_request_cookie(),
      body => get_bitcoin_receivers_id_request_body()}.
-type get_bitcoin_receivers_id_request_query() :: #{expand => [binary()]}.
-type get_bitcoin_receivers_id_request_header() :: map().
-type get_bitcoin_receivers_id_request_cookie() :: map().
-type get_bitcoin_receivers_id_request_body() :: map().
-type get_bitcoin_receivers_id_response() ::
    stripe_model:error() | stripe_model:bitcoin_receiver().
-type post_orders_request() ::
    #{query => post_orders_request_query(),
      header => post_orders_request_header(),
      cookie => post_orders_request_cookie(),
      body => post_orders_request_body()}.
-type post_orders_request_query() :: map().
-type post_orders_request_header() :: map().
-type post_orders_request_cookie() :: map().
-type post_orders_request_body() :: map().
-type post_orders_response() :: stripe_model:error() | stripe_model:order().
-type get_orders_request() ::
    #{query => get_orders_request_query(),
      header => get_orders_request_header(),
      cookie => get_orders_request_cookie(),
      body => get_orders_request_body()}.
-type get_orders_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      ids => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => binary(),
      status_transitions =>
          #{returned =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            paid =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            fulfilled =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            canceled =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer()},
      upstream_ids => [binary()]}.
-type get_orders_request_header() :: map().
-type get_orders_request_cookie() :: map().
-type get_orders_request_body() :: map().
-type get_orders_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:order()]}.
-type post_ephemeral_keys_request() ::
    #{query => post_ephemeral_keys_request_query(),
      header => post_ephemeral_keys_request_header(),
      cookie => post_ephemeral_keys_request_cookie(),
      body => post_ephemeral_keys_request_body()}.
-type post_ephemeral_keys_request_query() :: map().
-type post_ephemeral_keys_request_header() :: map().
-type post_ephemeral_keys_request_cookie() :: map().
-type post_ephemeral_keys_request_body() :: map().
-type post_ephemeral_keys_response() ::
    stripe_model:error() | stripe_model:ephemeral_key().
-type delete_webhook_endpoints_webhook_endpoint_request() ::
    #{webhook_endpoint := binary(),
      query => delete_webhook_endpoints_webhook_endpoint_request_query(),
      header => delete_webhook_endpoints_webhook_endpoint_request_header(),
      cookie => delete_webhook_endpoints_webhook_endpoint_request_cookie(),
      body => delete_webhook_endpoints_webhook_endpoint_request_body()}.
-type delete_webhook_endpoints_webhook_endpoint_request_query() :: map().
-type delete_webhook_endpoints_webhook_endpoint_request_header() :: map().
-type delete_webhook_endpoints_webhook_endpoint_request_cookie() :: map().
-type delete_webhook_endpoints_webhook_endpoint_request_body() :: map().
-type delete_webhook_endpoints_webhook_endpoint_response() ::
    stripe_model:error() | stripe_model:deleted_webhook_endpoint().
-type post_webhook_endpoints_webhook_endpoint_request() ::
    #{webhook_endpoint := binary(),
      query => post_webhook_endpoints_webhook_endpoint_request_query(),
      header => post_webhook_endpoints_webhook_endpoint_request_header(),
      cookie => post_webhook_endpoints_webhook_endpoint_request_cookie(),
      body => post_webhook_endpoints_webhook_endpoint_request_body()}.
-type post_webhook_endpoints_webhook_endpoint_request_query() :: map().
-type post_webhook_endpoints_webhook_endpoint_request_header() :: map().
-type post_webhook_endpoints_webhook_endpoint_request_cookie() :: map().
-type post_webhook_endpoints_webhook_endpoint_request_body() :: map().
-type post_webhook_endpoints_webhook_endpoint_response() ::
    stripe_model:error() | stripe_model:webhook_endpoint().
-type get_webhook_endpoints_webhook_endpoint_request() ::
    #{webhook_endpoint := binary(),
      query => get_webhook_endpoints_webhook_endpoint_request_query(),
      header => get_webhook_endpoints_webhook_endpoint_request_header(),
      cookie => get_webhook_endpoints_webhook_endpoint_request_cookie(),
      body => get_webhook_endpoints_webhook_endpoint_request_body()}.
-type get_webhook_endpoints_webhook_endpoint_request_query() :: #{expand => [binary()]}.
-type get_webhook_endpoints_webhook_endpoint_request_header() :: map().
-type get_webhook_endpoints_webhook_endpoint_request_cookie() :: map().
-type get_webhook_endpoints_webhook_endpoint_request_body() :: map().
-type get_webhook_endpoints_webhook_endpoint_response() ::
    stripe_model:error() | stripe_model:webhook_endpoint().
-type post_account_persons_request() ::
    #{query => post_account_persons_request_query(),
      header => post_account_persons_request_header(),
      cookie => post_account_persons_request_cookie(),
      body => post_account_persons_request_body()}.
-type post_account_persons_request_query() :: map().
-type post_account_persons_request_header() :: map().
-type post_account_persons_request_cookie() :: map().
-type post_account_persons_request_body() :: map().
-type post_account_persons_response() :: stripe_model:error() | stripe_model:person().
-type get_account_persons_request() ::
    #{query => get_account_persons_request_query(),
      header => get_account_persons_request_header(),
      cookie => get_account_persons_request_cookie(),
      body => get_account_persons_request_body()}.
-type get_account_persons_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      relationship =>
          #{representative => boolean(),
            owner => boolean(),
            executive => boolean(),
            director => boolean()},
      starting_after => binary()}.
-type get_account_persons_request_header() :: map().
-type get_account_persons_request_cookie() :: map().
-type get_account_persons_request_body() :: map().
-type get_account_persons_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:person()]}.
-type get_account_capabilities_request() ::
    #{query => get_account_capabilities_request_query(),
      header => get_account_capabilities_request_header(),
      cookie => get_account_capabilities_request_cookie(),
      body => get_account_capabilities_request_body()}.
-type get_account_capabilities_request_query() :: #{expand => [binary()]}.
-type get_account_capabilities_request_header() :: map().
-type get_account_capabilities_request_cookie() :: map().
-type get_account_capabilities_request_body() :: map().
-type get_account_capabilities_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:capability()]}.
-type post_checkout_sessions_session_expire_request() ::
    #{session := binary(),
      query => post_checkout_sessions_session_expire_request_query(),
      header => post_checkout_sessions_session_expire_request_header(),
      cookie => post_checkout_sessions_session_expire_request_cookie(),
      body => post_checkout_sessions_session_expire_request_body()}.
-type post_checkout_sessions_session_expire_request_query() :: map().
-type post_checkout_sessions_session_expire_request_header() :: map().
-type post_checkout_sessions_session_expire_request_cookie() :: map().
-type post_checkout_sessions_session_expire_request_body() :: map().
-type post_checkout_sessions_session_expire_response() ::
    stripe_model:error() | stripe_model:checkout_session().
-type get_bitcoin_receivers_receiver_transactions_request() ::
    #{receiver := binary(),
      query => get_bitcoin_receivers_receiver_transactions_request_query(),
      header => get_bitcoin_receivers_receiver_transactions_request_header(),
      cookie => get_bitcoin_receivers_receiver_transactions_request_cookie(),
      body => get_bitcoin_receivers_receiver_transactions_request_body()}.
-type get_bitcoin_receivers_receiver_transactions_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_bitcoin_receivers_receiver_transactions_request_header() :: map().
-type get_bitcoin_receivers_receiver_transactions_request_cookie() :: map().
-type get_bitcoin_receivers_receiver_transactions_request_body() :: map().
-type get_bitcoin_receivers_receiver_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bitcoin_transaction()]}.
-type post_quotes_quote_request() ::
    #{quote := binary(),
      query => post_quotes_quote_request_query(),
      header => post_quotes_quote_request_header(),
      cookie => post_quotes_quote_request_cookie(),
      body => post_quotes_quote_request_body()}.
-type post_quotes_quote_request_query() :: map().
-type post_quotes_quote_request_header() :: map().
-type post_quotes_quote_request_cookie() :: map().
-type post_quotes_quote_request_body() :: map().
-type post_quotes_quote_response() :: stripe_model:error() | stripe_model:quote().
-type get_quotes_quote_request() ::
    #{quote := binary(),
      query => get_quotes_quote_request_query(),
      header => get_quotes_quote_request_header(),
      cookie => get_quotes_quote_request_cookie(),
      body => get_quotes_quote_request_body()}.
-type get_quotes_quote_request_query() :: #{expand => [binary()]}.
-type get_quotes_quote_request_header() :: map().
-type get_quotes_quote_request_cookie() :: map().
-type get_quotes_quote_request_body() :: map().
-type get_quotes_quote_response() :: stripe_model:error() | stripe_model:quote().
-type post_account_people_request() ::
    #{query => post_account_people_request_query(),
      header => post_account_people_request_header(),
      cookie => post_account_people_request_cookie(),
      body => post_account_people_request_body()}.
-type post_account_people_request_query() :: map().
-type post_account_people_request_header() :: map().
-type post_account_people_request_cookie() :: map().
-type post_account_people_request_body() :: map().
-type post_account_people_response() :: stripe_model:error() | stripe_model:person().
-type get_account_people_request() ::
    #{query => get_account_people_request_query(),
      header => get_account_people_request_header(),
      cookie => get_account_people_request_cookie(),
      body => get_account_people_request_body()}.
-type get_account_people_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      relationship =>
          #{representative => boolean(),
            owner => boolean(),
            executive => boolean(),
            director => boolean()},
      starting_after => binary()}.
-type get_account_people_request_header() :: map().
-type get_account_people_request_cookie() :: map().
-type get_account_people_request_body() :: map().
-type get_account_people_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:person()]}.
-type post_setup_intents_intent_confirm_request() ::
    #{intent := binary(),
      query => post_setup_intents_intent_confirm_request_query(),
      header => post_setup_intents_intent_confirm_request_header(),
      cookie => post_setup_intents_intent_confirm_request_cookie(),
      body => post_setup_intents_intent_confirm_request_body()}.
-type post_setup_intents_intent_confirm_request_query() :: map().
-type post_setup_intents_intent_confirm_request_header() :: map().
-type post_setup_intents_intent_confirm_request_cookie() :: map().
-type post_setup_intents_intent_confirm_request_body() :: map().
-type post_setup_intents_intent_confirm_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type post_customers_customer_cards_request() ::
    #{customer := binary(),
      query => post_customers_customer_cards_request_query(),
      header => post_customers_customer_cards_request_header(),
      cookie => post_customers_customer_cards_request_cookie(),
      body => post_customers_customer_cards_request_body()}.
-type post_customers_customer_cards_request_query() :: map().
-type post_customers_customer_cards_request_header() :: map().
-type post_customers_customer_cards_request_cookie() :: map().
-type post_customers_customer_cards_request_body() :: map().
-type post_customers_customer_cards_response() ::
    stripe_model:error() | stripe_model:payment_source().
-type get_customers_customer_cards_request() ::
    #{customer := binary(),
      query => get_customers_customer_cards_request_query(),
      header => get_customers_customer_cards_request_header(),
      cookie => get_customers_customer_cards_request_cookie(),
      body => get_customers_customer_cards_request_body()}.
-type get_customers_customer_cards_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_cards_request_header() :: map().
-type get_customers_customer_cards_request_cookie() :: map().
-type get_customers_customer_cards_request_body() :: map().
-type get_customers_customer_cards_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:card()]}.
-type get_identity_verification_reports_request() ::
    #{query => get_identity_verification_reports_request_query(),
      header => get_identity_verification_reports_request_header(),
      cookie => get_identity_verification_reports_request_cookie(),
      body => get_identity_verification_reports_request_body()}.
-type get_identity_verification_reports_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type => document | id_number,
      verification_session => binary()}.
-type get_identity_verification_reports_request_header() :: map().
-type get_identity_verification_reports_request_cookie() :: map().
-type get_identity_verification_reports_request_body() :: map().
-type get_identity_verification_reports_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:identity_verification_report()]}.
-type post_accounts_account_persons_request() ::
    #{account := binary(),
      query => post_accounts_account_persons_request_query(),
      header => post_accounts_account_persons_request_header(),
      cookie => post_accounts_account_persons_request_cookie(),
      body => post_accounts_account_persons_request_body()}.
-type post_accounts_account_persons_request_query() :: map().
-type post_accounts_account_persons_request_header() :: map().
-type post_accounts_account_persons_request_cookie() :: map().
-type post_accounts_account_persons_request_body() :: map().
-type post_accounts_account_persons_response() ::
    stripe_model:error() | stripe_model:person().
-type get_accounts_account_persons_request() ::
    #{account := binary(),
      query => get_accounts_account_persons_request_query(),
      header => get_accounts_account_persons_request_header(),
      cookie => get_accounts_account_persons_request_cookie(),
      body => get_accounts_account_persons_request_body()}.
-type get_accounts_account_persons_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      relationship =>
          #{representative => boolean(),
            owner => boolean(),
            executive => boolean(),
            director => boolean()},
      starting_after => binary()}.
-type get_accounts_account_persons_request_header() :: map().
-type get_accounts_account_persons_request_cookie() :: map().
-type get_accounts_account_persons_request_body() :: map().
-type get_accounts_account_persons_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:person()]}.
-type post_application_fees_id_refund_request() ::
    #{id := binary(),
      query => post_application_fees_id_refund_request_query(),
      header => post_application_fees_id_refund_request_header(),
      cookie => post_application_fees_id_refund_request_cookie(),
      body => post_application_fees_id_refund_request_body()}.
-type post_application_fees_id_refund_request_query() :: map().
-type post_application_fees_id_refund_request_header() :: map().
-type post_application_fees_id_refund_request_cookie() :: map().
-type post_application_fees_id_refund_request_body() :: map().
-type post_application_fees_id_refund_response() ::
    stripe_model:error() | stripe_model:application_fee().
-type post_payment_intents_request() ::
    #{query => post_payment_intents_request_query(),
      header => post_payment_intents_request_header(),
      cookie => post_payment_intents_request_cookie(),
      body => post_payment_intents_request_body()}.
-type post_payment_intents_request_query() :: map().
-type post_payment_intents_request_header() :: map().
-type post_payment_intents_request_cookie() :: map().
-type post_payment_intents_request_body() :: map().
-type post_payment_intents_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type get_payment_intents_request() ::
    #{query => get_payment_intents_request_query(),
      header => get_payment_intents_request_header(),
      cookie => get_payment_intents_request_cookie(),
      body => get_payment_intents_request_body()}.
-type get_payment_intents_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_payment_intents_request_header() :: map().
-type get_payment_intents_request_cookie() :: map().
-type get_payment_intents_request_body() :: map().
-type get_payment_intents_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payment_intent()]}.
-type post_skus_request() ::
    #{query => post_skus_request_query(),
      header => post_skus_request_header(),
      cookie => post_skus_request_cookie(),
      body => post_skus_request_body()}.
-type post_skus_request_query() :: map().
-type post_skus_request_header() :: map().
-type post_skus_request_cookie() :: map().
-type post_skus_request_body() :: map().
-type post_skus_response() :: stripe_model:error() | stripe_model:sku().
-type get_skus_request() ::
    #{query => get_skus_request_query(),
      header => get_skus_request_header(),
      cookie => get_skus_request_cookie(),
      body => get_skus_request_body()}.
-type get_skus_request_query() ::
    #{active => boolean(),
      attributes => json:value(),
      ending_before => binary(),
      expand => [binary()],
      ids => [binary()],
      in_stock => boolean(),
      limit => integer(),
      product => binary(),
      starting_after => binary()}.
-type get_skus_request_header() :: map().
-type get_skus_request_cookie() :: map().
-type get_skus_request_body() :: map().
-type get_skus_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:sku()]}.
-type post_webhook_endpoints_request() ::
    #{query => post_webhook_endpoints_request_query(),
      header => post_webhook_endpoints_request_header(),
      cookie => post_webhook_endpoints_request_cookie(),
      body => post_webhook_endpoints_request_body()}.
-type post_webhook_endpoints_request_query() :: map().
-type post_webhook_endpoints_request_header() :: map().
-type post_webhook_endpoints_request_cookie() :: map().
-type post_webhook_endpoints_request_body() :: map().
-type post_webhook_endpoints_response() ::
    stripe_model:error() | stripe_model:webhook_endpoint().
-type get_webhook_endpoints_request() ::
    #{query => get_webhook_endpoints_request_query(),
      header => get_webhook_endpoints_request_header(),
      cookie => get_webhook_endpoints_request_cookie(),
      body => get_webhook_endpoints_request_body()}.
-type get_webhook_endpoints_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_webhook_endpoints_request_header() :: map().
-type get_webhook_endpoints_request_cookie() :: map().
-type get_webhook_endpoints_request_body() :: map().
-type get_webhook_endpoints_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:webhook_endpoint()]}.
-type get_balance_request() ::
    #{query => get_balance_request_query(),
      header => get_balance_request_header(),
      cookie => get_balance_request_cookie(),
      body => get_balance_request_body()}.
-type get_balance_request_query() :: #{expand => [binary()]}.
-type get_balance_request_header() :: map().
-type get_balance_request_cookie() :: map().
-type get_balance_request_body() :: map().
-type get_balance_response() :: stripe_model:error() | stripe_model:balance().
-type post_customers_customer_balance_transactions_transaction_request() ::
    #{customer := binary(),
      transaction := binary(),
      query => post_customers_customer_balance_transactions_transaction_request_query(),
      header => post_customers_customer_balance_transactions_transaction_request_header(),
      cookie => post_customers_customer_balance_transactions_transaction_request_cookie(),
      body => post_customers_customer_balance_transactions_transaction_request_body()}.
-type post_customers_customer_balance_transactions_transaction_request_query() :: map().
-type post_customers_customer_balance_transactions_transaction_request_header() :: map().
-type post_customers_customer_balance_transactions_transaction_request_cookie() :: map().
-type post_customers_customer_balance_transactions_transaction_request_body() :: map().
-type post_customers_customer_balance_transactions_transaction_response() ::
    stripe_model:error() | stripe_model:customer_balance_transaction().
-type get_customers_customer_balance_transactions_transaction_request() ::
    #{customer := binary(),
      transaction := binary(),
      query => get_customers_customer_balance_transactions_transaction_request_query(),
      header => get_customers_customer_balance_transactions_transaction_request_header(),
      cookie => get_customers_customer_balance_transactions_transaction_request_cookie(),
      body => get_customers_customer_balance_transactions_transaction_request_body()}.
-type get_customers_customer_balance_transactions_transaction_request_query() ::
    #{expand => [binary()]}.
-type get_customers_customer_balance_transactions_transaction_request_header() :: map().
-type get_customers_customer_balance_transactions_transaction_request_cookie() :: map().
-type get_customers_customer_balance_transactions_transaction_request_body() :: map().
-type get_customers_customer_balance_transactions_transaction_response() ::
    stripe_model:error() | stripe_model:customer_balance_transaction().
-type post_payment_methods_payment_method_request() ::
    #{payment_method := binary(),
      query => post_payment_methods_payment_method_request_query(),
      header => post_payment_methods_payment_method_request_header(),
      cookie => post_payment_methods_payment_method_request_cookie(),
      body => post_payment_methods_payment_method_request_body()}.
-type post_payment_methods_payment_method_request_query() :: map().
-type post_payment_methods_payment_method_request_header() :: map().
-type post_payment_methods_payment_method_request_cookie() :: map().
-type post_payment_methods_payment_method_request_body() :: map().
-type post_payment_methods_payment_method_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type get_payment_methods_payment_method_request() ::
    #{payment_method := binary(),
      query => get_payment_methods_payment_method_request_query(),
      header => get_payment_methods_payment_method_request_header(),
      cookie => get_payment_methods_payment_method_request_cookie(),
      body => get_payment_methods_payment_method_request_body()}.
-type get_payment_methods_payment_method_request_query() :: #{expand => [binary()]}.
-type get_payment_methods_payment_method_request_header() :: map().
-type get_payment_methods_payment_method_request_cookie() :: map().
-type get_payment_methods_payment_method_request_body() :: map().
-type get_payment_methods_payment_method_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type post_topups_topup_cancel_request() ::
    #{topup := binary(),
      query => post_topups_topup_cancel_request_query(),
      header => post_topups_topup_cancel_request_header(),
      cookie => post_topups_topup_cancel_request_cookie(),
      body => post_topups_topup_cancel_request_body()}.
-type post_topups_topup_cancel_request_query() :: map().
-type post_topups_topup_cancel_request_header() :: map().
-type post_topups_topup_cancel_request_cookie() :: map().
-type post_topups_topup_cancel_request_body() :: map().
-type post_topups_topup_cancel_response() :: stripe_model:error() | stripe_model:topup().
-type get_events_request() ::
    #{query => get_events_request_query(),
      header => get_events_request_header(),
      cookie => get_events_request_cookie(),
      body => get_events_request_body()}.
-type get_events_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      delivery_success => boolean(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type => binary(),
      types => [binary()]}.
-type get_events_request_header() :: map().
-type get_events_request_cookie() :: map().
-type get_events_request_body() :: map().
-type get_events_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:event()]}.
-type post_charges_charge_refunds_refund_request() ::
    #{charge := binary(),
      refund := binary(),
      query => post_charges_charge_refunds_refund_request_query(),
      header => post_charges_charge_refunds_refund_request_header(),
      cookie => post_charges_charge_refunds_refund_request_cookie(),
      body => post_charges_charge_refunds_refund_request_body()}.
-type post_charges_charge_refunds_refund_request_query() :: map().
-type post_charges_charge_refunds_refund_request_header() :: map().
-type post_charges_charge_refunds_refund_request_cookie() :: map().
-type post_charges_charge_refunds_refund_request_body() :: map().
-type post_charges_charge_refunds_refund_response() ::
    stripe_model:error() | stripe_model:refund().
-type get_charges_charge_refunds_refund_request() ::
    #{charge := binary(),
      refund := binary(),
      query => get_charges_charge_refunds_refund_request_query(),
      header => get_charges_charge_refunds_refund_request_header(),
      cookie => get_charges_charge_refunds_refund_request_cookie(),
      body => get_charges_charge_refunds_refund_request_body()}.
-type get_charges_charge_refunds_refund_request_query() :: #{expand => [binary()]}.
-type get_charges_charge_refunds_refund_request_header() :: map().
-type get_charges_charge_refunds_refund_request_cookie() :: map().
-type get_charges_charge_refunds_refund_request_body() :: map().
-type get_charges_charge_refunds_refund_response() ::
    stripe_model:error() | stripe_model:refund().
-type post_accounts_account_capabilities_capability_request() ::
    #{account := binary(),
      capability := binary(),
      query => post_accounts_account_capabilities_capability_request_query(),
      header => post_accounts_account_capabilities_capability_request_header(),
      cookie => post_accounts_account_capabilities_capability_request_cookie(),
      body => post_accounts_account_capabilities_capability_request_body()}.
-type post_accounts_account_capabilities_capability_request_query() :: map().
-type post_accounts_account_capabilities_capability_request_header() :: map().
-type post_accounts_account_capabilities_capability_request_cookie() :: map().
-type post_accounts_account_capabilities_capability_request_body() :: map().
-type post_accounts_account_capabilities_capability_response() ::
    stripe_model:error() | stripe_model:capability().
-type get_accounts_account_capabilities_capability_request() ::
    #{account := binary(),
      capability := binary(),
      query => get_accounts_account_capabilities_capability_request_query(),
      header => get_accounts_account_capabilities_capability_request_header(),
      cookie => get_accounts_account_capabilities_capability_request_cookie(),
      body => get_accounts_account_capabilities_capability_request_body()}.
-type get_accounts_account_capabilities_capability_request_query() ::
    #{expand => [binary()]}.
-type get_accounts_account_capabilities_capability_request_header() :: map().
-type get_accounts_account_capabilities_capability_request_cookie() :: map().
-type get_accounts_account_capabilities_capability_request_body() :: map().
-type get_accounts_account_capabilities_capability_response() ::
    stripe_model:error() | stripe_model:capability().
-type post_subscription_items_request() ::
    #{query => post_subscription_items_request_query(),
      header => post_subscription_items_request_header(),
      cookie => post_subscription_items_request_cookie(),
      body => post_subscription_items_request_body()}.
-type post_subscription_items_request_query() :: map().
-type post_subscription_items_request_header() :: map().
-type post_subscription_items_request_cookie() :: map().
-type post_subscription_items_request_body() :: map().
-type post_subscription_items_response() ::
    stripe_model:error() | stripe_model:subscription_item().
-type get_subscription_items_request() ::
    #{query => get_subscription_items_request_query(),
      header => get_subscription_items_request_header(),
      cookie => get_subscription_items_request_cookie(),
      body => get_subscription_items_request_body()}.
-type get_subscription_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      subscription := binary()}.
-type get_subscription_items_request_header() :: map().
-type get_subscription_items_request_cookie() :: map().
-type get_subscription_items_request_body() :: map().
-type get_subscription_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:subscription_item()]}.
-type get_quotes_quote_pdf_request() ::
    #{quote := binary(),
      query => get_quotes_quote_pdf_request_query(),
      header => get_quotes_quote_pdf_request_header(),
      cookie => get_quotes_quote_pdf_request_cookie(),
      body => get_quotes_quote_pdf_request_body()}.
-type get_quotes_quote_pdf_request_query() :: #{expand => [binary()]}.
-type get_quotes_quote_pdf_request_header() :: map().
-type get_quotes_quote_pdf_request_cookie() :: map().
-type get_quotes_quote_pdf_request_body() :: map().
-type get_quotes_quote_pdf_response() :: stripe_model:error() | binary().
-type delete_account_bank_accounts_id_request() ::
    #{id := binary(),
      query => delete_account_bank_accounts_id_request_query(),
      header => delete_account_bank_accounts_id_request_header(),
      cookie => delete_account_bank_accounts_id_request_cookie(),
      body => delete_account_bank_accounts_id_request_body()}.
-type delete_account_bank_accounts_id_request_query() :: map().
-type delete_account_bank_accounts_id_request_header() :: map().
-type delete_account_bank_accounts_id_request_cookie() :: map().
-type delete_account_bank_accounts_id_request_body() :: map().
-type delete_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:deleted_external_account().
-type post_account_bank_accounts_id_request() ::
    #{id := binary(),
      query => post_account_bank_accounts_id_request_query(),
      header => post_account_bank_accounts_id_request_header(),
      cookie => post_account_bank_accounts_id_request_cookie(),
      body => post_account_bank_accounts_id_request_body()}.
-type post_account_bank_accounts_id_request_query() :: map().
-type post_account_bank_accounts_id_request_header() :: map().
-type post_account_bank_accounts_id_request_cookie() :: map().
-type post_account_bank_accounts_id_request_body() :: map().
-type post_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_account_bank_accounts_id_request() ::
    #{id := binary(),
      query => get_account_bank_accounts_id_request_query(),
      header => get_account_bank_accounts_id_request_header(),
      cookie => get_account_bank_accounts_id_request_cookie(),
      body => get_account_bank_accounts_id_request_body()}.
-type get_account_bank_accounts_id_request_query() :: #{expand => [binary()]}.
-type get_account_bank_accounts_id_request_header() :: map().
-type get_account_bank_accounts_id_request_cookie() :: map().
-type get_account_bank_accounts_id_request_body() :: map().
-type get_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_payment_links_payment_link_line_items_request() ::
    #{payment_link := binary(),
      query => get_payment_links_payment_link_line_items_request_query(),
      header => get_payment_links_payment_link_line_items_request_header(),
      cookie => get_payment_links_payment_link_line_items_request_cookie(),
      body => get_payment_links_payment_link_line_items_request_body()}.
-type get_payment_links_payment_link_line_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_payment_links_payment_link_line_items_request_header() :: map().
-type get_payment_links_payment_link_line_items_request_cookie() :: map().
-type get_payment_links_payment_link_line_items_request_body() :: map().
-type get_payment_links_payment_link_line_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:item()]}.
-type get_subscription_items_subscription_item_usage_record_summaries_request() ::
    #{subscription_item := binary(),
      query => get_subscription_items_subscription_item_usage_record_summaries_request_query(),
      header =>
          get_subscription_items_subscription_item_usage_record_summaries_request_header(),
      cookie =>
          get_subscription_items_subscription_item_usage_record_summaries_request_cookie(),
      body => get_subscription_items_subscription_item_usage_record_summaries_request_body()}.
-type get_subscription_items_subscription_item_usage_record_summaries_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_subscription_items_subscription_item_usage_record_summaries_request_header() ::
    map().
-type get_subscription_items_subscription_item_usage_record_summaries_request_cookie() ::
    map().
-type get_subscription_items_subscription_item_usage_record_summaries_request_body() ::
    map().
-type get_subscription_items_subscription_item_usage_record_summaries_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:usage_record_summary()]}.
-type post_payment_intents_intent_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_request_query(),
      header => post_payment_intents_intent_request_header(),
      cookie => post_payment_intents_intent_request_cookie(),
      body => post_payment_intents_intent_request_body()}.
-type post_payment_intents_intent_request_query() :: map().
-type post_payment_intents_intent_request_header() :: map().
-type post_payment_intents_intent_request_cookie() :: map().
-type post_payment_intents_intent_request_body() :: map().
-type post_payment_intents_intent_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type get_payment_intents_intent_request() ::
    #{intent := binary(),
      query => get_payment_intents_intent_request_query(),
      header => get_payment_intents_intent_request_header(),
      cookie => get_payment_intents_intent_request_cookie(),
      body => get_payment_intents_intent_request_body()}.
-type get_payment_intents_intent_request_query() ::
    #{client_secret => binary(), expand => [binary()]}.
-type get_payment_intents_intent_request_header() :: map().
-type get_payment_intents_intent_request_cookie() :: map().
-type get_payment_intents_intent_request_body() :: map().
-type get_payment_intents_intent_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type post_charges_request() ::
    #{query => post_charges_request_query(),
      header => post_charges_request_header(),
      cookie => post_charges_request_cookie(),
      body => post_charges_request_body()}.
-type post_charges_request_query() :: map().
-type post_charges_request_header() :: map().
-type post_charges_request_cookie() :: map().
-type post_charges_request_body() :: map().
-type post_charges_response() :: stripe_model:error() | stripe_model:charge().
-type get_charges_request() ::
    #{query => get_charges_request_query(),
      header => get_charges_request_header(),
      cookie => get_charges_request_cookie(),
      body => get_charges_request_body()}.
-type get_charges_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary(),
      transfer_group => binary()}.
-type get_charges_request_header() :: map().
-type get_charges_request_cookie() :: map().
-type get_charges_request_body() :: map().
-type get_charges_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:charge()]}.
-type post_accounts_account_external_accounts_request() ::
    #{account := binary(),
      query => post_accounts_account_external_accounts_request_query(),
      header => post_accounts_account_external_accounts_request_header(),
      cookie => post_accounts_account_external_accounts_request_cookie(),
      body => post_accounts_account_external_accounts_request_body()}.
-type post_accounts_account_external_accounts_request_query() :: map().
-type post_accounts_account_external_accounts_request_header() :: map().
-type post_accounts_account_external_accounts_request_cookie() :: map().
-type post_accounts_account_external_accounts_request_body() :: map().
-type post_accounts_account_external_accounts_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_accounts_account_external_accounts_request() ::
    #{account := binary(),
      query => get_accounts_account_external_accounts_request_query(),
      header => get_accounts_account_external_accounts_request_header(),
      cookie => get_accounts_account_external_accounts_request_cookie(),
      body => get_accounts_account_external_accounts_request_body()}.
-type get_accounts_account_external_accounts_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_accounts_account_external_accounts_request_header() :: map().
-type get_accounts_account_external_accounts_request_cookie() :: map().
-type get_accounts_account_external_accounts_request_body() :: map().
-type get_accounts_account_external_accounts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bank_account() | stripe_model:card()]}.
-type get_issuing_authorizations_request() ::
    #{query => get_issuing_authorizations_request_query(),
      header => get_issuing_authorizations_request_header(),
      cookie => get_issuing_authorizations_request_cookie(),
      body => get_issuing_authorizations_request_body()}.
-type get_issuing_authorizations_request_query() ::
    #{card => binary(),
      cardholder => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => closed | pending | reversed}.
-type get_issuing_authorizations_request_header() :: map().
-type get_issuing_authorizations_request_cookie() :: map().
-type get_issuing_authorizations_request_body() :: map().
-type get_issuing_authorizations_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_authorization()]}.
-type delete_products_id_request() ::
    #{id := binary(),
      query => delete_products_id_request_query(),
      header => delete_products_id_request_header(),
      cookie => delete_products_id_request_cookie(),
      body => delete_products_id_request_body()}.
-type delete_products_id_request_query() :: map().
-type delete_products_id_request_header() :: map().
-type delete_products_id_request_cookie() :: map().
-type delete_products_id_request_body() :: map().
-type delete_products_id_response() ::
    stripe_model:error() | stripe_model:deleted_product().
-type post_products_id_request() ::
    #{id := binary(),
      query => post_products_id_request_query(),
      header => post_products_id_request_header(),
      cookie => post_products_id_request_cookie(),
      body => post_products_id_request_body()}.
-type post_products_id_request_query() :: map().
-type post_products_id_request_header() :: map().
-type post_products_id_request_cookie() :: map().
-type post_products_id_request_body() :: map().
-type post_products_id_response() :: stripe_model:error() | stripe_model:product().
-type get_products_id_request() ::
    #{id := binary(),
      query => get_products_id_request_query(),
      header => get_products_id_request_header(),
      cookie => get_products_id_request_cookie(),
      body => get_products_id_request_body()}.
-type get_products_id_request_query() :: #{expand => [binary()]}.
-type get_products_id_request_header() :: map().
-type get_products_id_request_cookie() :: map().
-type get_products_id_request_body() :: map().
-type get_products_id_response() :: stripe_model:error() | stripe_model:product().
-type post_setup_intents_intent_verify_microdeposits_request() ::
    #{intent := binary(),
      query => post_setup_intents_intent_verify_microdeposits_request_query(),
      header => post_setup_intents_intent_verify_microdeposits_request_header(),
      cookie => post_setup_intents_intent_verify_microdeposits_request_cookie(),
      body => post_setup_intents_intent_verify_microdeposits_request_body()}.
-type post_setup_intents_intent_verify_microdeposits_request_query() :: map().
-type post_setup_intents_intent_verify_microdeposits_request_header() :: map().
-type post_setup_intents_intent_verify_microdeposits_request_cookie() :: map().
-type post_setup_intents_intent_verify_microdeposits_request_body() :: map().
-type post_setup_intents_intent_verify_microdeposits_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type get_reporting_report_types_request() ::
    #{query => get_reporting_report_types_request_query(),
      header => get_reporting_report_types_request_header(),
      cookie => get_reporting_report_types_request_cookie(),
      body => get_reporting_report_types_request_body()}.
-type get_reporting_report_types_request_query() :: #{expand => [binary()]}.
-type get_reporting_report_types_request_header() :: map().
-type get_reporting_report_types_request_cookie() :: map().
-type get_reporting_report_types_request_body() :: map().
-type get_reporting_report_types_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:reporting_report_type()]}.
-type post_account_external_accounts_request() ::
    #{query => post_account_external_accounts_request_query(),
      header => post_account_external_accounts_request_header(),
      cookie => post_account_external_accounts_request_cookie(),
      body => post_account_external_accounts_request_body()}.
-type post_account_external_accounts_request_query() :: map().
-type post_account_external_accounts_request_header() :: map().
-type post_account_external_accounts_request_cookie() :: map().
-type post_account_external_accounts_request_body() :: map().
-type post_account_external_accounts_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_account_external_accounts_request() ::
    #{query => get_account_external_accounts_request_query(),
      header => get_account_external_accounts_request_header(),
      cookie => get_account_external_accounts_request_cookie(),
      body => get_account_external_accounts_request_body()}.
-type get_account_external_accounts_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_account_external_accounts_request_header() :: map().
-type get_account_external_accounts_request_cookie() :: map().
-type get_account_external_accounts_request_body() :: map().
-type get_account_external_accounts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bank_account() | stripe_model:card()]}.
-type post_radar_value_lists_request() ::
    #{query => post_radar_value_lists_request_query(),
      header => post_radar_value_lists_request_header(),
      cookie => post_radar_value_lists_request_cookie(),
      body => post_radar_value_lists_request_body()}.
-type post_radar_value_lists_request_query() :: map().
-type post_radar_value_lists_request_header() :: map().
-type post_radar_value_lists_request_cookie() :: map().
-type post_radar_value_lists_request_body() :: map().
-type post_radar_value_lists_response() ::
    stripe_model:error() | stripe_model:radar_value_list().
-type get_radar_value_lists_request() ::
    #{query => get_radar_value_lists_request_query(),
      header => get_radar_value_lists_request_header(),
      cookie => get_radar_value_lists_request_cookie(),
      body => get_radar_value_lists_request_body()}.
-type get_radar_value_lists_request_query() ::
    #{alias => binary(),
      contains => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_radar_value_lists_request_header() :: map().
-type get_radar_value_lists_request_cookie() :: map().
-type get_radar_value_lists_request_body() :: map().
-type get_radar_value_lists_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:radar_value_list()]}.
-type post_shipping_rates_request() ::
    #{query => post_shipping_rates_request_query(),
      header => post_shipping_rates_request_header(),
      cookie => post_shipping_rates_request_cookie(),
      body => post_shipping_rates_request_body()}.
-type post_shipping_rates_request_query() :: map().
-type post_shipping_rates_request_header() :: map().
-type post_shipping_rates_request_cookie() :: map().
-type post_shipping_rates_request_body() :: map().
-type post_shipping_rates_response() ::
    stripe_model:error() | stripe_model:shipping_rate().
-type get_shipping_rates_request() ::
    #{query => get_shipping_rates_request_query(),
      header => get_shipping_rates_request_header(),
      cookie => get_shipping_rates_request_cookie(),
      body => get_shipping_rates_request_body()}.
-type get_shipping_rates_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      currency => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_shipping_rates_request_header() :: map().
-type get_shipping_rates_request_cookie() :: map().
-type get_shipping_rates_request_body() :: map().
-type get_shipping_rates_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:shipping_rate()]}.
-type post_file_links_link_request() ::
    #{link := binary(),
      query => post_file_links_link_request_query(),
      header => post_file_links_link_request_header(),
      cookie => post_file_links_link_request_cookie(),
      body => post_file_links_link_request_body()}.
-type post_file_links_link_request_query() :: map().
-type post_file_links_link_request_header() :: map().
-type post_file_links_link_request_cookie() :: map().
-type post_file_links_link_request_body() :: map().
-type post_file_links_link_response() :: stripe_model:error() | stripe_model:file_link().
-type get_file_links_link_request() ::
    #{link := binary(),
      query => get_file_links_link_request_query(),
      header => get_file_links_link_request_header(),
      cookie => get_file_links_link_request_cookie(),
      body => get_file_links_link_request_body()}.
-type get_file_links_link_request_query() :: #{expand => [binary()]}.
-type get_file_links_link_request_header() :: map().
-type get_file_links_link_request_cookie() :: map().
-type get_file_links_link_request_body() :: map().
-type get_file_links_link_response() :: stripe_model:error() | stripe_model:file_link().
-type get3d_secure_three_d_secure_request() ::
    #{three_d_secure := binary(),
      query => get3d_secure_three_d_secure_request_query(),
      header => get3d_secure_three_d_secure_request_header(),
      cookie => get3d_secure_three_d_secure_request_cookie(),
      body => get3d_secure_three_d_secure_request_body()}.
-type get3d_secure_three_d_secure_request_query() :: #{expand => [binary()]}.
-type get3d_secure_three_d_secure_request_header() :: map().
-type get3d_secure_three_d_secure_request_cookie() :: map().
-type get3d_secure_three_d_secure_request_body() :: map().
-type get3d_secure_three_d_secure_response() ::
    stripe_model:error() | stripe_model:three_d_secure().
-type post_invoices_invoice_send_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_send_request_query(),
      header => post_invoices_invoice_send_request_header(),
      cookie => post_invoices_invoice_send_request_cookie(),
      body => post_invoices_invoice_send_request_body()}.
-type post_invoices_invoice_send_request_query() :: map().
-type post_invoices_invoice_send_request_header() :: map().
-type post_invoices_invoice_send_request_cookie() :: map().
-type post_invoices_invoice_send_request_body() :: map().
-type post_invoices_invoice_send_response() ::
    stripe_model:error() | stripe_model:invoice().
-type get_invoices_upcoming_request() ::
    #{query => get_invoices_upcoming_request_query(),
      header => get_invoices_upcoming_request_header(),
      cookie => get_invoices_upcoming_request_cookie(),
      body => get_invoices_upcoming_request_body()}.
-type get_invoices_upcoming_request_query() ::
    #{automatic_tax => #{enabled := boolean()},
      coupon => binary(),
      customer => binary(),
      customer_details =>
          #{tax_ids =>
                [#{value := binary(),
                   type :=
                       ae_trn | au_abn | au_arn | br_cnpj | br_cpf | ca_bn | ca_gst_hst |
                       ca_pst_bc | ca_pst_mb | ca_pst_sk | ca_qst | ch_vat | cl_tin | es_cif |
                       eu_vat | gb_vat | ge_vat | hk_br | id_npwp | il_vat | in_gst | is_vat |
                       jp_cn | jp_rn | kr_brn | li_uid | mx_rfc | my_frp | my_itn | my_sst |
                       no_vat | nz_gst | ru_inn | ru_kpp | sa_vat | sg_gst | sg_uen | th_vat |
                       tw_vat | ua_vat | us_ein | za_vat}],
            tax_exempt => '' | exempt | none | reverse,
            tax => #{ip_address => binary() | ''},
            shipping =>
                #{phone => binary(),
                  name := binary(),
                  address :=
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary()}} |
                '',
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary()} |
                ''},
      discounts => [#{discount => binary(), coupon => binary()}] | '',
      expand => [binary()],
      invoice_items =>
          [#{unit_amount_decimal => binary(),
             unit_amount => integer(),
             tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   product := binary(),
                   currency := binary()},
             price => binary(),
             period => #{start := integer(), 'end' := integer()},
             metadata => json:value() | '',
             invoiceitem => binary(),
             discounts => [#{discount => binary(), coupon => binary()}] | '',
             discountable => boolean(),
             description => binary(),
             currency => binary(),
             amount => integer()}],
      schedule => binary(),
      subscription => binary(),
      subscription_billing_cycle_anchor => now | unchanged | integer(),
      subscription_cancel_at => integer() | '',
      subscription_cancel_at_period_end => boolean(),
      subscription_cancel_now => boolean(),
      subscription_default_tax_rates => [binary()] | '',
      subscription_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring :=
                       #{interval_count => integer(), interval := day | month | week | year},
                   product := binary(),
                   currency := binary()},
             price => binary(),
             metadata => json:value() | '',
             id => binary(),
             deleted => boolean(),
             clear_usage => boolean(),
             billing_thresholds => #{usage_gte := integer()} | ''}],
      subscription_proration_behavior => always_invoice | create_prorations | none,
      subscription_proration_date => integer(),
      subscription_start_date => integer(),
      subscription_trial_end => now | integer(),
      subscription_trial_from_plan => boolean()}.
-type get_invoices_upcoming_request_header() :: map().
-type get_invoices_upcoming_request_cookie() :: map().
-type get_invoices_upcoming_request_body() :: map().
-type get_invoices_upcoming_response() :: stripe_model:error() | stripe_model:invoice().
-type get_checkout_sessions_session_line_items_request() ::
    #{session := binary(),
      query => get_checkout_sessions_session_line_items_request_query(),
      header => get_checkout_sessions_session_line_items_request_header(),
      cookie => get_checkout_sessions_session_line_items_request_cookie(),
      body => get_checkout_sessions_session_line_items_request_body()}.
-type get_checkout_sessions_session_line_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_checkout_sessions_session_line_items_request_header() :: map().
-type get_checkout_sessions_session_line_items_request_cookie() :: map().
-type get_checkout_sessions_session_line_items_request_body() :: map().
-type get_checkout_sessions_session_line_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:item()]}.
-type get_tax_codes_request() ::
    #{query => get_tax_codes_request_query(),
      header => get_tax_codes_request_header(),
      cookie => get_tax_codes_request_cookie(),
      body => get_tax_codes_request_body()}.
-type get_tax_codes_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_tax_codes_request_header() :: map().
-type get_tax_codes_request_cookie() :: map().
-type get_tax_codes_request_body() :: map().
-type get_tax_codes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:tax_code()]}.
-type post_invoices_request() ::
    #{query => post_invoices_request_query(),
      header => post_invoices_request_header(),
      cookie => post_invoices_request_cookie(),
      body => post_invoices_request_body()}.
-type post_invoices_request_query() :: map().
-type post_invoices_request_header() :: map().
-type post_invoices_request_cookie() :: map().
-type post_invoices_request_body() :: map().
-type post_invoices_response() :: stripe_model:error() | stripe_model:invoice().
-type get_invoices_request() ::
    #{query => get_invoices_request_query(),
      header => get_invoices_request_header(),
      cookie => get_invoices_request_cookie(),
      body => get_invoices_request_body()}.
-type get_invoices_request_query() ::
    #{collection_method => charge_automatically | send_invoice,
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      customer => binary(),
      due_date =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => draft | open | paid | uncollectible | void,
      subscription => binary()}.
-type get_invoices_request_header() :: map().
-type get_invoices_request_cookie() :: map().
-type get_invoices_request_body() :: map().
-type get_invoices_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:invoice()]}.
-type post_charges_charge_request() ::
    #{charge := binary(),
      query => post_charges_charge_request_query(),
      header => post_charges_charge_request_header(),
      cookie => post_charges_charge_request_cookie(),
      body => post_charges_charge_request_body()}.
-type post_charges_charge_request_query() :: map().
-type post_charges_charge_request_header() :: map().
-type post_charges_charge_request_cookie() :: map().
-type post_charges_charge_request_body() :: map().
-type post_charges_charge_response() :: stripe_model:error() | stripe_model:charge().
-type get_charges_charge_request() ::
    #{charge := binary(),
      query => get_charges_charge_request_query(),
      header => get_charges_charge_request_header(),
      cookie => get_charges_charge_request_cookie(),
      body => get_charges_charge_request_body()}.
-type get_charges_charge_request_query() :: #{expand => [binary()]}.
-type get_charges_charge_request_header() :: map().
-type get_charges_charge_request_cookie() :: map().
-type get_charges_charge_request_body() :: map().
-type get_charges_charge_response() :: stripe_model:error() | stripe_model:charge().
-type post_invoices_invoice_mark_uncollectible_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_mark_uncollectible_request_query(),
      header => post_invoices_invoice_mark_uncollectible_request_header(),
      cookie => post_invoices_invoice_mark_uncollectible_request_cookie(),
      body => post_invoices_invoice_mark_uncollectible_request_body()}.
-type post_invoices_invoice_mark_uncollectible_request_query() :: map().
-type post_invoices_invoice_mark_uncollectible_request_header() :: map().
-type post_invoices_invoice_mark_uncollectible_request_cookie() :: map().
-type post_invoices_invoice_mark_uncollectible_request_body() :: map().
-type post_invoices_invoice_mark_uncollectible_response() ::
    stripe_model:error() | stripe_model:invoice().
-type post_customers_customer_sources_id_verify_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_sources_id_verify_request_query(),
      header => post_customers_customer_sources_id_verify_request_header(),
      cookie => post_customers_customer_sources_id_verify_request_cookie(),
      body => post_customers_customer_sources_id_verify_request_body()}.
-type post_customers_customer_sources_id_verify_request_query() :: map().
-type post_customers_customer_sources_id_verify_request_header() :: map().
-type post_customers_customer_sources_id_verify_request_cookie() :: map().
-type post_customers_customer_sources_id_verify_request_body() :: map().
-type post_customers_customer_sources_id_verify_response() ::
    stripe_model:error() | stripe_model:bank_account().
-type post_orders_id_pay_request() ::
    #{id := binary(),
      query => post_orders_id_pay_request_query(),
      header => post_orders_id_pay_request_header(),
      cookie => post_orders_id_pay_request_cookie(),
      body => post_orders_id_pay_request_body()}.
-type post_orders_id_pay_request_query() :: map().
-type post_orders_id_pay_request_header() :: map().
-type post_orders_id_pay_request_cookie() :: map().
-type post_orders_id_pay_request_body() :: map().
-type post_orders_id_pay_response() :: stripe_model:error() | stripe_model:order().
-type post_customers_customer_bank_accounts_id_verify_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_bank_accounts_id_verify_request_query(),
      header => post_customers_customer_bank_accounts_id_verify_request_header(),
      cookie => post_customers_customer_bank_accounts_id_verify_request_cookie(),
      body => post_customers_customer_bank_accounts_id_verify_request_body()}.
-type post_customers_customer_bank_accounts_id_verify_request_query() :: map().
-type post_customers_customer_bank_accounts_id_verify_request_header() :: map().
-type post_customers_customer_bank_accounts_id_verify_request_cookie() :: map().
-type post_customers_customer_bank_accounts_id_verify_request_body() :: map().
-type post_customers_customer_bank_accounts_id_verify_response() ::
    stripe_model:error() | stripe_model:bank_account().
-type delete_account_people_person_request() ::
    #{person := binary(),
      query => delete_account_people_person_request_query(),
      header => delete_account_people_person_request_header(),
      cookie => delete_account_people_person_request_cookie(),
      body => delete_account_people_person_request_body()}.
-type delete_account_people_person_request_query() :: map().
-type delete_account_people_person_request_header() :: map().
-type delete_account_people_person_request_cookie() :: map().
-type delete_account_people_person_request_body() :: map().
-type delete_account_people_person_response() ::
    stripe_model:error() | stripe_model:deleted_person().
-type post_account_people_person_request() ::
    #{person := binary(),
      query => post_account_people_person_request_query(),
      header => post_account_people_person_request_header(),
      cookie => post_account_people_person_request_cookie(),
      body => post_account_people_person_request_body()}.
-type post_account_people_person_request_query() :: map().
-type post_account_people_person_request_header() :: map().
-type post_account_people_person_request_cookie() :: map().
-type post_account_people_person_request_body() :: map().
-type post_account_people_person_response() ::
    stripe_model:error() | stripe_model:person().
-type get_account_people_person_request() ::
    #{person := binary(),
      query => get_account_people_person_request_query(),
      header => get_account_people_person_request_header(),
      cookie => get_account_people_person_request_cookie(),
      body => get_account_people_person_request_body()}.
-type get_account_people_person_request_query() :: #{expand => [binary()]}.
-type get_account_people_person_request_header() :: map().
-type get_account_people_person_request_cookie() :: map().
-type get_account_people_person_request_body() :: map().
-type get_account_people_person_response() ::
    stripe_model:error() | stripe_model:person().
-type post_checkout_sessions_request() ::
    #{query => post_checkout_sessions_request_query(),
      header => post_checkout_sessions_request_header(),
      cookie => post_checkout_sessions_request_cookie(),
      body => post_checkout_sessions_request_body()}.
-type post_checkout_sessions_request_query() :: map().
-type post_checkout_sessions_request_header() :: map().
-type post_checkout_sessions_request_cookie() :: map().
-type post_checkout_sessions_request_body() :: map().
-type post_checkout_sessions_response() ::
    stripe_model:error() | stripe_model:checkout_session().
-type get_checkout_sessions_request() ::
    #{query => get_checkout_sessions_request_query(),
      header => get_checkout_sessions_request_header(),
      cookie => get_checkout_sessions_request_cookie(),
      body => get_checkout_sessions_request_body()}.
-type get_checkout_sessions_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary(),
      subscription => binary()}.
-type get_checkout_sessions_request_header() :: map().
-type get_checkout_sessions_request_cookie() :: map().
-type get_checkout_sessions_request_body() :: map().
-type get_checkout_sessions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:checkout_session()]}.
-type post_accounts_account_login_links_request() ::
    #{account := binary(),
      query => post_accounts_account_login_links_request_query(),
      header => post_accounts_account_login_links_request_header(),
      cookie => post_accounts_account_login_links_request_cookie(),
      body => post_accounts_account_login_links_request_body()}.
-type post_accounts_account_login_links_request_query() :: map().
-type post_accounts_account_login_links_request_header() :: map().
-type post_accounts_account_login_links_request_cookie() :: map().
-type post_accounts_account_login_links_request_body() :: map().
-type post_accounts_account_login_links_response() ::
    stripe_model:error() | stripe_model:login_link().
-type post_terminal_readers_request() ::
    #{query => post_terminal_readers_request_query(),
      header => post_terminal_readers_request_header(),
      cookie => post_terminal_readers_request_cookie(),
      body => post_terminal_readers_request_body()}.
-type post_terminal_readers_request_query() :: map().
-type post_terminal_readers_request_header() :: map().
-type post_terminal_readers_request_cookie() :: map().
-type post_terminal_readers_request_body() :: map().
-type post_terminal_readers_response() ::
    stripe_model:error() | stripe_model:terminal_reader().
-type get_terminal_readers_request() ::
    #{query => get_terminal_readers_request_query(),
      header => get_terminal_readers_request_header(),
      cookie => get_terminal_readers_request_cookie(),
      body => get_terminal_readers_request_body()}.
-type get_terminal_readers_request_query() ::
    #{device_type =>
          bbpos_chipper2x | bbpos_wisepad3 | bbpos_wisepos_e | stripe_m2 | verifone_P400,
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      location => binary(),
      starting_after => binary(),
      status => offline | online}.
-type get_terminal_readers_request_header() :: map().
-type get_terminal_readers_request_cookie() :: map().
-type get_terminal_readers_request_body() :: map().
-type get_terminal_readers_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:terminal_reader()]}.
-type post_issuing_disputes_request() ::
    #{query => post_issuing_disputes_request_query(),
      header => post_issuing_disputes_request_header(),
      cookie => post_issuing_disputes_request_cookie(),
      body => post_issuing_disputes_request_body()}.
-type post_issuing_disputes_request_query() :: map().
-type post_issuing_disputes_request_header() :: map().
-type post_issuing_disputes_request_cookie() :: map().
-type post_issuing_disputes_request_body() :: map().
-type post_issuing_disputes_response() ::
    stripe_model:error() | stripe_model:issuing_dispute().
-type get_issuing_disputes_request() ::
    #{query => get_issuing_disputes_request_query(),
      header => get_issuing_disputes_request_header(),
      cookie => get_issuing_disputes_request_cookie(),
      body => get_issuing_disputes_request_body()}.
-type get_issuing_disputes_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => expired | lost | submitted | unsubmitted | won,
      transaction => binary()}.
-type get_issuing_disputes_request_header() :: map().
-type get_issuing_disputes_request_cookie() :: map().
-type get_issuing_disputes_request_body() :: map().
-type get_issuing_disputes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_dispute()]}.
-type post3d_secure_request() ::
    #{query => post3d_secure_request_query(),
      header => post3d_secure_request_header(),
      cookie => post3d_secure_request_cookie(),
      body => post3d_secure_request_body()}.
-type post3d_secure_request_query() :: map().
-type post3d_secure_request_header() :: map().
-type post3d_secure_request_cookie() :: map().
-type post3d_secure_request_body() :: map().
-type post3d_secure_response() :: stripe_model:error() | stripe_model:three_d_secure().
-type post_prices_request() ::
    #{query => post_prices_request_query(),
      header => post_prices_request_header(),
      cookie => post_prices_request_cookie(),
      body => post_prices_request_body()}.
-type post_prices_request_query() :: map().
-type post_prices_request_header() :: map().
-type post_prices_request_cookie() :: map().
-type post_prices_request_body() :: map().
-type post_prices_response() :: stripe_model:error() | stripe_model:price().
-type get_prices_request() ::
    #{query => get_prices_request_query(),
      header => get_prices_request_header(),
      cookie => get_prices_request_cookie(),
      body => get_prices_request_body()}.
-type get_prices_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      currency => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      lookup_keys => [binary()],
      product => binary(),
      recurring => #{usage_type => licensed | metered, interval => day | month | week | year},
      starting_after => binary(),
      type => one_time | recurring}.
-type get_prices_request_header() :: map().
-type get_prices_request_cookie() :: map().
-type get_prices_request_body() :: map().
-type get_prices_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:price()]}.
-type delete_invoices_invoice_request() ::
    #{invoice := binary(),
      query => delete_invoices_invoice_request_query(),
      header => delete_invoices_invoice_request_header(),
      cookie => delete_invoices_invoice_request_cookie(),
      body => delete_invoices_invoice_request_body()}.
-type delete_invoices_invoice_request_query() :: map().
-type delete_invoices_invoice_request_header() :: map().
-type delete_invoices_invoice_request_cookie() :: map().
-type delete_invoices_invoice_request_body() :: map().
-type delete_invoices_invoice_response() ::
    stripe_model:error() | stripe_model:deleted_invoice().
-type post_invoices_invoice_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_request_query(),
      header => post_invoices_invoice_request_header(),
      cookie => post_invoices_invoice_request_cookie(),
      body => post_invoices_invoice_request_body()}.
-type post_invoices_invoice_request_query() :: map().
-type post_invoices_invoice_request_header() :: map().
-type post_invoices_invoice_request_cookie() :: map().
-type post_invoices_invoice_request_body() :: map().
-type post_invoices_invoice_response() :: stripe_model:error() | stripe_model:invoice().
-type get_invoices_invoice_request() ::
    #{invoice := binary(),
      query => get_invoices_invoice_request_query(),
      header => get_invoices_invoice_request_header(),
      cookie => get_invoices_invoice_request_cookie(),
      body => get_invoices_invoice_request_body()}.
-type get_invoices_invoice_request_query() :: #{expand => [binary()]}.
-type get_invoices_invoice_request_header() :: map().
-type get_invoices_invoice_request_cookie() :: map().
-type get_invoices_invoice_request_body() :: map().
-type get_invoices_invoice_response() :: stripe_model:error() | stripe_model:invoice().
-type post_identity_verification_sessions_session_request() ::
    #{session := binary(),
      query => post_identity_verification_sessions_session_request_query(),
      header => post_identity_verification_sessions_session_request_header(),
      cookie => post_identity_verification_sessions_session_request_cookie(),
      body => post_identity_verification_sessions_session_request_body()}.
-type post_identity_verification_sessions_session_request_query() :: map().
-type post_identity_verification_sessions_session_request_header() :: map().
-type post_identity_verification_sessions_session_request_cookie() :: map().
-type post_identity_verification_sessions_session_request_body() :: map().
-type post_identity_verification_sessions_session_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type get_identity_verification_sessions_session_request() ::
    #{session := binary(),
      query => get_identity_verification_sessions_session_request_query(),
      header => get_identity_verification_sessions_session_request_header(),
      cookie => get_identity_verification_sessions_session_request_cookie(),
      body => get_identity_verification_sessions_session_request_body()}.
-type get_identity_verification_sessions_session_request_query() ::
    #{expand => [binary()]}.
-type get_identity_verification_sessions_session_request_header() :: map().
-type get_identity_verification_sessions_session_request_cookie() :: map().
-type get_identity_verification_sessions_session_request_body() :: map().
-type get_identity_verification_sessions_session_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type get_balance_transactions_id_request() ::
    #{id := binary(),
      query => get_balance_transactions_id_request_query(),
      header => get_balance_transactions_id_request_header(),
      cookie => get_balance_transactions_id_request_cookie(),
      body => get_balance_transactions_id_request_body()}.
-type get_balance_transactions_id_request_query() :: #{expand => [binary()]}.
-type get_balance_transactions_id_request_header() :: map().
-type get_balance_transactions_id_request_cookie() :: map().
-type get_balance_transactions_id_request_body() :: map().
-type get_balance_transactions_id_response() ::
    stripe_model:error() | stripe_model:balance_transaction().
-type post_setup_intents_intent_cancel_request() ::
    #{intent := binary(),
      query => post_setup_intents_intent_cancel_request_query(),
      header => post_setup_intents_intent_cancel_request_header(),
      cookie => post_setup_intents_intent_cancel_request_cookie(),
      body => post_setup_intents_intent_cancel_request_body()}.
-type post_setup_intents_intent_cancel_request_query() :: map().
-type post_setup_intents_intent_cancel_request_header() :: map().
-type post_setup_intents_intent_cancel_request_cookie() :: map().
-type post_setup_intents_intent_cancel_request_body() :: map().
-type post_setup_intents_intent_cancel_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type post_issuing_transactions_transaction_request() ::
    #{transaction := binary(),
      query => post_issuing_transactions_transaction_request_query(),
      header => post_issuing_transactions_transaction_request_header(),
      cookie => post_issuing_transactions_transaction_request_cookie(),
      body => post_issuing_transactions_transaction_request_body()}.
-type post_issuing_transactions_transaction_request_query() :: map().
-type post_issuing_transactions_transaction_request_header() :: map().
-type post_issuing_transactions_transaction_request_cookie() :: map().
-type post_issuing_transactions_transaction_request_body() :: map().
-type post_issuing_transactions_transaction_response() ::
    stripe_model:error() | stripe_model:issuing_transaction().
-type get_issuing_transactions_transaction_request() ::
    #{transaction := binary(),
      query => get_issuing_transactions_transaction_request_query(),
      header => get_issuing_transactions_transaction_request_header(),
      cookie => get_issuing_transactions_transaction_request_cookie(),
      body => get_issuing_transactions_transaction_request_body()}.
-type get_issuing_transactions_transaction_request_query() :: #{expand => [binary()]}.
-type get_issuing_transactions_transaction_request_header() :: map().
-type get_issuing_transactions_transaction_request_cookie() :: map().
-type get_issuing_transactions_transaction_request_body() :: map().
-type get_issuing_transactions_transaction_response() ::
    stripe_model:error() | stripe_model:issuing_transaction().
-type post_terminal_connection_tokens_request() ::
    #{query => post_terminal_connection_tokens_request_query(),
      header => post_terminal_connection_tokens_request_header(),
      cookie => post_terminal_connection_tokens_request_cookie(),
      body => post_terminal_connection_tokens_request_body()}.
-type post_terminal_connection_tokens_request_query() :: map().
-type post_terminal_connection_tokens_request_header() :: map().
-type post_terminal_connection_tokens_request_cookie() :: map().
-type post_terminal_connection_tokens_request_body() :: map().
-type post_terminal_connection_tokens_response() ::
    stripe_model:error() | stripe_model:terminal_connection_token().
-type get_reviews_request() ::
    #{query => get_reviews_request_query(),
      header => get_reviews_request_header(),
      cookie => get_reviews_request_cookie(),
      body => get_reviews_request_body()}.
-type get_reviews_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_reviews_request_header() :: map().
-type get_reviews_request_cookie() :: map().
-type get_reviews_request_body() :: map().
-type get_reviews_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:review()]}.
-type post_promotion_codes_request() ::
    #{query => post_promotion_codes_request_query(),
      header => post_promotion_codes_request_header(),
      cookie => post_promotion_codes_request_cookie(),
      body => post_promotion_codes_request_body()}.
-type post_promotion_codes_request_query() :: map().
-type post_promotion_codes_request_header() :: map().
-type post_promotion_codes_request_cookie() :: map().
-type post_promotion_codes_request_body() :: map().
-type post_promotion_codes_response() ::
    stripe_model:error() | stripe_model:promotion_code().
-type get_promotion_codes_request() ::
    #{query => get_promotion_codes_request_query(),
      header => get_promotion_codes_request_header(),
      cookie => get_promotion_codes_request_cookie(),
      body => get_promotion_codes_request_body()}.
-type get_promotion_codes_request_query() ::
    #{active => boolean(),
      code => binary(),
      coupon => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_promotion_codes_request_header() :: map().
-type get_promotion_codes_request_cookie() :: map().
-type get_promotion_codes_request_body() :: map().
-type get_promotion_codes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:promotion_code()]}.
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query =>
          delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_query(),
      header =>
          delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_header(),
      cookie =>
          delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie(),
      body =>
          delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_body()}.
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_query() ::
    map().
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_header() ::
    map().
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie() ::
    map().
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_body() ::
    map().
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_response() ::
    stripe_model:error() | stripe_model:deleted_discount().
-type get_customers_customer_subscriptions_subscription_exposed_id_discount_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query =>
          get_customers_customer_subscriptions_subscription_exposed_id_discount_request_query(),
      header =>
          get_customers_customer_subscriptions_subscription_exposed_id_discount_request_header(),
      cookie =>
          get_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie(),
      body =>
          get_customers_customer_subscriptions_subscription_exposed_id_discount_request_body()}.
-type
get_customers_customer_subscriptions_subscription_exposed_id_discount_request_query() ::
    #{expand => [binary()]}.
-type
get_customers_customer_subscriptions_subscription_exposed_id_discount_request_header() ::
    map().
-type
get_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie() ::
    map().
-type
get_customers_customer_subscriptions_subscription_exposed_id_discount_request_body() ::
    map().
-type get_customers_customer_subscriptions_subscription_exposed_id_discount_response() ::
    stripe_model:error() | stripe_model:discount().
-type get_quotes_quote_computed_upfront_line_items_request() ::
    #{quote := binary(),
      query => get_quotes_quote_computed_upfront_line_items_request_query(),
      header => get_quotes_quote_computed_upfront_line_items_request_header(),
      cookie => get_quotes_quote_computed_upfront_line_items_request_cookie(),
      body => get_quotes_quote_computed_upfront_line_items_request_body()}.
-type get_quotes_quote_computed_upfront_line_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_quotes_quote_computed_upfront_line_items_request_header() :: map().
-type get_quotes_quote_computed_upfront_line_items_request_cookie() :: map().
-type get_quotes_quote_computed_upfront_line_items_request_body() :: map().
-type get_quotes_quote_computed_upfront_line_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:item()]}.
-type delete_radar_value_list_items_item_request() ::
    #{item := binary(),
      query => delete_radar_value_list_items_item_request_query(),
      header => delete_radar_value_list_items_item_request_header(),
      cookie => delete_radar_value_list_items_item_request_cookie(),
      body => delete_radar_value_list_items_item_request_body()}.
-type delete_radar_value_list_items_item_request_query() :: map().
-type delete_radar_value_list_items_item_request_header() :: map().
-type delete_radar_value_list_items_item_request_cookie() :: map().
-type delete_radar_value_list_items_item_request_body() :: map().
-type delete_radar_value_list_items_item_response() ::
    stripe_model:error() | stripe_model:deleted_radar_value_list_item().
-type get_radar_value_list_items_item_request() ::
    #{item := binary(),
      query => get_radar_value_list_items_item_request_query(),
      header => get_radar_value_list_items_item_request_header(),
      cookie => get_radar_value_list_items_item_request_cookie(),
      body => get_radar_value_list_items_item_request_body()}.
-type get_radar_value_list_items_item_request_query() :: #{expand => [binary()]}.
-type get_radar_value_list_items_item_request_header() :: map().
-type get_radar_value_list_items_item_request_cookie() :: map().
-type get_radar_value_list_items_item_request_body() :: map().
-type get_radar_value_list_items_item_response() ::
    stripe_model:error() | stripe_model:radar_value_list_item().
-type get_issuer_fraud_records_request() ::
    #{query => get_issuer_fraud_records_request_query(),
      header => get_issuer_fraud_records_request_header(),
      cookie => get_issuer_fraud_records_request_cookie(),
      body => get_issuer_fraud_records_request_body()}.
-type get_issuer_fraud_records_request_query() ::
    #{charge => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_issuer_fraud_records_request_header() :: map().
-type get_issuer_fraud_records_request_cookie() :: map().
-type get_issuer_fraud_records_request_body() :: map().
-type get_issuer_fraud_records_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuer_fraud_record()]}.
-type post_tax_rates_tax_rate_request() ::
    #{tax_rate := binary(),
      query => post_tax_rates_tax_rate_request_query(),
      header => post_tax_rates_tax_rate_request_header(),
      cookie => post_tax_rates_tax_rate_request_cookie(),
      body => post_tax_rates_tax_rate_request_body()}.
-type post_tax_rates_tax_rate_request_query() :: map().
-type post_tax_rates_tax_rate_request_header() :: map().
-type post_tax_rates_tax_rate_request_cookie() :: map().
-type post_tax_rates_tax_rate_request_body() :: map().
-type post_tax_rates_tax_rate_response() ::
    stripe_model:error() | stripe_model:tax_rate().
-type get_tax_rates_tax_rate_request() ::
    #{tax_rate := binary(),
      query => get_tax_rates_tax_rate_request_query(),
      header => get_tax_rates_tax_rate_request_header(),
      cookie => get_tax_rates_tax_rate_request_cookie(),
      body => get_tax_rates_tax_rate_request_body()}.
-type get_tax_rates_tax_rate_request_query() :: #{expand => [binary()]}.
-type get_tax_rates_tax_rate_request_header() :: map().
-type get_tax_rates_tax_rate_request_cookie() :: map().
-type get_tax_rates_tax_rate_request_body() :: map().
-type get_tax_rates_tax_rate_response() :: stripe_model:error() | stripe_model:tax_rate().
-type post_recipients_request() ::
    #{query => post_recipients_request_query(),
      header => post_recipients_request_header(),
      cookie => post_recipients_request_cookie(),
      body => post_recipients_request_body()}.
-type post_recipients_request_query() :: map().
-type post_recipients_request_header() :: map().
-type post_recipients_request_cookie() :: map().
-type post_recipients_request_body() :: map().
-type post_recipients_response() :: stripe_model:error() | stripe_model:recipient().
-type get_recipients_request() ::
    #{query => get_recipients_request_query(),
      header => get_recipients_request_header(),
      cookie => get_recipients_request_cookie(),
      body => get_recipients_request_body()}.
-type get_recipients_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type => corporation | individual,
      verified => boolean()}.
-type get_recipients_request_header() :: map().
-type get_recipients_request_cookie() :: map().
-type get_recipients_request_body() :: map().
-type get_recipients_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:recipient()]}.
-type post_plans_request() ::
    #{query => post_plans_request_query(),
      header => post_plans_request_header(),
      cookie => post_plans_request_cookie(),
      body => post_plans_request_body()}.
-type post_plans_request_query() :: map().
-type post_plans_request_header() :: map().
-type post_plans_request_cookie() :: map().
-type post_plans_request_body() :: map().
-type post_plans_response() :: stripe_model:error() | stripe_model:plan().
-type get_plans_request() ::
    #{query => get_plans_request_query(),
      header => get_plans_request_header(),
      cookie => get_plans_request_cookie(),
      body => get_plans_request_body()}.
-type get_plans_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      product => binary(),
      starting_after => binary()}.
-type get_plans_request_header() :: map().
-type get_plans_request_cookie() :: map().
-type get_plans_request_body() :: map().
-type get_plans_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:plan()]}.
-type post_customers_customer_balance_transactions_request() ::
    #{customer := binary(),
      query => post_customers_customer_balance_transactions_request_query(),
      header => post_customers_customer_balance_transactions_request_header(),
      cookie => post_customers_customer_balance_transactions_request_cookie(),
      body => post_customers_customer_balance_transactions_request_body()}.
-type post_customers_customer_balance_transactions_request_query() :: map().
-type post_customers_customer_balance_transactions_request_header() :: map().
-type post_customers_customer_balance_transactions_request_cookie() :: map().
-type post_customers_customer_balance_transactions_request_body() :: map().
-type post_customers_customer_balance_transactions_response() ::
    stripe_model:error() | stripe_model:customer_balance_transaction().
-type get_customers_customer_balance_transactions_request() ::
    #{customer := binary(),
      query => get_customers_customer_balance_transactions_request_query(),
      header => get_customers_customer_balance_transactions_request_header(),
      cookie => get_customers_customer_balance_transactions_request_cookie(),
      body => get_customers_customer_balance_transactions_request_body()}.
-type get_customers_customer_balance_transactions_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_balance_transactions_request_header() :: map().
-type get_customers_customer_balance_transactions_request_cookie() :: map().
-type get_customers_customer_balance_transactions_request_body() :: map().
-type get_customers_customer_balance_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:customer_balance_transaction()]}.
-type post_reviews_review_approve_request() ::
    #{review := binary(),
      query => post_reviews_review_approve_request_query(),
      header => post_reviews_review_approve_request_header(),
      cookie => post_reviews_review_approve_request_cookie(),
      body => post_reviews_review_approve_request_body()}.
-type post_reviews_review_approve_request_query() :: map().
-type post_reviews_review_approve_request_header() :: map().
-type post_reviews_review_approve_request_cookie() :: map().
-type post_reviews_review_approve_request_body() :: map().
-type post_reviews_review_approve_response() ::
    stripe_model:error() | stripe_model:review().
-type post_customers_customer_tax_ids_request() ::
    #{customer := binary(),
      query => post_customers_customer_tax_ids_request_query(),
      header => post_customers_customer_tax_ids_request_header(),
      cookie => post_customers_customer_tax_ids_request_cookie(),
      body => post_customers_customer_tax_ids_request_body()}.
-type post_customers_customer_tax_ids_request_query() :: map().
-type post_customers_customer_tax_ids_request_header() :: map().
-type post_customers_customer_tax_ids_request_cookie() :: map().
-type post_customers_customer_tax_ids_request_body() :: map().
-type post_customers_customer_tax_ids_response() ::
    stripe_model:error() | stripe_model:tax_id().
-type get_customers_customer_tax_ids_request() ::
    #{customer := binary(),
      query => get_customers_customer_tax_ids_request_query(),
      header => get_customers_customer_tax_ids_request_header(),
      cookie => get_customers_customer_tax_ids_request_cookie(),
      body => get_customers_customer_tax_ids_request_body()}.
-type get_customers_customer_tax_ids_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_tax_ids_request_header() :: map().
-type get_customers_customer_tax_ids_request_cookie() :: map().
-type get_customers_customer_tax_ids_request_body() :: map().
-type get_customers_customer_tax_ids_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:tax_id()]}.
-type get_tokens_token_request() ::
    #{token := binary(),
      query => get_tokens_token_request_query(),
      header => get_tokens_token_request_header(),
      cookie => get_tokens_token_request_cookie(),
      body => get_tokens_token_request_body()}.
-type get_tokens_token_request_query() :: #{expand => [binary()]}.
-type get_tokens_token_request_header() :: map().
-type get_tokens_token_request_cookie() :: map().
-type get_tokens_token_request_body() :: map().
-type get_tokens_token_response() :: stripe_model:error() | stripe_model:token().
-type get_balance_transactions_request() ::
    #{query => get_balance_transactions_request_query(),
      header => get_balance_transactions_request_header(),
      cookie => get_balance_transactions_request_cookie(),
      body => get_balance_transactions_request_body()}.
-type get_balance_transactions_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      currency => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payout => binary(),
      source => binary(),
      starting_after => binary(),
      type => binary()}.
-type get_balance_transactions_request_header() :: map().
-type get_balance_transactions_request_cookie() :: map().
-type get_balance_transactions_request_body() :: map().
-type get_balance_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:balance_transaction()]}.
-type get_tax_codes_id_request() ::
    #{id := binary(),
      query => get_tax_codes_id_request_query(),
      header => get_tax_codes_id_request_header(),
      cookie => get_tax_codes_id_request_cookie(),
      body => get_tax_codes_id_request_body()}.
-type get_tax_codes_id_request_query() :: #{expand => [binary()]}.
-type get_tax_codes_id_request_header() :: map().
-type get_tax_codes_id_request_cookie() :: map().
-type get_tax_codes_id_request_body() :: map().
-type get_tax_codes_id_response() :: stripe_model:error() | stripe_model:tax_code().
-type post_accounts_account_reject_request() ::
    #{account := binary(),
      query => post_accounts_account_reject_request_query(),
      header => post_accounts_account_reject_request_header(),
      cookie => post_accounts_account_reject_request_cookie(),
      body => post_accounts_account_reject_request_body()}.
-type post_accounts_account_reject_request_query() :: map().
-type post_accounts_account_reject_request_header() :: map().
-type post_accounts_account_reject_request_cookie() :: map().
-type post_accounts_account_reject_request_body() :: map().
-type post_accounts_account_reject_response() ::
    stripe_model:error() | stripe_model:account().
-type delete_subscriptions_subscription_exposed_id_request() ::
    #{subscription_exposed_id := binary(),
      query => delete_subscriptions_subscription_exposed_id_request_query(),
      header => delete_subscriptions_subscription_exposed_id_request_header(),
      cookie => delete_subscriptions_subscription_exposed_id_request_cookie(),
      body => delete_subscriptions_subscription_exposed_id_request_body()}.
-type delete_subscriptions_subscription_exposed_id_request_query() :: map().
-type delete_subscriptions_subscription_exposed_id_request_header() :: map().
-type delete_subscriptions_subscription_exposed_id_request_cookie() :: map().
-type delete_subscriptions_subscription_exposed_id_request_body() :: map().
-type delete_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type post_subscriptions_subscription_exposed_id_request() ::
    #{subscription_exposed_id := binary(),
      query => post_subscriptions_subscription_exposed_id_request_query(),
      header => post_subscriptions_subscription_exposed_id_request_header(),
      cookie => post_subscriptions_subscription_exposed_id_request_cookie(),
      body => post_subscriptions_subscription_exposed_id_request_body()}.
-type post_subscriptions_subscription_exposed_id_request_query() :: map().
-type post_subscriptions_subscription_exposed_id_request_header() :: map().
-type post_subscriptions_subscription_exposed_id_request_cookie() :: map().
-type post_subscriptions_subscription_exposed_id_request_body() :: map().
-type post_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_subscriptions_subscription_exposed_id_request() ::
    #{subscription_exposed_id := binary(),
      query => get_subscriptions_subscription_exposed_id_request_query(),
      header => get_subscriptions_subscription_exposed_id_request_header(),
      cookie => get_subscriptions_subscription_exposed_id_request_cookie(),
      body => get_subscriptions_subscription_exposed_id_request_body()}.
-type get_subscriptions_subscription_exposed_id_request_query() ::
    #{expand => [binary()]}.
-type get_subscriptions_subscription_exposed_id_request_header() :: map().
-type get_subscriptions_subscription_exposed_id_request_cookie() :: map().
-type get_subscriptions_subscription_exposed_id_request_body() :: map().
-type get_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_country_specs_country_request() ::
    #{country := binary(),
      query => get_country_specs_country_request_query(),
      header => get_country_specs_country_request_header(),
      cookie => get_country_specs_country_request_cookie(),
      body => get_country_specs_country_request_body()}.
-type get_country_specs_country_request_query() :: #{expand => [binary()]}.
-type get_country_specs_country_request_header() :: map().
-type get_country_specs_country_request_cookie() :: map().
-type get_country_specs_country_request_body() :: map().
-type get_country_specs_country_response() ::
    stripe_model:error() | stripe_model:country_spec().
-type post_invoices_invoice_finalize_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_finalize_request_query(),
      header => post_invoices_invoice_finalize_request_header(),
      cookie => post_invoices_invoice_finalize_request_cookie(),
      body => post_invoices_invoice_finalize_request_body()}.
-type post_invoices_invoice_finalize_request_query() :: map().
-type post_invoices_invoice_finalize_request_header() :: map().
-type post_invoices_invoice_finalize_request_cookie() :: map().
-type post_invoices_invoice_finalize_request_body() :: map().
-type post_invoices_invoice_finalize_response() ::
    stripe_model:error() | stripe_model:invoice().
-type delete_terminal_locations_location_request() ::
    #{location := binary(),
      query => delete_terminal_locations_location_request_query(),
      header => delete_terminal_locations_location_request_header(),
      cookie => delete_terminal_locations_location_request_cookie(),
      body => delete_terminal_locations_location_request_body()}.
-type delete_terminal_locations_location_request_query() :: map().
-type delete_terminal_locations_location_request_header() :: map().
-type delete_terminal_locations_location_request_cookie() :: map().
-type delete_terminal_locations_location_request_body() :: map().
-type delete_terminal_locations_location_response() ::
    stripe_model:error() | stripe_model:deleted_terminal_location().
-type post_terminal_locations_location_request() ::
    #{location := binary(),
      query => post_terminal_locations_location_request_query(),
      header => post_terminal_locations_location_request_header(),
      cookie => post_terminal_locations_location_request_cookie(),
      body => post_terminal_locations_location_request_body()}.
-type post_terminal_locations_location_request_query() :: map().
-type post_terminal_locations_location_request_header() :: map().
-type post_terminal_locations_location_request_cookie() :: map().
-type post_terminal_locations_location_request_body() :: map().
-type post_terminal_locations_location_response() ::
    stripe_model:error() | stripe_model:terminal_location().
-type get_terminal_locations_location_request() ::
    #{location := binary(),
      query => get_terminal_locations_location_request_query(),
      header => get_terminal_locations_location_request_header(),
      cookie => get_terminal_locations_location_request_cookie(),
      body => get_terminal_locations_location_request_body()}.
-type get_terminal_locations_location_request_query() :: #{expand => [binary()]}.
-type get_terminal_locations_location_request_header() :: map().
-type get_terminal_locations_location_request_cookie() :: map().
-type get_terminal_locations_location_request_body() :: map().
-type get_terminal_locations_location_response() ::
    stripe_model:error() | stripe_model:terminal_location().
-type delete_account_request() ::
    #{query => delete_account_request_query(),
      header => delete_account_request_header(),
      cookie => delete_account_request_cookie(),
      body => delete_account_request_body()}.
-type delete_account_request_query() :: map().
-type delete_account_request_header() :: map().
-type delete_account_request_cookie() :: map().
-type delete_account_request_body() :: map().
-type delete_account_response() :: stripe_model:error() | stripe_model:deleted_account().
-type post_account_request() ::
    #{query => post_account_request_query(),
      header => post_account_request_header(),
      cookie => post_account_request_cookie(),
      body => post_account_request_body()}.
-type post_account_request_query() :: map().
-type post_account_request_header() :: map().
-type post_account_request_cookie() :: map().
-type post_account_request_body() :: map().
-type post_account_response() :: stripe_model:error() | stripe_model:account().
-type get_account_request() ::
    #{query => get_account_request_query(),
      header => get_account_request_header(),
      cookie => get_account_request_cookie(),
      body => get_account_request_body()}.
-type get_account_request_query() :: #{expand => [binary()]}.
-type get_account_request_header() :: map().
-type get_account_request_cookie() :: map().
-type get_account_request_body() :: map().
-type get_account_response() :: stripe_model:error() | stripe_model:account().
-type post_shipping_rates_shipping_rate_token_request() ::
    #{shipping_rate_token := binary(),
      query => post_shipping_rates_shipping_rate_token_request_query(),
      header => post_shipping_rates_shipping_rate_token_request_header(),
      cookie => post_shipping_rates_shipping_rate_token_request_cookie(),
      body => post_shipping_rates_shipping_rate_token_request_body()}.
-type post_shipping_rates_shipping_rate_token_request_query() :: map().
-type post_shipping_rates_shipping_rate_token_request_header() :: map().
-type post_shipping_rates_shipping_rate_token_request_cookie() :: map().
-type post_shipping_rates_shipping_rate_token_request_body() :: map().
-type post_shipping_rates_shipping_rate_token_response() ::
    stripe_model:error() | stripe_model:shipping_rate().
-type get_shipping_rates_shipping_rate_token_request() ::
    #{shipping_rate_token := binary(),
      query => get_shipping_rates_shipping_rate_token_request_query(),
      header => get_shipping_rates_shipping_rate_token_request_header(),
      cookie => get_shipping_rates_shipping_rate_token_request_cookie(),
      body => get_shipping_rates_shipping_rate_token_request_body()}.
-type get_shipping_rates_shipping_rate_token_request_query() :: #{expand => [binary()]}.
-type get_shipping_rates_shipping_rate_token_request_header() :: map().
-type get_shipping_rates_shipping_rate_token_request_cookie() :: map().
-type get_shipping_rates_shipping_rate_token_request_body() :: map().
-type get_shipping_rates_shipping_rate_token_response() ::
    stripe_model:error() | stripe_model:shipping_rate().
-type get_invoices_upcoming_lines_request() ::
    #{query => get_invoices_upcoming_lines_request_query(),
      header => get_invoices_upcoming_lines_request_header(),
      cookie => get_invoices_upcoming_lines_request_cookie(),
      body => get_invoices_upcoming_lines_request_body()}.
-type get_invoices_upcoming_lines_request_query() ::
    #{automatic_tax => #{enabled := boolean()},
      coupon => binary(),
      customer => binary(),
      customer_details =>
          #{tax_ids =>
                [#{value := binary(),
                   type :=
                       ae_trn | au_abn | au_arn | br_cnpj | br_cpf | ca_bn | ca_gst_hst |
                       ca_pst_bc | ca_pst_mb | ca_pst_sk | ca_qst | ch_vat | cl_tin | es_cif |
                       eu_vat | gb_vat | ge_vat | hk_br | id_npwp | il_vat | in_gst | is_vat |
                       jp_cn | jp_rn | kr_brn | li_uid | mx_rfc | my_frp | my_itn | my_sst |
                       no_vat | nz_gst | ru_inn | ru_kpp | sa_vat | sg_gst | sg_uen | th_vat |
                       tw_vat | ua_vat | us_ein | za_vat}],
            tax_exempt => '' | exempt | none | reverse,
            tax => #{ip_address => binary() | ''},
            shipping =>
                #{phone => binary(),
                  name := binary(),
                  address :=
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary()}} |
                '',
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary()} |
                ''},
      discounts => [#{discount => binary(), coupon => binary()}] | '',
      ending_before => binary(),
      expand => [binary()],
      invoice_items =>
          [#{unit_amount_decimal => binary(),
             unit_amount => integer(),
             tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   product := binary(),
                   currency := binary()},
             price => binary(),
             period => #{start := integer(), 'end' := integer()},
             metadata => json:value() | '',
             invoiceitem => binary(),
             discounts => [#{discount => binary(), coupon => binary()}] | '',
             discountable => boolean(),
             description => binary(),
             currency => binary(),
             amount => integer()}],
      limit => integer(),
      schedule => binary(),
      starting_after => binary(),
      subscription => binary(),
      subscription_billing_cycle_anchor => now | unchanged | integer(),
      subscription_cancel_at => integer() | '',
      subscription_cancel_at_period_end => boolean(),
      subscription_cancel_now => boolean(),
      subscription_default_tax_rates => [binary()] | '',
      subscription_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring :=
                       #{interval_count => integer(), interval := day | month | week | year},
                   product := binary(),
                   currency := binary()},
             price => binary(),
             metadata => json:value() | '',
             id => binary(),
             deleted => boolean(),
             clear_usage => boolean(),
             billing_thresholds => #{usage_gte := integer()} | ''}],
      subscription_proration_behavior => always_invoice | create_prorations | none,
      subscription_proration_date => integer(),
      subscription_start_date => integer(),
      subscription_trial_end => now | integer(),
      subscription_trial_from_plan => boolean()}.
-type get_invoices_upcoming_lines_request_header() :: map().
-type get_invoices_upcoming_lines_request_cookie() :: map().
-type get_invoices_upcoming_lines_request_body() :: map().
-type get_invoices_upcoming_lines_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:line_item()]}.
-type post_issuing_cardholders_request() ::
    #{query => post_issuing_cardholders_request_query(),
      header => post_issuing_cardholders_request_header(),
      cookie => post_issuing_cardholders_request_cookie(),
      body => post_issuing_cardholders_request_body()}.
-type post_issuing_cardholders_request_query() :: map().
-type post_issuing_cardholders_request_header() :: map().
-type post_issuing_cardholders_request_cookie() :: map().
-type post_issuing_cardholders_request_body() :: map().
-type post_issuing_cardholders_response() ::
    stripe_model:error() | stripe_model:issuing_cardholder().
-type get_issuing_cardholders_request() ::
    #{query => get_issuing_cardholders_request_query(),
      header => get_issuing_cardholders_request_header(),
      cookie => get_issuing_cardholders_request_cookie(),
      body => get_issuing_cardholders_request_body()}.
-type get_issuing_cardholders_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      email => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      phone_number => binary(),
      starting_after => binary(),
      status => active | blocked | inactive,
      type => company | individual}.
-type get_issuing_cardholders_request_header() :: map().
-type get_issuing_cardholders_request_cookie() :: map().
-type get_issuing_cardholders_request_body() :: map().
-type get_issuing_cardholders_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_cardholder()]}.
-type delete_customers_customer_sources_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => delete_customers_customer_sources_id_request_query(),
      header => delete_customers_customer_sources_id_request_header(),
      cookie => delete_customers_customer_sources_id_request_cookie(),
      body => delete_customers_customer_sources_id_request_body()}.
-type delete_customers_customer_sources_id_request_query() :: map().
-type delete_customers_customer_sources_id_request_header() :: map().
-type delete_customers_customer_sources_id_request_cookie() :: map().
-type delete_customers_customer_sources_id_request_body() :: map().
-type delete_customers_customer_sources_id_response() ::
    stripe_model:error() |
    stripe_model:payment_source() |
    stripe_model:deleted_payment_source().
-type post_customers_customer_sources_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_sources_id_request_query(),
      header => post_customers_customer_sources_id_request_header(),
      cookie => post_customers_customer_sources_id_request_cookie(),
      body => post_customers_customer_sources_id_request_body()}.
-type post_customers_customer_sources_id_request_query() :: map().
-type post_customers_customer_sources_id_request_header() :: map().
-type post_customers_customer_sources_id_request_cookie() :: map().
-type post_customers_customer_sources_id_request_body() :: map().
-type post_customers_customer_sources_id_response() ::
    stripe_model:error() |
    stripe_model:card() |
    stripe_model:bank_account() |
    stripe_model:source().
-type get_customers_customer_sources_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => get_customers_customer_sources_id_request_query(),
      header => get_customers_customer_sources_id_request_header(),
      cookie => get_customers_customer_sources_id_request_cookie(),
      body => get_customers_customer_sources_id_request_body()}.
-type get_customers_customer_sources_id_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_sources_id_request_header() :: map().
-type get_customers_customer_sources_id_request_cookie() :: map().
-type get_customers_customer_sources_id_request_body() :: map().
-type get_customers_customer_sources_id_response() ::
    stripe_model:error() | stripe_model:payment_source().
-type get_application_fees_request() ::
    #{query => get_application_fees_request_query(),
      header => get_application_fees_request_header(),
      cookie => get_application_fees_request_cookie(),
      body => get_application_fees_request_body()}.
-type get_application_fees_request_query() ::
    #{charge => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_application_fees_request_header() :: map().
-type get_application_fees_request_cookie() :: map().
-type get_application_fees_request_body() :: map().
-type get_application_fees_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:application_fee()]}.
-type get_bitcoin_receivers_request() ::
    #{query => get_bitcoin_receivers_request_query(),
      header => get_bitcoin_receivers_request_header(),
      cookie => get_bitcoin_receivers_request_cookie(),
      body => get_bitcoin_receivers_request_body()}.
-type get_bitcoin_receivers_request_query() ::
    #{active => boolean(),
      ending_before => binary(),
      expand => [binary()],
      filled => boolean(),
      limit => integer(),
      starting_after => binary(),
      uncaptured_funds => boolean()}.
-type get_bitcoin_receivers_request_header() :: map().
-type get_bitcoin_receivers_request_cookie() :: map().
-type get_bitcoin_receivers_request_body() :: map().
-type get_bitcoin_receivers_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bitcoin_receiver()]}.
-type post_refunds_refund_request() ::
    #{refund := binary(),
      query => post_refunds_refund_request_query(),
      header => post_refunds_refund_request_header(),
      cookie => post_refunds_refund_request_cookie(),
      body => post_refunds_refund_request_body()}.
-type post_refunds_refund_request_query() :: map().
-type post_refunds_refund_request_header() :: map().
-type post_refunds_refund_request_cookie() :: map().
-type post_refunds_refund_request_body() :: map().
-type post_refunds_refund_response() :: stripe_model:error() | stripe_model:refund().
-type get_refunds_refund_request() ::
    #{refund := binary(),
      query => get_refunds_refund_request_query(),
      header => get_refunds_refund_request_header(),
      cookie => get_refunds_refund_request_cookie(),
      body => get_refunds_refund_request_body()}.
-type get_refunds_refund_request_query() :: #{expand => [binary()]}.
-type get_refunds_refund_request_header() :: map().
-type get_refunds_refund_request_cookie() :: map().
-type get_refunds_refund_request_body() :: map().
-type get_refunds_refund_response() :: stripe_model:error() | stripe_model:refund().
-type post_account_login_links_request() ::
    #{query => post_account_login_links_request_query(),
      header => post_account_login_links_request_header(),
      cookie => post_account_login_links_request_cookie(),
      body => post_account_login_links_request_body()}.
-type post_account_login_links_request_query() :: map().
-type post_account_login_links_request_header() :: map().
-type post_account_login_links_request_cookie() :: map().
-type post_account_login_links_request_body() :: map().
-type post_account_login_links_response() ::
    stripe_model:error() | stripe_model:login_link().
-type post_tax_rates_request() ::
    #{query => post_tax_rates_request_query(),
      header => post_tax_rates_request_header(),
      cookie => post_tax_rates_request_cookie(),
      body => post_tax_rates_request_body()}.
-type post_tax_rates_request_query() :: map().
-type post_tax_rates_request_header() :: map().
-type post_tax_rates_request_cookie() :: map().
-type post_tax_rates_request_body() :: map().
-type post_tax_rates_response() :: stripe_model:error() | stripe_model:tax_rate().
-type get_tax_rates_request() ::
    #{query => get_tax_rates_request_query(),
      header => get_tax_rates_request_header(),
      cookie => get_tax_rates_request_cookie(),
      body => get_tax_rates_request_body()}.
-type get_tax_rates_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      inclusive => boolean(),
      limit => integer(),
      starting_after => binary()}.
-type get_tax_rates_request_header() :: map().
-type get_tax_rates_request_cookie() :: map().
-type get_tax_rates_request_body() :: map().
-type get_tax_rates_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:tax_rate()]}.
-type post_accounts_account_people_request() ::
    #{account := binary(),
      query => post_accounts_account_people_request_query(),
      header => post_accounts_account_people_request_header(),
      cookie => post_accounts_account_people_request_cookie(),
      body => post_accounts_account_people_request_body()}.
-type post_accounts_account_people_request_query() :: map().
-type post_accounts_account_people_request_header() :: map().
-type post_accounts_account_people_request_cookie() :: map().
-type post_accounts_account_people_request_body() :: map().
-type post_accounts_account_people_response() ::
    stripe_model:error() | stripe_model:person().
-type get_accounts_account_people_request() ::
    #{account := binary(),
      query => get_accounts_account_people_request_query(),
      header => get_accounts_account_people_request_header(),
      cookie => get_accounts_account_people_request_cookie(),
      body => get_accounts_account_people_request_body()}.
-type get_accounts_account_people_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      relationship =>
          #{representative => boolean(),
            owner => boolean(),
            executive => boolean(),
            director => boolean()},
      starting_after => binary()}.
-type get_accounts_account_people_request_header() :: map().
-type get_accounts_account_people_request_cookie() :: map().
-type get_accounts_account_people_request_body() :: map().
-type get_accounts_account_people_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:person()]}.
-type post_issuing_disputes_dispute_submit_request() ::
    #{dispute := binary(),
      query => post_issuing_disputes_dispute_submit_request_query(),
      header => post_issuing_disputes_dispute_submit_request_header(),
      cookie => post_issuing_disputes_dispute_submit_request_cookie(),
      body => post_issuing_disputes_dispute_submit_request_body()}.
-type post_issuing_disputes_dispute_submit_request_query() :: map().
-type post_issuing_disputes_dispute_submit_request_header() :: map().
-type post_issuing_disputes_dispute_submit_request_cookie() :: map().
-type post_issuing_disputes_dispute_submit_request_body() :: map().
-type post_issuing_disputes_dispute_submit_response() ::
    stripe_model:error() | stripe_model:issuing_dispute().
-type post_sources_source_request() ::
    #{source := binary(),
      query => post_sources_source_request_query(),
      header => post_sources_source_request_header(),
      cookie => post_sources_source_request_cookie(),
      body => post_sources_source_request_body()}.
-type post_sources_source_request_query() :: map().
-type post_sources_source_request_header() :: map().
-type post_sources_source_request_cookie() :: map().
-type post_sources_source_request_body() :: map().
-type post_sources_source_response() :: stripe_model:error() | stripe_model:source().
-type get_sources_source_request() ::
    #{source := binary(),
      query => get_sources_source_request_query(),
      header => get_sources_source_request_header(),
      cookie => get_sources_source_request_cookie(),
      body => get_sources_source_request_body()}.
-type get_sources_source_request_query() ::
    #{client_secret => binary(), expand => [binary()]}.
-type get_sources_source_request_header() :: map().
-type get_sources_source_request_cookie() :: map().
-type get_sources_source_request_body() :: map().
-type get_sources_source_response() :: stripe_model:error() | stripe_model:source().
-type get_checkout_sessions_session_request() ::
    #{session := binary(),
      query => get_checkout_sessions_session_request_query(),
      header => get_checkout_sessions_session_request_header(),
      cookie => get_checkout_sessions_session_request_cookie(),
      body => get_checkout_sessions_session_request_body()}.
-type get_checkout_sessions_session_request_query() :: #{expand => [binary()]}.
-type get_checkout_sessions_session_request_header() :: map().
-type get_checkout_sessions_session_request_cookie() :: map().
-type get_checkout_sessions_session_request_body() :: map().
-type get_checkout_sessions_session_response() ::
    stripe_model:error() | stripe_model:checkout_session().
-type post_payment_methods_payment_method_detach_request() ::
    #{payment_method := binary(),
      query => post_payment_methods_payment_method_detach_request_query(),
      header => post_payment_methods_payment_method_detach_request_header(),
      cookie => post_payment_methods_payment_method_detach_request_cookie(),
      body => post_payment_methods_payment_method_detach_request_body()}.
-type post_payment_methods_payment_method_detach_request_query() :: map().
-type post_payment_methods_payment_method_detach_request_header() :: map().
-type post_payment_methods_payment_method_detach_request_cookie() :: map().
-type post_payment_methods_payment_method_detach_request_body() :: map().
-type post_payment_methods_payment_method_detach_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type post_customers_request() ::
    #{query => post_customers_request_query(),
      header => post_customers_request_header(),
      cookie => post_customers_request_cookie(),
      body => post_customers_request_body()}.
-type post_customers_request_query() :: map().
-type post_customers_request_header() :: map().
-type post_customers_request_cookie() :: map().
-type post_customers_request_body() :: map().
-type post_customers_response() :: stripe_model:error() | stripe_model:customer().
-type get_customers_request() ::
    #{query => get_customers_request_query(),
      header => get_customers_request_header(),
      cookie => get_customers_request_cookie(),
      body => get_customers_request_body()}.
-type get_customers_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      email => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_request_header() :: map().
-type get_customers_request_cookie() :: map().
-type get_customers_request_body() :: map().
-type get_customers_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:customer()]}.
-type post_account_bank_accounts_request() ::
    #{query => post_account_bank_accounts_request_query(),
      header => post_account_bank_accounts_request_header(),
      cookie => post_account_bank_accounts_request_cookie(),
      body => post_account_bank_accounts_request_body()}.
-type post_account_bank_accounts_request_query() :: map().
-type post_account_bank_accounts_request_header() :: map().
-type post_account_bank_accounts_request_cookie() :: map().
-type post_account_bank_accounts_request_body() :: map().
-type post_account_bank_accounts_response() ::
    stripe_model:error() | stripe_model:external_account().
-type post_issuing_disputes_dispute_request() ::
    #{dispute := binary(),
      query => post_issuing_disputes_dispute_request_query(),
      header => post_issuing_disputes_dispute_request_header(),
      cookie => post_issuing_disputes_dispute_request_cookie(),
      body => post_issuing_disputes_dispute_request_body()}.
-type post_issuing_disputes_dispute_request_query() :: map().
-type post_issuing_disputes_dispute_request_header() :: map().
-type post_issuing_disputes_dispute_request_cookie() :: map().
-type post_issuing_disputes_dispute_request_body() :: map().
-type post_issuing_disputes_dispute_response() ::
    stripe_model:error() | stripe_model:issuing_dispute().
-type get_issuing_disputes_dispute_request() ::
    #{dispute := binary(),
      query => get_issuing_disputes_dispute_request_query(),
      header => get_issuing_disputes_dispute_request_header(),
      cookie => get_issuing_disputes_dispute_request_cookie(),
      body => get_issuing_disputes_dispute_request_body()}.
-type get_issuing_disputes_dispute_request_query() :: #{expand => [binary()]}.
-type get_issuing_disputes_dispute_request_header() :: map().
-type get_issuing_disputes_dispute_request_cookie() :: map().
-type get_issuing_disputes_dispute_request_body() :: map().
-type get_issuing_disputes_dispute_response() ::
    stripe_model:error() | stripe_model:issuing_dispute().
-type post_disputes_dispute_close_request() ::
    #{dispute := binary(),
      query => post_disputes_dispute_close_request_query(),
      header => post_disputes_dispute_close_request_header(),
      cookie => post_disputes_dispute_close_request_cookie(),
      body => post_disputes_dispute_close_request_body()}.
-type post_disputes_dispute_close_request_query() :: map().
-type post_disputes_dispute_close_request_header() :: map().
-type post_disputes_dispute_close_request_cookie() :: map().
-type post_disputes_dispute_close_request_body() :: map().
-type post_disputes_dispute_close_response() ::
    stripe_model:error() | stripe_model:dispute().
-type post_quotes_quote_cancel_request() ::
    #{quote := binary(),
      query => post_quotes_quote_cancel_request_query(),
      header => post_quotes_quote_cancel_request_header(),
      cookie => post_quotes_quote_cancel_request_cookie(),
      body => post_quotes_quote_cancel_request_body()}.
-type post_quotes_quote_cancel_request_query() :: map().
-type post_quotes_quote_cancel_request_header() :: map().
-type post_quotes_quote_cancel_request_cookie() :: map().
-type post_quotes_quote_cancel_request_body() :: map().
-type post_quotes_quote_cancel_response() :: stripe_model:error() | stripe_model:quote().
-type get_customers_customer_payment_methods_request() ::
    #{customer := binary(),
      query => get_customers_customer_payment_methods_request_query(),
      header => get_customers_customer_payment_methods_request_header(),
      cookie => get_customers_customer_payment_methods_request_cookie(),
      body => get_customers_customer_payment_methods_request_body()}.
-type get_customers_customer_payment_methods_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type :=
          acss_debit |
          afterpay_clearpay |
          alipay |
          au_becs_debit |
          bacs_debit |
          bancontact |
          boleto |
          card |
          eps |
          fpx |
          giropay |
          grabpay |
          ideal |
          klarna |
          oxxo |
          p24 |
          sepa_debit |
          sofort |
          wechat_pay}.
-type get_customers_customer_payment_methods_request_header() :: map().
-type get_customers_customer_payment_methods_request_cookie() :: map().
-type get_customers_customer_payment_methods_request_body() :: map().
-type get_customers_customer_payment_methods_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payment_method()]}.
-type post_refunds_request() ::
    #{query => post_refunds_request_query(),
      header => post_refunds_request_header(),
      cookie => post_refunds_request_cookie(),
      body => post_refunds_request_body()}.
-type post_refunds_request_query() :: map().
-type post_refunds_request_header() :: map().
-type post_refunds_request_cookie() :: map().
-type post_refunds_request_body() :: map().
-type post_refunds_response() :: stripe_model:error() | stripe_model:refund().
-type get_refunds_request() ::
    #{query => get_refunds_request_query(),
      header => get_refunds_request_header(),
      cookie => get_refunds_request_cookie(),
      body => get_refunds_request_body()}.
-type get_refunds_request_query() ::
    #{charge => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary()}.
-type get_refunds_request_header() :: map().
-type get_refunds_request_cookie() :: map().
-type get_refunds_request_body() :: map().
-type get_refunds_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:refund()]}.
-type post_credit_notes_id_request() ::
    #{id := binary(),
      query => post_credit_notes_id_request_query(),
      header => post_credit_notes_id_request_header(),
      cookie => post_credit_notes_id_request_cookie(),
      body => post_credit_notes_id_request_body()}.
-type post_credit_notes_id_request_query() :: map().
-type post_credit_notes_id_request_header() :: map().
-type post_credit_notes_id_request_cookie() :: map().
-type post_credit_notes_id_request_body() :: map().
-type post_credit_notes_id_response() ::
    stripe_model:error() | stripe_model:credit_note().
-type get_credit_notes_id_request() ::
    #{id := binary(),
      query => get_credit_notes_id_request_query(),
      header => get_credit_notes_id_request_header(),
      cookie => get_credit_notes_id_request_cookie(),
      body => get_credit_notes_id_request_body()}.
-type get_credit_notes_id_request_query() :: #{expand => [binary()]}.
-type get_credit_notes_id_request_header() :: map().
-type get_credit_notes_id_request_cookie() :: map().
-type get_credit_notes_id_request_body() :: map().
-type get_credit_notes_id_response() :: stripe_model:error() | stripe_model:credit_note().
-type get_bitcoin_transactions_request() ::
    #{query => get_bitcoin_transactions_request_query(),
      header => get_bitcoin_transactions_request_header(),
      cookie => get_bitcoin_transactions_request_cookie(),
      body => get_bitcoin_transactions_request_body()}.
-type get_bitcoin_transactions_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      receiver => binary(),
      starting_after => binary()}.
-type get_bitcoin_transactions_request_header() :: map().
-type get_bitcoin_transactions_request_cookie() :: map().
-type get_bitcoin_transactions_request_body() :: map().
-type get_bitcoin_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bitcoin_transaction()]}.
-type post_setup_intents_request() ::
    #{query => post_setup_intents_request_query(),
      header => post_setup_intents_request_header(),
      cookie => post_setup_intents_request_cookie(),
      body => post_setup_intents_request_body()}.
-type post_setup_intents_request_query() :: map().
-type post_setup_intents_request_header() :: map().
-type post_setup_intents_request_cookie() :: map().
-type post_setup_intents_request_body() :: map().
-type post_setup_intents_response() :: stripe_model:error() | stripe_model:setup_intent().
-type get_setup_intents_request() ::
    #{query => get_setup_intents_request_query(),
      header => get_setup_intents_request_header(),
      cookie => get_setup_intents_request_cookie(),
      body => get_setup_intents_request_body()}.
-type get_setup_intents_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_method => binary(),
      starting_after => binary()}.
-type get_setup_intents_request_header() :: map().
-type get_setup_intents_request_cookie() :: map().
-type get_setup_intents_request_body() :: map().
-type get_setup_intents_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:setup_intent()]}.
-type post_payouts_payout_cancel_request() ::
    #{payout := binary(),
      query => post_payouts_payout_cancel_request_query(),
      header => post_payouts_payout_cancel_request_header(),
      cookie => post_payouts_payout_cancel_request_cookie(),
      body => post_payouts_payout_cancel_request_body()}.
-type post_payouts_payout_cancel_request_query() :: map().
-type post_payouts_payout_cancel_request_header() :: map().
-type post_payouts_payout_cancel_request_cookie() :: map().
-type post_payouts_payout_cancel_request_body() :: map().
-type post_payouts_payout_cancel_response() ::
    stripe_model:error() | stripe_model:payout().
-type post_issuing_authorizations_authorization_approve_request() ::
    #{authorization := binary(),
      query => post_issuing_authorizations_authorization_approve_request_query(),
      header => post_issuing_authorizations_authorization_approve_request_header(),
      cookie => post_issuing_authorizations_authorization_approve_request_cookie(),
      body => post_issuing_authorizations_authorization_approve_request_body()}.
-type post_issuing_authorizations_authorization_approve_request_query() :: map().
-type post_issuing_authorizations_authorization_approve_request_header() :: map().
-type post_issuing_authorizations_authorization_approve_request_cookie() :: map().
-type post_issuing_authorizations_authorization_approve_request_body() :: map().
-type post_issuing_authorizations_authorization_approve_response() ::
    stripe_model:error() | stripe_model:issuing_authorization().
-type post_issuing_authorizations_authorization_decline_request() ::
    #{authorization := binary(),
      query => post_issuing_authorizations_authorization_decline_request_query(),
      header => post_issuing_authorizations_authorization_decline_request_header(),
      cookie => post_issuing_authorizations_authorization_decline_request_cookie(),
      body => post_issuing_authorizations_authorization_decline_request_body()}.
-type post_issuing_authorizations_authorization_decline_request_query() :: map().
-type post_issuing_authorizations_authorization_decline_request_header() :: map().
-type post_issuing_authorizations_authorization_decline_request_cookie() :: map().
-type post_issuing_authorizations_authorization_decline_request_body() :: map().
-type post_issuing_authorizations_authorization_decline_response() ::
    stripe_model:error() | stripe_model:issuing_authorization().
-type post_reporting_report_runs_request() ::
    #{query => post_reporting_report_runs_request_query(),
      header => post_reporting_report_runs_request_header(),
      cookie => post_reporting_report_runs_request_cookie(),
      body => post_reporting_report_runs_request_body()}.
-type post_reporting_report_runs_request_query() :: map().
-type post_reporting_report_runs_request_header() :: map().
-type post_reporting_report_runs_request_cookie() :: map().
-type post_reporting_report_runs_request_body() :: map().
-type post_reporting_report_runs_response() ::
    stripe_model:error() | stripe_model:reporting_report_run().
-type get_reporting_report_runs_request() ::
    #{query => get_reporting_report_runs_request_query(),
      header => get_reporting_report_runs_request_header(),
      cookie => get_reporting_report_runs_request_cookie(),
      body => get_reporting_report_runs_request_body()}.
-type get_reporting_report_runs_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_reporting_report_runs_request_header() :: map().
-type get_reporting_report_runs_request_cookie() :: map().
-type get_reporting_report_runs_request_body() :: map().
-type get_reporting_report_runs_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:reporting_report_run()]}.
-type post_invoices_invoice_void_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_void_request_query(),
      header => post_invoices_invoice_void_request_header(),
      cookie => post_invoices_invoice_void_request_cookie(),
      body => post_invoices_invoice_void_request_body()}.
-type post_invoices_invoice_void_request_query() :: map().
-type post_invoices_invoice_void_request_header() :: map().
-type post_invoices_invoice_void_request_cookie() :: map().
-type post_invoices_invoice_void_request_body() :: map().
-type post_invoices_invoice_void_response() ::
    stripe_model:error() | stripe_model:invoice().
-type post_sources_request() ::
    #{query => post_sources_request_query(),
      header => post_sources_request_header(),
      cookie => post_sources_request_cookie(),
      body => post_sources_request_body()}.
-type post_sources_request_query() :: map().
-type post_sources_request_header() :: map().
-type post_sources_request_cookie() :: map().
-type post_sources_request_body() :: map().
-type post_sources_response() :: stripe_model:error() | stripe_model:source().
-type post_billing_portal_configurations_request() ::
    #{query => post_billing_portal_configurations_request_query(),
      header => post_billing_portal_configurations_request_header(),
      cookie => post_billing_portal_configurations_request_cookie(),
      body => post_billing_portal_configurations_request_body()}.
-type post_billing_portal_configurations_request_query() :: map().
-type post_billing_portal_configurations_request_header() :: map().
-type post_billing_portal_configurations_request_cookie() :: map().
-type post_billing_portal_configurations_request_body() :: map().
-type post_billing_portal_configurations_response() ::
    stripe_model:error() | stripe_model:billing_portal_configuration().
-type get_billing_portal_configurations_request() ::
    #{query => get_billing_portal_configurations_request_query(),
      header => get_billing_portal_configurations_request_header(),
      cookie => get_billing_portal_configurations_request_cookie(),
      body => get_billing_portal_configurations_request_body()}.
-type get_billing_portal_configurations_request_query() ::
    #{active => boolean(),
      ending_before => binary(),
      expand => [binary()],
      is_default => boolean(),
      limit => integer(),
      starting_after => binary()}.
-type get_billing_portal_configurations_request_header() :: map().
-type get_billing_portal_configurations_request_cookie() :: map().
-type get_billing_portal_configurations_request_body() :: map().
-type get_billing_portal_configurations_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:billing_portal_configuration()]}.
-type post_quotes_request() ::
    #{query => post_quotes_request_query(),
      header => post_quotes_request_header(),
      cookie => post_quotes_request_cookie(),
      body => post_quotes_request_body()}.
-type post_quotes_request_query() :: map().
-type post_quotes_request_header() :: map().
-type post_quotes_request_cookie() :: map().
-type post_quotes_request_body() :: map().
-type post_quotes_response() :: stripe_model:error() | stripe_model:quote().
-type get_quotes_request() ::
    #{query => get_quotes_request_query(),
      header => get_quotes_request_header(),
      cookie => get_quotes_request_cookie(),
      body => get_quotes_request_body()}.
-type get_quotes_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => accepted | canceled | draft | open}.
-type get_quotes_request_header() :: map().
-type get_quotes_request_cookie() :: map().
-type get_quotes_request_body() :: map().
-type get_quotes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:quote()]}.
-type post_transfers_transfer_request() ::
    #{transfer := binary(),
      query => post_transfers_transfer_request_query(),
      header => post_transfers_transfer_request_header(),
      cookie => post_transfers_transfer_request_cookie(),
      body => post_transfers_transfer_request_body()}.
-type post_transfers_transfer_request_query() :: map().
-type post_transfers_transfer_request_header() :: map().
-type post_transfers_transfer_request_cookie() :: map().
-type post_transfers_transfer_request_body() :: map().
-type post_transfers_transfer_response() ::
    stripe_model:error() | stripe_model:transfer().
-type get_transfers_transfer_request() ::
    #{transfer := binary(),
      query => get_transfers_transfer_request_query(),
      header => get_transfers_transfer_request_header(),
      cookie => get_transfers_transfer_request_cookie(),
      body => get_transfers_transfer_request_body()}.
-type get_transfers_transfer_request_query() :: #{expand => [binary()]}.
-type get_transfers_transfer_request_header() :: map().
-type get_transfers_transfer_request_cookie() :: map().
-type get_transfers_transfer_request_body() :: map().
-type get_transfers_transfer_response() :: stripe_model:error() | stripe_model:transfer().
-type get_quotes_quote_line_items_request() ::
    #{quote := binary(),
      query => get_quotes_quote_line_items_request_query(),
      header => get_quotes_quote_line_items_request_header(),
      cookie => get_quotes_quote_line_items_request_cookie(),
      body => get_quotes_quote_line_items_request_body()}.
-type get_quotes_quote_line_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_quotes_quote_line_items_request_header() :: map().
-type get_quotes_quote_line_items_request_cookie() :: map().
-type get_quotes_quote_line_items_request_body() :: map().
-type get_quotes_quote_line_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:item()]}.
-type delete_invoiceitems_invoiceitem_request() ::
    #{invoiceitem := binary(),
      query => delete_invoiceitems_invoiceitem_request_query(),
      header => delete_invoiceitems_invoiceitem_request_header(),
      cookie => delete_invoiceitems_invoiceitem_request_cookie(),
      body => delete_invoiceitems_invoiceitem_request_body()}.
-type delete_invoiceitems_invoiceitem_request_query() :: map().
-type delete_invoiceitems_invoiceitem_request_header() :: map().
-type delete_invoiceitems_invoiceitem_request_cookie() :: map().
-type delete_invoiceitems_invoiceitem_request_body() :: map().
-type delete_invoiceitems_invoiceitem_response() ::
    stripe_model:error() | stripe_model:deleted_invoiceitem().
-type post_invoiceitems_invoiceitem_request() ::
    #{invoiceitem := binary(),
      query => post_invoiceitems_invoiceitem_request_query(),
      header => post_invoiceitems_invoiceitem_request_header(),
      cookie => post_invoiceitems_invoiceitem_request_cookie(),
      body => post_invoiceitems_invoiceitem_request_body()}.
-type post_invoiceitems_invoiceitem_request_query() :: map().
-type post_invoiceitems_invoiceitem_request_header() :: map().
-type post_invoiceitems_invoiceitem_request_cookie() :: map().
-type post_invoiceitems_invoiceitem_request_body() :: map().
-type post_invoiceitems_invoiceitem_response() ::
    stripe_model:error() | stripe_model:invoiceitem().
-type get_invoiceitems_invoiceitem_request() ::
    #{invoiceitem := binary(),
      query => get_invoiceitems_invoiceitem_request_query(),
      header => get_invoiceitems_invoiceitem_request_header(),
      cookie => get_invoiceitems_invoiceitem_request_cookie(),
      body => get_invoiceitems_invoiceitem_request_body()}.
-type get_invoiceitems_invoiceitem_request_query() :: #{expand => [binary()]}.
-type get_invoiceitems_invoiceitem_request_header() :: map().
-type get_invoiceitems_invoiceitem_request_cookie() :: map().
-type get_invoiceitems_invoiceitem_request_body() :: map().
-type get_invoiceitems_invoiceitem_response() ::
    stripe_model:error() | stripe_model:invoiceitem().
-type post_payment_intents_intent_capture_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_capture_request_query(),
      header => post_payment_intents_intent_capture_request_header(),
      cookie => post_payment_intents_intent_capture_request_cookie(),
      body => post_payment_intents_intent_capture_request_body()}.
-type post_payment_intents_intent_capture_request_query() :: map().
-type post_payment_intents_intent_capture_request_header() :: map().
-type post_payment_intents_intent_capture_request_cookie() :: map().
-type post_payment_intents_intent_capture_request_body() :: map().
-type post_payment_intents_intent_capture_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type post_issuing_cards_request() ::
    #{query => post_issuing_cards_request_query(),
      header => post_issuing_cards_request_header(),
      cookie => post_issuing_cards_request_cookie(),
      body => post_issuing_cards_request_body()}.
-type post_issuing_cards_request_query() :: map().
-type post_issuing_cards_request_header() :: map().
-type post_issuing_cards_request_cookie() :: map().
-type post_issuing_cards_request_body() :: map().
-type post_issuing_cards_response() :: stripe_model:error() | stripe_model:issuing_card().
-type get_issuing_cards_request() ::
    #{query => get_issuing_cards_request_query(),
      header => get_issuing_cards_request_header(),
      cookie => get_issuing_cards_request_cookie(),
      body => get_issuing_cards_request_body()}.
-type get_issuing_cards_request_query() ::
    #{cardholder => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      ending_before => binary(),
      exp_month => integer(),
      exp_year => integer(),
      expand => [binary()],
      last4 => binary(),
      limit => integer(),
      starting_after => binary(),
      status => active | canceled | inactive,
      type => physical | virtual}.
-type get_issuing_cards_request_header() :: map().
-type get_issuing_cards_request_cookie() :: map().
-type get_issuing_cards_request_body() :: map().
-type get_issuing_cards_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_card()]}.
-type get_sources_source_source_transactions_request() ::
    #{source := binary(),
      query => get_sources_source_source_transactions_request_query(),
      header => get_sources_source_source_transactions_request_header(),
      cookie => get_sources_source_source_transactions_request_cookie(),
      body => get_sources_source_source_transactions_request_body()}.
-type get_sources_source_source_transactions_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_sources_source_source_transactions_request_header() :: map().
-type get_sources_source_source_transactions_request_cookie() :: map().
-type get_sources_source_source_transactions_request_body() :: map().
-type get_sources_source_source_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:source_transaction()]}.
-type post_subscription_schedules_schedule_release_request() ::
    #{schedule := binary(),
      query => post_subscription_schedules_schedule_release_request_query(),
      header => post_subscription_schedules_schedule_release_request_header(),
      cookie => post_subscription_schedules_schedule_release_request_cookie(),
      body => post_subscription_schedules_schedule_release_request_body()}.
-type post_subscription_schedules_schedule_release_request_query() :: map().
-type post_subscription_schedules_schedule_release_request_header() :: map().
-type post_subscription_schedules_schedule_release_request_cookie() :: map().
-type post_subscription_schedules_schedule_release_request_body() :: map().
-type post_subscription_schedules_schedule_release_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type delete_customers_customer_cards_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => delete_customers_customer_cards_id_request_query(),
      header => delete_customers_customer_cards_id_request_header(),
      cookie => delete_customers_customer_cards_id_request_cookie(),
      body => delete_customers_customer_cards_id_request_body()}.
-type delete_customers_customer_cards_id_request_query() :: map().
-type delete_customers_customer_cards_id_request_header() :: map().
-type delete_customers_customer_cards_id_request_cookie() :: map().
-type delete_customers_customer_cards_id_request_body() :: map().
-type delete_customers_customer_cards_id_response() ::
    stripe_model:error() |
    stripe_model:payment_source() |
    stripe_model:deleted_payment_source().
-type post_customers_customer_cards_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_cards_id_request_query(),
      header => post_customers_customer_cards_id_request_header(),
      cookie => post_customers_customer_cards_id_request_cookie(),
      body => post_customers_customer_cards_id_request_body()}.
-type post_customers_customer_cards_id_request_query() :: map().
-type post_customers_customer_cards_id_request_header() :: map().
-type post_customers_customer_cards_id_request_cookie() :: map().
-type post_customers_customer_cards_id_request_body() :: map().
-type post_customers_customer_cards_id_response() ::
    stripe_model:error() |
    stripe_model:card() |
    stripe_model:bank_account() |
    stripe_model:source().
-type get_customers_customer_cards_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => get_customers_customer_cards_id_request_query(),
      header => get_customers_customer_cards_id_request_header(),
      cookie => get_customers_customer_cards_id_request_cookie(),
      body => get_customers_customer_cards_id_request_body()}.
-type get_customers_customer_cards_id_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_cards_id_request_header() :: map().
-type get_customers_customer_cards_id_request_cookie() :: map().
-type get_customers_customer_cards_id_request_body() :: map().
-type get_customers_customer_cards_id_response() ::
    stripe_model:error() | stripe_model:card().
-type post_charges_charge_dispute_request() ::
    #{charge := binary(),
      query => post_charges_charge_dispute_request_query(),
      header => post_charges_charge_dispute_request_header(),
      cookie => post_charges_charge_dispute_request_cookie(),
      body => post_charges_charge_dispute_request_body()}.
-type post_charges_charge_dispute_request_query() :: map().
-type post_charges_charge_dispute_request_header() :: map().
-type post_charges_charge_dispute_request_cookie() :: map().
-type post_charges_charge_dispute_request_body() :: map().
-type post_charges_charge_dispute_response() ::
    stripe_model:error() | stripe_model:dispute().
-type get_charges_charge_dispute_request() ::
    #{charge := binary(),
      query => get_charges_charge_dispute_request_query(),
      header => get_charges_charge_dispute_request_header(),
      cookie => get_charges_charge_dispute_request_cookie(),
      body => get_charges_charge_dispute_request_body()}.
-type get_charges_charge_dispute_request_query() :: #{expand => [binary()]}.
-type get_charges_charge_dispute_request_header() :: map().
-type get_charges_charge_dispute_request_cookie() :: map().
-type get_charges_charge_dispute_request_body() :: map().
-type get_charges_charge_dispute_response() ::
    stripe_model:error() | stripe_model:dispute().
-type post_quotes_quote_finalize_request() ::
    #{quote := binary(),
      query => post_quotes_quote_finalize_request_query(),
      header => post_quotes_quote_finalize_request_header(),
      cookie => post_quotes_quote_finalize_request_cookie(),
      body => post_quotes_quote_finalize_request_body()}.
-type post_quotes_quote_finalize_request_query() :: map().
-type post_quotes_quote_finalize_request_header() :: map().
-type post_quotes_quote_finalize_request_cookie() :: map().
-type post_quotes_quote_finalize_request_body() :: map().
-type post_quotes_quote_finalize_response() ::
    stripe_model:error() | stripe_model:quote().
-type delete_skus_id_request() ::
    #{id := binary(),
      query => delete_skus_id_request_query(),
      header => delete_skus_id_request_header(),
      cookie => delete_skus_id_request_cookie(),
      body => delete_skus_id_request_body()}.
-type delete_skus_id_request_query() :: map().
-type delete_skus_id_request_header() :: map().
-type delete_skus_id_request_cookie() :: map().
-type delete_skus_id_request_body() :: map().
-type delete_skus_id_response() :: stripe_model:error() | stripe_model:deleted_sku().
-type post_skus_id_request() ::
    #{id := binary(),
      query => post_skus_id_request_query(),
      header => post_skus_id_request_header(),
      cookie => post_skus_id_request_cookie(),
      body => post_skus_id_request_body()}.
-type post_skus_id_request_query() :: map().
-type post_skus_id_request_header() :: map().
-type post_skus_id_request_cookie() :: map().
-type post_skus_id_request_body() :: map().
-type post_skus_id_response() :: stripe_model:error() | stripe_model:sku().
-type get_skus_id_request() ::
    #{id := binary(),
      query => get_skus_id_request_query(),
      header => get_skus_id_request_header(),
      cookie => get_skus_id_request_cookie(),
      body => get_skus_id_request_body()}.
-type get_skus_id_request_query() :: #{expand => [binary()]}.
-type get_skus_id_request_header() :: map().
-type get_skus_id_request_cookie() :: map().
-type get_skus_id_request_body() :: map().
-type get_skus_id_response() ::
    stripe_model:error() | stripe_model:sku() | stripe_model:deleted_sku().
-type post_disputes_dispute_request() ::
    #{dispute := binary(),
      query => post_disputes_dispute_request_query(),
      header => post_disputes_dispute_request_header(),
      cookie => post_disputes_dispute_request_cookie(),
      body => post_disputes_dispute_request_body()}.
-type post_disputes_dispute_request_query() :: map().
-type post_disputes_dispute_request_header() :: map().
-type post_disputes_dispute_request_cookie() :: map().
-type post_disputes_dispute_request_body() :: map().
-type post_disputes_dispute_response() :: stripe_model:error() | stripe_model:dispute().
-type get_disputes_dispute_request() ::
    #{dispute := binary(),
      query => get_disputes_dispute_request_query(),
      header => get_disputes_dispute_request_header(),
      cookie => get_disputes_dispute_request_cookie(),
      body => get_disputes_dispute_request_body()}.
-type get_disputes_dispute_request_query() :: #{expand => [binary()]}.
-type get_disputes_dispute_request_header() :: map().
-type get_disputes_dispute_request_cookie() :: map().
-type get_disputes_dispute_request_body() :: map().
-type get_disputes_dispute_response() :: stripe_model:error() | stripe_model:dispute().
-type post_terminal_locations_request() ::
    #{query => post_terminal_locations_request_query(),
      header => post_terminal_locations_request_header(),
      cookie => post_terminal_locations_request_cookie(),
      body => post_terminal_locations_request_body()}.
-type post_terminal_locations_request_query() :: map().
-type post_terminal_locations_request_header() :: map().
-type post_terminal_locations_request_cookie() :: map().
-type post_terminal_locations_request_body() :: map().
-type post_terminal_locations_response() ::
    stripe_model:error() | stripe_model:terminal_location().
-type get_terminal_locations_request() ::
    #{query => get_terminal_locations_request_query(),
      header => get_terminal_locations_request_header(),
      cookie => get_terminal_locations_request_cookie(),
      body => get_terminal_locations_request_body()}.
-type get_terminal_locations_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_terminal_locations_request_header() :: map().
-type get_terminal_locations_request_cookie() :: map().
-type get_terminal_locations_request_body() :: map().
-type get_terminal_locations_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:terminal_location()]}.
-type post_subscription_schedules_request() ::
    #{query => post_subscription_schedules_request_query(),
      header => post_subscription_schedules_request_header(),
      cookie => post_subscription_schedules_request_cookie(),
      body => post_subscription_schedules_request_body()}.
-type post_subscription_schedules_request_query() :: map().
-type post_subscription_schedules_request_header() :: map().
-type post_subscription_schedules_request_cookie() :: map().
-type post_subscription_schedules_request_body() :: map().
-type post_subscription_schedules_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type get_subscription_schedules_request() ::
    #{query => get_subscription_schedules_request_query(),
      header => get_subscription_schedules_request_header(),
      cookie => get_subscription_schedules_request_cookie(),
      body => get_subscription_schedules_request_body()}.
-type get_subscription_schedules_request_query() ::
    #{canceled_at =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      completed_at =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      released_at =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer()} |
          integer(),
      scheduled => boolean(),
      starting_after => binary()}.
-type get_subscription_schedules_request_header() :: map().
-type get_subscription_schedules_request_cookie() :: map().
-type get_subscription_schedules_request_body() :: map().
-type get_subscription_schedules_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:subscription_schedule()]}.
-type post_payment_links_request() ::
    #{query => post_payment_links_request_query(),
      header => post_payment_links_request_header(),
      cookie => post_payment_links_request_cookie(),
      body => post_payment_links_request_body()}.
-type post_payment_links_request_query() :: map().
-type post_payment_links_request_header() :: map().
-type post_payment_links_request_cookie() :: map().
-type post_payment_links_request_body() :: map().
-type post_payment_links_response() :: stripe_model:error() | stripe_model:payment_link().
-type get_payment_links_request() ::
    #{query => get_payment_links_request_query(),
      header => get_payment_links_request_header(),
      cookie => get_payment_links_request_cookie(),
      body => get_payment_links_request_body()}.
-type get_payment_links_request_query() ::
    #{active => boolean(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_payment_links_request_header() :: map().
-type get_payment_links_request_cookie() :: map().
-type get_payment_links_request_body() :: map().
-type get_payment_links_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payment_link()]}.
-type post_tokens_request() ::
    #{query => post_tokens_request_query(),
      header => post_tokens_request_header(),
      cookie => post_tokens_request_cookie(),
      body => post_tokens_request_body()}.
-type post_tokens_request_query() :: map().
-type post_tokens_request_header() :: map().
-type post_tokens_request_cookie() :: map().
-type post_tokens_request_body() :: map().
-type post_tokens_response() :: stripe_model:error() | stripe_model:token().
-type post_issuing_cardholders_cardholder_request() ::
    #{cardholder := binary(),
      query => post_issuing_cardholders_cardholder_request_query(),
      header => post_issuing_cardholders_cardholder_request_header(),
      cookie => post_issuing_cardholders_cardholder_request_cookie(),
      body => post_issuing_cardholders_cardholder_request_body()}.
-type post_issuing_cardholders_cardholder_request_query() :: map().
-type post_issuing_cardholders_cardholder_request_header() :: map().
-type post_issuing_cardholders_cardholder_request_cookie() :: map().
-type post_issuing_cardholders_cardholder_request_body() :: map().
-type post_issuing_cardholders_cardholder_response() ::
    stripe_model:error() | stripe_model:issuing_cardholder().
-type get_issuing_cardholders_cardholder_request() ::
    #{cardholder := binary(),
      query => get_issuing_cardholders_cardholder_request_query(),
      header => get_issuing_cardholders_cardholder_request_header(),
      cookie => get_issuing_cardholders_cardholder_request_cookie(),
      body => get_issuing_cardholders_cardholder_request_body()}.
-type get_issuing_cardholders_cardholder_request_query() :: #{expand => [binary()]}.
-type get_issuing_cardholders_cardholder_request_header() :: map().
-type get_issuing_cardholders_cardholder_request_cookie() :: map().
-type get_issuing_cardholders_cardholder_request_body() :: map().
-type get_issuing_cardholders_cardholder_response() ::
    stripe_model:error() | stripe_model:issuing_cardholder().
-type get_application_fees_id_request() ::
    #{id := binary(),
      query => get_application_fees_id_request_query(),
      header => get_application_fees_id_request_header(),
      cookie => get_application_fees_id_request_cookie(),
      body => get_application_fees_id_request_body()}.
-type get_application_fees_id_request_query() :: #{expand => [binary()]}.
-type get_application_fees_id_request_header() :: map().
-type get_application_fees_id_request_cookie() :: map().
-type get_application_fees_id_request_body() :: map().
-type get_application_fees_id_response() ::
    stripe_model:error() | stripe_model:application_fee().
-type get_exchange_rates_rate_id_request() ::
    #{rate_id := binary(),
      query => get_exchange_rates_rate_id_request_query(),
      header => get_exchange_rates_rate_id_request_header(),
      cookie => get_exchange_rates_rate_id_request_cookie(),
      body => get_exchange_rates_rate_id_request_body()}.
-type get_exchange_rates_rate_id_request_query() :: #{expand => [binary()]}.
-type get_exchange_rates_rate_id_request_header() :: map().
-type get_exchange_rates_rate_id_request_cookie() :: map().
-type get_exchange_rates_rate_id_request_body() :: map().
-type get_exchange_rates_rate_id_response() ::
    stripe_model:error() | stripe_model:exchange_rate().
-type post_payment_intents_intent_confirm_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_confirm_request_query(),
      header => post_payment_intents_intent_confirm_request_header(),
      cookie => post_payment_intents_intent_confirm_request_cookie(),
      body => post_payment_intents_intent_confirm_request_body()}.
-type post_payment_intents_intent_confirm_request_query() :: map().
-type post_payment_intents_intent_confirm_request_header() :: map().
-type post_payment_intents_intent_confirm_request_cookie() :: map().
-type post_payment_intents_intent_confirm_request_body() :: map().
-type post_payment_intents_intent_confirm_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type get_credit_notes_preview_request() ::
    #{query => get_credit_notes_preview_request_query(),
      header => get_credit_notes_preview_request_header(),
      cookie => get_credit_notes_preview_request_cookie(),
      body => get_credit_notes_preview_request_body()}.
-type get_credit_notes_preview_request_query() ::
    #{amount => integer(),
      credit_amount => integer(),
      expand => [binary()],
      invoice := binary(),
      lines =>
          [#{unit_amount_decimal => binary(),
             unit_amount => integer(),
             type := custom_line_item | invoice_line_item,
             tax_rates => [binary()] | '',
             quantity => integer(),
             invoice_line_item => binary(),
             description => binary(),
             amount => integer()}],
      memo => binary(),
      metadata => json:value(),
      out_of_band_amount => integer(),
      reason => duplicate | fraudulent | order_change | product_unsatisfactory,
      refund => binary(),
      refund_amount => integer()}.
-type get_credit_notes_preview_request_header() :: map().
-type get_credit_notes_preview_request_cookie() :: map().
-type get_credit_notes_preview_request_body() :: map().
-type get_credit_notes_preview_response() ::
    stripe_model:error() | stripe_model:credit_note().
-type get_balance_history_id_request() ::
    #{id := binary(),
      query => get_balance_history_id_request_query(),
      header => get_balance_history_id_request_header(),
      cookie => get_balance_history_id_request_cookie(),
      body => get_balance_history_id_request_body()}.
-type get_balance_history_id_request_query() :: #{expand => [binary()]}.
-type get_balance_history_id_request_header() :: map().
-type get_balance_history_id_request_cookie() :: map().
-type get_balance_history_id_request_body() :: map().
-type get_balance_history_id_response() ::
    stripe_model:error() | stripe_model:balance_transaction().
-type post_payouts_payout_reverse_request() ::
    #{payout := binary(),
      query => post_payouts_payout_reverse_request_query(),
      header => post_payouts_payout_reverse_request_header(),
      cookie => post_payouts_payout_reverse_request_cookie(),
      body => post_payouts_payout_reverse_request_body()}.
-type post_payouts_payout_reverse_request_query() :: map().
-type post_payouts_payout_reverse_request_header() :: map().
-type post_payouts_payout_reverse_request_cookie() :: map().
-type post_payouts_payout_reverse_request_body() :: map().
-type post_payouts_payout_reverse_response() ::
    stripe_model:error() | stripe_model:payout().
-type get_reporting_report_runs_report_run_request() ::
    #{report_run := binary(),
      query => get_reporting_report_runs_report_run_request_query(),
      header => get_reporting_report_runs_report_run_request_header(),
      cookie => get_reporting_report_runs_report_run_request_cookie(),
      body => get_reporting_report_runs_report_run_request_body()}.
-type get_reporting_report_runs_report_run_request_query() :: #{expand => [binary()]}.
-type get_reporting_report_runs_report_run_request_header() :: map().
-type get_reporting_report_runs_report_run_request_cookie() :: map().
-type get_reporting_report_runs_report_run_request_body() :: map().
-type get_reporting_report_runs_report_run_response() ::
    stripe_model:error() | stripe_model:reporting_report_run().
-type get_sources_source_source_transactions_source_transaction_request() ::
    #{source := binary(),
      source_transaction := binary(),
      query => get_sources_source_source_transactions_source_transaction_request_query(),
      header => get_sources_source_source_transactions_source_transaction_request_header(),
      cookie => get_sources_source_source_transactions_source_transaction_request_cookie(),
      body => get_sources_source_source_transactions_source_transaction_request_body()}.
-type get_sources_source_source_transactions_source_transaction_request_query() ::
    #{expand => [binary()]}.
-type get_sources_source_source_transactions_source_transaction_request_header() :: map().
-type get_sources_source_source_transactions_source_transaction_request_cookie() :: map().
-type get_sources_source_source_transactions_source_transaction_request_body() :: map().
-type get_sources_source_source_transactions_source_transaction_response() ::
    stripe_model:error() | stripe_model:source_transaction().
-type delete_customers_customer_request() ::
    #{customer := binary(),
      query => delete_customers_customer_request_query(),
      header => delete_customers_customer_request_header(),
      cookie => delete_customers_customer_request_cookie(),
      body => delete_customers_customer_request_body()}.
-type delete_customers_customer_request_query() :: map().
-type delete_customers_customer_request_header() :: map().
-type delete_customers_customer_request_cookie() :: map().
-type delete_customers_customer_request_body() :: map().
-type delete_customers_customer_response() ::
    stripe_model:error() | stripe_model:deleted_customer().
-type post_customers_customer_request() ::
    #{customer := binary(),
      query => post_customers_customer_request_query(),
      header => post_customers_customer_request_header(),
      cookie => post_customers_customer_request_cookie(),
      body => post_customers_customer_request_body()}.
-type post_customers_customer_request_query() :: map().
-type post_customers_customer_request_header() :: map().
-type post_customers_customer_request_cookie() :: map().
-type post_customers_customer_request_body() :: map().
-type post_customers_customer_response() ::
    stripe_model:error() | stripe_model:customer().
-type get_customers_customer_request() ::
    #{customer := binary(),
      query => get_customers_customer_request_query(),
      header => get_customers_customer_request_header(),
      cookie => get_customers_customer_request_cookie(),
      body => get_customers_customer_request_body()}.
-type get_customers_customer_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_request_header() :: map().
-type get_customers_customer_request_cookie() :: map().
-type get_customers_customer_request_body() :: map().
-type get_customers_customer_response() ::
    stripe_model:error() | stripe_model:customer() | stripe_model:deleted_customer().
-type post_billing_portal_sessions_request() ::
    #{query => post_billing_portal_sessions_request_query(),
      header => post_billing_portal_sessions_request_header(),
      cookie => post_billing_portal_sessions_request_cookie(),
      body => post_billing_portal_sessions_request_body()}.
-type post_billing_portal_sessions_request_query() :: map().
-type post_billing_portal_sessions_request_header() :: map().
-type post_billing_portal_sessions_request_cookie() :: map().
-type post_billing_portal_sessions_request_body() :: map().
-type post_billing_portal_sessions_response() ::
    stripe_model:error() | stripe_model:billing_portal_session().
-type post_payment_links_payment_link_request() ::
    #{payment_link := binary(),
      query => post_payment_links_payment_link_request_query(),
      header => post_payment_links_payment_link_request_header(),
      cookie => post_payment_links_payment_link_request_cookie(),
      body => post_payment_links_payment_link_request_body()}.
-type post_payment_links_payment_link_request_query() :: map().
-type post_payment_links_payment_link_request_header() :: map().
-type post_payment_links_payment_link_request_cookie() :: map().
-type post_payment_links_payment_link_request_body() :: map().
-type post_payment_links_payment_link_response() ::
    stripe_model:error() | stripe_model:payment_link().
-type get_payment_links_payment_link_request() ::
    #{payment_link := binary(),
      query => get_payment_links_payment_link_request_query(),
      header => get_payment_links_payment_link_request_header(),
      cookie => get_payment_links_payment_link_request_cookie(),
      body => get_payment_links_payment_link_request_body()}.
-type get_payment_links_payment_link_request_query() :: #{expand => [binary()]}.
-type get_payment_links_payment_link_request_header() :: map().
-type get_payment_links_payment_link_request_cookie() :: map().
-type get_payment_links_payment_link_request_body() :: map().
-type get_payment_links_payment_link_response() ::
    stripe_model:error() | stripe_model:payment_link().
-type get_credit_notes_credit_note_lines_request() ::
    #{credit_note := binary(),
      query => get_credit_notes_credit_note_lines_request_query(),
      header => get_credit_notes_credit_note_lines_request_header(),
      cookie => get_credit_notes_credit_note_lines_request_cookie(),
      body => get_credit_notes_credit_note_lines_request_body()}.
-type get_credit_notes_credit_note_lines_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_credit_notes_credit_note_lines_request_header() :: map().
-type get_credit_notes_credit_note_lines_request_cookie() :: map().
-type get_credit_notes_credit_note_lines_request_body() :: map().
-type get_credit_notes_credit_note_lines_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:credit_note_line_item()]}.
-type get_sigma_scheduled_query_runs_request() ::
    #{query => get_sigma_scheduled_query_runs_request_query(),
      header => get_sigma_scheduled_query_runs_request_header(),
      cookie => get_sigma_scheduled_query_runs_request_cookie(),
      body => get_sigma_scheduled_query_runs_request_body()}.
-type get_sigma_scheduled_query_runs_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_sigma_scheduled_query_runs_request_header() :: map().
-type get_sigma_scheduled_query_runs_request_cookie() :: map().
-type get_sigma_scheduled_query_runs_request_body() :: map().
-type get_sigma_scheduled_query_runs_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:scheduled_query_run()]}.

-spec get_radar_early_fraud_warnings(get_radar_early_fraud_warnings_request()) ->
                                        result(get_radar_early_fraud_warnings_response()).
get_radar_early_fraud_warnings(Args) ->
    get_radar_early_fraud_warnings(Args, #{}).

-spec get_radar_early_fraud_warnings(get_radar_early_fraud_warnings_request(),
                                     options()) ->
                                        result(get_radar_early_fraud_warnings_response()).
get_radar_early_fraud_warnings(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           radar_early_fraud_warning}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refunds(post_charges_charge_refunds_request()) ->
                                     result(post_charges_charge_refunds_response()).
post_charges_charge_refunds(Args) ->
    post_charges_charge_refunds(Args, #{}).

-spec post_charges_charge_refunds(post_charges_charge_refunds_request(), options()) ->
                                     result(post_charges_charge_refunds_response()).
post_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refunds", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, refund},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_refunds(get_charges_charge_refunds_request()) ->
                                    result(get_charges_charge_refunds_response()).
get_charges_charge_refunds(Args) ->
    get_charges_charge_refunds(Args, #{}).

-spec get_charges_charge_refunds(get_charges_charge_refunds_request(), options()) ->
                                    result(get_charges_charge_refunds_response()).
get_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refunds", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           refund}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_identity_verification_sessions_session_redact(post_identity_verification_sessions_session_redact_request()) ->
                                                          result(post_identity_verification_sessions_session_redact_response()).
post_identity_verification_sessions_session_redact(Args) ->
    post_identity_verification_sessions_session_redact(Args, #{}).

-spec
    post_identity_verification_sessions_session_redact(post_identity_verification_sessions_session_redact_request(),
                                                       options()) ->
                                                          result(post_identity_verification_sessions_session_redact_response()).
post_identity_verification_sessions_session_redact(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s/redact", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       identity_verification_session},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_billing_portal_configurations_configuration(post_billing_portal_configurations_configuration_request()) ->
                                                        result(post_billing_portal_configurations_configuration_response()).
post_billing_portal_configurations_configuration(Args) ->
    post_billing_portal_configurations_configuration(Args, #{}).

-spec
    post_billing_portal_configurations_configuration(post_billing_portal_configurations_configuration_request(),
                                                     options()) ->
                                                        result(post_billing_portal_configurations_configuration_response()).
post_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/configurations/~s", [VarConfiguration]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       billing_portal_configuration},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_billing_portal_configurations_configuration(get_billing_portal_configurations_configuration_request()) ->
                                                       result(get_billing_portal_configurations_configuration_response()).
get_billing_portal_configurations_configuration(Args) ->
    get_billing_portal_configurations_configuration(Args, #{}).

-spec
    get_billing_portal_configurations_configuration(get_billing_portal_configurations_configuration_request(),
                                                    options()) ->
                                                       result(get_billing_portal_configurations_configuration_response()).
get_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/configurations/~s", [VarConfiguration]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       billing_portal_configuration},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods(post_payment_methods_request()) ->
                              result(post_payment_methods_response()).
post_payment_methods(Args) ->
    post_payment_methods(Args, #{}).

-spec post_payment_methods(post_payment_methods_request(), options()) ->
                              result(post_payment_methods_response()).
post_payment_methods(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_method},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_methods(get_payment_methods_request()) ->
                             result(get_payment_methods_response()).
get_payment_methods(Args) ->
    get_payment_methods(Args, #{}).

-spec get_payment_methods(get_payment_methods_request(), options()) ->
                             result(get_payment_methods_response()).
get_payment_methods(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           payment_method}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_radar_value_lists_value_list(delete_radar_value_lists_value_list_request()) ->
                                           result(delete_radar_value_lists_value_list_response()).
delete_radar_value_lists_value_list(Args) ->
    delete_radar_value_lists_value_list(Args, #{}).

-spec delete_radar_value_lists_value_list(delete_radar_value_lists_value_list_request(),
                                          options()) ->
                                             result(delete_radar_value_lists_value_list_response()).
delete_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_radar_value_list},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_lists_value_list(post_radar_value_lists_value_list_request()) ->
                                           result(post_radar_value_lists_value_list_response()).
post_radar_value_lists_value_list(Args) ->
    post_radar_value_lists_value_list(Args, #{}).

-spec post_radar_value_lists_value_list(post_radar_value_lists_value_list_request(),
                                        options()) ->
                                           result(post_radar_value_lists_value_list_response()).
post_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       radar_value_list},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_lists_value_list(get_radar_value_lists_value_list_request()) ->
                                          result(get_radar_value_lists_value_list_response()).
get_radar_value_lists_value_list(Args) ->
    get_radar_value_lists_value_list(Args, #{}).

-spec get_radar_value_lists_value_list(get_radar_value_lists_value_list_request(),
                                       options()) ->
                                          result(get_radar_value_lists_value_list_response()).
get_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       radar_value_list},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_capture(post_charges_charge_capture_request()) ->
                                     result(post_charges_charge_capture_response()).
post_charges_charge_capture(Args) ->
    post_charges_charge_capture(Args, #{}).

-spec post_charges_charge_capture(post_charges_charge_capture_request(), options()) ->
                                     result(post_charges_charge_capture_response()).
post_charges_charge_capture(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/capture", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, charge},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_disputes(get_disputes_request()) -> result(get_disputes_response()).
get_disputes(Args) ->
    get_disputes(Args, #{}).

-spec get_disputes(get_disputes_request(), options()) -> result(get_disputes_response()).
get_disputes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/disputes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           dispute}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_prices_price(post_prices_price_request()) ->
                           result(post_prices_price_response()).
post_prices_price(Args) ->
    post_prices_price(Args, #{}).

-spec post_prices_price(post_prices_price_request(), options()) ->
                           result(post_prices_price_response()).
post_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/prices/~s", [VarPrice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, price},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_prices_price(get_prices_price_request()) -> result(get_prices_price_response()).
get_prices_price(Args) ->
    get_prices_price(Args, #{}).

-spec get_prices_price(get_prices_price_request(), options()) ->
                          result(get_prices_price_response()).
get_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/prices/~s", [VarPrice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, price},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts(post_accounts_request()) -> result(post_accounts_response()).
post_accounts(Args) ->
    post_accounts(Args, #{}).

-spec post_accounts(post_accounts_request(), options()) ->
                       result(post_accounts_response()).
post_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts(get_accounts_request()) -> result(get_accounts_response()).
get_accounts(Args) ->
    get_accounts(Args, #{}).

-spec get_accounts(get_accounts_request(), options()) -> result(get_accounts_response()).
get_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           account}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_identity_verification_sessions_session_cancel(post_identity_verification_sessions_session_cancel_request()) ->
                                                          result(post_identity_verification_sessions_session_cancel_response()).
post_identity_verification_sessions_session_cancel(Args) ->
    post_identity_verification_sessions_session_cancel(Args, #{}).

-spec
    post_identity_verification_sessions_session_cancel(post_identity_verification_sessions_session_cancel_request(),
                                                       options()) ->
                                                          result(post_identity_verification_sessions_session_cancel_response()).
post_identity_verification_sessions_session_cancel(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s/cancel", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       identity_verification_session},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_persons_person(delete_account_persons_person_request()) ->
                                       result(delete_account_persons_person_response()).
delete_account_persons_person(Args) ->
    delete_account_persons_person(Args, #{}).

-spec delete_account_persons_person(delete_account_persons_person_request(), options()) ->
                                       result(delete_account_persons_person_response()).
delete_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, deleted_person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_persons_person(post_account_persons_person_request()) ->
                                     result(post_account_persons_person_response()).
post_account_persons_person(Args) ->
    post_account_persons_person(Args, #{}).

-spec post_account_persons_person(post_account_persons_person_request(), options()) ->
                                     result(post_account_persons_person_response()).
post_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_persons_person(get_account_persons_person_request()) ->
                                    result(get_account_persons_person_response()).
get_account_persons_person(Args) ->
    get_account_persons_person(Args, #{}).

-spec get_account_persons_person(get_account_persons_person_request(), options()) ->
                                    result(get_account_persons_person_response()).
get_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_authorizations_authorization(post_issuing_authorizations_authorization_request()) ->
                                                 result(post_issuing_authorizations_authorization_response()).
post_issuing_authorizations_authorization(Args) ->
    post_issuing_authorizations_authorization(Args, #{}).

-spec
    post_issuing_authorizations_authorization(post_issuing_authorizations_authorization_request(),
                                              options()) ->
                                                 result(post_issuing_authorizations_authorization_response()).
post_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s", [VarAuthorization]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_authorization},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_issuing_authorizations_authorization(get_issuing_authorizations_authorization_request()) ->
                                                result(get_issuing_authorizations_authorization_response()).
get_issuing_authorizations_authorization(Args) ->
    get_issuing_authorizations_authorization(Args, #{}).

-spec
    get_issuing_authorizations_authorization(get_issuing_authorizations_authorization_request(),
                                             options()) ->
                                                result(get_issuing_authorizations_authorization_response()).
get_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s", [VarAuthorization]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_authorization},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_files_file(get_files_file_request()) -> result(get_files_file_response()).
get_files_file(Args) ->
    get_files_file(Args, #{}).

-spec get_files_file(get_files_file_request(), options()) ->
                        result(get_files_file_response()).
get_files_file(Args, Options) ->
    VarFile = maps:get(file, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/files/~s", [VarFile]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, file},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cards_card(post_issuing_cards_card_request()) ->
                                 result(post_issuing_cards_card_response()).
post_issuing_cards_card(Args) ->
    post_issuing_cards_card(Args, #{}).

-spec post_issuing_cards_card(post_issuing_cards_card_request(), options()) ->
                                 result(post_issuing_cards_card_response()).
post_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cards/~s", [VarCard]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, issuing_card},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cards_card(get_issuing_cards_card_request()) ->
                                result(get_issuing_cards_card_response()).
get_issuing_cards_card(Args) ->
    get_issuing_cards_card(Args, #{}).

-spec get_issuing_cards_card(get_issuing_cards_card_request(), options()) ->
                                result(get_issuing_cards_card_response()).
get_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cards/~s", [VarCard]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, issuing_card},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources_source_verify(post_sources_source_verify_request()) ->
                                    result(post_sources_source_verify_response()).
post_sources_source_verify(Args) ->
    post_sources_source_verify(Args, #{}).

-spec post_sources_source_verify(post_sources_source_verify_request(), options()) ->
                                    result(post_sources_source_verify_response()).
post_sources_source_verify(Args, Options) ->
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources/~s/verify", [VarSource]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, source},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoiceitems(post_invoiceitems_request()) ->
                           result(post_invoiceitems_response()).
post_invoiceitems(Args) ->
    post_invoiceitems(Args, #{}).

-spec post_invoiceitems(post_invoiceitems_request(), options()) ->
                           result(post_invoiceitems_response()).
post_invoiceitems(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoiceitem},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoiceitems(get_invoiceitems_request()) -> result(get_invoiceitems_response()).
get_invoiceitems(Args) ->
    get_invoiceitems(Args, #{}).

-spec get_invoiceitems(get_invoiceitems_request(), options()) ->
                          result(get_invoiceitems_response()).
get_invoiceitems(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({pending, Value}) ->
                encode_q(form, false, <<"pending">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           invoiceitem}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_ephemeral_keys_key(delete_ephemeral_keys_key_request()) ->
                                   result(delete_ephemeral_keys_key_response()).
delete_ephemeral_keys_key(Args) ->
    delete_ephemeral_keys_key(Args, #{}).

-spec delete_ephemeral_keys_key(delete_ephemeral_keys_key_request(), options()) ->
                                   result(delete_ephemeral_keys_key_response()).
delete_ephemeral_keys_key(Args, Options) ->
    VarKey = maps:get(key, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/ephemeral_keys/~s", [VarKey]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, ephemeral_key},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_exchange_rates(get_exchange_rates_request()) ->
                            result(get_exchange_rates_response()).
get_exchange_rates(Args) ->
    get_exchange_rates(Args, #{}).

-spec get_exchange_rates(get_exchange_rates_request(), options()) ->
                            result(get_exchange_rates_response()).
get_exchange_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/exchange_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           exchange_rate}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent(post_setup_intents_intent_request()) ->
                                   result(post_setup_intents_intent_response()).
post_setup_intents_intent(Args) ->
    post_setup_intents_intent(Args, #{}).

-spec post_setup_intents_intent(post_setup_intents_intent_request(), options()) ->
                                   result(post_setup_intents_intent_response()).
post_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, setup_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_intents_intent(get_setup_intents_intent_request()) ->
                                  result(get_setup_intents_intent_response()).
get_setup_intents_intent(Args) ->
    get_setup_intents_intent(Args, #{}).

-spec get_setup_intents_intent(get_setup_intents_intent_request(), options()) ->
                                  result(get_setup_intents_intent_response()).
get_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({client_secret, Value}) ->
                encode_q(form, false, <<"client_secret">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, setup_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_files(post_files_request()) -> result(post_files_response()).
post_files(Args) ->
    post_files(Args, #{}).

-spec post_files(post_files_request(), options()) -> result(post_files_response()).
post_files(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/files", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, file},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_files(get_files_request()) -> result(get_files_response()).
get_files(Args) ->
    get_files(Args, #{}).

-spec get_files(get_files_request(), options()) -> result(get_files_response()).
get_files(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({purpose, Value}) ->
                encode_q(form, false, <<"purpose">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/files", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           file}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_bank_accounts_id(delete_customers_customer_bank_accounts_id_request()) ->
                                                  result(delete_customers_customer_bank_accounts_id_response()).
delete_customers_customer_bank_accounts_id(Args) ->
    delete_customers_customer_bank_accounts_id(Args, #{}).

-spec
    delete_customers_customer_bank_accounts_id(delete_customers_customer_bank_accounts_id_request(),
                                               options()) ->
                                                  result(delete_customers_customer_bank_accounts_id_response()).
delete_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref,
                                                                         stripe,
                                                                         payment_source},
                                                                        {ref,
                                                                         stripe,
                                                                         deleted_payment_source}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_bank_accounts_id(post_customers_customer_bank_accounts_id_request()) ->
                                                result(post_customers_customer_bank_accounts_id_response()).
post_customers_customer_bank_accounts_id(Args) ->
    post_customers_customer_bank_accounts_id(Args, #{}).

-spec
    post_customers_customer_bank_accounts_id(post_customers_customer_bank_accounts_id_request(),
                                             options()) ->
                                                result(post_customers_customer_bank_accounts_id_response()).
post_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref, stripe, card},
                                                                        {ref, stripe, bank_account},
                                                                        {ref, stripe, source}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_bank_accounts_id(get_customers_customer_bank_accounts_id_request()) ->
                                               result(get_customers_customer_bank_accounts_id_response()).
get_customers_customer_bank_accounts_id(Args) ->
    get_customers_customer_bank_accounts_id(Args, #{}).

-spec
    get_customers_customer_bank_accounts_id(get_customers_customer_bank_accounts_id_request(),
                                            options()) ->
                                               result(get_customers_customer_bank_accounts_id_response()).
get_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, bank_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_issuer_fraud_records_issuer_fraud_record(get_issuer_fraud_records_issuer_fraud_record_request()) ->
                                                    result(get_issuer_fraud_records_issuer_fraud_record_response()).
get_issuer_fraud_records_issuer_fraud_record(Args) ->
    get_issuer_fraud_records_issuer_fraud_record(Args, #{}).

-spec
    get_issuer_fraud_records_issuer_fraud_record(get_issuer_fraud_records_issuer_fraud_record_request(),
                                                 options()) ->
                                                    result(get_issuer_fraud_records_issuer_fraud_record_response()).
get_issuer_fraud_records_issuer_fraud_record(Args, Options) ->
    VarIssuerFraudRecord = maps:get(issuer_fraud_record, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuer_fraud_records/~s", [VarIssuerFraudRecord]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuer_fraud_record},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_accounts_account_people_person(delete_accounts_account_people_person_request()) ->
                                             result(delete_accounts_account_people_person_response()).
delete_accounts_account_people_person(Args) ->
    delete_accounts_account_people_person(Args, #{}).

-spec
    delete_accounts_account_people_person(delete_accounts_account_people_person_request(),
                                          options()) ->
                                             result(delete_accounts_account_people_person_response()).
delete_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, deleted_person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_people_person(post_accounts_account_people_person_request()) ->
                                           result(post_accounts_account_people_person_response()).
post_accounts_account_people_person(Args) ->
    post_accounts_account_people_person(Args, #{}).

-spec post_accounts_account_people_person(post_accounts_account_people_person_request(),
                                          options()) ->
                                             result(post_accounts_account_people_person_response()).
post_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_people_person(get_accounts_account_people_person_request()) ->
                                            result(get_accounts_account_people_person_response()).
get_accounts_account_people_person(Args) ->
    get_accounts_account_people_person(Args, #{}).

-spec get_accounts_account_people_person(get_accounts_account_people_person_request(),
                                         options()) ->
                                            result(get_accounts_account_people_person_response()).
get_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts(post_payouts_request()) -> result(post_payouts_response()).
post_payouts(Args) ->
    post_payouts(Args, #{}).

-spec post_payouts(post_payouts_request(), options()) -> result(post_payouts_response()).
post_payouts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payout},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payouts(get_payouts_request()) -> result(get_payouts_response()).
get_payouts(Args) ->
    get_payouts(Args, #{}).

-spec get_payouts(get_payouts_request(), options()) -> result(get_payouts_response()).
get_payouts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({arrival_date, Value}) ->
                encode_q(deepObject, true, <<"arrival_date">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({destination, Value}) ->
                encode_q(form, false, <<"destination">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           payout}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_account_capabilities_capability(post_account_capabilities_capability_request()) ->
                                            result(post_account_capabilities_capability_response()).
post_account_capabilities_capability(Args) ->
    post_account_capabilities_capability(Args, #{}).

-spec post_account_capabilities_capability(post_account_capabilities_capability_request(),
                                           options()) ->
                                              result(post_account_capabilities_capability_response()).
post_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/capabilities/~s", [VarCapability]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, capability},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_account_capabilities_capability(get_account_capabilities_capability_request()) ->
                                           result(get_account_capabilities_capability_response()).
get_account_capabilities_capability(Args) ->
    get_account_capabilities_capability(Args, #{}).

-spec get_account_capabilities_capability(get_account_capabilities_capability_request(),
                                          options()) ->
                                             result(get_account_capabilities_capability_response()).
get_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/capabilities/~s", [VarCapability]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, capability},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_sources_source_mandate_notifications_mandate_notification(get_sources_source_mandate_notifications_mandate_notification_request()) ->
                                                                     result(get_sources_source_mandate_notifications_mandate_notification_response()).
get_sources_source_mandate_notifications_mandate_notification(Args) ->
    get_sources_source_mandate_notifications_mandate_notification(Args, #{}).

-spec
    get_sources_source_mandate_notifications_mandate_notification(get_sources_source_mandate_notifications_mandate_notification_request(),
                                                                  options()) ->
                                                                     result(get_sources_source_mandate_notifications_mandate_notification_response()).
get_sources_source_mandate_notifications_mandate_notification(Args, Options) ->
    VarMandateNotification = maps:get(mandate_notification, Args),
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/sources/~s/mandate_notifications/~s",
                      [VarSource, VarMandateNotification]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       source_mandate_notification},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_application_fees_fee_refunds_id(post_application_fees_fee_refunds_id_request()) ->
                                            result(post_application_fees_fee_refunds_id_response()).
post_application_fees_fee_refunds_id(Args) ->
    post_application_fees_fee_refunds_id(Args, #{}).

-spec post_application_fees_fee_refunds_id(post_application_fees_fee_refunds_id_request(),
                                           options()) ->
                                              result(post_application_fees_fee_refunds_id_response()).
post_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds/~s", [VarFee, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, fee_refund},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_application_fees_fee_refunds_id(get_application_fees_fee_refunds_id_request()) ->
                                           result(get_application_fees_fee_refunds_id_response()).
get_application_fees_fee_refunds_id(Args) ->
    get_application_fees_fee_refunds_id(Args, #{}).

-spec get_application_fees_fee_refunds_id(get_application_fees_fee_refunds_id_request(),
                                          options()) ->
                                             result(get_application_fees_fee_refunds_id_response()).
get_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds/~s", [VarFee, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, fee_refund},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_discount(delete_customers_customer_discount_request()) ->
                                            result(delete_customers_customer_discount_response()).
delete_customers_customer_discount(Args) ->
    delete_customers_customer_discount(Args, #{}).

-spec delete_customers_customer_discount(delete_customers_customer_discount_request(),
                                         options()) ->
                                            result(delete_customers_customer_discount_response()).
delete_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/discount", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_discount},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_discount(get_customers_customer_discount_request()) ->
                                         result(get_customers_customer_discount_response()).
get_customers_customer_discount(Args) ->
    get_customers_customer_discount(Args, #{}).

-spec get_customers_customer_discount(get_customers_customer_discount_request(),
                                      options()) ->
                                         result(get_customers_customer_discount_response()).
get_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/discount", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, discount},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_coupons(post_coupons_request()) -> result(post_coupons_response()).
post_coupons(Args) ->
    post_coupons(Args, #{}).

-spec post_coupons(post_coupons_request(), options()) -> result(post_coupons_response()).
post_coupons(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, coupon},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_coupons(get_coupons_request()) -> result(get_coupons_response()).
get_coupons(Args) ->
    get_coupons(Args, #{}).

-spec get_coupons(get_coupons_request(), options()) -> result(get_coupons_response()).
get_coupons(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           coupon}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_dispute_close(post_charges_charge_dispute_close_request()) ->
                                           result(post_charges_charge_dispute_close_response()).
post_charges_charge_dispute_close(Args) ->
    post_charges_charge_dispute_close(Args, #{}).

-spec post_charges_charge_dispute_close(post_charges_charge_dispute_close_request(),
                                        options()) ->
                                           result(post_charges_charge_dispute_close_response()).
post_charges_charge_dispute_close(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/dispute/close", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_plans_plan(delete_plans_plan_request()) ->
                           result(delete_plans_plan_response()).
delete_plans_plan(Args) ->
    delete_plans_plan(Args, #{}).

-spec delete_plans_plan(delete_plans_plan_request(), options()) ->
                           result(delete_plans_plan_response()).
delete_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, deleted_plan},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_plans_plan(post_plans_plan_request()) -> result(post_plans_plan_response()).
post_plans_plan(Args) ->
    post_plans_plan(Args, #{}).

-spec post_plans_plan(post_plans_plan_request(), options()) ->
                         result(post_plans_plan_response()).
post_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, plan},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_plans_plan(get_plans_plan_request()) -> result(get_plans_plan_response()).
get_plans_plan(Args) ->
    get_plans_plan(Args, #{}).

-spec get_plans_plan(get_plans_plan_request(), options()) ->
                        result(get_plans_plan_response()).
get_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, plan},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_bank_accounts(post_customers_customer_bank_accounts_request()) ->
                                             result(post_customers_customer_bank_accounts_response()).
post_customers_customer_bank_accounts(Args) ->
    post_customers_customer_bank_accounts(Args, #{}).

-spec
    post_customers_customer_bank_accounts(post_customers_customer_bank_accounts_request(),
                                          options()) ->
                                             result(post_customers_customer_bank_accounts_response()).
post_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_source},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_bank_accounts(get_customers_customer_bank_accounts_request()) ->
                                            result(get_customers_customer_bank_accounts_response()).
get_customers_customer_bank_accounts(Args) ->
    get_customers_customer_bank_accounts(Args, #{}).

-spec get_customers_customer_bank_accounts(get_customers_customer_bank_accounts_request(),
                                           options()) ->
                                              result(get_customers_customer_bank_accounts_response()).
get_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           bank_account}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_terminal_readers_reader(delete_terminal_readers_reader_request()) ->
                                        result(delete_terminal_readers_reader_response()).
delete_terminal_readers_reader(Args) ->
    delete_terminal_readers_reader(Args, #{}).

-spec delete_terminal_readers_reader(delete_terminal_readers_reader_request(),
                                     options()) ->
                                        result(delete_terminal_readers_reader_response()).
delete_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_terminal_reader},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_readers_reader(post_terminal_readers_reader_request()) ->
                                      result(post_terminal_readers_reader_response()).
post_terminal_readers_reader(Args) ->
    post_terminal_readers_reader(Args, #{}).

-spec post_terminal_readers_reader(post_terminal_readers_reader_request(), options()) ->
                                      result(post_terminal_readers_reader_response()).
post_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref,
                                                                         stripe,
                                                                         terminal_reader},
                                                                        {ref,
                                                                         stripe,
                                                                         deleted_terminal_reader}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_readers_reader(get_terminal_readers_reader_request()) ->
                                     result(get_terminal_readers_reader_response()).
get_terminal_readers_reader(Args) ->
    get_terminal_readers_reader(Args, #{}).

-spec get_terminal_readers_reader(get_terminal_readers_reader_request(), options()) ->
                                     result(get_terminal_readers_reader_response()).
get_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref,
                                                                         stripe,
                                                                         terminal_reader},
                                                                        {ref,
                                                                         stripe,
                                                                         deleted_terminal_reader}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_accounts_account_persons_person(delete_accounts_account_persons_person_request()) ->
                                              result(delete_accounts_account_persons_person_response()).
delete_accounts_account_persons_person(Args) ->
    delete_accounts_account_persons_person(Args, #{}).

-spec
    delete_accounts_account_persons_person(delete_accounts_account_persons_person_request(),
                                           options()) ->
                                              result(delete_accounts_account_persons_person_response()).
delete_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, deleted_person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_persons_person(post_accounts_account_persons_person_request()) ->
                                            result(post_accounts_account_persons_person_response()).
post_accounts_account_persons_person(Args) ->
    post_accounts_account_persons_person(Args, #{}).

-spec post_accounts_account_persons_person(post_accounts_account_persons_person_request(),
                                           options()) ->
                                              result(post_accounts_account_persons_person_response()).
post_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_persons_person(get_accounts_account_persons_person_request()) ->
                                           result(get_accounts_account_persons_person_response()).
get_accounts_account_persons_person(Args) ->
    get_accounts_account_persons_person(Args, #{}).

-spec get_accounts_account_persons_person(get_accounts_account_persons_person_request(),
                                          options()) ->
                                             result(get_accounts_account_persons_person_response()).
get_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes_id_void(post_credit_notes_id_void_request()) ->
                                   result(post_credit_notes_id_void_response()).
post_credit_notes_id_void(Args) ->
    post_credit_notes_id_void(Args, #{}).

-spec post_credit_notes_id_void(post_credit_notes_id_void_request(), options()) ->
                                   result(post_credit_notes_id_void_response()).
post_credit_notes_id_void(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/~s/void", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, credit_note},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources(post_customers_customer_sources_request()) ->
                                         result(post_customers_customer_sources_response()).
post_customers_customer_sources(Args) ->
    post_customers_customer_sources(Args, #{}).

-spec post_customers_customer_sources(post_customers_customer_sources_request(),
                                      options()) ->
                                         result(post_customers_customer_sources_response()).
post_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_source},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_sources(get_customers_customer_sources_request()) ->
                                        result(get_customers_customer_sources_response()).
get_customers_customer_sources(Args) ->
    get_customers_customer_sources(Args, #{}).

-spec get_customers_customer_sources(get_customers_customer_sources_request(),
                                     options()) ->
                                        result(get_customers_customer_sources_response()).
get_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({object, Value}) ->
                encode_q(form, false, <<"object">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {one_of,
                                                                                           [{ref,
                                                                                             stripe,
                                                                                             alipay_account},
                                                                                            {ref,
                                                                                             stripe,
                                                                                             bank_account},
                                                                                            {ref,
                                                                                             stripe,
                                                                                             bitcoin_receiver},
                                                                                            {ref,
                                                                                             stripe,
                                                                                             card},
                                                                                            {ref,
                                                                                             stripe,
                                                                                             source}]}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_links(post_account_links_request()) ->
                            result(post_account_links_response()).
post_account_links(Args) ->
    post_account_links(Args, #{}).

-spec post_account_links(post_account_links_request(), options()) ->
                            result(post_account_links_response()).
post_account_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, account_link},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout(post_payouts_payout_request()) ->
                             result(post_payouts_payout_response()).
post_payouts_payout(Args) ->
    post_payouts_payout(Args, #{}).

-spec post_payouts_payout(post_payouts_payout_request(), options()) ->
                             result(post_payouts_payout_response()).
post_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts/~s", [VarPayout]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payout},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payouts_payout(get_payouts_payout_request()) ->
                            result(get_payouts_payout_response()).
get_payouts_payout(Args) ->
    get_payouts_payout(Args, #{}).

-spec get_payouts_payout(get_payouts_payout_request(), options()) ->
                            result(get_payouts_payout_response()).
get_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts/~s", [VarPayout]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payout},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_subscription_items_item(delete_subscription_items_item_request()) ->
                                        result(delete_subscription_items_item_response()).
delete_subscription_items_item(Args) ->
    delete_subscription_items_item(Args, #{}).

-spec delete_subscription_items_item(delete_subscription_items_item_request(),
                                     options()) ->
                                        result(delete_subscription_items_item_response()).
delete_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_subscription_item},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items_item(post_subscription_items_item_request()) ->
                                      result(post_subscription_items_item_response()).
post_subscription_items_item(Args) ->
    post_subscription_items_item(Args, #{}).

-spec post_subscription_items_item(post_subscription_items_item_request(), options()) ->
                                      result(post_subscription_items_item_response()).
post_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       subscription_item},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items_item(get_subscription_items_item_request()) ->
                                     result(get_subscription_items_item_response()).
get_subscription_items_item(Args) ->
    get_subscription_items_item(Args, #{}).

-spec get_subscription_items_item(get_subscription_items_item_request(), options()) ->
                                     result(get_subscription_items_item_response()).
get_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       subscription_item},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_products(post_products_request()) -> result(post_products_response()).
post_products(Args) ->
    post_products(Args, #{}).

-spec post_products(post_products_request(), options()) ->
                       result(post_products_response()).
post_products(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, product},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_products(get_products_request()) -> result(get_products_response()).
get_products(Args) ->
    get_products(Args, #{}).

-spec get_products(get_products_request(), options()) -> result(get_products_response()).
get_products(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({ids, Value}) ->
                encode_q(deepObject, true, <<"ids">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({shippable, Value}) ->
                encode_q(form, false, <<"shippable">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({url, Value}) ->
                encode_q(form, false, <<"url">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           product}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_reporting_report_types_report_type(get_reporting_report_types_report_type_request()) ->
                                              result(get_reporting_report_types_report_type_response()).
get_reporting_report_types_report_type(Args) ->
    get_reporting_report_types_report_type(Args, #{}).

-spec
    get_reporting_report_types_report_type(get_reporting_report_types_report_type_request(),
                                           options()) ->
                                              result(get_reporting_report_types_report_type_response()).
get_reporting_report_types_report_type(Args, Options) ->
    VarReportType = maps:get(report_type, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_types/~s", [VarReportType]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       reporting_report_type},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_accept(post_quotes_quote_accept_request()) ->
                                  result(post_quotes_quote_accept_response()).
post_quotes_quote_accept(Args) ->
    post_quotes_quote_accept(Args, #{}).

-spec post_quotes_quote_accept(post_quotes_quote_accept_request(), options()) ->
                                  result(post_quotes_quote_accept_response()).
post_quotes_quote_accept(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/accept", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, quote},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_mandates_mandate(get_mandates_mandate_request()) ->
                              result(get_mandates_mandate_response()).
get_mandates_mandate(Args) ->
    get_mandates_mandate(Args, #{}).

-spec get_mandates_mandate(get_mandates_mandate_request(), options()) ->
                              result(get_mandates_mandate_response()).
get_mandates_mandate(Args, Options) ->
    VarMandate = maps:get(mandate, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/mandates/~s", [VarMandate]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, mandate},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_subscriptions(post_customers_customer_subscriptions_request()) ->
                                             result(post_customers_customer_subscriptions_response()).
post_customers_customer_subscriptions(Args) ->
    post_customers_customer_subscriptions(Args, #{}).

-spec
    post_customers_customer_subscriptions(post_customers_customer_subscriptions_request(),
                                          options()) ->
                                             result(post_customers_customer_subscriptions_response()).
post_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/subscriptions", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, subscription},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_subscriptions(get_customers_customer_subscriptions_request()) ->
                                            result(get_customers_customer_subscriptions_response()).
get_customers_customer_subscriptions(Args) ->
    get_customers_customer_subscriptions(Args, #{}).

-spec get_customers_customer_subscriptions(get_customers_customer_subscriptions_request(),
                                           options()) ->
                                              result(get_customers_customer_subscriptions_response()).
get_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/subscriptions", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           subscription}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_order_returns_id(get_order_returns_id_request()) ->
                              result(get_order_returns_id_response()).
get_order_returns_id(Args) ->
    get_order_returns_id(Args, #{}).

-spec get_order_returns_id(get_order_returns_id_request(), options()) ->
                              result(get_order_returns_id_response()).
get_order_returns_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/order_returns/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, order_return},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_id_reversals(post_transfers_id_reversals_request()) ->
                                     result(post_transfers_id_reversals_response()).
post_transfers_id_reversals(Args) ->
    post_transfers_id_reversals(Args, #{}).

-spec post_transfers_id_reversals(post_transfers_id_reversals_request(), options()) ->
                                     result(post_transfers_id_reversals_response()).
post_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s/reversals", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       transfer_reversal},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_id_reversals(get_transfers_id_reversals_request()) ->
                                    result(get_transfers_id_reversals_response()).
get_transfers_id_reversals(Args) ->
    get_transfers_id_reversals(Args, #{}).

-spec get_transfers_id_reversals(get_transfers_id_reversals_request(), options()) ->
                                    result(get_transfers_id_reversals_response()).
get_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s/reversals", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           transfer_reversal}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reviews_review(get_reviews_review_request()) ->
                            result(get_reviews_review_response()).
get_reviews_review(Args) ->
    get_reviews_review(Args, #{}).

-spec get_reviews_review(get_reviews_review_request(), options()) ->
                            result(get_reviews_review_response()).
get_reviews_review(Args, Options) ->
    VarReview = maps:get(review, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reviews/~s", [VarReview]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, review},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_accounts_account_bank_accounts_id(delete_accounts_account_bank_accounts_id_request()) ->
                                                result(delete_accounts_account_bank_accounts_id_response()).
delete_accounts_account_bank_accounts_id(Args) ->
    delete_accounts_account_bank_accounts_id(Args, #{}).

-spec
    delete_accounts_account_bank_accounts_id(delete_accounts_account_bank_accounts_id_request(),
                                             options()) ->
                                                result(delete_accounts_account_bank_accounts_id_response()).
delete_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_bank_accounts_id(post_accounts_account_bank_accounts_id_request()) ->
                                              result(post_accounts_account_bank_accounts_id_response()).
post_accounts_account_bank_accounts_id(Args) ->
    post_accounts_account_bank_accounts_id(Args, #{}).

-spec
    post_accounts_account_bank_accounts_id(post_accounts_account_bank_accounts_id_request(),
                                           options()) ->
                                              result(post_accounts_account_bank_accounts_id_response()).
post_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_bank_accounts_id(get_accounts_account_bank_accounts_id_request()) ->
                                             result(get_accounts_account_bank_accounts_id_response()).
get_accounts_account_bank_accounts_id(Args) ->
    get_accounts_account_bank_accounts_id(Args, #{}).

-spec
    get_accounts_account_bank_accounts_id(get_accounts_account_bank_accounts_id_request(),
                                          options()) ->
                                             result(get_accounts_account_bank_accounts_id_response()).
get_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_settlements_settlement(post_issuing_settlements_settlement_request()) ->
                                           result(post_issuing_settlements_settlement_response()).
post_issuing_settlements_settlement(Args) ->
    post_issuing_settlements_settlement(Args, #{}).

-spec post_issuing_settlements_settlement(post_issuing_settlements_settlement_request(),
                                          options()) ->
                                             result(post_issuing_settlements_settlement_response()).
post_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/settlements/~s", [VarSettlement]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_settlement},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_settlements_settlement(get_issuing_settlements_settlement_request()) ->
                                            result(get_issuing_settlements_settlement_response()).
get_issuing_settlements_settlement(Args) ->
    get_issuing_settlements_settlement(Args, #{}).

-spec get_issuing_settlements_settlement(get_issuing_settlements_settlement_request(),
                                         options()) ->
                                            result(get_issuing_settlements_settlement_response()).
get_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/settlements/~s", [VarSettlement]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_settlement},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_promotion_codes_promotion_code(post_promotion_codes_promotion_code_request()) ->
                                           result(post_promotion_codes_promotion_code_response()).
post_promotion_codes_promotion_code(Args) ->
    post_promotion_codes_promotion_code(Args, #{}).

-spec post_promotion_codes_promotion_code(post_promotion_codes_promotion_code_request(),
                                          options()) ->
                                             result(post_promotion_codes_promotion_code_response()).
post_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/promotion_codes/~s", [VarPromotionCode]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, promotion_code},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_promotion_codes_promotion_code(get_promotion_codes_promotion_code_request()) ->
                                            result(get_promotion_codes_promotion_code_response()).
get_promotion_codes_promotion_code(Args) ->
    get_promotion_codes_promotion_code(Args, #{}).

-spec get_promotion_codes_promotion_code(get_promotion_codes_promotion_code_request(),
                                         options()) ->
                                            result(get_promotion_codes_promotion_code_response()).
get_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/promotion_codes/~s", [VarPromotionCode]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, promotion_code},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscription_schedules_schedule_cancel(post_subscription_schedules_schedule_cancel_request()) ->
                                                   result(post_subscription_schedules_schedule_cancel_response()).
post_subscription_schedules_schedule_cancel(Args) ->
    post_subscription_schedules_schedule_cancel(Args, #{}).

-spec
    post_subscription_schedules_schedule_cancel(post_subscription_schedules_schedule_cancel_request(),
                                                options()) ->
                                                   result(post_subscription_schedules_schedule_cancel_response()).
post_subscription_schedules_schedule_cancel(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules/~s/cancel", [VarSchedule]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       subscription_schedule},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_identity_verification_sessions(post_identity_verification_sessions_request()) ->
                                           result(post_identity_verification_sessions_response()).
post_identity_verification_sessions(Args) ->
    post_identity_verification_sessions(Args, #{}).

-spec post_identity_verification_sessions(post_identity_verification_sessions_request(),
                                          options()) ->
                                             result(post_identity_verification_sessions_response()).
post_identity_verification_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       identity_verification_session},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_sessions(get_identity_verification_sessions_request()) ->
                                            result(get_identity_verification_sessions_response()).
get_identity_verification_sessions(Args) ->
    get_identity_verification_sessions(Args, #{}).

-spec get_identity_verification_sessions(get_identity_verification_sessions_request(),
                                         options()) ->
                                            result(get_identity_verification_sessions_response()).
get_identity_verification_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           identity_verification_session}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_list_items(post_radar_value_list_items_request()) ->
                                     result(post_radar_value_list_items_response()).
post_radar_value_list_items(Args) ->
    post_radar_value_list_items(Args, #{}).

-spec post_radar_value_list_items(post_radar_value_list_items_request(), options()) ->
                                     result(post_radar_value_list_items_response()).
post_radar_value_list_items(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       radar_value_list_item},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_list_items(get_radar_value_list_items_request()) ->
                                    result(get_radar_value_list_items_response()).
get_radar_value_list_items(Args) ->
    get_radar_value_list_items(Args, #{}).

-spec get_radar_value_list_items(get_radar_value_list_items_request(), options()) ->
                                    result(get_radar_value_list_items_response()).
get_radar_value_list_items(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({value, Value}) ->
                encode_q(form, false, <<"value">>, Value);
            ({value_list, Value}) ->
                encode_q(form, false, <<"value_list">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           radar_value_list_item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_events_id(get_events_id_request()) -> result(get_events_id_response()).
get_events_id(Args) ->
    get_events_id(Args, #{}).

-spec get_events_id(get_events_id_request(), options()) ->
                       result(get_events_id_response()).
get_events_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/events/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, event},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_country_specs(get_country_specs_request()) ->
                           result(get_country_specs_response()).
get_country_specs(Args) ->
    get_country_specs(Args, #{}).

-spec get_country_specs(get_country_specs_request(), options()) ->
                           result(get_country_specs_response()).
get_country_specs(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/country_specs", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           country_spec}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_intents_intent_verify_microdeposits(post_payment_intents_intent_verify_microdeposits_request()) ->
                                                        result(post_payment_intents_intent_verify_microdeposits_response()).
post_payment_intents_intent_verify_microdeposits(Args) ->
    post_payment_intents_intent_verify_microdeposits(Args, #{}).

-spec
    post_payment_intents_intent_verify_microdeposits(post_payment_intents_intent_verify_microdeposits_request(),
                                                     options()) ->
                                                        result(post_payment_intents_intent_verify_microdeposits_response()).
post_payment_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s/verify_microdeposits", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscription_items_subscription_item_usage_records(post_subscription_items_subscription_item_usage_records_request()) ->
                                                               result(post_subscription_items_subscription_item_usage_records_response()).
post_subscription_items_subscription_item_usage_records(Args) ->
    post_subscription_items_subscription_item_usage_records(Args, #{}).

-spec
    post_subscription_items_subscription_item_usage_records(post_subscription_items_subscription_item_usage_records_request(),
                                                            options()) ->
                                                               result(post_subscription_items_subscription_item_usage_records_response()).
post_subscription_items_subscription_item_usage_records(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items/~s/usage_records", [VarSubscriptionItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, usage_record},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_history(get_balance_history_request()) ->
                             result(get_balance_history_response()).
get_balance_history(Args) ->
    get_balance_history(Args, #{}).

-spec get_balance_history(get_balance_history_request(), options()) ->
                             result(get_balance_history_response()).
get_balance_history(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payout, Value}) ->
                encode_q(form, false, <<"payout">>, Value);
            ({source, Value}) ->
                encode_q(form, false, <<"source">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance/history", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           balance_transaction}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_order_returns(get_order_returns_request()) ->
                           result(get_order_returns_response()).
get_order_returns(Args) ->
    get_order_returns(Args, #{}).

-spec get_order_returns(get_order_returns_request(), options()) ->
                           result(get_order_returns_response()).
get_order_returns(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({order, Value}) ->
                encode_q(form, false, <<"order">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/order_returns", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           order_return}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_account_external_accounts_id(delete_account_external_accounts_id_request()) ->
                                           result(delete_account_external_accounts_id_response()).
delete_account_external_accounts_id(Args) ->
    delete_account_external_accounts_id(Args, #{}).

-spec delete_account_external_accounts_id(delete_account_external_accounts_id_request(),
                                          options()) ->
                                             result(delete_account_external_accounts_id_response()).
delete_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_external_accounts_id(post_account_external_accounts_id_request()) ->
                                           result(post_account_external_accounts_id_response()).
post_account_external_accounts_id(Args) ->
    post_account_external_accounts_id(Args, #{}).

-spec post_account_external_accounts_id(post_account_external_accounts_id_request(),
                                        options()) ->
                                           result(post_account_external_accounts_id_response()).
post_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_external_accounts_id(get_account_external_accounts_id_request()) ->
                                          result(get_account_external_accounts_id_response()).
get_account_external_accounts_id(Args) ->
    get_account_external_accounts_id(Args, #{}).

-spec get_account_external_accounts_id(get_account_external_accounts_id_request(),
                                       options()) ->
                                          result(get_account_external_accounts_id_response()).
get_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_apple_pay_domains(post_apple_pay_domains_request()) ->
                                result(post_apple_pay_domains_response()).
post_apple_pay_domains(Args) ->
    post_apple_pay_domains(Args, #{}).

-spec post_apple_pay_domains(post_apple_pay_domains_request(), options()) ->
                                result(post_apple_pay_domains_response()).
post_apple_pay_domains(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       apple_pay_domain},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_apple_pay_domains(get_apple_pay_domains_request()) ->
                               result(get_apple_pay_domains_response()).
get_apple_pay_domains(Args) ->
    get_apple_pay_domains(Args, #{}).

-spec get_apple_pay_domains(get_apple_pay_domains_request(), options()) ->
                               result(get_apple_pay_domains_response()).
get_apple_pay_domains(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({domain_name, Value}) ->
                encode_q(form, false, <<"domain_name">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           apple_pay_domain}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes(post_credit_notes_request()) ->
                           result(post_credit_notes_response()).
post_credit_notes(Args) ->
    post_credit_notes(Args, #{}).

-spec post_credit_notes(post_credit_notes_request(), options()) ->
                           result(post_credit_notes_response()).
post_credit_notes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, credit_note},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes(get_credit_notes_request()) -> result(get_credit_notes_response()).
get_credit_notes(Args) ->
    get_credit_notes(Args, #{}).

-spec get_credit_notes(get_credit_notes_request(), options()) ->
                          result(get_credit_notes_response()).
get_credit_notes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           credit_note}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_sigma_scheduled_query_runs_scheduled_query_run(get_sigma_scheduled_query_runs_scheduled_query_run_request()) ->
                                                          result(get_sigma_scheduled_query_runs_scheduled_query_run_response()).
get_sigma_scheduled_query_runs_scheduled_query_run(Args) ->
    get_sigma_scheduled_query_runs_scheduled_query_run(Args, #{}).

-spec
    get_sigma_scheduled_query_runs_scheduled_query_run(get_sigma_scheduled_query_runs_scheduled_query_run_request(),
                                                       options()) ->
                                                          result(get_sigma_scheduled_query_runs_scheduled_query_run_response()).
get_sigma_scheduled_query_runs_scheduled_query_run(Args, Options) ->
    VarScheduledQueryRun = maps:get(scheduled_query_run, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs/~s", [VarScheduledQueryRun]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       scheduled_query_run},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_coupons_coupon(delete_coupons_coupon_request()) ->
                               result(delete_coupons_coupon_response()).
delete_coupons_coupon(Args) ->
    delete_coupons_coupon(Args, #{}).

-spec delete_coupons_coupon(delete_coupons_coupon_request(), options()) ->
                               result(delete_coupons_coupon_response()).
delete_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, deleted_coupon},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_coupons_coupon(post_coupons_coupon_request()) ->
                             result(post_coupons_coupon_response()).
post_coupons_coupon(Args) ->
    post_coupons_coupon(Args, #{}).

-spec post_coupons_coupon(post_coupons_coupon_request(), options()) ->
                             result(post_coupons_coupon_response()).
post_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, coupon},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_coupons_coupon(get_coupons_coupon_request()) ->
                            result(get_coupons_coupon_response()).
get_coupons_coupon(Args) ->
    get_coupons_coupon(Args, #{}).

-spec get_coupons_coupon(get_coupons_coupon_request(), options()) ->
                            result(get_coupons_coupon_response()).
get_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, coupon},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_tax_ids_id(delete_customers_customer_tax_ids_id_request()) ->
                                            result(delete_customers_customer_tax_ids_id_response()).
delete_customers_customer_tax_ids_id(Args) ->
    delete_customers_customer_tax_ids_id(Args, #{}).

-spec delete_customers_customer_tax_ids_id(delete_customers_customer_tax_ids_id_request(),
                                           options()) ->
                                              result(delete_customers_customer_tax_ids_id_response()).
delete_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, deleted_tax_id},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_tax_ids_id(get_customers_customer_tax_ids_id_request()) ->
                                           result(get_customers_customer_tax_ids_id_response()).
get_customers_customer_tax_ids_id(Args) ->
    get_customers_customer_tax_ids_id(Args, #{}).

-spec get_customers_customer_tax_ids_id(get_customers_customer_tax_ids_id_request(),
                                        options()) ->
                                           result(get_customers_customer_tax_ids_id_response()).
get_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, tax_id},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_radar_early_fraud_warnings_early_fraud_warning(get_radar_early_fraud_warnings_early_fraud_warning_request()) ->
                                                          result(get_radar_early_fraud_warnings_early_fraud_warning_response()).
get_radar_early_fraud_warnings_early_fraud_warning(Args) ->
    get_radar_early_fraud_warnings_early_fraud_warning(Args, #{}).

-spec
    get_radar_early_fraud_warnings_early_fraud_warning(get_radar_early_fraud_warnings_early_fraud_warning_request(),
                                                       options()) ->
                                                          result(get_radar_early_fraud_warnings_early_fraud_warning_response()).
get_radar_early_fraud_warnings_early_fraud_warning(Args, Options) ->
    VarEarlyFraudWarning = maps:get(early_fraud_warning, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings/~s", [VarEarlyFraudWarning]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       radar_early_fraud_warning},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_settlements(get_issuing_settlements_request()) ->
                                 result(get_issuing_settlements_response()).
get_issuing_settlements(Args) ->
    get_issuing_settlements(Args, #{}).

-spec get_issuing_settlements(get_issuing_settlements_request(), options()) ->
                                 result(get_issuing_settlements_response()).
get_issuing_settlements(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/settlements", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           issuing_settlement}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_file_links(post_file_links_request()) -> result(post_file_links_response()).
post_file_links(Args) ->
    post_file_links(Args, #{}).

-spec post_file_links(post_file_links_request(), options()) ->
                         result(post_file_links_response()).
post_file_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/file_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, file_link},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_file_links(get_file_links_request()) -> result(get_file_links_response()).
get_file_links(Args) ->
    get_file_links(Args, #{}).

-spec get_file_links(get_file_links_request(), options()) ->
                        result(get_file_links_response()).
get_file_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({expired, Value}) ->
                encode_q(form, false, <<"expired">>, Value);
            ({file, Value}) ->
                encode_q(form, false, <<"file">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/file_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           file_link}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_identity_verification_reports_report(get_identity_verification_reports_report_request()) ->
                                                result(get_identity_verification_reports_report_response()).
get_identity_verification_reports_report(Args) ->
    get_identity_verification_reports_report(Args, #{}).

-spec
    get_identity_verification_reports_report(get_identity_verification_reports_report_request(),
                                             options()) ->
                                                result(get_identity_verification_reports_report_response()).
get_identity_verification_reports_report(Args, Options) ->
    VarReport = maps:get(report, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_reports/~s", [VarReport]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       identity_verification_report},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers(post_transfers_request()) -> result(post_transfers_response()).
post_transfers(Args) ->
    post_transfers(Args, #{}).

-spec post_transfers(post_transfers_request(), options()) ->
                        result(post_transfers_response()).
post_transfers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, transfer},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers(get_transfers_request()) -> result(get_transfers_response()).
get_transfers(Args) ->
    get_transfers(Args, #{}).

-spec get_transfers(get_transfers_request(), options()) ->
                       result(get_transfers_response()).
get_transfers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({destination, Value}) ->
                encode_q(form, false, <<"destination">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({transfer_group, Value}) ->
                encode_q(form, false, <<"transfer_group">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           transfer}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_subscriptions_subscription_exposed_id_discount(delete_subscriptions_subscription_exposed_id_discount_request()) ->
                                                             result(delete_subscriptions_subscription_exposed_id_discount_response()).
delete_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec
    delete_subscriptions_subscription_exposed_id_discount(delete_subscriptions_subscription_exposed_id_discount_request(),
                                                          options()) ->
                                                             result(delete_subscriptions_subscription_exposed_id_discount_response()).
delete_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions/~s/discount", [VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_discount},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_id_refunds(post_application_fees_id_refunds_request()) ->
                                          result(post_application_fees_id_refunds_response()).
post_application_fees_id_refunds(Args) ->
    post_application_fees_id_refunds(Args, #{}).

-spec post_application_fees_id_refunds(post_application_fees_id_refunds_request(),
                                       options()) ->
                                          result(post_application_fees_id_refunds_response()).
post_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, fee_refund},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_id_refunds(get_application_fees_id_refunds_request()) ->
                                         result(get_application_fees_id_refunds_response()).
get_application_fees_id_refunds(Args) ->
    get_application_fees_id_refunds(Args, #{}).

-spec get_application_fees_id_refunds(get_application_fees_id_refunds_request(),
                                      options()) ->
                                         result(get_application_fees_id_refunds_response()).
get_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           fee_refund}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_bank_accounts(post_accounts_account_bank_accounts_request()) ->
                                           result(post_accounts_account_bank_accounts_response()).
post_accounts_account_bank_accounts(Args) ->
    post_accounts_account_bank_accounts(Args, #{}).

-spec post_accounts_account_bank_accounts(post_accounts_account_bank_accounts_request(),
                                          options()) ->
                                             result(post_accounts_account_bank_accounts_response()).
post_accounts_account_bank_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account(delete_accounts_account_request()) ->
                                 result(delete_accounts_account_response()).
delete_accounts_account(Args) ->
    delete_accounts_account(Args, #{}).

-spec delete_accounts_account(delete_accounts_account_request(), options()) ->
                                 result(delete_accounts_account_response()).
delete_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account(post_accounts_account_request()) ->
                               result(post_accounts_account_response()).
post_accounts_account(Args) ->
    post_accounts_account(Args, #{}).

-spec post_accounts_account(post_accounts_account_request(), options()) ->
                               result(post_accounts_account_response()).
post_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account(get_accounts_account_request()) ->
                              result(get_accounts_account_response()).
get_accounts_account(Args) ->
    get_accounts_account(Args, #{}).

-spec get_accounts_account(get_accounts_account_request(), options()) ->
                              result(get_accounts_account_response()).
get_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscription_schedules_schedule(post_subscription_schedules_schedule_request()) ->
                                            result(post_subscription_schedules_schedule_response()).
post_subscription_schedules_schedule(Args) ->
    post_subscription_schedules_schedule(Args, #{}).

-spec post_subscription_schedules_schedule(post_subscription_schedules_schedule_request(),
                                           options()) ->
                                              result(post_subscription_schedules_schedule_response()).
post_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules/~s", [VarSchedule]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       subscription_schedule},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_subscription_schedules_schedule(get_subscription_schedules_schedule_request()) ->
                                           result(get_subscription_schedules_schedule_response()).
get_subscription_schedules_schedule(Args) ->
    get_subscription_schedules_schedule(Args, #{}).

-spec get_subscription_schedules_schedule(get_subscription_schedules_schedule_request(),
                                          options()) ->
                                             result(get_subscription_schedules_schedule_response()).
get_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules/~s", [VarSchedule]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       subscription_schedule},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_pay(post_invoices_invoice_pay_request()) ->
                                   result(post_invoices_invoice_pay_response()).
post_invoices_invoice_pay(Args) ->
    post_invoices_invoice_pay(Args, #{}).

-spec post_invoices_invoice_pay(post_invoices_invoice_pay_request(), options()) ->
                                   result(post_invoices_invoice_pay_response()).
post_invoices_invoice_pay(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/pay", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_transfers_transfer_reversals_id(post_transfers_transfer_reversals_id_request()) ->
                                            result(post_transfers_transfer_reversals_id_response()).
post_transfers_transfer_reversals_id(Args) ->
    post_transfers_transfer_reversals_id(Args, #{}).

-spec post_transfers_transfer_reversals_id(post_transfers_transfer_reversals_id_request(),
                                           options()) ->
                                              result(post_transfers_transfer_reversals_id_response()).
post_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s/reversals/~s", [VarTransfer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       transfer_reversal},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_transfers_transfer_reversals_id(get_transfers_transfer_reversals_id_request()) ->
                                           result(get_transfers_transfer_reversals_id_response()).
get_transfers_transfer_reversals_id(Args) ->
    get_transfers_transfer_reversals_id(Args, #{}).

-spec get_transfers_transfer_reversals_id(get_transfers_transfer_reversals_id_request(),
                                          options()) ->
                                             result(get_transfers_transfer_reversals_id_response()).
get_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s/reversals/~s", [VarTransfer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       transfer_reversal},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups_topup(post_topups_topup_request()) ->
                           result(post_topups_topup_response()).
post_topups_topup(Args) ->
    post_topups_topup(Args, #{}).

-spec post_topups_topup(post_topups_topup_request(), options()) ->
                           result(post_topups_topup_response()).
post_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups/~s", [VarTopup]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, topup},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_topups_topup(get_topups_topup_request()) -> result(get_topups_topup_response()).
get_topups_topup(Args) ->
    get_topups_topup(Args, #{}).

-spec get_topups_topup(get_topups_topup_request(), options()) ->
                          result(get_topups_topup_response()).
get_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups/~s", [VarTopup]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, topup},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_recipients_id(delete_recipients_id_request()) ->
                              result(delete_recipients_id_response()).
delete_recipients_id(Args) ->
    delete_recipients_id(Args, #{}).

-spec delete_recipients_id(delete_recipients_id_request(), options()) ->
                              result(delete_recipients_id_response()).
delete_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_recipient},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_recipients_id(post_recipients_id_request()) ->
                            result(post_recipients_id_response()).
post_recipients_id(Args) ->
    post_recipients_id(Args, #{}).

-spec post_recipients_id(post_recipients_id_request(), options()) ->
                            result(post_recipients_id_response()).
post_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, recipient},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_recipients_id(get_recipients_id_request()) ->
                           result(get_recipients_id_response()).
get_recipients_id(Args) ->
    get_recipients_id(Args, #{}).

-spec get_recipients_id(get_recipients_id_request(), options()) ->
                           result(get_recipients_id_response()).
get_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref, stripe, recipient},
                                                                        {ref,
                                                                         stripe,
                                                                         deleted_recipient}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_invoice_lines(get_invoices_invoice_lines_request()) ->
                                    result(get_invoices_invoice_lines_response()).
get_invoices_invoice_lines(Args) ->
    get_invoices_invoice_lines(Args, #{}).

-spec get_invoices_invoice_lines(get_invoices_invoice_lines_request(), options()) ->
                                    result(get_invoices_invoice_lines_response()).
get_invoices_invoice_lines(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/lines", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           line_item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_accounts_account_external_accounts_id(delete_accounts_account_external_accounts_id_request()) ->
                                                    result(delete_accounts_account_external_accounts_id_response()).
delete_accounts_account_external_accounts_id(Args) ->
    delete_accounts_account_external_accounts_id(Args, #{}).

-spec
    delete_accounts_account_external_accounts_id(delete_accounts_account_external_accounts_id_request(),
                                                 options()) ->
                                                    result(delete_accounts_account_external_accounts_id_response()).
delete_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_external_accounts_id(post_accounts_account_external_accounts_id_request()) ->
                                                  result(post_accounts_account_external_accounts_id_response()).
post_accounts_account_external_accounts_id(Args) ->
    post_accounts_account_external_accounts_id(Args, #{}).

-spec
    post_accounts_account_external_accounts_id(post_accounts_account_external_accounts_id_request(),
                                               options()) ->
                                                  result(post_accounts_account_external_accounts_id_response()).
post_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_external_accounts_id(get_accounts_account_external_accounts_id_request()) ->
                                                 result(get_accounts_account_external_accounts_id_response()).
get_accounts_account_external_accounts_id(Args) ->
    get_accounts_account_external_accounts_id(Args, #{}).

-spec
    get_accounts_account_external_accounts_id(get_accounts_account_external_accounts_id_request(),
                                              options()) ->
                                                 result(get_accounts_account_external_accounts_id_response()).
get_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups(post_topups_request()) -> result(post_topups_response()).
post_topups(Args) ->
    post_topups(Args, #{}).

-spec post_topups(post_topups_request(), options()) -> result(post_topups_response()).
post_topups(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, topup},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_topups(get_topups_request()) -> result(get_topups_response()).
get_topups(Args) ->
    get_topups(Args, #{}).

-spec get_topups(get_topups_request(), options()) -> result(get_topups_response()).
get_topups(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({amount, Value}) ->
                encode_q(deepObject, true, <<"amount">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           topup}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id_returns(post_orders_id_returns_request()) ->
                                result(post_orders_id_returns_response()).
post_orders_id_returns(Args) ->
    post_orders_id_returns(Args, #{}).

-spec post_orders_id_returns(post_orders_id_returns_request(), options()) ->
                                result(post_orders_id_returns_response()).
post_orders_id_returns(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders/~s/returns", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, order_return},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id(post_orders_id_request()) -> result(post_orders_id_response()).
post_orders_id(Args) ->
    post_orders_id(Args, #{}).

-spec post_orders_id(post_orders_id_request(), options()) ->
                        result(post_orders_id_response()).
post_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, order},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_orders_id(get_orders_id_request()) -> result(get_orders_id_response()).
get_orders_id(Args) ->
    get_orders_id(Args, #{}).

-spec get_orders_id(get_orders_id_request(), options()) ->
                       result(get_orders_id_response()).
get_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, order},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_apple_pay_domains_domain(delete_apple_pay_domains_domain_request()) ->
                                         result(delete_apple_pay_domains_domain_response()).
delete_apple_pay_domains_domain(Args) ->
    delete_apple_pay_domains_domain(Args, #{}).

-spec delete_apple_pay_domains_domain(delete_apple_pay_domains_domain_request(),
                                      options()) ->
                                         result(delete_apple_pay_domains_domain_response()).
delete_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/apple_pay/domains/~s", [VarDomain]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_apple_pay_domain},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_apple_pay_domains_domain(get_apple_pay_domains_domain_request()) ->
                                      result(get_apple_pay_domains_domain_response()).
get_apple_pay_domains_domain(Args) ->
    get_apple_pay_domains_domain(Args, #{}).

-spec get_apple_pay_domains_domain(get_apple_pay_domains_domain_request(), options()) ->
                                      result(get_apple_pay_domains_domain_response()).
get_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/apple_pay/domains/~s", [VarDomain]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       apple_pay_domain},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_transactions(get_issuing_transactions_request()) ->
                                  result(get_issuing_transactions_response()).
get_issuing_transactions(Args) ->
    get_issuing_transactions(Args, #{}).

-spec get_issuing_transactions(get_issuing_transactions_request(), options()) ->
                                  result(get_issuing_transactions_response()).
get_issuing_transactions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({card, Value}) ->
                encode_q(form, false, <<"card">>, Value);
            ({cardholder, Value}) ->
                encode_q(form, false, <<"cardholder">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/transactions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           issuing_transaction}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refund(post_charges_charge_refund_request()) ->
                                    result(post_charges_charge_refund_response()).
post_charges_charge_refund(Args) ->
    post_charges_charge_refund(Args, #{}).

-spec post_charges_charge_refund(post_charges_charge_refund_request(), options()) ->
                                    result(post_charges_charge_refund_response()).
post_charges_charge_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refund", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, charge},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_methods_payment_method_attach(post_payment_methods_payment_method_attach_request()) ->
                                                  result(post_payment_methods_payment_method_attach_response()).
post_payment_methods_payment_method_attach(Args) ->
    post_payment_methods_payment_method_attach(Args, #{}).

-spec
    post_payment_methods_payment_method_attach(post_payment_methods_payment_method_attach_request(),
                                               options()) ->
                                                  result(post_payment_methods_payment_method_attach_response()).
post_payment_methods_payment_method_attach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods/~s/attach", [VarPaymentMethod]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_method},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_cancel(post_payment_intents_intent_cancel_request()) ->
                                            result(post_payment_intents_intent_cancel_response()).
post_payment_intents_intent_cancel(Args) ->
    post_payment_intents_intent_cancel(Args, #{}).

-spec post_payment_intents_intent_cancel(post_payment_intents_intent_cancel_request(),
                                         options()) ->
                                            result(post_payment_intents_intent_cancel_response()).
post_payment_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s/cancel", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_capabilities(get_accounts_account_capabilities_request()) ->
                                           result(get_accounts_account_capabilities_response()).
get_accounts_account_capabilities(Args) ->
    get_accounts_account_capabilities(Args, #{}).

-spec get_accounts_account_capabilities(get_accounts_account_capabilities_request(),
                                        options()) ->
                                           result(get_accounts_account_capabilities_response()).
get_accounts_account_capabilities(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           capability}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_preview_lines(get_credit_notes_preview_lines_request()) ->
                                        result(get_credit_notes_preview_lines_response()).
get_credit_notes_preview_lines(Args) ->
    get_credit_notes_preview_lines(Args, #{}).

-spec get_credit_notes_preview_lines(get_credit_notes_preview_lines_request(),
                                     options()) ->
                                        result(get_credit_notes_preview_lines_response()).
get_credit_notes_preview_lines(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({amount, Value}) ->
                encode_q(form, false, <<"amount">>, Value);
            ({credit_amount, Value}) ->
                encode_q(form, false, <<"credit_amount">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({lines, Value}) ->
                encode_q(deepObject, true, <<"lines">>, Value);
            ({memo, Value}) ->
                encode_q(form, false, <<"memo">>, Value);
            ({metadata, Value}) ->
                encode_q(deepObject, true, <<"metadata">>, Value);
            ({out_of_band_amount, Value}) ->
                encode_q(form, false, <<"out_of_band_amount">>, Value);
            ({reason, Value}) ->
                encode_q(form, false, <<"reason">>, Value);
            ({refund, Value}) ->
                encode_q(form, false, <<"refund">>, Value);
            ({refund_amount, Value}) ->
                encode_q(form, false, <<"refund_amount">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/preview/lines", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           credit_note_line_item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscriptions(post_subscriptions_request()) ->
                            result(post_subscriptions_response()).
post_subscriptions(Args) ->
    post_subscriptions(Args, #{}).

-spec post_subscriptions(post_subscriptions_request(), options()) ->
                            result(post_subscriptions_response()).
post_subscriptions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, subscription},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscriptions(get_subscriptions_request()) ->
                           result(get_subscriptions_response()).
get_subscriptions(Args) ->
    get_subscriptions(Args, #{}).

-spec get_subscriptions(get_subscriptions_request(), options()) ->
                           result(get_subscriptions_response()).
get_subscriptions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({collection_method, Value}) ->
                encode_q(form, false, <<"collection_method">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({current_period_end, Value}) ->
                encode_q(deepObject, true, <<"current_period_end">>, Value);
            ({current_period_start, Value}) ->
                encode_q(deepObject, true, <<"current_period_start">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({price, Value}) ->
                encode_q(form, false, <<"price">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           subscription}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_attempts(get_setup_attempts_request()) ->
                            result(get_setup_attempts_response()).
get_setup_attempts(Args) ->
    get_setup_attempts(Args, #{}).

-spec get_setup_attempts(get_setup_attempts_request(), options()) ->
                            result(get_setup_attempts_response()).
get_setup_attempts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({setup_intent, Value}) ->
                encode_q(form, false, <<"setup_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_attempts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           setup_attempt}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id(delete_customers_customer_subscriptions_subscription_exposed_id_request()) ->
                                                                       result(delete_customers_customer_subscriptions_subscription_exposed_id_response()).
delete_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id(delete_customers_customer_subscriptions_subscription_exposed_id_request(),
                                                                    options()) ->
                                                                       result(delete_customers_customer_subscriptions_subscription_exposed_id_response()).
delete_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, subscription},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_subscriptions_subscription_exposed_id(post_customers_customer_subscriptions_subscription_exposed_id_request()) ->
                                                                     result(post_customers_customer_subscriptions_subscription_exposed_id_response()).
post_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    post_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    post_customers_customer_subscriptions_subscription_exposed_id(post_customers_customer_subscriptions_subscription_exposed_id_request(),
                                                                  options()) ->
                                                                     result(post_customers_customer_subscriptions_subscription_exposed_id_response()).
post_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, subscription},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_subscriptions_subscription_exposed_id(get_customers_customer_subscriptions_subscription_exposed_id_request()) ->
                                                                    result(get_customers_customer_subscriptions_subscription_exposed_id_response()).
get_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    get_customers_customer_subscriptions_subscription_exposed_id(get_customers_customer_subscriptions_subscription_exposed_id_request(),
                                                                 options()) ->
                                                                    result(get_customers_customer_subscriptions_subscription_exposed_id_response()).
get_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, subscription},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers_id(get_bitcoin_receivers_id_request()) ->
                                  result(get_bitcoin_receivers_id_response()).
get_bitcoin_receivers_id(Args) ->
    get_bitcoin_receivers_id(Args, #{}).

-spec get_bitcoin_receivers_id(get_bitcoin_receivers_id_request(), options()) ->
                                  result(get_bitcoin_receivers_id_response()).
get_bitcoin_receivers_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/bitcoin/receivers/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       bitcoin_receiver},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders(post_orders_request()) -> result(post_orders_response()).
post_orders(Args) ->
    post_orders(Args, #{}).

-spec post_orders(post_orders_request(), options()) -> result(post_orders_response()).
post_orders(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, order},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_orders(get_orders_request()) -> result(get_orders_response()).
get_orders(Args) ->
    get_orders(Args, #{}).

-spec get_orders(get_orders_request(), options()) -> result(get_orders_response()).
get_orders(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({ids, Value}) ->
                encode_q(deepObject, true, <<"ids">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({status_transitions, Value}) ->
                encode_q(deepObject, true, <<"status_transitions">>, Value);
            ({upstream_ids, Value}) ->
                encode_q(deepObject, true, <<"upstream_ids">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           order}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_ephemeral_keys(post_ephemeral_keys_request()) ->
                             result(post_ephemeral_keys_response()).
post_ephemeral_keys(Args) ->
    post_ephemeral_keys(Args, #{}).

-spec post_ephemeral_keys(post_ephemeral_keys_request(), options()) ->
                             result(post_ephemeral_keys_response()).
post_ephemeral_keys(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/ephemeral_keys", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, ephemeral_key},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_webhook_endpoints_webhook_endpoint(delete_webhook_endpoints_webhook_endpoint_request()) ->
                                                 result(delete_webhook_endpoints_webhook_endpoint_response()).
delete_webhook_endpoints_webhook_endpoint(Args) ->
    delete_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec
    delete_webhook_endpoints_webhook_endpoint(delete_webhook_endpoints_webhook_endpoint_request(),
                                              options()) ->
                                                 result(delete_webhook_endpoints_webhook_endpoint_response()).
delete_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_webhook_endpoint},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_webhook_endpoints_webhook_endpoint(post_webhook_endpoints_webhook_endpoint_request()) ->
                                               result(post_webhook_endpoints_webhook_endpoint_response()).
post_webhook_endpoints_webhook_endpoint(Args) ->
    post_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec
    post_webhook_endpoints_webhook_endpoint(post_webhook_endpoints_webhook_endpoint_request(),
                                            options()) ->
                                               result(post_webhook_endpoints_webhook_endpoint_response()).
post_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       webhook_endpoint},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_webhook_endpoints_webhook_endpoint(get_webhook_endpoints_webhook_endpoint_request()) ->
                                              result(get_webhook_endpoints_webhook_endpoint_response()).
get_webhook_endpoints_webhook_endpoint(Args) ->
    get_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec
    get_webhook_endpoints_webhook_endpoint(get_webhook_endpoints_webhook_endpoint_request(),
                                           options()) ->
                                              result(get_webhook_endpoints_webhook_endpoint_response()).
get_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       webhook_endpoint},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_persons(post_account_persons_request()) ->
                              result(post_account_persons_response()).
post_account_persons(Args) ->
    post_account_persons(Args, #{}).

-spec post_account_persons(post_account_persons_request(), options()) ->
                              result(post_account_persons_response()).
post_account_persons(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_persons(get_account_persons_request()) ->
                             result(get_account_persons_response()).
get_account_persons(Args) ->
    get_account_persons(Args, #{}).

-spec get_account_persons(get_account_persons_request(), options()) ->
                             result(get_account_persons_response()).
get_account_persons(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           person}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_capabilities(get_account_capabilities_request()) ->
                                  result(get_account_capabilities_response()).
get_account_capabilities(Args) ->
    get_account_capabilities(Args, #{}).

-spec get_account_capabilities(get_account_capabilities_request(), options()) ->
                                  result(get_account_capabilities_response()).
get_account_capabilities(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/capabilities", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           capability}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_checkout_sessions_session_expire(post_checkout_sessions_session_expire_request()) ->
                                             result(post_checkout_sessions_session_expire_response()).
post_checkout_sessions_session_expire(Args) ->
    post_checkout_sessions_session_expire(Args, #{}).

-spec
    post_checkout_sessions_session_expire(post_checkout_sessions_session_expire_request(),
                                          options()) ->
                                             result(post_checkout_sessions_session_expire_response()).
post_checkout_sessions_session_expire(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions/~s/expire", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       checkout_session},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_bitcoin_receivers_receiver_transactions(get_bitcoin_receivers_receiver_transactions_request()) ->
                                                   result(get_bitcoin_receivers_receiver_transactions_response()).
get_bitcoin_receivers_receiver_transactions(Args) ->
    get_bitcoin_receivers_receiver_transactions(Args, #{}).

-spec
    get_bitcoin_receivers_receiver_transactions(get_bitcoin_receivers_receiver_transactions_request(),
                                                options()) ->
                                                   result(get_bitcoin_receivers_receiver_transactions_response()).
get_bitcoin_receivers_receiver_transactions(Args, Options) ->
    VarReceiver = maps:get(receiver, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/bitcoin/receivers/~s/transactions", [VarReceiver]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           bitcoin_transaction}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote(post_quotes_quote_request()) ->
                           result(post_quotes_quote_response()).
post_quotes_quote(Args) ->
    post_quotes_quote(Args, #{}).

-spec post_quotes_quote(post_quotes_quote_request(), options()) ->
                           result(post_quotes_quote_response()).
post_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, quote},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote(get_quotes_quote_request()) -> result(get_quotes_quote_response()).
get_quotes_quote(Args) ->
    get_quotes_quote(Args, #{}).

-spec get_quotes_quote(get_quotes_quote_request(), options()) ->
                          result(get_quotes_quote_response()).
get_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, quote},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_people(post_account_people_request()) ->
                             result(post_account_people_response()).
post_account_people(Args) ->
    post_account_people(Args, #{}).

-spec post_account_people(post_account_people_request(), options()) ->
                             result(post_account_people_response()).
post_account_people(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_people(get_account_people_request()) ->
                            result(get_account_people_response()).
get_account_people(Args) ->
    get_account_people(Args, #{}).

-spec get_account_people(get_account_people_request(), options()) ->
                            result(get_account_people_response()).
get_account_people(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           person}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_confirm(post_setup_intents_intent_confirm_request()) ->
                                           result(post_setup_intents_intent_confirm_response()).
post_setup_intents_intent_confirm(Args) ->
    post_setup_intents_intent_confirm(Args, #{}).

-spec post_setup_intents_intent_confirm(post_setup_intents_intent_confirm_request(),
                                        options()) ->
                                           result(post_setup_intents_intent_confirm_response()).
post_setup_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s/confirm", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, setup_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_cards(post_customers_customer_cards_request()) ->
                                       result(post_customers_customer_cards_response()).
post_customers_customer_cards(Args) ->
    post_customers_customer_cards(Args, #{}).

-spec post_customers_customer_cards(post_customers_customer_cards_request(), options()) ->
                                       result(post_customers_customer_cards_response()).
post_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_source},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_cards(get_customers_customer_cards_request()) ->
                                      result(get_customers_customer_cards_response()).
get_customers_customer_cards(Args) ->
    get_customers_customer_cards(Args, #{}).

-spec get_customers_customer_cards(get_customers_customer_cards_request(), options()) ->
                                      result(get_customers_customer_cards_response()).
get_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           card}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_reports(get_identity_verification_reports_request()) ->
                                           result(get_identity_verification_reports_response()).
get_identity_verification_reports(Args) ->
    get_identity_verification_reports(Args, #{}).

-spec get_identity_verification_reports(get_identity_verification_reports_request(),
                                        options()) ->
                                           result(get_identity_verification_reports_response()).
get_identity_verification_reports(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({verification_session, Value}) ->
                encode_q(form, false, <<"verification_session">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_reports", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           identity_verification_report}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_persons(post_accounts_account_persons_request()) ->
                                       result(post_accounts_account_persons_response()).
post_accounts_account_persons(Args) ->
    post_accounts_account_persons(Args, #{}).

-spec post_accounts_account_persons(post_accounts_account_persons_request(), options()) ->
                                       result(post_accounts_account_persons_response()).
post_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_persons(get_accounts_account_persons_request()) ->
                                      result(get_accounts_account_persons_response()).
get_accounts_account_persons(Args) ->
    get_accounts_account_persons(Args, #{}).

-spec get_accounts_account_persons(get_accounts_account_persons_request(), options()) ->
                                      result(get_accounts_account_persons_response()).
get_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           person}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_id_refund(post_application_fees_id_refund_request()) ->
                                         result(post_application_fees_id_refund_response()).
post_application_fees_id_refund(Args) ->
    post_application_fees_id_refund(Args, #{}).

-spec post_application_fees_id_refund(post_application_fees_id_refund_request(),
                                      options()) ->
                                         result(post_application_fees_id_refund_response()).
post_application_fees_id_refund(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refund", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       application_fee},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents(post_payment_intents_request()) ->
                              result(post_payment_intents_response()).
post_payment_intents(Args) ->
    post_payment_intents(Args, #{}).

-spec post_payment_intents(post_payment_intents_request(), options()) ->
                              result(post_payment_intents_response()).
post_payment_intents(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_intents(get_payment_intents_request()) ->
                             result(get_payment_intents_response()).
get_payment_intents(Args) ->
    get_payment_intents(Args, #{}).

-spec get_payment_intents(get_payment_intents_request(), options()) ->
                             result(get_payment_intents_response()).
get_payment_intents(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           payment_intent}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_skus(post_skus_request()) -> result(post_skus_response()).
post_skus(Args) ->
    post_skus(Args, #{}).

-spec post_skus(post_skus_request(), options()) -> result(post_skus_response()).
post_skus(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, sku},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_skus(get_skus_request()) -> result(get_skus_response()).
get_skus(Args) ->
    get_skus(Args, #{}).

-spec get_skus(get_skus_request(), options()) -> result(get_skus_response()).
get_skus(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({attributes, Value}) ->
                encode_q(deepObject, true, <<"attributes">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({ids, Value}) ->
                encode_q(deepObject, true, <<"ids">>, Value);
            ({in_stock, Value}) ->
                encode_q(form, false, <<"in_stock">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({product, Value}) ->
                encode_q(form, false, <<"product">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           sku}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_webhook_endpoints(post_webhook_endpoints_request()) ->
                                result(post_webhook_endpoints_response()).
post_webhook_endpoints(Args) ->
    post_webhook_endpoints(Args, #{}).

-spec post_webhook_endpoints(post_webhook_endpoints_request(), options()) ->
                                result(post_webhook_endpoints_response()).
post_webhook_endpoints(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       webhook_endpoint},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_webhook_endpoints(get_webhook_endpoints_request()) ->
                               result(get_webhook_endpoints_response()).
get_webhook_endpoints(Args) ->
    get_webhook_endpoints(Args, #{}).

-spec get_webhook_endpoints(get_webhook_endpoints_request(), options()) ->
                               result(get_webhook_endpoints_response()).
get_webhook_endpoints(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           webhook_endpoint}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance(get_balance_request()) -> result(get_balance_response()).
get_balance(Args) ->
    get_balance(Args, #{}).

-spec get_balance(get_balance_request(), options()) -> result(get_balance_response()).
get_balance(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, balance},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_balance_transactions_transaction(post_customers_customer_balance_transactions_transaction_request()) ->
                                                                result(post_customers_customer_balance_transactions_transaction_response()).
post_customers_customer_balance_transactions_transaction(Args) ->
    post_customers_customer_balance_transactions_transaction(Args, #{}).

-spec
    post_customers_customer_balance_transactions_transaction(post_customers_customer_balance_transactions_transaction_request(),
                                                             options()) ->
                                                                result(post_customers_customer_balance_transactions_transaction_response()).
post_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/balance_transactions/~s", [VarCustomer, VarTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       customer_balance_transaction},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_balance_transactions_transaction(get_customers_customer_balance_transactions_transaction_request()) ->
                                                               result(get_customers_customer_balance_transactions_transaction_response()).
get_customers_customer_balance_transactions_transaction(Args) ->
    get_customers_customer_balance_transactions_transaction(Args, #{}).

-spec
    get_customers_customer_balance_transactions_transaction(get_customers_customer_balance_transactions_transaction_request(),
                                                            options()) ->
                                                               result(get_customers_customer_balance_transactions_transaction_response()).
get_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/balance_transactions/~s", [VarCustomer, VarTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       customer_balance_transaction},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_methods_payment_method(post_payment_methods_payment_method_request()) ->
                                           result(post_payment_methods_payment_method_response()).
post_payment_methods_payment_method(Args) ->
    post_payment_methods_payment_method(Args, #{}).

-spec post_payment_methods_payment_method(post_payment_methods_payment_method_request(),
                                          options()) ->
                                             result(post_payment_methods_payment_method_response()).
post_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods/~s", [VarPaymentMethod]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_method},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_methods_payment_method(get_payment_methods_payment_method_request()) ->
                                            result(get_payment_methods_payment_method_response()).
get_payment_methods_payment_method(Args) ->
    get_payment_methods_payment_method(Args, #{}).

-spec get_payment_methods_payment_method(get_payment_methods_payment_method_request(),
                                         options()) ->
                                            result(get_payment_methods_payment_method_response()).
get_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods/~s", [VarPaymentMethod]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_method},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups_topup_cancel(post_topups_topup_cancel_request()) ->
                                  result(post_topups_topup_cancel_response()).
post_topups_topup_cancel(Args) ->
    post_topups_topup_cancel(Args, #{}).

-spec post_topups_topup_cancel(post_topups_topup_cancel_request(), options()) ->
                                  result(post_topups_topup_cancel_response()).
post_topups_topup_cancel(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups/~s/cancel", [VarTopup]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, topup},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_events(get_events_request()) -> result(get_events_response()).
get_events(Args) ->
    get_events(Args, #{}).

-spec get_events(get_events_request(), options()) -> result(get_events_response()).
get_events(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({delivery_success, Value}) ->
                encode_q(form, false, <<"delivery_success">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({types, Value}) ->
                encode_q(deepObject, true, <<"types">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/events", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           event}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refunds_refund(post_charges_charge_refunds_refund_request()) ->
                                            result(post_charges_charge_refunds_refund_response()).
post_charges_charge_refunds_refund(Args) ->
    post_charges_charge_refunds_refund(Args, #{}).

-spec post_charges_charge_refunds_refund(post_charges_charge_refunds_refund_request(),
                                         options()) ->
                                            result(post_charges_charge_refunds_refund_response()).
post_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refunds/~s", [VarCharge, VarRefund]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, refund},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_refunds_refund(get_charges_charge_refunds_refund_request()) ->
                                           result(get_charges_charge_refunds_refund_response()).
get_charges_charge_refunds_refund(Args) ->
    get_charges_charge_refunds_refund(Args, #{}).

-spec get_charges_charge_refunds_refund(get_charges_charge_refunds_refund_request(),
                                        options()) ->
                                           result(get_charges_charge_refunds_refund_response()).
get_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refunds/~s", [VarCharge, VarRefund]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, refund},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_capabilities_capability(post_accounts_account_capabilities_capability_request()) ->
                                                     result(post_accounts_account_capabilities_capability_response()).
post_accounts_account_capabilities_capability(Args) ->
    post_accounts_account_capabilities_capability(Args, #{}).

-spec
    post_accounts_account_capabilities_capability(post_accounts_account_capabilities_capability_request(),
                                                  options()) ->
                                                     result(post_accounts_account_capabilities_capability_response()).
post_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities/~s", [VarAccount, VarCapability]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, capability},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_capabilities_capability(get_accounts_account_capabilities_capability_request()) ->
                                                    result(get_accounts_account_capabilities_capability_response()).
get_accounts_account_capabilities_capability(Args) ->
    get_accounts_account_capabilities_capability(Args, #{}).

-spec
    get_accounts_account_capabilities_capability(get_accounts_account_capabilities_capability_request(),
                                                 options()) ->
                                                    result(get_accounts_account_capabilities_capability_response()).
get_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities/~s", [VarAccount, VarCapability]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, capability},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items(post_subscription_items_request()) ->
                                 result(post_subscription_items_response()).
post_subscription_items(Args) ->
    post_subscription_items(Args, #{}).

-spec post_subscription_items(post_subscription_items_request(), options()) ->
                                 result(post_subscription_items_response()).
post_subscription_items(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       subscription_item},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items(get_subscription_items_request()) ->
                                result(get_subscription_items_response()).
get_subscription_items(Args) ->
    get_subscription_items(Args, #{}).

-spec get_subscription_items(get_subscription_items_request(), options()) ->
                                result(get_subscription_items_response()).
get_subscription_items(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           subscription_item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_pdf(get_quotes_quote_pdf_request()) ->
                              result(get_quotes_quote_pdf_response()).
get_quotes_quote_pdf(Args) ->
    get_quotes_quote_pdf(Args, #{}).

-spec get_quotes_quote_pdf(get_quotes_quote_pdf_request(), options()) ->
                              result(get_quotes_quote_pdf_response()).
get_quotes_quote_pdf(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/pdf", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"pdf">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, string, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_bank_accounts_id(delete_account_bank_accounts_id_request()) ->
                                         result(delete_account_bank_accounts_id_response()).
delete_account_bank_accounts_id(Args) ->
    delete_account_bank_accounts_id(Args, #{}).

-spec delete_account_bank_accounts_id(delete_account_bank_accounts_id_request(),
                                      options()) ->
                                         result(delete_account_bank_accounts_id_response()).
delete_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_bank_accounts_id(post_account_bank_accounts_id_request()) ->
                                       result(post_account_bank_accounts_id_response()).
post_account_bank_accounts_id(Args) ->
    post_account_bank_accounts_id(Args, #{}).

-spec post_account_bank_accounts_id(post_account_bank_accounts_id_request(), options()) ->
                                       result(post_account_bank_accounts_id_response()).
post_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_bank_accounts_id(get_account_bank_accounts_id_request()) ->
                                      result(get_account_bank_accounts_id_response()).
get_account_bank_accounts_id(Args) ->
    get_account_bank_accounts_id(Args, #{}).

-spec get_account_bank_accounts_id(get_account_bank_accounts_id_request(), options()) ->
                                      result(get_account_bank_accounts_id_response()).
get_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_payment_links_payment_link_line_items(get_payment_links_payment_link_line_items_request()) ->
                                                 result(get_payment_links_payment_link_line_items_response()).
get_payment_links_payment_link_line_items(Args) ->
    get_payment_links_payment_link_line_items(Args, #{}).

-spec
    get_payment_links_payment_link_line_items(get_payment_links_payment_link_line_items_request(),
                                              options()) ->
                                                 result(get_payment_links_payment_link_line_items_response()).
get_payment_links_payment_link_line_items(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links/~s/line_items", [VarPaymentLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_subscription_items_subscription_item_usage_record_summaries(get_subscription_items_subscription_item_usage_record_summaries_request()) ->
                                                                       result(get_subscription_items_subscription_item_usage_record_summaries_response()).
get_subscription_items_subscription_item_usage_record_summaries(Args) ->
    get_subscription_items_subscription_item_usage_record_summaries(Args, #{}).

-spec
    get_subscription_items_subscription_item_usage_record_summaries(get_subscription_items_subscription_item_usage_record_summaries_request(),
                                                                    options()) ->
                                                                       result(get_subscription_items_subscription_item_usage_record_summaries_response()).
get_subscription_items_subscription_item_usage_record_summaries(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/subscription_items/~s/usage_record_summaries", [VarSubscriptionItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           usage_record_summary}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent(post_payment_intents_intent_request()) ->
                                     result(post_payment_intents_intent_response()).
post_payment_intents_intent(Args) ->
    post_payment_intents_intent(Args, #{}).

-spec post_payment_intents_intent(post_payment_intents_intent_request(), options()) ->
                                     result(post_payment_intents_intent_response()).
post_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_intents_intent(get_payment_intents_intent_request()) ->
                                    result(get_payment_intents_intent_response()).
get_payment_intents_intent(Args) ->
    get_payment_intents_intent(Args, #{}).

-spec get_payment_intents_intent(get_payment_intents_intent_request(), options()) ->
                                    result(get_payment_intents_intent_response()).
get_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({client_secret, Value}) ->
                encode_q(form, false, <<"client_secret">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges(post_charges_request()) -> result(post_charges_response()).
post_charges(Args) ->
    post_charges(Args, #{}).

-spec post_charges(post_charges_request(), options()) -> result(post_charges_response()).
post_charges(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, charge},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges(get_charges_request()) -> result(get_charges_response()).
get_charges(Args) ->
    get_charges(Args, #{}).

-spec get_charges(get_charges_request(), options()) -> result(get_charges_response()).
get_charges(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({transfer_group, Value}) ->
                encode_q(form, false, <<"transfer_group">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           charge}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_external_accounts(post_accounts_account_external_accounts_request()) ->
                                               result(post_accounts_account_external_accounts_response()).
post_accounts_account_external_accounts(Args) ->
    post_accounts_account_external_accounts(Args, #{}).

-spec
    post_accounts_account_external_accounts(post_accounts_account_external_accounts_request(),
                                            options()) ->
                                               result(post_accounts_account_external_accounts_response()).
post_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_external_accounts(get_accounts_account_external_accounts_request()) ->
                                              result(get_accounts_account_external_accounts_response()).
get_accounts_account_external_accounts(Args) ->
    get_accounts_account_external_accounts(Args, #{}).

-spec
    get_accounts_account_external_accounts(get_accounts_account_external_accounts_request(),
                                           options()) ->
                                              result(get_accounts_account_external_accounts_response()).
get_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {one_of,
                                                                                           [{ref,
                                                                                             stripe,
                                                                                             bank_account},
                                                                                            {ref,
                                                                                             stripe,
                                                                                             card}]}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_authorizations(get_issuing_authorizations_request()) ->
                                    result(get_issuing_authorizations_response()).
get_issuing_authorizations(Args) ->
    get_issuing_authorizations(Args, #{}).

-spec get_issuing_authorizations(get_issuing_authorizations_request(), options()) ->
                                    result(get_issuing_authorizations_response()).
get_issuing_authorizations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({card, Value}) ->
                encode_q(form, false, <<"card">>, Value);
            ({cardholder, Value}) ->
                encode_q(form, false, <<"cardholder">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           issuing_authorization}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_products_id(delete_products_id_request()) ->
                            result(delete_products_id_response()).
delete_products_id(Args) ->
    delete_products_id(Args, #{}).

-spec delete_products_id(delete_products_id_request(), options()) ->
                            result(delete_products_id_response()).
delete_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_product},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_products_id(post_products_id_request()) -> result(post_products_id_response()).
post_products_id(Args) ->
    post_products_id(Args, #{}).

-spec post_products_id(post_products_id_request(), options()) ->
                          result(post_products_id_response()).
post_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, product},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_products_id(get_products_id_request()) -> result(get_products_id_response()).
get_products_id(Args) ->
    get_products_id(Args, #{}).

-spec get_products_id(get_products_id_request(), options()) ->
                         result(get_products_id_response()).
get_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, product},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_setup_intents_intent_verify_microdeposits(post_setup_intents_intent_verify_microdeposits_request()) ->
                                                      result(post_setup_intents_intent_verify_microdeposits_response()).
post_setup_intents_intent_verify_microdeposits(Args) ->
    post_setup_intents_intent_verify_microdeposits(Args, #{}).

-spec
    post_setup_intents_intent_verify_microdeposits(post_setup_intents_intent_verify_microdeposits_request(),
                                                   options()) ->
                                                      result(post_setup_intents_intent_verify_microdeposits_response()).
post_setup_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s/verify_microdeposits", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, setup_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_types(get_reporting_report_types_request()) ->
                                    result(get_reporting_report_types_response()).
get_reporting_report_types(Args) ->
    get_reporting_report_types(Args, #{}).

-spec get_reporting_report_types(get_reporting_report_types_request(), options()) ->
                                    result(get_reporting_report_types_response()).
get_reporting_report_types(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_types", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           reporting_report_type}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_external_accounts(post_account_external_accounts_request()) ->
                                        result(post_account_external_accounts_response()).
post_account_external_accounts(Args) ->
    post_account_external_accounts(Args, #{}).

-spec post_account_external_accounts(post_account_external_accounts_request(),
                                     options()) ->
                                        result(post_account_external_accounts_response()).
post_account_external_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_external_accounts(get_account_external_accounts_request()) ->
                                       result(get_account_external_accounts_response()).
get_account_external_accounts(Args) ->
    get_account_external_accounts(Args, #{}).

-spec get_account_external_accounts(get_account_external_accounts_request(), options()) ->
                                       result(get_account_external_accounts_response()).
get_account_external_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {one_of,
                                                                                           [{ref,
                                                                                             stripe,
                                                                                             bank_account},
                                                                                            {ref,
                                                                                             stripe,
                                                                                             card}]}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_lists(post_radar_value_lists_request()) ->
                                result(post_radar_value_lists_response()).
post_radar_value_lists(Args) ->
    post_radar_value_lists(Args, #{}).

-spec post_radar_value_lists(post_radar_value_lists_request(), options()) ->
                                result(post_radar_value_lists_response()).
post_radar_value_lists(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       radar_value_list},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_lists(get_radar_value_lists_request()) ->
                               result(get_radar_value_lists_response()).
get_radar_value_lists(Args) ->
    get_radar_value_lists(Args, #{}).

-spec get_radar_value_lists(get_radar_value_lists_request(), options()) ->
                               result(get_radar_value_lists_response()).
get_radar_value_lists(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({alias, Value}) ->
                encode_q(form, false, <<"alias">>, Value);
            ({contains, Value}) ->
                encode_q(form, false, <<"contains">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           radar_value_list}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_shipping_rates(post_shipping_rates_request()) ->
                             result(post_shipping_rates_response()).
post_shipping_rates(Args) ->
    post_shipping_rates(Args, #{}).

-spec post_shipping_rates(post_shipping_rates_request(), options()) ->
                             result(post_shipping_rates_response()).
post_shipping_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, shipping_rate},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_shipping_rates(get_shipping_rates_request()) ->
                            result(get_shipping_rates_response()).
get_shipping_rates(Args) ->
    get_shipping_rates(Args, #{}).

-spec get_shipping_rates(get_shipping_rates_request(), options()) ->
                            result(get_shipping_rates_response()).
get_shipping_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           shipping_rate}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_file_links_link(post_file_links_link_request()) ->
                              result(post_file_links_link_response()).
post_file_links_link(Args) ->
    post_file_links_link(Args, #{}).

-spec post_file_links_link(post_file_links_link_request(), options()) ->
                              result(post_file_links_link_response()).
post_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/file_links/~s", [VarLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, file_link},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_file_links_link(get_file_links_link_request()) ->
                             result(get_file_links_link_response()).
get_file_links_link(Args) ->
    get_file_links_link(Args, #{}).

-spec get_file_links_link(get_file_links_link_request(), options()) ->
                             result(get_file_links_link_response()).
get_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/file_links/~s", [VarLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, file_link},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get3d_secure_three_d_secure(get3d_secure_three_d_secure_request()) ->
                                     result(get3d_secure_three_d_secure_response()).
get3d_secure_three_d_secure(Args) ->
    get3d_secure_three_d_secure(Args, #{}).

-spec get3d_secure_three_d_secure(get3d_secure_three_d_secure_request(), options()) ->
                                     result(get3d_secure_three_d_secure_response()).
get3d_secure_three_d_secure(Args, Options) ->
    VarThreeDSecure = maps:get(three_d_secure, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/3d_secure/~s", [VarThreeDSecure]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, three_d_secure},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_send(post_invoices_invoice_send_request()) ->
                                    result(post_invoices_invoice_send_response()).
post_invoices_invoice_send(Args) ->
    post_invoices_invoice_send(Args, #{}).

-spec post_invoices_invoice_send(post_invoices_invoice_send_request(), options()) ->
                                    result(post_invoices_invoice_send_response()).
post_invoices_invoice_send(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/send", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_upcoming(get_invoices_upcoming_request()) ->
                               result(get_invoices_upcoming_response()).
get_invoices_upcoming(Args) ->
    get_invoices_upcoming(Args, #{}).

-spec get_invoices_upcoming(get_invoices_upcoming_request(), options()) ->
                               result(get_invoices_upcoming_response()).
get_invoices_upcoming(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({automatic_tax, Value}) ->
                encode_q(deepObject, true, <<"automatic_tax">>, Value);
            ({coupon, Value}) ->
                encode_q(form, false, <<"coupon">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({customer_details, Value}) ->
                encode_q(deepObject, true, <<"customer_details">>, Value);
            ({discounts, Value}) ->
                encode_q(deepObject, true, <<"discounts">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice_items, Value}) ->
                encode_q(deepObject, true, <<"invoice_items">>, Value);
            ({schedule, Value}) ->
                encode_q(form, false, <<"schedule">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({subscription_billing_cycle_anchor, Value}) ->
                encode_q(deepObject, true, <<"subscription_billing_cycle_anchor">>, Value);
            ({subscription_cancel_at, Value}) ->
                encode_q(deepObject, true, <<"subscription_cancel_at">>, Value);
            ({subscription_cancel_at_period_end, Value}) ->
                encode_q(form, false, <<"subscription_cancel_at_period_end">>, Value);
            ({subscription_cancel_now, Value}) ->
                encode_q(form, false, <<"subscription_cancel_now">>, Value);
            ({subscription_default_tax_rates, Value}) ->
                encode_q(deepObject, true, <<"subscription_default_tax_rates">>, Value);
            ({subscription_items, Value}) ->
                encode_q(deepObject, true, <<"subscription_items">>, Value);
            ({subscription_proration_behavior, Value}) ->
                encode_q(form, false, <<"subscription_proration_behavior">>, Value);
            ({subscription_proration_date, Value}) ->
                encode_q(form, false, <<"subscription_proration_date">>, Value);
            ({subscription_start_date, Value}) ->
                encode_q(form, false, <<"subscription_start_date">>, Value);
            ({subscription_trial_end, Value}) ->
                encode_q(deepObject, true, <<"subscription_trial_end">>, Value);
            ({subscription_trial_from_plan, Value}) ->
                encode_q(form, false, <<"subscription_trial_from_plan">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/upcoming", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_checkout_sessions_session_line_items(get_checkout_sessions_session_line_items_request()) ->
                                                result(get_checkout_sessions_session_line_items_response()).
get_checkout_sessions_session_line_items(Args) ->
    get_checkout_sessions_session_line_items(Args, #{}).

-spec
    get_checkout_sessions_session_line_items(get_checkout_sessions_session_line_items_request(),
                                             options()) ->
                                                result(get_checkout_sessions_session_line_items_response()).
get_checkout_sessions_session_line_items(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions/~s/line_items", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_codes(get_tax_codes_request()) -> result(get_tax_codes_response()).
get_tax_codes(Args) ->
    get_tax_codes(Args, #{}).

-spec get_tax_codes(get_tax_codes_request(), options()) ->
                       result(get_tax_codes_response()).
get_tax_codes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_codes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           tax_code}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices(post_invoices_request()) -> result(post_invoices_response()).
post_invoices(Args) ->
    post_invoices(Args, #{}).

-spec post_invoices(post_invoices_request(), options()) ->
                       result(post_invoices_response()).
post_invoices(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices(get_invoices_request()) -> result(get_invoices_response()).
get_invoices(Args) ->
    get_invoices(Args, #{}).

-spec get_invoices(get_invoices_request(), options()) -> result(get_invoices_response()).
get_invoices(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({collection_method, Value}) ->
                encode_q(form, false, <<"collection_method">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({due_date, Value}) ->
                encode_q(deepObject, true, <<"due_date">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           invoice}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge(post_charges_charge_request()) ->
                             result(post_charges_charge_response()).
post_charges_charge(Args) ->
    post_charges_charge(Args, #{}).

-spec post_charges_charge(post_charges_charge_request(), options()) ->
                             result(post_charges_charge_response()).
post_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, charge},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge(get_charges_charge_request()) ->
                            result(get_charges_charge_response()).
get_charges_charge(Args) ->
    get_charges_charge(Args, #{}).

-spec get_charges_charge(get_charges_charge_request(), options()) ->
                            result(get_charges_charge_response()).
get_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, charge},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_invoices_invoice_mark_uncollectible(post_invoices_invoice_mark_uncollectible_request()) ->
                                                result(post_invoices_invoice_mark_uncollectible_response()).
post_invoices_invoice_mark_uncollectible(Args) ->
    post_invoices_invoice_mark_uncollectible(Args, #{}).

-spec
    post_invoices_invoice_mark_uncollectible(post_invoices_invoice_mark_uncollectible_request(),
                                             options()) ->
                                                result(post_invoices_invoice_mark_uncollectible_response()).
post_invoices_invoice_mark_uncollectible(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/mark_uncollectible", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_sources_id_verify(post_customers_customer_sources_id_verify_request()) ->
                                                 result(post_customers_customer_sources_id_verify_response()).
post_customers_customer_sources_id_verify(Args) ->
    post_customers_customer_sources_id_verify(Args, #{}).

-spec
    post_customers_customer_sources_id_verify(post_customers_customer_sources_id_verify_request(),
                                              options()) ->
                                                 result(post_customers_customer_sources_id_verify_response()).
post_customers_customer_sources_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s/verify", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, bank_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id_pay(post_orders_id_pay_request()) ->
                            result(post_orders_id_pay_response()).
post_orders_id_pay(Args) ->
    post_orders_id_pay(Args, #{}).

-spec post_orders_id_pay(post_orders_id_pay_request(), options()) ->
                            result(post_orders_id_pay_response()).
post_orders_id_pay(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders/~s/pay", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, order},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_bank_accounts_id_verify(post_customers_customer_bank_accounts_id_verify_request()) ->
                                                       result(post_customers_customer_bank_accounts_id_verify_response()).
post_customers_customer_bank_accounts_id_verify(Args) ->
    post_customers_customer_bank_accounts_id_verify(Args, #{}).

-spec
    post_customers_customer_bank_accounts_id_verify(post_customers_customer_bank_accounts_id_verify_request(),
                                                    options()) ->
                                                       result(post_customers_customer_bank_accounts_id_verify_response()).
post_customers_customer_bank_accounts_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s/verify", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, bank_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_people_person(delete_account_people_person_request()) ->
                                      result(delete_account_people_person_response()).
delete_account_people_person(Args) ->
    delete_account_people_person(Args, #{}).

-spec delete_account_people_person(delete_account_people_person_request(), options()) ->
                                      result(delete_account_people_person_response()).
delete_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, deleted_person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_people_person(post_account_people_person_request()) ->
                                    result(post_account_people_person_response()).
post_account_people_person(Args) ->
    post_account_people_person(Args, #{}).

-spec post_account_people_person(post_account_people_person_request(), options()) ->
                                    result(post_account_people_person_response()).
post_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_people_person(get_account_people_person_request()) ->
                                   result(get_account_people_person_response()).
get_account_people_person(Args) ->
    get_account_people_person(Args, #{}).

-spec get_account_people_person(get_account_people_person_request(), options()) ->
                                   result(get_account_people_person_response()).
get_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_checkout_sessions(post_checkout_sessions_request()) ->
                                result(post_checkout_sessions_response()).
post_checkout_sessions(Args) ->
    post_checkout_sessions(Args, #{}).

-spec post_checkout_sessions(post_checkout_sessions_request(), options()) ->
                                result(post_checkout_sessions_response()).
post_checkout_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       checkout_session},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions(get_checkout_sessions_request()) ->
                               result(get_checkout_sessions_response()).
get_checkout_sessions(Args) ->
    get_checkout_sessions(Args, #{}).

-spec get_checkout_sessions(get_checkout_sessions_request(), options()) ->
                               result(get_checkout_sessions_response()).
get_checkout_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           checkout_session}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_login_links(post_accounts_account_login_links_request()) ->
                                           result(post_accounts_account_login_links_response()).
post_accounts_account_login_links(Args) ->
    post_accounts_account_login_links(Args, #{}).

-spec post_accounts_account_login_links(post_accounts_account_login_links_request(),
                                        options()) ->
                                           result(post_accounts_account_login_links_response()).
post_accounts_account_login_links(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/login_links", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, login_link},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_readers(post_terminal_readers_request()) ->
                               result(post_terminal_readers_response()).
post_terminal_readers(Args) ->
    post_terminal_readers(Args, #{}).

-spec post_terminal_readers(post_terminal_readers_request(), options()) ->
                               result(post_terminal_readers_response()).
post_terminal_readers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       terminal_reader},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_readers(get_terminal_readers_request()) ->
                              result(get_terminal_readers_response()).
get_terminal_readers(Args) ->
    get_terminal_readers(Args, #{}).

-spec get_terminal_readers(get_terminal_readers_request(), options()) ->
                              result(get_terminal_readers_response()).
get_terminal_readers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({device_type, Value}) ->
                encode_q(form, false, <<"device_type">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({location, Value}) ->
                encode_q(form, false, <<"location">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           terminal_reader}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes(post_issuing_disputes_request()) ->
                               result(post_issuing_disputes_response()).
post_issuing_disputes(Args) ->
    post_issuing_disputes(Args, #{}).

-spec post_issuing_disputes(post_issuing_disputes_request(), options()) ->
                               result(post_issuing_disputes_response()).
post_issuing_disputes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_disputes(get_issuing_disputes_request()) ->
                              result(get_issuing_disputes_response()).
get_issuing_disputes(Args) ->
    get_issuing_disputes(Args, #{}).

-spec get_issuing_disputes(get_issuing_disputes_request(), options()) ->
                              result(get_issuing_disputes_response()).
get_issuing_disputes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({transaction, Value}) ->
                encode_q(form, false, <<"transaction">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           issuing_dispute}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post3d_secure(post3d_secure_request()) -> result(post3d_secure_response()).
post3d_secure(Args) ->
    post3d_secure(Args, #{}).

-spec post3d_secure(post3d_secure_request(), options()) ->
                       result(post3d_secure_response()).
post3d_secure(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/3d_secure", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, three_d_secure},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_prices(post_prices_request()) -> result(post_prices_response()).
post_prices(Args) ->
    post_prices(Args, #{}).

-spec post_prices(post_prices_request(), options()) -> result(post_prices_response()).
post_prices(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/prices", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, price},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_prices(get_prices_request()) -> result(get_prices_response()).
get_prices(Args) ->
    get_prices(Args, #{}).

-spec get_prices(get_prices_request(), options()) -> result(get_prices_response()).
get_prices(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({lookup_keys, Value}) ->
                encode_q(deepObject, true, <<"lookup_keys">>, Value);
            ({product, Value}) ->
                encode_q(form, false, <<"product">>, Value);
            ({recurring, Value}) ->
                encode_q(deepObject, true, <<"recurring">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/prices", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           price}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_invoices_invoice(delete_invoices_invoice_request()) ->
                                 result(delete_invoices_invoice_response()).
delete_invoices_invoice(Args) ->
    delete_invoices_invoice(Args, #{}).

-spec delete_invoices_invoice(delete_invoices_invoice_request(), options()) ->
                                 result(delete_invoices_invoice_response()).
delete_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice(post_invoices_invoice_request()) ->
                               result(post_invoices_invoice_response()).
post_invoices_invoice(Args) ->
    post_invoices_invoice(Args, #{}).

-spec post_invoices_invoice(post_invoices_invoice_request(), options()) ->
                               result(post_invoices_invoice_response()).
post_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_invoice(get_invoices_invoice_request()) ->
                              result(get_invoices_invoice_response()).
get_invoices_invoice(Args) ->
    get_invoices_invoice(Args, #{}).

-spec get_invoices_invoice(get_invoices_invoice_request(), options()) ->
                              result(get_invoices_invoice_response()).
get_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_identity_verification_sessions_session(post_identity_verification_sessions_session_request()) ->
                                                   result(post_identity_verification_sessions_session_response()).
post_identity_verification_sessions_session(Args) ->
    post_identity_verification_sessions_session(Args, #{}).

-spec
    post_identity_verification_sessions_session(post_identity_verification_sessions_session_request(),
                                                options()) ->
                                                   result(post_identity_verification_sessions_session_response()).
post_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       identity_verification_session},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_identity_verification_sessions_session(get_identity_verification_sessions_session_request()) ->
                                                  result(get_identity_verification_sessions_session_response()).
get_identity_verification_sessions_session(Args) ->
    get_identity_verification_sessions_session(Args, #{}).

-spec
    get_identity_verification_sessions_session(get_identity_verification_sessions_session_request(),
                                               options()) ->
                                                  result(get_identity_verification_sessions_session_response()).
get_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       identity_verification_session},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_transactions_id(get_balance_transactions_id_request()) ->
                                     result(get_balance_transactions_id_response()).
get_balance_transactions_id(Args) ->
    get_balance_transactions_id(Args, #{}).

-spec get_balance_transactions_id(get_balance_transactions_id_request(), options()) ->
                                     result(get_balance_transactions_id_response()).
get_balance_transactions_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance_transactions/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       balance_transaction},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_cancel(post_setup_intents_intent_cancel_request()) ->
                                          result(post_setup_intents_intent_cancel_response()).
post_setup_intents_intent_cancel(Args) ->
    post_setup_intents_intent_cancel(Args, #{}).

-spec post_setup_intents_intent_cancel(post_setup_intents_intent_cancel_request(),
                                       options()) ->
                                          result(post_setup_intents_intent_cancel_response()).
post_setup_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s/cancel", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, setup_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_transactions_transaction(post_issuing_transactions_transaction_request()) ->
                                             result(post_issuing_transactions_transaction_response()).
post_issuing_transactions_transaction(Args) ->
    post_issuing_transactions_transaction(Args, #{}).

-spec
    post_issuing_transactions_transaction(post_issuing_transactions_transaction_request(),
                                          options()) ->
                                             result(post_issuing_transactions_transaction_response()).
post_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/transactions/~s", [VarTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_transaction},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_issuing_transactions_transaction(get_issuing_transactions_transaction_request()) ->
                                            result(get_issuing_transactions_transaction_response()).
get_issuing_transactions_transaction(Args) ->
    get_issuing_transactions_transaction(Args, #{}).

-spec get_issuing_transactions_transaction(get_issuing_transactions_transaction_request(),
                                           options()) ->
                                              result(get_issuing_transactions_transaction_response()).
get_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/transactions/~s", [VarTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_transaction},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_connection_tokens(post_terminal_connection_tokens_request()) ->
                                         result(post_terminal_connection_tokens_response()).
post_terminal_connection_tokens(Args) ->
    post_terminal_connection_tokens(Args, #{}).

-spec post_terminal_connection_tokens(post_terminal_connection_tokens_request(),
                                      options()) ->
                                         result(post_terminal_connection_tokens_response()).
post_terminal_connection_tokens(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/connection_tokens", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       terminal_connection_token},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reviews(get_reviews_request()) -> result(get_reviews_response()).
get_reviews(Args) ->
    get_reviews(Args, #{}).

-spec get_reviews(get_reviews_request(), options()) -> result(get_reviews_response()).
get_reviews(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reviews", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           review}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_promotion_codes(post_promotion_codes_request()) ->
                              result(post_promotion_codes_response()).
post_promotion_codes(Args) ->
    post_promotion_codes(Args, #{}).

-spec post_promotion_codes(post_promotion_codes_request(), options()) ->
                              result(post_promotion_codes_response()).
post_promotion_codes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, promotion_code},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_promotion_codes(get_promotion_codes_request()) ->
                             result(get_promotion_codes_response()).
get_promotion_codes(Args) ->
    get_promotion_codes(Args, #{}).

-spec get_promotion_codes(get_promotion_codes_request(), options()) ->
                             result(get_promotion_codes_response()).
get_promotion_codes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({code, Value}) ->
                encode_q(form, false, <<"code">>, Value);
            ({coupon, Value}) ->
                encode_q(form, false, <<"coupon">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           promotion_code}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(delete_customers_customer_subscriptions_subscription_exposed_id_discount_request()) ->
                                                                                result(delete_customers_customer_subscriptions_subscription_exposed_id_discount_response()).
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(delete_customers_customer_subscriptions_subscription_exposed_id_discount_request(),
                                                                             options()) ->
                                                                                result(delete_customers_customer_subscriptions_subscription_exposed_id_discount_response()).
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s/discount",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_discount},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_subscriptions_subscription_exposed_id_discount(get_customers_customer_subscriptions_subscription_exposed_id_discount_request()) ->
                                                                             result(get_customers_customer_subscriptions_subscription_exposed_id_discount_response()).
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec
    get_customers_customer_subscriptions_subscription_exposed_id_discount(get_customers_customer_subscriptions_subscription_exposed_id_discount_request(),
                                                                          options()) ->
                                                                             result(get_customers_customer_subscriptions_subscription_exposed_id_discount_response()).
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s/discount",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, discount},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_quotes_quote_computed_upfront_line_items(get_quotes_quote_computed_upfront_line_items_request()) ->
                                                    result(get_quotes_quote_computed_upfront_line_items_response()).
get_quotes_quote_computed_upfront_line_items(Args) ->
    get_quotes_quote_computed_upfront_line_items(Args, #{}).

-spec
    get_quotes_quote_computed_upfront_line_items(get_quotes_quote_computed_upfront_line_items_request(),
                                                 options()) ->
                                                    result(get_quotes_quote_computed_upfront_line_items_response()).
get_quotes_quote_computed_upfront_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/computed_upfront_line_items", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_radar_value_list_items_item(delete_radar_value_list_items_item_request()) ->
                                            result(delete_radar_value_list_items_item_response()).
delete_radar_value_list_items_item(Args) ->
    delete_radar_value_list_items_item(Args, #{}).

-spec delete_radar_value_list_items_item(delete_radar_value_list_items_item_request(),
                                         options()) ->
                                            result(delete_radar_value_list_items_item_response()).
delete_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_list_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_radar_value_list_item},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_list_items_item(get_radar_value_list_items_item_request()) ->
                                         result(get_radar_value_list_items_item_response()).
get_radar_value_list_items_item(Args) ->
    get_radar_value_list_items_item(Args, #{}).

-spec get_radar_value_list_items_item(get_radar_value_list_items_item_request(),
                                      options()) ->
                                         result(get_radar_value_list_items_item_response()).
get_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_list_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       radar_value_list_item},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuer_fraud_records(get_issuer_fraud_records_request()) ->
                                  result(get_issuer_fraud_records_response()).
get_issuer_fraud_records(Args) ->
    get_issuer_fraud_records(Args, #{}).

-spec get_issuer_fraud_records(get_issuer_fraud_records_request(), options()) ->
                                  result(get_issuer_fraud_records_response()).
get_issuer_fraud_records(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuer_fraud_records", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           issuer_fraud_record}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tax_rates_tax_rate(post_tax_rates_tax_rate_request()) ->
                                 result(post_tax_rates_tax_rate_response()).
post_tax_rates_tax_rate(Args) ->
    post_tax_rates_tax_rate(Args, #{}).

-spec post_tax_rates_tax_rate(post_tax_rates_tax_rate_request(), options()) ->
                                 result(post_tax_rates_tax_rate_response()).
post_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_rates/~s", [VarTaxRate]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, tax_rate},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_rates_tax_rate(get_tax_rates_tax_rate_request()) ->
                                result(get_tax_rates_tax_rate_response()).
get_tax_rates_tax_rate(Args) ->
    get_tax_rates_tax_rate(Args, #{}).

-spec get_tax_rates_tax_rate(get_tax_rates_tax_rate_request(), options()) ->
                                result(get_tax_rates_tax_rate_response()).
get_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_rates/~s", [VarTaxRate]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, tax_rate},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_recipients(post_recipients_request()) -> result(post_recipients_response()).
post_recipients(Args) ->
    post_recipients(Args, #{}).

-spec post_recipients(post_recipients_request(), options()) ->
                         result(post_recipients_response()).
post_recipients(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, recipient},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_recipients(get_recipients_request()) -> result(get_recipients_response()).
get_recipients(Args) ->
    get_recipients(Args, #{}).

-spec get_recipients(get_recipients_request(), options()) ->
                        result(get_recipients_response()).
get_recipients(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({verified, Value}) ->
                encode_q(form, false, <<"verified">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           recipient}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_plans(post_plans_request()) -> result(post_plans_response()).
post_plans(Args) ->
    post_plans(Args, #{}).

-spec post_plans(post_plans_request(), options()) -> result(post_plans_response()).
post_plans(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, plan},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_plans(get_plans_request()) -> result(get_plans_response()).
get_plans(Args) ->
    get_plans(Args, #{}).

-spec get_plans(get_plans_request(), options()) -> result(get_plans_response()).
get_plans(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({product, Value}) ->
                encode_q(form, false, <<"product">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           plan}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_balance_transactions(post_customers_customer_balance_transactions_request()) ->
                                                    result(post_customers_customer_balance_transactions_response()).
post_customers_customer_balance_transactions(Args) ->
    post_customers_customer_balance_transactions(Args, #{}).

-spec
    post_customers_customer_balance_transactions(post_customers_customer_balance_transactions_request(),
                                                 options()) ->
                                                    result(post_customers_customer_balance_transactions_response()).
post_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/balance_transactions", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       customer_balance_transaction},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_balance_transactions(get_customers_customer_balance_transactions_request()) ->
                                                   result(get_customers_customer_balance_transactions_response()).
get_customers_customer_balance_transactions(Args) ->
    get_customers_customer_balance_transactions(Args, #{}).

-spec
    get_customers_customer_balance_transactions(get_customers_customer_balance_transactions_request(),
                                                options()) ->
                                                   result(get_customers_customer_balance_transactions_response()).
get_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/balance_transactions", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           customer_balance_transaction}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_reviews_review_approve(post_reviews_review_approve_request()) ->
                                     result(post_reviews_review_approve_response()).
post_reviews_review_approve(Args) ->
    post_reviews_review_approve(Args, #{}).

-spec post_reviews_review_approve(post_reviews_review_approve_request(), options()) ->
                                     result(post_reviews_review_approve_response()).
post_reviews_review_approve(Args, Options) ->
    VarReview = maps:get(review, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reviews/~s/approve", [VarReview]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, review},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_tax_ids(post_customers_customer_tax_ids_request()) ->
                                         result(post_customers_customer_tax_ids_response()).
post_customers_customer_tax_ids(Args) ->
    post_customers_customer_tax_ids(Args, #{}).

-spec post_customers_customer_tax_ids(post_customers_customer_tax_ids_request(),
                                      options()) ->
                                         result(post_customers_customer_tax_ids_response()).
post_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, tax_id},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_tax_ids(get_customers_customer_tax_ids_request()) ->
                                        result(get_customers_customer_tax_ids_response()).
get_customers_customer_tax_ids(Args) ->
    get_customers_customer_tax_ids(Args, #{}).

-spec get_customers_customer_tax_ids(get_customers_customer_tax_ids_request(),
                                     options()) ->
                                        result(get_customers_customer_tax_ids_response()).
get_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           tax_id}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tokens_token(get_tokens_token_request()) -> result(get_tokens_token_response()).
get_tokens_token(Args) ->
    get_tokens_token(Args, #{}).

-spec get_tokens_token(get_tokens_token_request(), options()) ->
                          result(get_tokens_token_response()).
get_tokens_token(Args, Options) ->
    VarToken = maps:get(token, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tokens/~s", [VarToken]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, token},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_transactions(get_balance_transactions_request()) ->
                                  result(get_balance_transactions_response()).
get_balance_transactions(Args) ->
    get_balance_transactions(Args, #{}).

-spec get_balance_transactions(get_balance_transactions_request(), options()) ->
                                  result(get_balance_transactions_response()).
get_balance_transactions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payout, Value}) ->
                encode_q(form, false, <<"payout">>, Value);
            ({source, Value}) ->
                encode_q(form, false, <<"source">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance_transactions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           balance_transaction}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_codes_id(get_tax_codes_id_request()) -> result(get_tax_codes_id_response()).
get_tax_codes_id(Args) ->
    get_tax_codes_id(Args, #{}).

-spec get_tax_codes_id(get_tax_codes_id_request(), options()) ->
                          result(get_tax_codes_id_response()).
get_tax_codes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_codes/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, tax_code},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_reject(post_accounts_account_reject_request()) ->
                                      result(post_accounts_account_reject_response()).
post_accounts_account_reject(Args) ->
    post_accounts_account_reject(Args, #{}).

-spec post_accounts_account_reject(post_accounts_account_reject_request(), options()) ->
                                      result(post_accounts_account_reject_response()).
post_accounts_account_reject(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/reject", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_subscriptions_subscription_exposed_id(delete_subscriptions_subscription_exposed_id_request()) ->
                                                    result(delete_subscriptions_subscription_exposed_id_response()).
delete_subscriptions_subscription_exposed_id(Args) ->
    delete_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    delete_subscriptions_subscription_exposed_id(delete_subscriptions_subscription_exposed_id_request(),
                                                 options()) ->
                                                    result(delete_subscriptions_subscription_exposed_id_response()).
delete_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, subscription},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscriptions_subscription_exposed_id(post_subscriptions_subscription_exposed_id_request()) ->
                                                  result(post_subscriptions_subscription_exposed_id_response()).
post_subscriptions_subscription_exposed_id(Args) ->
    post_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    post_subscriptions_subscription_exposed_id(post_subscriptions_subscription_exposed_id_request(),
                                               options()) ->
                                                  result(post_subscriptions_subscription_exposed_id_response()).
post_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, subscription},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_subscriptions_subscription_exposed_id(get_subscriptions_subscription_exposed_id_request()) ->
                                                 result(get_subscriptions_subscription_exposed_id_response()).
get_subscriptions_subscription_exposed_id(Args) ->
    get_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    get_subscriptions_subscription_exposed_id(get_subscriptions_subscription_exposed_id_request(),
                                              options()) ->
                                                 result(get_subscriptions_subscription_exposed_id_response()).
get_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, subscription},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_country_specs_country(get_country_specs_country_request()) ->
                                   result(get_country_specs_country_response()).
get_country_specs_country(Args) ->
    get_country_specs_country(Args, #{}).

-spec get_country_specs_country(get_country_specs_country_request(), options()) ->
                                   result(get_country_specs_country_response()).
get_country_specs_country(Args, Options) ->
    VarCountry = maps:get(country, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/country_specs/~s", [VarCountry]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, country_spec},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_finalize(post_invoices_invoice_finalize_request()) ->
                                        result(post_invoices_invoice_finalize_response()).
post_invoices_invoice_finalize(Args) ->
    post_invoices_invoice_finalize(Args, #{}).

-spec post_invoices_invoice_finalize(post_invoices_invoice_finalize_request(),
                                     options()) ->
                                        result(post_invoices_invoice_finalize_response()).
post_invoices_invoice_finalize(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/finalize", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_terminal_locations_location(delete_terminal_locations_location_request()) ->
                                            result(delete_terminal_locations_location_response()).
delete_terminal_locations_location(Args) ->
    delete_terminal_locations_location(Args, #{}).

-spec delete_terminal_locations_location(delete_terminal_locations_location_request(),
                                         options()) ->
                                            result(delete_terminal_locations_location_response()).
delete_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_terminal_location},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_locations_location(post_terminal_locations_location_request()) ->
                                          result(post_terminal_locations_location_response()).
post_terminal_locations_location(Args) ->
    post_terminal_locations_location(Args, #{}).

-spec post_terminal_locations_location(post_terminal_locations_location_request(),
                                       options()) ->
                                          result(post_terminal_locations_location_response()).
post_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       terminal_location},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_locations_location(get_terminal_locations_location_request()) ->
                                         result(get_terminal_locations_location_response()).
get_terminal_locations_location(Args) ->
    get_terminal_locations_location(Args, #{}).

-spec get_terminal_locations_location(get_terminal_locations_location_request(),
                                      options()) ->
                                         result(get_terminal_locations_location_response()).
get_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       terminal_location},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account(delete_account_request()) -> result(delete_account_response()).
delete_account(Args) ->
    delete_account(Args, #{}).

-spec delete_account(delete_account_request(), options()) ->
                        result(delete_account_response()).
delete_account(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account(post_account_request()) -> result(post_account_response()).
post_account(Args) ->
    post_account(Args, #{}).

-spec post_account(post_account_request(), options()) -> result(post_account_response()).
post_account(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account(get_account_request()) -> result(get_account_response()).
get_account(Args) ->
    get_account(Args, #{}).

-spec get_account(get_account_request(), options()) -> result(get_account_response()).
get_account(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_shipping_rates_shipping_rate_token(post_shipping_rates_shipping_rate_token_request()) ->
                                               result(post_shipping_rates_shipping_rate_token_response()).
post_shipping_rates_shipping_rate_token(Args) ->
    post_shipping_rates_shipping_rate_token(Args, #{}).

-spec
    post_shipping_rates_shipping_rate_token(post_shipping_rates_shipping_rate_token_request(),
                                            options()) ->
                                               result(post_shipping_rates_shipping_rate_token_response()).
post_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/shipping_rates/~s", [VarShippingRateToken]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, shipping_rate},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_shipping_rates_shipping_rate_token(get_shipping_rates_shipping_rate_token_request()) ->
                                              result(get_shipping_rates_shipping_rate_token_response()).
get_shipping_rates_shipping_rate_token(Args) ->
    get_shipping_rates_shipping_rate_token(Args, #{}).

-spec
    get_shipping_rates_shipping_rate_token(get_shipping_rates_shipping_rate_token_request(),
                                           options()) ->
                                              result(get_shipping_rates_shipping_rate_token_response()).
get_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/shipping_rates/~s", [VarShippingRateToken]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, shipping_rate},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_upcoming_lines(get_invoices_upcoming_lines_request()) ->
                                     result(get_invoices_upcoming_lines_response()).
get_invoices_upcoming_lines(Args) ->
    get_invoices_upcoming_lines(Args, #{}).

-spec get_invoices_upcoming_lines(get_invoices_upcoming_lines_request(), options()) ->
                                     result(get_invoices_upcoming_lines_response()).
get_invoices_upcoming_lines(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({automatic_tax, Value}) ->
                encode_q(deepObject, true, <<"automatic_tax">>, Value);
            ({coupon, Value}) ->
                encode_q(form, false, <<"coupon">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({customer_details, Value}) ->
                encode_q(deepObject, true, <<"customer_details">>, Value);
            ({discounts, Value}) ->
                encode_q(deepObject, true, <<"discounts">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice_items, Value}) ->
                encode_q(deepObject, true, <<"invoice_items">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({schedule, Value}) ->
                encode_q(form, false, <<"schedule">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({subscription_billing_cycle_anchor, Value}) ->
                encode_q(deepObject, true, <<"subscription_billing_cycle_anchor">>, Value);
            ({subscription_cancel_at, Value}) ->
                encode_q(deepObject, true, <<"subscription_cancel_at">>, Value);
            ({subscription_cancel_at_period_end, Value}) ->
                encode_q(form, false, <<"subscription_cancel_at_period_end">>, Value);
            ({subscription_cancel_now, Value}) ->
                encode_q(form, false, <<"subscription_cancel_now">>, Value);
            ({subscription_default_tax_rates, Value}) ->
                encode_q(deepObject, true, <<"subscription_default_tax_rates">>, Value);
            ({subscription_items, Value}) ->
                encode_q(deepObject, true, <<"subscription_items">>, Value);
            ({subscription_proration_behavior, Value}) ->
                encode_q(form, false, <<"subscription_proration_behavior">>, Value);
            ({subscription_proration_date, Value}) ->
                encode_q(form, false, <<"subscription_proration_date">>, Value);
            ({subscription_start_date, Value}) ->
                encode_q(form, false, <<"subscription_start_date">>, Value);
            ({subscription_trial_end, Value}) ->
                encode_q(deepObject, true, <<"subscription_trial_end">>, Value);
            ({subscription_trial_from_plan, Value}) ->
                encode_q(form, false, <<"subscription_trial_from_plan">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/upcoming/lines", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           line_item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cardholders(post_issuing_cardholders_request()) ->
                                  result(post_issuing_cardholders_response()).
post_issuing_cardholders(Args) ->
    post_issuing_cardholders(Args, #{}).

-spec post_issuing_cardholders(post_issuing_cardholders_request(), options()) ->
                                  result(post_issuing_cardholders_response()).
post_issuing_cardholders(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_cardholder},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cardholders(get_issuing_cardholders_request()) ->
                                 result(get_issuing_cardholders_response()).
get_issuing_cardholders(Args) ->
    get_issuing_cardholders(Args, #{}).

-spec get_issuing_cardholders(get_issuing_cardholders_request(), options()) ->
                                 result(get_issuing_cardholders_response()).
get_issuing_cardholders(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({email, Value}) ->
                encode_q(form, false, <<"email">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({phone_number, Value}) ->
                encode_q(form, false, <<"phone_number">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           issuing_cardholder}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_sources_id(delete_customers_customer_sources_id_request()) ->
                                            result(delete_customers_customer_sources_id_response()).
delete_customers_customer_sources_id(Args) ->
    delete_customers_customer_sources_id(Args, #{}).

-spec delete_customers_customer_sources_id(delete_customers_customer_sources_id_request(),
                                           options()) ->
                                              result(delete_customers_customer_sources_id_response()).
delete_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref,
                                                                         stripe,
                                                                         payment_source},
                                                                        {ref,
                                                                         stripe,
                                                                         deleted_payment_source}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources_id(post_customers_customer_sources_id_request()) ->
                                            result(post_customers_customer_sources_id_response()).
post_customers_customer_sources_id(Args) ->
    post_customers_customer_sources_id(Args, #{}).

-spec post_customers_customer_sources_id(post_customers_customer_sources_id_request(),
                                         options()) ->
                                            result(post_customers_customer_sources_id_response()).
post_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref, stripe, card},
                                                                        {ref, stripe, bank_account},
                                                                        {ref, stripe, source}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_sources_id(get_customers_customer_sources_id_request()) ->
                                           result(get_customers_customer_sources_id_response()).
get_customers_customer_sources_id(Args) ->
    get_customers_customer_sources_id(Args, #{}).

-spec get_customers_customer_sources_id(get_customers_customer_sources_id_request(),
                                        options()) ->
                                           result(get_customers_customer_sources_id_response()).
get_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_source},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees(get_application_fees_request()) ->
                              result(get_application_fees_response()).
get_application_fees(Args) ->
    get_application_fees(Args, #{}).

-spec get_application_fees(get_application_fees_request(), options()) ->
                              result(get_application_fees_response()).
get_application_fees(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           application_fee}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers(get_bitcoin_receivers_request()) ->
                               result(get_bitcoin_receivers_response()).
get_bitcoin_receivers(Args) ->
    get_bitcoin_receivers(Args, #{}).

-spec get_bitcoin_receivers(get_bitcoin_receivers_request(), options()) ->
                               result(get_bitcoin_receivers_response()).
get_bitcoin_receivers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({filled, Value}) ->
                encode_q(form, false, <<"filled">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({uncaptured_funds, Value}) ->
                encode_q(form, false, <<"uncaptured_funds">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/bitcoin/receivers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           bitcoin_receiver}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_refunds_refund(post_refunds_refund_request()) ->
                             result(post_refunds_refund_response()).
post_refunds_refund(Args) ->
    post_refunds_refund(Args, #{}).

-spec post_refunds_refund(post_refunds_refund_request(), options()) ->
                             result(post_refunds_refund_response()).
post_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/refunds/~s", [VarRefund]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, refund},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_refunds_refund(get_refunds_refund_request()) ->
                            result(get_refunds_refund_response()).
get_refunds_refund(Args) ->
    get_refunds_refund(Args, #{}).

-spec get_refunds_refund(get_refunds_refund_request(), options()) ->
                            result(get_refunds_refund_response()).
get_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/refunds/~s", [VarRefund]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, refund},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_login_links(post_account_login_links_request()) ->
                                  result(post_account_login_links_response()).
post_account_login_links(Args) ->
    post_account_login_links(Args, #{}).

-spec post_account_login_links(post_account_login_links_request(), options()) ->
                                  result(post_account_login_links_response()).
post_account_login_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/login_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, login_link},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tax_rates(post_tax_rates_request()) -> result(post_tax_rates_response()).
post_tax_rates(Args) ->
    post_tax_rates(Args, #{}).

-spec post_tax_rates(post_tax_rates_request(), options()) ->
                        result(post_tax_rates_response()).
post_tax_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, tax_rate},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_rates(get_tax_rates_request()) -> result(get_tax_rates_response()).
get_tax_rates(Args) ->
    get_tax_rates(Args, #{}).

-spec get_tax_rates(get_tax_rates_request(), options()) ->
                       result(get_tax_rates_response()).
get_tax_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({inclusive, Value}) ->
                encode_q(form, false, <<"inclusive">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           tax_rate}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_people(post_accounts_account_people_request()) ->
                                      result(post_accounts_account_people_response()).
post_accounts_account_people(Args) ->
    post_accounts_account_people(Args, #{}).

-spec post_accounts_account_people(post_accounts_account_people_request(), options()) ->
                                      result(post_accounts_account_people_response()).
post_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, person},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_people(get_accounts_account_people_request()) ->
                                     result(get_accounts_account_people_response()).
get_accounts_account_people(Args) ->
    get_accounts_account_people(Args, #{}).

-spec get_accounts_account_people(get_accounts_account_people_request(), options()) ->
                                     result(get_accounts_account_people_response()).
get_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           person}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_disputes_dispute_submit(post_issuing_disputes_dispute_submit_request()) ->
                                            result(post_issuing_disputes_dispute_submit_response()).
post_issuing_disputes_dispute_submit(Args) ->
    post_issuing_disputes_dispute_submit(Args, #{}).

-spec post_issuing_disputes_dispute_submit(post_issuing_disputes_dispute_submit_request(),
                                           options()) ->
                                              result(post_issuing_disputes_dispute_submit_response()).
post_issuing_disputes_dispute_submit(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes/~s/submit", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources_source(post_sources_source_request()) ->
                             result(post_sources_source_response()).
post_sources_source(Args) ->
    post_sources_source(Args, #{}).

-spec post_sources_source(post_sources_source_request(), options()) ->
                             result(post_sources_source_response()).
post_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources/~s", [VarSource]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, source},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source(get_sources_source_request()) ->
                            result(get_sources_source_response()).
get_sources_source(Args) ->
    get_sources_source(Args, #{}).

-spec get_sources_source(get_sources_source_request(), options()) ->
                            result(get_sources_source_response()).
get_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({client_secret, Value}) ->
                encode_q(form, false, <<"client_secret">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources/~s", [VarSource]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, source},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions_session(get_checkout_sessions_session_request()) ->
                                       result(get_checkout_sessions_session_response()).
get_checkout_sessions_session(Args) ->
    get_checkout_sessions_session(Args, #{}).

-spec get_checkout_sessions_session(get_checkout_sessions_session_request(), options()) ->
                                       result(get_checkout_sessions_session_response()).
get_checkout_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions/~s", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       checkout_session},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_methods_payment_method_detach(post_payment_methods_payment_method_detach_request()) ->
                                                  result(post_payment_methods_payment_method_detach_response()).
post_payment_methods_payment_method_detach(Args) ->
    post_payment_methods_payment_method_detach(Args, #{}).

-spec
    post_payment_methods_payment_method_detach(post_payment_methods_payment_method_detach_request(),
                                               options()) ->
                                                  result(post_payment_methods_payment_method_detach_response()).
post_payment_methods_payment_method_detach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods/~s/detach", [VarPaymentMethod]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_method},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers(post_customers_request()) -> result(post_customers_response()).
post_customers(Args) ->
    post_customers(Args, #{}).

-spec post_customers(post_customers_request(), options()) ->
                        result(post_customers_response()).
post_customers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, customer},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers(get_customers_request()) -> result(get_customers_response()).
get_customers(Args) ->
    get_customers(Args, #{}).

-spec get_customers(get_customers_request(), options()) ->
                       result(get_customers_response()).
get_customers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({email, Value}) ->
                encode_q(form, false, <<"email">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           customer}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_bank_accounts(post_account_bank_accounts_request()) ->
                                    result(post_account_bank_accounts_response()).
post_account_bank_accounts(Args) ->
    post_account_bank_accounts(Args, #{}).

-spec post_account_bank_accounts(post_account_bank_accounts_request(), options()) ->
                                    result(post_account_bank_accounts_response()).
post_account_bank_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/bank_accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       external_account},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes_dispute(post_issuing_disputes_dispute_request()) ->
                                       result(post_issuing_disputes_dispute_response()).
post_issuing_disputes_dispute(Args) ->
    post_issuing_disputes_dispute(Args, #{}).

-spec post_issuing_disputes_dispute(post_issuing_disputes_dispute_request(), options()) ->
                                       result(post_issuing_disputes_dispute_response()).
post_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes/~s", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_disputes_dispute(get_issuing_disputes_dispute_request()) ->
                                      result(get_issuing_disputes_dispute_response()).
get_issuing_disputes_dispute(Args) ->
    get_issuing_disputes_dispute(Args, #{}).

-spec get_issuing_disputes_dispute(get_issuing_disputes_dispute_request(), options()) ->
                                      result(get_issuing_disputes_dispute_response()).
get_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes/~s", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_disputes_dispute_close(post_disputes_dispute_close_request()) ->
                                     result(post_disputes_dispute_close_response()).
post_disputes_dispute_close(Args) ->
    post_disputes_dispute_close(Args, #{}).

-spec post_disputes_dispute_close(post_disputes_dispute_close_request(), options()) ->
                                     result(post_disputes_dispute_close_response()).
post_disputes_dispute_close(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/disputes/~s/close", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_cancel(post_quotes_quote_cancel_request()) ->
                                  result(post_quotes_quote_cancel_response()).
post_quotes_quote_cancel(Args) ->
    post_quotes_quote_cancel(Args, #{}).

-spec post_quotes_quote_cancel(post_quotes_quote_cancel_request(), options()) ->
                                  result(post_quotes_quote_cancel_response()).
post_quotes_quote_cancel(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/cancel", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, quote},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_payment_methods(get_customers_customer_payment_methods_request()) ->
                                              result(get_customers_customer_payment_methods_response()).
get_customers_customer_payment_methods(Args) ->
    get_customers_customer_payment_methods(Args, #{}).

-spec
    get_customers_customer_payment_methods(get_customers_customer_payment_methods_request(),
                                           options()) ->
                                              result(get_customers_customer_payment_methods_response()).
get_customers_customer_payment_methods(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/payment_methods", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           payment_method}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_refunds(post_refunds_request()) -> result(post_refunds_response()).
post_refunds(Args) ->
    post_refunds(Args, #{}).

-spec post_refunds(post_refunds_request(), options()) -> result(post_refunds_response()).
post_refunds(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/refunds", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, refund},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_refunds(get_refunds_request()) -> result(get_refunds_response()).
get_refunds(Args) ->
    get_refunds(Args, #{}).

-spec get_refunds(get_refunds_request(), options()) -> result(get_refunds_response()).
get_refunds(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/refunds", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           refund}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes_id(post_credit_notes_id_request()) ->
                              result(post_credit_notes_id_response()).
post_credit_notes_id(Args) ->
    post_credit_notes_id(Args, #{}).

-spec post_credit_notes_id(post_credit_notes_id_request(), options()) ->
                              result(post_credit_notes_id_response()).
post_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, credit_note},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_id(get_credit_notes_id_request()) ->
                             result(get_credit_notes_id_response()).
get_credit_notes_id(Args) ->
    get_credit_notes_id(Args, #{}).

-spec get_credit_notes_id(get_credit_notes_id_request(), options()) ->
                             result(get_credit_notes_id_response()).
get_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, credit_note},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_transactions(get_bitcoin_transactions_request()) ->
                                  result(get_bitcoin_transactions_response()).
get_bitcoin_transactions(Args) ->
    get_bitcoin_transactions(Args, #{}).

-spec get_bitcoin_transactions(get_bitcoin_transactions_request(), options()) ->
                                  result(get_bitcoin_transactions_response()).
get_bitcoin_transactions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({receiver, Value}) ->
                encode_q(form, false, <<"receiver">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/bitcoin/transactions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           bitcoin_transaction}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents(post_setup_intents_request()) ->
                            result(post_setup_intents_response()).
post_setup_intents(Args) ->
    post_setup_intents(Args, #{}).

-spec post_setup_intents(post_setup_intents_request(), options()) ->
                            result(post_setup_intents_response()).
post_setup_intents(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, setup_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_intents(get_setup_intents_request()) ->
                           result(get_setup_intents_response()).
get_setup_intents(Args) ->
    get_setup_intents(Args, #{}).

-spec get_setup_intents(get_setup_intents_request(), options()) ->
                           result(get_setup_intents_response()).
get_setup_intents(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_method, Value}) ->
                encode_q(form, false, <<"payment_method">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           setup_intent}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout_cancel(post_payouts_payout_cancel_request()) ->
                                    result(post_payouts_payout_cancel_response()).
post_payouts_payout_cancel(Args) ->
    post_payouts_payout_cancel(Args, #{}).

-spec post_payouts_payout_cancel(post_payouts_payout_cancel_request(), options()) ->
                                    result(post_payouts_payout_cancel_response()).
post_payouts_payout_cancel(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts/~s/cancel", [VarPayout]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payout},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_authorizations_authorization_approve(post_issuing_authorizations_authorization_approve_request()) ->
                                                         result(post_issuing_authorizations_authorization_approve_response()).
post_issuing_authorizations_authorization_approve(Args) ->
    post_issuing_authorizations_authorization_approve(Args, #{}).

-spec
    post_issuing_authorizations_authorization_approve(post_issuing_authorizations_authorization_approve_request(),
                                                      options()) ->
                                                         result(post_issuing_authorizations_authorization_approve_response()).
post_issuing_authorizations_authorization_approve(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s/approve", [VarAuthorization]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_authorization},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_authorizations_authorization_decline(post_issuing_authorizations_authorization_decline_request()) ->
                                                         result(post_issuing_authorizations_authorization_decline_response()).
post_issuing_authorizations_authorization_decline(Args) ->
    post_issuing_authorizations_authorization_decline(Args, #{}).

-spec
    post_issuing_authorizations_authorization_decline(post_issuing_authorizations_authorization_decline_request(),
                                                      options()) ->
                                                         result(post_issuing_authorizations_authorization_decline_response()).
post_issuing_authorizations_authorization_decline(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s/decline", [VarAuthorization]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_authorization},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_reporting_report_runs(post_reporting_report_runs_request()) ->
                                    result(post_reporting_report_runs_response()).
post_reporting_report_runs(Args) ->
    post_reporting_report_runs(Args, #{}).

-spec post_reporting_report_runs(post_reporting_report_runs_request(), options()) ->
                                    result(post_reporting_report_runs_response()).
post_reporting_report_runs(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       reporting_report_run},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_runs(get_reporting_report_runs_request()) ->
                                   result(get_reporting_report_runs_response()).
get_reporting_report_runs(Args) ->
    get_reporting_report_runs(Args, #{}).

-spec get_reporting_report_runs(get_reporting_report_runs_request(), options()) ->
                                   result(get_reporting_report_runs_response()).
get_reporting_report_runs(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           reporting_report_run}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_void(post_invoices_invoice_void_request()) ->
                                    result(post_invoices_invoice_void_response()).
post_invoices_invoice_void(Args) ->
    post_invoices_invoice_void(Args, #{}).

-spec post_invoices_invoice_void(post_invoices_invoice_void_request(), options()) ->
                                    result(post_invoices_invoice_void_response()).
post_invoices_invoice_void(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/void", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoice},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources(post_sources_request()) -> result(post_sources_response()).
post_sources(Args) ->
    post_sources(Args, #{}).

-spec post_sources(post_sources_request(), options()) -> result(post_sources_response()).
post_sources(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, source},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_configurations(post_billing_portal_configurations_request()) ->
                                            result(post_billing_portal_configurations_response()).
post_billing_portal_configurations(Args) ->
    post_billing_portal_configurations(Args, #{}).

-spec post_billing_portal_configurations(post_billing_portal_configurations_request(),
                                         options()) ->
                                            result(post_billing_portal_configurations_response()).
post_billing_portal_configurations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       billing_portal_configuration},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_billing_portal_configurations(get_billing_portal_configurations_request()) ->
                                           result(get_billing_portal_configurations_response()).
get_billing_portal_configurations(Args) ->
    get_billing_portal_configurations(Args, #{}).

-spec get_billing_portal_configurations(get_billing_portal_configurations_request(),
                                        options()) ->
                                           result(get_billing_portal_configurations_response()).
get_billing_portal_configurations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({is_default, Value}) ->
                encode_q(form, false, <<"is_default">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           billing_portal_configuration}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes(post_quotes_request()) -> result(post_quotes_response()).
post_quotes(Args) ->
    post_quotes(Args, #{}).

-spec post_quotes(post_quotes_request(), options()) -> result(post_quotes_response()).
post_quotes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, quote},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes(get_quotes_request()) -> result(get_quotes_response()).
get_quotes(Args) ->
    get_quotes(Args, #{}).

-spec get_quotes(get_quotes_request(), options()) -> result(get_quotes_response()).
get_quotes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           quote}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_transfer(post_transfers_transfer_request()) ->
                                 result(post_transfers_transfer_response()).
post_transfers_transfer(Args) ->
    post_transfers_transfer(Args, #{}).

-spec post_transfers_transfer(post_transfers_transfer_request(), options()) ->
                                 result(post_transfers_transfer_response()).
post_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s", [VarTransfer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, transfer},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_transfer(get_transfers_transfer_request()) ->
                                result(get_transfers_transfer_response()).
get_transfers_transfer(Args) ->
    get_transfers_transfer(Args, #{}).

-spec get_transfers_transfer(get_transfers_transfer_request(), options()) ->
                                result(get_transfers_transfer_response()).
get_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s", [VarTransfer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, transfer},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_line_items(get_quotes_quote_line_items_request()) ->
                                     result(get_quotes_quote_line_items_response()).
get_quotes_quote_line_items(Args) ->
    get_quotes_quote_line_items(Args, #{}).

-spec get_quotes_quote_line_items(get_quotes_quote_line_items_request(), options()) ->
                                     result(get_quotes_quote_line_items_response()).
get_quotes_quote_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/line_items", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_invoiceitems_invoiceitem(delete_invoiceitems_invoiceitem_request()) ->
                                         result(delete_invoiceitems_invoiceitem_response()).
delete_invoiceitems_invoiceitem(Args) ->
    delete_invoiceitems_invoiceitem(Args, #{}).

-spec delete_invoiceitems_invoiceitem(delete_invoiceitems_invoiceitem_request(),
                                      options()) ->
                                         result(delete_invoiceitems_invoiceitem_response()).
delete_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_invoiceitem},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoiceitems_invoiceitem(post_invoiceitems_invoiceitem_request()) ->
                                       result(post_invoiceitems_invoiceitem_response()).
post_invoiceitems_invoiceitem(Args) ->
    post_invoiceitems_invoiceitem(Args, #{}).

-spec post_invoiceitems_invoiceitem(post_invoiceitems_invoiceitem_request(), options()) ->
                                       result(post_invoiceitems_invoiceitem_response()).
post_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoiceitem},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoiceitems_invoiceitem(get_invoiceitems_invoiceitem_request()) ->
                                      result(get_invoiceitems_invoiceitem_response()).
get_invoiceitems_invoiceitem(Args) ->
    get_invoiceitems_invoiceitem(Args, #{}).

-spec get_invoiceitems_invoiceitem(get_invoiceitems_invoiceitem_request(), options()) ->
                                      result(get_invoiceitems_invoiceitem_response()).
get_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, invoiceitem},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_intents_intent_capture(post_payment_intents_intent_capture_request()) ->
                                           result(post_payment_intents_intent_capture_response()).
post_payment_intents_intent_capture(Args) ->
    post_payment_intents_intent_capture(Args, #{}).

-spec post_payment_intents_intent_capture(post_payment_intents_intent_capture_request(),
                                          options()) ->
                                             result(post_payment_intents_intent_capture_response()).
post_payment_intents_intent_capture(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s/capture", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cards(post_issuing_cards_request()) ->
                            result(post_issuing_cards_response()).
post_issuing_cards(Args) ->
    post_issuing_cards(Args, #{}).

-spec post_issuing_cards(post_issuing_cards_request(), options()) ->
                            result(post_issuing_cards_response()).
post_issuing_cards(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, issuing_card},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cards(get_issuing_cards_request()) ->
                           result(get_issuing_cards_response()).
get_issuing_cards(Args) ->
    get_issuing_cards(Args, #{}).

-spec get_issuing_cards(get_issuing_cards_request(), options()) ->
                           result(get_issuing_cards_response()).
get_issuing_cards(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({cardholder, Value}) ->
                encode_q(form, false, <<"cardholder">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({exp_month, Value}) ->
                encode_q(form, false, <<"exp_month">>, Value);
            ({exp_year, Value}) ->
                encode_q(form, false, <<"exp_year">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({last4, Value}) ->
                encode_q(form, false, <<"last4">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           issuing_card}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_sources_source_source_transactions(get_sources_source_source_transactions_request()) ->
                                              result(get_sources_source_source_transactions_response()).
get_sources_source_source_transactions(Args) ->
    get_sources_source_source_transactions(Args, #{}).

-spec
    get_sources_source_source_transactions(get_sources_source_source_transactions_request(),
                                           options()) ->
                                              result(get_sources_source_source_transactions_response()).
get_sources_source_source_transactions(Args, Options) ->
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources/~s/source_transactions", [VarSource]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           source_transaction}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscription_schedules_schedule_release(post_subscription_schedules_schedule_release_request()) ->
                                                    result(post_subscription_schedules_schedule_release_response()).
post_subscription_schedules_schedule_release(Args) ->
    post_subscription_schedules_schedule_release(Args, #{}).

-spec
    post_subscription_schedules_schedule_release(post_subscription_schedules_schedule_release_request(),
                                                 options()) ->
                                                    result(post_subscription_schedules_schedule_release_response()).
post_subscription_schedules_schedule_release(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules/~s/release", [VarSchedule]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       subscription_schedule},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_cards_id(delete_customers_customer_cards_id_request()) ->
                                            result(delete_customers_customer_cards_id_response()).
delete_customers_customer_cards_id(Args) ->
    delete_customers_customer_cards_id(Args, #{}).

-spec delete_customers_customer_cards_id(delete_customers_customer_cards_id_request(),
                                         options()) ->
                                            result(delete_customers_customer_cards_id_response()).
delete_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref,
                                                                         stripe,
                                                                         payment_source},
                                                                        {ref,
                                                                         stripe,
                                                                         deleted_payment_source}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_cards_id(post_customers_customer_cards_id_request()) ->
                                          result(post_customers_customer_cards_id_response()).
post_customers_customer_cards_id(Args) ->
    post_customers_customer_cards_id(Args, #{}).

-spec post_customers_customer_cards_id(post_customers_customer_cards_id_request(),
                                       options()) ->
                                          result(post_customers_customer_cards_id_response()).
post_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref, stripe, card},
                                                                        {ref, stripe, bank_account},
                                                                        {ref, stripe, source}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_cards_id(get_customers_customer_cards_id_request()) ->
                                         result(get_customers_customer_cards_id_response()).
get_customers_customer_cards_id(Args) ->
    get_customers_customer_cards_id(Args, #{}).

-spec get_customers_customer_cards_id(get_customers_customer_cards_id_request(),
                                      options()) ->
                                         result(get_customers_customer_cards_id_response()).
get_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, card},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_dispute(post_charges_charge_dispute_request()) ->
                                     result(post_charges_charge_dispute_response()).
post_charges_charge_dispute(Args) ->
    post_charges_charge_dispute(Args, #{}).

-spec post_charges_charge_dispute(post_charges_charge_dispute_request(), options()) ->
                                     result(post_charges_charge_dispute_response()).
post_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/dispute", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_dispute(get_charges_charge_dispute_request()) ->
                                    result(get_charges_charge_dispute_response()).
get_charges_charge_dispute(Args) ->
    get_charges_charge_dispute(Args, #{}).

-spec get_charges_charge_dispute(get_charges_charge_dispute_request(), options()) ->
                                    result(get_charges_charge_dispute_response()).
get_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/dispute", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_finalize(post_quotes_quote_finalize_request()) ->
                                    result(post_quotes_quote_finalize_response()).
post_quotes_quote_finalize(Args) ->
    post_quotes_quote_finalize(Args, #{}).

-spec post_quotes_quote_finalize(post_quotes_quote_finalize_request(), options()) ->
                                    result(post_quotes_quote_finalize_response()).
post_quotes_quote_finalize(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/finalize", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, quote},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_skus_id(delete_skus_id_request()) -> result(delete_skus_id_response()).
delete_skus_id(Args) ->
    delete_skus_id(Args, #{}).

-spec delete_skus_id(delete_skus_id_request(), options()) ->
                        result(delete_skus_id_response()).
delete_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, deleted_sku},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_skus_id(post_skus_id_request()) -> result(post_skus_id_response()).
post_skus_id(Args) ->
    post_skus_id(Args, #{}).

-spec post_skus_id(post_skus_id_request(), options()) -> result(post_skus_id_response()).
post_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, sku},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_skus_id(get_skus_id_request()) -> result(get_skus_id_response()).
get_skus_id(Args) ->
    get_skus_id(Args, #{}).

-spec get_skus_id(get_skus_id_request(), options()) -> result(get_skus_id_response()).
get_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref, stripe, sku},
                                                                        {ref,
                                                                         stripe,
                                                                         deleted_sku}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_disputes_dispute(post_disputes_dispute_request()) ->
                               result(post_disputes_dispute_response()).
post_disputes_dispute(Args) ->
    post_disputes_dispute(Args, #{}).

-spec post_disputes_dispute(post_disputes_dispute_request(), options()) ->
                               result(post_disputes_dispute_response()).
post_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/disputes/~s", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_disputes_dispute(get_disputes_dispute_request()) ->
                              result(get_disputes_dispute_response()).
get_disputes_dispute(Args) ->
    get_disputes_dispute(Args, #{}).

-spec get_disputes_dispute(get_disputes_dispute_request(), options()) ->
                              result(get_disputes_dispute_response()).
get_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/disputes/~s", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, dispute},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_locations(post_terminal_locations_request()) ->
                                 result(post_terminal_locations_response()).
post_terminal_locations(Args) ->
    post_terminal_locations(Args, #{}).

-spec post_terminal_locations(post_terminal_locations_request(), options()) ->
                                 result(post_terminal_locations_response()).
post_terminal_locations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       terminal_location},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_locations(get_terminal_locations_request()) ->
                                result(get_terminal_locations_response()).
get_terminal_locations(Args) ->
    get_terminal_locations(Args, #{}).

-spec get_terminal_locations(get_terminal_locations_request(), options()) ->
                                result(get_terminal_locations_response()).
get_terminal_locations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           terminal_location}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules(post_subscription_schedules_request()) ->
                                     result(post_subscription_schedules_response()).
post_subscription_schedules(Args) ->
    post_subscription_schedules(Args, #{}).

-spec post_subscription_schedules(post_subscription_schedules_request(), options()) ->
                                     result(post_subscription_schedules_response()).
post_subscription_schedules(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       subscription_schedule},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_schedules(get_subscription_schedules_request()) ->
                                    result(get_subscription_schedules_response()).
get_subscription_schedules(Args) ->
    get_subscription_schedules(Args, #{}).

-spec get_subscription_schedules(get_subscription_schedules_request(), options()) ->
                                    result(get_subscription_schedules_response()).
get_subscription_schedules(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({canceled_at, Value}) ->
                encode_q(deepObject, true, <<"canceled_at">>, Value);
            ({completed_at, Value}) ->
                encode_q(deepObject, true, <<"completed_at">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({released_at, Value}) ->
                encode_q(deepObject, true, <<"released_at">>, Value);
            ({scheduled, Value}) ->
                encode_q(form, false, <<"scheduled">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           subscription_schedule}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_links(post_payment_links_request()) ->
                            result(post_payment_links_response()).
post_payment_links(Args) ->
    post_payment_links(Args, #{}).

-spec post_payment_links(post_payment_links_request(), options()) ->
                            result(post_payment_links_response()).
post_payment_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_link},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links(get_payment_links_request()) ->
                           result(get_payment_links_response()).
get_payment_links(Args) ->
    get_payment_links(Args, #{}).

-spec get_payment_links(get_payment_links_request(), options()) ->
                           result(get_payment_links_response()).
get_payment_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           payment_link}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tokens(post_tokens_request()) -> result(post_tokens_response()).
post_tokens(Args) ->
    post_tokens(Args, #{}).

-spec post_tokens(post_tokens_request(), options()) -> result(post_tokens_response()).
post_tokens(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tokens", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, token},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_cardholders_cardholder(post_issuing_cardholders_cardholder_request()) ->
                                           result(post_issuing_cardholders_cardholder_response()).
post_issuing_cardholders_cardholder(Args) ->
    post_issuing_cardholders_cardholder(Args, #{}).

-spec post_issuing_cardholders_cardholder(post_issuing_cardholders_cardholder_request(),
                                          options()) ->
                                             result(post_issuing_cardholders_cardholder_response()).
post_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cardholders/~s", [VarCardholder]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_cardholder},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cardholders_cardholder(get_issuing_cardholders_cardholder_request()) ->
                                            result(get_issuing_cardholders_cardholder_response()).
get_issuing_cardholders_cardholder(Args) ->
    get_issuing_cardholders_cardholder(Args, #{}).

-spec get_issuing_cardholders_cardholder(get_issuing_cardholders_cardholder_request(),
                                         options()) ->
                                            result(get_issuing_cardholders_cardholder_response()).
get_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cardholders/~s", [VarCardholder]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       issuing_cardholder},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_id(get_application_fees_id_request()) ->
                                 result(get_application_fees_id_response()).
get_application_fees_id(Args) ->
    get_application_fees_id(Args, #{}).

-spec get_application_fees_id(get_application_fees_id_request(), options()) ->
                                 result(get_application_fees_id_response()).
get_application_fees_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       application_fee},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_exchange_rates_rate_id(get_exchange_rates_rate_id_request()) ->
                                    result(get_exchange_rates_rate_id_response()).
get_exchange_rates_rate_id(Args) ->
    get_exchange_rates_rate_id(Args, #{}).

-spec get_exchange_rates_rate_id(get_exchange_rates_rate_id_request(), options()) ->
                                    result(get_exchange_rates_rate_id_response()).
get_exchange_rates_rate_id(Args, Options) ->
    VarRateId = maps:get(rate_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/exchange_rates/~s", [VarRateId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, exchange_rate},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_intents_intent_confirm(post_payment_intents_intent_confirm_request()) ->
                                           result(post_payment_intents_intent_confirm_response()).
post_payment_intents_intent_confirm(Args) ->
    post_payment_intents_intent_confirm(Args, #{}).

-spec post_payment_intents_intent_confirm(post_payment_intents_intent_confirm_request(),
                                          options()) ->
                                             result(post_payment_intents_intent_confirm_response()).
post_payment_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s/confirm", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_intent},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_preview(get_credit_notes_preview_request()) ->
                                  result(get_credit_notes_preview_response()).
get_credit_notes_preview(Args) ->
    get_credit_notes_preview(Args, #{}).

-spec get_credit_notes_preview(get_credit_notes_preview_request(), options()) ->
                                  result(get_credit_notes_preview_response()).
get_credit_notes_preview(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({amount, Value}) ->
                encode_q(form, false, <<"amount">>, Value);
            ({credit_amount, Value}) ->
                encode_q(form, false, <<"credit_amount">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({lines, Value}) ->
                encode_q(deepObject, true, <<"lines">>, Value);
            ({memo, Value}) ->
                encode_q(form, false, <<"memo">>, Value);
            ({metadata, Value}) ->
                encode_q(deepObject, true, <<"metadata">>, Value);
            ({out_of_band_amount, Value}) ->
                encode_q(form, false, <<"out_of_band_amount">>, Value);
            ({reason, Value}) ->
                encode_q(form, false, <<"reason">>, Value);
            ({refund, Value}) ->
                encode_q(form, false, <<"refund">>, Value);
            ({refund_amount, Value}) ->
                encode_q(form, false, <<"refund_amount">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/preview", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, credit_note},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_history_id(get_balance_history_id_request()) ->
                                result(get_balance_history_id_response()).
get_balance_history_id(Args) ->
    get_balance_history_id(Args, #{}).

-spec get_balance_history_id(get_balance_history_id_request(), options()) ->
                                result(get_balance_history_id_response()).
get_balance_history_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance/history/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       balance_transaction},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout_reverse(post_payouts_payout_reverse_request()) ->
                                     result(post_payouts_payout_reverse_response()).
post_payouts_payout_reverse(Args) ->
    post_payouts_payout_reverse(Args, #{}).

-spec post_payouts_payout_reverse(post_payouts_payout_reverse_request(), options()) ->
                                     result(post_payouts_payout_reverse_response()).
post_payouts_payout_reverse(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts/~s/reverse", [VarPayout]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payout},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_reporting_report_runs_report_run(get_reporting_report_runs_report_run_request()) ->
                                            result(get_reporting_report_runs_report_run_response()).
get_reporting_report_runs_report_run(Args) ->
    get_reporting_report_runs_report_run(Args, #{}).

-spec get_reporting_report_runs_report_run(get_reporting_report_runs_report_run_request(),
                                           options()) ->
                                              result(get_reporting_report_runs_report_run_response()).
get_reporting_report_runs_report_run(Args, Options) ->
    VarReportRun = maps:get(report_run, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_runs/~s", [VarReportRun]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       reporting_report_run},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_sources_source_source_transactions_source_transaction(get_sources_source_source_transactions_source_transaction_request()) ->
                                                                 result(get_sources_source_source_transactions_source_transaction_response()).
get_sources_source_source_transactions_source_transaction(Args) ->
    get_sources_source_source_transactions_source_transaction(Args, #{}).

-spec
    get_sources_source_source_transactions_source_transaction(get_sources_source_source_transactions_source_transaction_request(),
                                                              options()) ->
                                                                 result(get_sources_source_source_transactions_source_transaction_response()).
get_sources_source_source_transactions_source_transaction(Args, Options) ->
    VarSource = maps:get(source, Args),
    VarSourceTransaction = maps:get(source_transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/sources/~s/source_transactions/~s", [VarSource, VarSourceTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       source_transaction},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer(delete_customers_customer_request()) ->
                                   result(delete_customers_customer_response()).
delete_customers_customer(Args) ->
    delete_customers_customer(Args, #{}).

-spec delete_customers_customer(delete_customers_customer_request(), options()) ->
                                   result(delete_customers_customer_response()).
delete_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       deleted_customer},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer(post_customers_customer_request()) ->
                                 result(post_customers_customer_response()).
post_customers_customer(Args) ->
    post_customers_customer(Args, #{}).

-spec post_customers_customer(post_customers_customer_request(), options()) ->
                                 result(post_customers_customer_response()).
post_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, customer},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer(get_customers_customer_request()) ->
                                result(get_customers_customer_response()).
get_customers_customer(Args) ->
    get_customers_customer(Args, #{}).

-spec get_customers_customer(get_customers_customer_request(), options()) ->
                                result(get_customers_customer_response()).
get_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {one_of,
                                                                       [{ref, stripe, customer},
                                                                        {ref,
                                                                         stripe,
                                                                         deleted_customer}]},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_sessions(post_billing_portal_sessions_request()) ->
                                      result(post_billing_portal_sessions_response()).
post_billing_portal_sessions(Args) ->
    post_billing_portal_sessions(Args, #{}).

-spec post_billing_portal_sessions(post_billing_portal_sessions_request(), options()) ->
                                      result(post_billing_portal_sessions_response()).
post_billing_portal_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref,
                                                                       stripe,
                                                                       billing_portal_session},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_links_payment_link(post_payment_links_payment_link_request()) ->
                                         result(post_payment_links_payment_link_response()).
post_payment_links_payment_link(Args) ->
    post_payment_links_payment_link(Args, #{}).

-spec post_payment_links_payment_link(post_payment_links_payment_link_request(),
                                      options()) ->
                                         result(post_payment_links_payment_link_response()).
post_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links/~s", [VarPaymentLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_link},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links_payment_link(get_payment_links_payment_link_request()) ->
                                        result(get_payment_links_payment_link_response()).
get_payment_links_payment_link(Args) ->
    get_payment_links_payment_link(Args, #{}).

-spec get_payment_links_payment_link(get_payment_links_payment_link_request(),
                                     options()) ->
                                        result(get_payment_links_payment_link_response()).
get_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links/~s", [VarPaymentLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, payment_link},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_credit_note_lines(get_credit_notes_credit_note_lines_request()) ->
                                            result(get_credit_notes_credit_note_lines_response()).
get_credit_notes_credit_note_lines(Args) ->
    get_credit_notes_credit_note_lines(Args, #{}).

-spec get_credit_notes_credit_note_lines(get_credit_notes_credit_note_lines_request(),
                                         options()) ->
                                            result(get_credit_notes_credit_note_lines_response()).
get_credit_notes_credit_note_lines(Args, Options) ->
    VarCreditNote = maps:get(credit_note, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/~s/lines", [VarCreditNote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           credit_note_line_item}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sigma_scheduled_query_runs(get_sigma_scheduled_query_runs_request()) ->
                                        result(get_sigma_scheduled_query_runs_response()).
get_sigma_scheduled_query_runs(Args) ->
    get_sigma_scheduled_query_runs(Args, #{}).

-spec get_sigma_scheduled_query_runs(get_sigma_scheduled_query_runs_request(),
                                     options()) ->
                                        result(get_sigma_scheduled_query_runs_response()).
get_sigma_scheduled_query_runs(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(http, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {object,
                                                                       #{members =>
                                                                             #{url => string,
                                                                               object =>
                                                                                   {string,
                                                                                    #{values =>
                                                                                          [list]}},
                                                                               has_more => boolean,
                                                                               data =>
                                                                                   {array,
                                                                                    #{element =>
                                                                                          {ref,
                                                                                           stripe,
                                                                                           scheduled_query_run}}}},
                                                                         required =>
                                                                             [data,
                                                                              has_more,
                                                                              object,
                                                                              url]}},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Reason} ->
                                                            {error, {invalid_payload, Reason}, Resp}
                                                    end;
                                                {error, Reason} ->
                                                    {error, {invalid_json, Reason}, Resp}
                                            end;
                                        _ ->
                                            {error, unknown_content_type, Resp}
                                    end
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}, Resp}
                    end;
                error ->
                    {error, missing_content_type, Resp}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec encode_q(Style, Explode, Key, Value) -> uri:query()
    when Style :: form | spaceDelimitde | pipeDelimited | deepObject,
         Explode :: boolean(),
         Key :: binary(),
         Value :: term().
encode_q(form, true, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_q(form, true, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_q(form, true, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_q(form, true, Key, Values) when is_list(Values) ->
    lists:map(fun (Value) when is_binary(Value) ->
                      {Key, Value};
                  (Value) when is_integer(Value) ->
                      {Key, integer_to_binary(Value)};
                  (Value) when is_atom(Value) ->
                      {Key, atom_to_binary(Value)}
              end,
              Values);
encode_q(form, true, _Key, Values) when is_map(Values) ->
    maps:fold(fun (Key, Value, Acc) when is_binary(Value) ->
                      [{Key, Value} | Acc];
                  (Key, Value, Acc) when is_integer(Value) ->
                      [{Key, integer_to_binary(Value)} | Acc];
                  (Key, Value, Acc) when is_atom(Value) ->
                      [{Key, atom_to_binary(Key)} | Acc]
              end,
              [],
              Values);
encode_q(form, false, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_q(form, false, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_q(form, false, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_q(form, false, Key, Values) when is_list(Values) ->
    Values1 =
        lists:map(fun (Value) when is_binary(Value) ->
                          Value;
                      (Value) when is_integer(Value) ->
                          integer_to_binary(Value);
                      (Value) when is_atom(Value) ->
                          atom_to_binary(Value)
                  end,
                  Values),
    [{Key,
      unicode:characters_to_binary(
          lists:join(",", Values1))}];
encode_q(form, false, Key, Values) when is_map(Values) ->
    Values1 =
        maps:fold(fun (K, V, Acc) when is_binary(V) ->
                          [[K, $,, V] | Acc];
                      (K, V, Acc) when is_integer(V) ->
                          [[K, $,, integer_to_binary(V)] | Acc];
                      (K, V, Acc) when is_atom(V) ->
                          [[K, $,, atom_to_binary(V)] | Acc]
                  end,
                  [],
                  Values),
    [{Key,
      unicode:characters_to_binary(
          lists:join(",", Values1))}];
%% deepObject MUST not encode primary or array value but Stripe use this style
%% to encode query parameter. So I'm force to extend the spec.
encode_q(deepObject, true, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_q(deepObject, true, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_q(deepObject, true, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_q(deepObject, true, Key, Values) when is_list(Values) ->
    lists:map(fun (Value) when is_binary(Value) ->
                      {<<Key/binary, "[]">>, Value};
                  (Value) when is_integer(Value) ->
                      {<<Key/binary, "[]">>, integer_to_binary(Value)};
                  (Value) when is_atom(Value) ->
                      {<<Key/binary, "[]">>, atom_to_binary(Value)}
              end,
              Values);
encode_q(deepObject, true, Key, Values) when is_map(Values) ->
    maps:fold(fun (K, V, Acc) when is_binary(V) ->
                      K2 = atom_to_binary(K),
                      [{<<Key/binary, $[, K2/binary, $]>>, V} | Acc];
                  (K, V, Acc) when is_integer(V) ->
                      K2 = atom_to_binary(K),
                      [{<<Key/binary, $[, K2/binary, $]>>, integer_to_binary(V)} | Acc];
                  (K, V, Acc) when is_atom(V) ->
                      K2 = atom_to_binary(K),
                      [{<<Key/binary, $[, K2/binary, $]>>, atom_to_binary(V)} | Acc]
              end,
              [],
              Values).

-spec encode_h(Style, Explode, Key, Value) -> mhttp:header()
    when Style :: simple,
         Explode :: boolean(),
         Key :: binary(),
         Value :: term().
encode_h(simple, false, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_h(simple, false, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_h(simple, false, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_h(simple, false, Key, Values) when is_list(Values) ->
    [{Key,
      unicode:characters_to_binary(
          lists:join(",",
                     lists:map(fun (Value) when is_binary(Value) ->
                                       Value;
                                   (Value) when is_integer(Value) ->
                                       integer_to_binary(Value);
                                   (Value) when is_atom(Value) ->
                                       atom_to_binary(Value)
                               end,
                               Values)))}];
encode_h(simple, false, Key, Values) when is_map(Values) ->
    [{Key,
      unicode:characters_to_binary(
          lists:join(",",
                     maps:fold(fun (K, V, Acc) when is_binary(V) ->
                                       [[K, $,, V] | Acc];
                                   (K, V, Acc) when is_integer(V) ->
                                       [[K, $,, integer_to_binary(V)] | Acc];
                                   (K, V, Acc) when is_atom(V) ->
                                       [[K, $,, atom_to_binary(V)] | Acc]
                               end,
                               [],
                               Values)))}];
encode_h(simple, true, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_h(simple, true, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_h(simple, true, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_h(simple, true, Key, Values) when is_list(Values) ->
    [{Key,
      unicode:characters_to_binary(
          lists:join(",",
                     lists:map(fun (Value) when is_binary(Value) ->
                                       Value;
                                   (Value) when is_integer(Value) ->
                                       integer_to_binary(Value);
                                   (Value) when is_atom(Value) ->
                                       atom_to_binary(Value)
                               end,
                               Values)))}];
encode_h(simple, true, Key, Values) when is_map(Values) ->
    [{Key,
      unicode:characters_to_binary(
          lists:join(",",
                     maps:fold(fun (K, V, Acc) when is_binary(V) ->
                                       [[K, $=, V] | Acc];
                                   (K, V, Acc) when is_integer(V) ->
                                       [[K, $=, integer_to_binary(V)] | Acc];
                                   (K, V, Acc) when is_atom(V) ->
                                       [[K, $=, atom_to_binary(V)] | Acc]
                               end,
                               [],
                               Values)))}].
