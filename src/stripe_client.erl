%% File generated by erl-openapi on "2022-03-01T10:10:02Z".

-module(stripe_client).

-export([get_radar_early_fraud_warnings/1, get_radar_early_fraud_warnings/2]).
-export([post_charges_charge_refunds/1, post_charges_charge_refunds/2]).
-export([get_charges_charge_refunds/1, get_charges_charge_refunds/2]).
-export([post_identity_verification_sessions_session_redact/1,
         post_identity_verification_sessions_session_redact/2]).
-export([post_billing_portal_configurations_configuration/1,
         post_billing_portal_configurations_configuration/2]).
-export([get_billing_portal_configurations_configuration/1,
         get_billing_portal_configurations_configuration/2]).
-export([post_payment_methods/1, post_payment_methods/2]).
-export([get_payment_methods/1, get_payment_methods/2]).
-export([post_radar_value_lists_value_list/1, post_radar_value_lists_value_list/2]).
-export([get_radar_value_lists_value_list/1, get_radar_value_lists_value_list/2]).
-export([delete_radar_value_lists_value_list/1, delete_radar_value_lists_value_list/2]).
-export([post_charges_charge_capture/1, post_charges_charge_capture/2]).
-export([get_disputes/1, get_disputes/2]).
-export([post_prices_price/1, post_prices_price/2]).
-export([get_prices_price/1, get_prices_price/2]).
-export([post_accounts/1, post_accounts/2]).
-export([get_accounts/1, get_accounts/2]).
-export([post_identity_verification_sessions_session_cancel/1,
         post_identity_verification_sessions_session_cancel/2]).
-export([post_account_persons_person/1, post_account_persons_person/2]).
-export([get_account_persons_person/1, get_account_persons_person/2]).
-export([delete_account_persons_person/1, delete_account_persons_person/2]).
-export([post_issuing_authorizations_authorization/1,
         post_issuing_authorizations_authorization/2]).
-export([get_issuing_authorizations_authorization/1,
         get_issuing_authorizations_authorization/2]).
-export([get_files_file/1, get_files_file/2]).
-export([post_issuing_cards_card/1, post_issuing_cards_card/2]).
-export([get_issuing_cards_card/1, get_issuing_cards_card/2]).
-export([post_sources_source_verify/1, post_sources_source_verify/2]).
-export([post_invoiceitems/1, post_invoiceitems/2]).
-export([get_invoiceitems/1, get_invoiceitems/2]).
-export([delete_ephemeral_keys_key/1, delete_ephemeral_keys_key/2]).
-export([get_exchange_rates/1, get_exchange_rates/2]).
-export([post_setup_intents_intent/1, post_setup_intents_intent/2]).
-export([get_setup_intents_intent/1, get_setup_intents_intent/2]).
-export([post_files/1, post_files/2]).
-export([get_files/1, get_files/2]).
-export([post_customers_customer_bank_accounts_id/1,
         post_customers_customer_bank_accounts_id/2]).
-export([get_customers_customer_bank_accounts_id/1,
         get_customers_customer_bank_accounts_id/2]).
-export([delete_customers_customer_bank_accounts_id/1,
         delete_customers_customer_bank_accounts_id/2]).
-export([get_issuer_fraud_records_issuer_fraud_record/1,
         get_issuer_fraud_records_issuer_fraud_record/2]).
-export([post_accounts_account_people_person/1, post_accounts_account_people_person/2]).
-export([get_accounts_account_people_person/1, get_accounts_account_people_person/2]).
-export([delete_accounts_account_people_person/1,
         delete_accounts_account_people_person/2]).
-export([post_payouts/1, post_payouts/2]).
-export([get_payouts/1, get_payouts/2]).
-export([post_account_capabilities_capability/1, post_account_capabilities_capability/2]).
-export([get_account_capabilities_capability/1, get_account_capabilities_capability/2]).
-export([get_sources_source_mandate_notifications_mandate_notification/1,
         get_sources_source_mandate_notifications_mandate_notification/2]).
-export([post_application_fees_fee_refunds_id/1, post_application_fees_fee_refunds_id/2]).
-export([get_application_fees_fee_refunds_id/1, get_application_fees_fee_refunds_id/2]).
-export([get_customers_customer_discount/1, get_customers_customer_discount/2]).
-export([delete_customers_customer_discount/1, delete_customers_customer_discount/2]).
-export([post_coupons/1, post_coupons/2]).
-export([get_coupons/1, get_coupons/2]).
-export([post_charges_charge_dispute_close/1, post_charges_charge_dispute_close/2]).
-export([post_plans_plan/1, post_plans_plan/2]).
-export([get_plans_plan/1, get_plans_plan/2]).
-export([delete_plans_plan/1, delete_plans_plan/2]).
-export([post_customers_customer_bank_accounts/1,
         post_customers_customer_bank_accounts/2]).
-export([get_customers_customer_bank_accounts/1, get_customers_customer_bank_accounts/2]).
-export([post_terminal_readers_reader/1, post_terminal_readers_reader/2]).
-export([get_terminal_readers_reader/1, get_terminal_readers_reader/2]).
-export([delete_terminal_readers_reader/1, delete_terminal_readers_reader/2]).
-export([post_accounts_account_persons_person/1, post_accounts_account_persons_person/2]).
-export([get_accounts_account_persons_person/1, get_accounts_account_persons_person/2]).
-export([delete_accounts_account_persons_person/1,
         delete_accounts_account_persons_person/2]).
-export([post_credit_notes_id_void/1, post_credit_notes_id_void/2]).
-export([post_customers_customer_sources/1, post_customers_customer_sources/2]).
-export([get_customers_customer_sources/1, get_customers_customer_sources/2]).
-export([post_account_links/1, post_account_links/2]).
-export([post_payouts_payout/1, post_payouts_payout/2]).
-export([get_payouts_payout/1, get_payouts_payout/2]).
-export([post_subscription_items_item/1, post_subscription_items_item/2]).
-export([get_subscription_items_item/1, get_subscription_items_item/2]).
-export([delete_subscription_items_item/1, delete_subscription_items_item/2]).
-export([post_products/1, post_products/2]).
-export([get_products/1, get_products/2]).
-export([get_reporting_report_types_report_type/1,
         get_reporting_report_types_report_type/2]).
-export([post_quotes_quote_accept/1, post_quotes_quote_accept/2]).
-export([get_mandates_mandate/1, get_mandates_mandate/2]).
-export([post_customers_customer_subscriptions/1,
         post_customers_customer_subscriptions/2]).
-export([get_customers_customer_subscriptions/1, get_customers_customer_subscriptions/2]).
-export([get_order_returns_id/1, get_order_returns_id/2]).
-export([post_transfers_id_reversals/1, post_transfers_id_reversals/2]).
-export([get_transfers_id_reversals/1, get_transfers_id_reversals/2]).
-export([get_reviews_review/1, get_reviews_review/2]).
-export([post_accounts_account_bank_accounts_id/1,
         post_accounts_account_bank_accounts_id/2]).
-export([get_accounts_account_bank_accounts_id/1,
         get_accounts_account_bank_accounts_id/2]).
-export([delete_accounts_account_bank_accounts_id/1,
         delete_accounts_account_bank_accounts_id/2]).
-export([post_issuing_settlements_settlement/1, post_issuing_settlements_settlement/2]).
-export([get_issuing_settlements_settlement/1, get_issuing_settlements_settlement/2]).
-export([post_promotion_codes_promotion_code/1, post_promotion_codes_promotion_code/2]).
-export([get_promotion_codes_promotion_code/1, get_promotion_codes_promotion_code/2]).
-export([post_subscription_schedules_schedule_cancel/1,
         post_subscription_schedules_schedule_cancel/2]).
-export([post_identity_verification_sessions/1, post_identity_verification_sessions/2]).
-export([get_identity_verification_sessions/1, get_identity_verification_sessions/2]).
-export([post_radar_value_list_items/1, post_radar_value_list_items/2]).
-export([get_radar_value_list_items/1, get_radar_value_list_items/2]).
-export([get_events_id/1, get_events_id/2]).
-export([get_country_specs/1, get_country_specs/2]).
-export([post_payment_intents_intent_verify_microdeposits/1,
         post_payment_intents_intent_verify_microdeposits/2]).
-export([post_subscription_items_subscription_item_usage_records/1,
         post_subscription_items_subscription_item_usage_records/2]).
-export([get_balance_history/1, get_balance_history/2]).
-export([get_order_returns/1, get_order_returns/2]).
-export([post_account_external_accounts_id/1, post_account_external_accounts_id/2]).
-export([get_account_external_accounts_id/1, get_account_external_accounts_id/2]).
-export([delete_account_external_accounts_id/1, delete_account_external_accounts_id/2]).
-export([post_apple_pay_domains/1, post_apple_pay_domains/2]).
-export([get_apple_pay_domains/1, get_apple_pay_domains/2]).
-export([post_credit_notes/1, post_credit_notes/2]).
-export([get_credit_notes/1, get_credit_notes/2]).
-export([get_sigma_scheduled_query_runs_scheduled_query_run/1,
         get_sigma_scheduled_query_runs_scheduled_query_run/2]).
-export([post_coupons_coupon/1, post_coupons_coupon/2]).
-export([get_coupons_coupon/1, get_coupons_coupon/2]).
-export([delete_coupons_coupon/1, delete_coupons_coupon/2]).
-export([get_customers_customer_tax_ids_id/1, get_customers_customer_tax_ids_id/2]).
-export([delete_customers_customer_tax_ids_id/1, delete_customers_customer_tax_ids_id/2]).
-export([get_radar_early_fraud_warnings_early_fraud_warning/1,
         get_radar_early_fraud_warnings_early_fraud_warning/2]).
-export([get_issuing_settlements/1, get_issuing_settlements/2]).
-export([post_file_links/1, post_file_links/2]).
-export([get_file_links/1, get_file_links/2]).
-export([get_identity_verification_reports_report/1,
         get_identity_verification_reports_report/2]).
-export([post_transfers/1, post_transfers/2]).
-export([get_transfers/1, get_transfers/2]).
-export([delete_subscriptions_subscription_exposed_id_discount/1,
         delete_subscriptions_subscription_exposed_id_discount/2]).
-export([post_application_fees_id_refunds/1, post_application_fees_id_refunds/2]).
-export([get_application_fees_id_refunds/1, get_application_fees_id_refunds/2]).
-export([post_accounts_account_bank_accounts/1, post_accounts_account_bank_accounts/2]).
-export([post_accounts_account/1, post_accounts_account/2]).
-export([get_accounts_account/1, get_accounts_account/2]).
-export([delete_accounts_account/1, delete_accounts_account/2]).
-export([post_subscription_schedules_schedule/1, post_subscription_schedules_schedule/2]).
-export([get_subscription_schedules_schedule/1, get_subscription_schedules_schedule/2]).
-export([post_invoices_invoice_pay/1, post_invoices_invoice_pay/2]).
-export([post_transfers_transfer_reversals_id/1, post_transfers_transfer_reversals_id/2]).
-export([get_transfers_transfer_reversals_id/1, get_transfers_transfer_reversals_id/2]).
-export([post_topups_topup/1, post_topups_topup/2]).
-export([get_topups_topup/1, get_topups_topup/2]).
-export([post_recipients_id/1, post_recipients_id/2]).
-export([get_recipients_id/1, get_recipients_id/2]).
-export([delete_recipients_id/1, delete_recipients_id/2]).
-export([get_invoices_invoice_lines/1, get_invoices_invoice_lines/2]).
-export([post_accounts_account_external_accounts_id/1,
         post_accounts_account_external_accounts_id/2]).
-export([get_accounts_account_external_accounts_id/1,
         get_accounts_account_external_accounts_id/2]).
-export([delete_accounts_account_external_accounts_id/1,
         delete_accounts_account_external_accounts_id/2]).
-export([post_topups/1, post_topups/2]).
-export([get_topups/1, get_topups/2]).
-export([post_orders_id_returns/1, post_orders_id_returns/2]).
-export([post_orders_id/1, post_orders_id/2]).
-export([get_orders_id/1, get_orders_id/2]).
-export([get_apple_pay_domains_domain/1, get_apple_pay_domains_domain/2]).
-export([delete_apple_pay_domains_domain/1, delete_apple_pay_domains_domain/2]).
-export([get_issuing_transactions/1, get_issuing_transactions/2]).
-export([post_charges_charge_refund/1, post_charges_charge_refund/2]).
-export([post_payment_methods_payment_method_attach/1,
         post_payment_methods_payment_method_attach/2]).
-export([post_payment_intents_intent_cancel/1, post_payment_intents_intent_cancel/2]).
-export([get_accounts_account_capabilities/1, get_accounts_account_capabilities/2]).
-export([get_credit_notes_preview_lines/1, get_credit_notes_preview_lines/2]).
-export([post_subscriptions/1, post_subscriptions/2]).
-export([get_subscriptions/1, get_subscriptions/2]).
-export([get_setup_attempts/1, get_setup_attempts/2]).
-export([post_customers_customer_subscriptions_subscription_exposed_id/1,
         post_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([get_customers_customer_subscriptions_subscription_exposed_id/1,
         get_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([delete_customers_customer_subscriptions_subscription_exposed_id/1,
         delete_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([get_bitcoin_receivers_id/1, get_bitcoin_receivers_id/2]).
-export([post_orders/1, post_orders/2]).
-export([get_orders/1, get_orders/2]).
-export([post_ephemeral_keys/1, post_ephemeral_keys/2]).
-export([post_webhook_endpoints_webhook_endpoint/1,
         post_webhook_endpoints_webhook_endpoint/2]).
-export([get_webhook_endpoints_webhook_endpoint/1,
         get_webhook_endpoints_webhook_endpoint/2]).
-export([delete_webhook_endpoints_webhook_endpoint/1,
         delete_webhook_endpoints_webhook_endpoint/2]).
-export([post_account_persons/1, post_account_persons/2]).
-export([get_account_persons/1, get_account_persons/2]).
-export([get_account_capabilities/1, get_account_capabilities/2]).
-export([post_checkout_sessions_session_expire/1,
         post_checkout_sessions_session_expire/2]).
-export([get_bitcoin_receivers_receiver_transactions/1,
         get_bitcoin_receivers_receiver_transactions/2]).
-export([post_quotes_quote/1, post_quotes_quote/2]).
-export([get_quotes_quote/1, get_quotes_quote/2]).
-export([post_account_people/1, post_account_people/2]).
-export([get_account_people/1, get_account_people/2]).
-export([post_setup_intents_intent_confirm/1, post_setup_intents_intent_confirm/2]).
-export([post_customers_customer_cards/1, post_customers_customer_cards/2]).
-export([get_customers_customer_cards/1, get_customers_customer_cards/2]).
-export([get_identity_verification_reports/1, get_identity_verification_reports/2]).
-export([post_accounts_account_persons/1, post_accounts_account_persons/2]).
-export([get_accounts_account_persons/1, get_accounts_account_persons/2]).
-export([post_application_fees_id_refund/1, post_application_fees_id_refund/2]).
-export([post_payment_intents/1, post_payment_intents/2]).
-export([get_payment_intents/1, get_payment_intents/2]).
-export([post_skus/1, post_skus/2]).
-export([get_skus/1, get_skus/2]).
-export([post_webhook_endpoints/1, post_webhook_endpoints/2]).
-export([get_webhook_endpoints/1, get_webhook_endpoints/2]).
-export([get_balance/1, get_balance/2]).
-export([post_customers_customer_balance_transactions_transaction/1,
         post_customers_customer_balance_transactions_transaction/2]).
-export([get_customers_customer_balance_transactions_transaction/1,
         get_customers_customer_balance_transactions_transaction/2]).
-export([post_payment_methods_payment_method/1, post_payment_methods_payment_method/2]).
-export([get_payment_methods_payment_method/1, get_payment_methods_payment_method/2]).
-export([post_topups_topup_cancel/1, post_topups_topup_cancel/2]).
-export([get_events/1, get_events/2]).
-export([post_charges_charge_refunds_refund/1, post_charges_charge_refunds_refund/2]).
-export([get_charges_charge_refunds_refund/1, get_charges_charge_refunds_refund/2]).
-export([post_accounts_account_capabilities_capability/1,
         post_accounts_account_capabilities_capability/2]).
-export([get_accounts_account_capabilities_capability/1,
         get_accounts_account_capabilities_capability/2]).
-export([post_subscription_items/1, post_subscription_items/2]).
-export([get_subscription_items/1, get_subscription_items/2]).
-export([get_quotes_quote_pdf/1, get_quotes_quote_pdf/2]).
-export([post_account_bank_accounts_id/1, post_account_bank_accounts_id/2]).
-export([get_account_bank_accounts_id/1, get_account_bank_accounts_id/2]).
-export([delete_account_bank_accounts_id/1, delete_account_bank_accounts_id/2]).
-export([get_payment_links_payment_link_line_items/1,
         get_payment_links_payment_link_line_items/2]).
-export([get_subscription_items_subscription_item_usage_record_summaries/1,
         get_subscription_items_subscription_item_usage_record_summaries/2]).
-export([post_payment_intents_intent/1, post_payment_intents_intent/2]).
-export([get_payment_intents_intent/1, get_payment_intents_intent/2]).
-export([post_charges/1, post_charges/2]).
-export([get_charges/1, get_charges/2]).
-export([post_accounts_account_external_accounts/1,
         post_accounts_account_external_accounts/2]).
-export([get_accounts_account_external_accounts/1,
         get_accounts_account_external_accounts/2]).
-export([get_issuing_authorizations/1, get_issuing_authorizations/2]).
-export([post_products_id/1, post_products_id/2]).
-export([get_products_id/1, get_products_id/2]).
-export([delete_products_id/1, delete_products_id/2]).
-export([post_setup_intents_intent_verify_microdeposits/1,
         post_setup_intents_intent_verify_microdeposits/2]).
-export([get_reporting_report_types/1, get_reporting_report_types/2]).
-export([post_account_external_accounts/1, post_account_external_accounts/2]).
-export([get_account_external_accounts/1, get_account_external_accounts/2]).
-export([post_radar_value_lists/1, post_radar_value_lists/2]).
-export([get_radar_value_lists/1, get_radar_value_lists/2]).
-export([post_shipping_rates/1, post_shipping_rates/2]).
-export([get_shipping_rates/1, get_shipping_rates/2]).
-export([post_file_links_link/1, post_file_links_link/2]).
-export([get_file_links_link/1, get_file_links_link/2]).
-export([get3d_secure_three_d_secure/1, get3d_secure_three_d_secure/2]).
-export([post_invoices_invoice_send/1, post_invoices_invoice_send/2]).
-export([get_invoices_upcoming/1, get_invoices_upcoming/2]).
-export([get_checkout_sessions_session_line_items/1,
         get_checkout_sessions_session_line_items/2]).
-export([get_tax_codes/1, get_tax_codes/2]).
-export([post_invoices/1, post_invoices/2]).
-export([get_invoices/1, get_invoices/2]).
-export([post_charges_charge/1, post_charges_charge/2]).
-export([get_charges_charge/1, get_charges_charge/2]).
-export([post_invoices_invoice_mark_uncollectible/1,
         post_invoices_invoice_mark_uncollectible/2]).
-export([post_customers_customer_sources_id_verify/1,
         post_customers_customer_sources_id_verify/2]).
-export([post_orders_id_pay/1, post_orders_id_pay/2]).
-export([post_customers_customer_bank_accounts_id_verify/1,
         post_customers_customer_bank_accounts_id_verify/2]).
-export([post_account_people_person/1, post_account_people_person/2]).
-export([get_account_people_person/1, get_account_people_person/2]).
-export([delete_account_people_person/1, delete_account_people_person/2]).
-export([post_checkout_sessions/1, post_checkout_sessions/2]).
-export([get_checkout_sessions/1, get_checkout_sessions/2]).
-export([post_accounts_account_login_links/1, post_accounts_account_login_links/2]).
-export([post_terminal_readers/1, post_terminal_readers/2]).
-export([get_terminal_readers/1, get_terminal_readers/2]).
-export([post_issuing_disputes/1, post_issuing_disputes/2]).
-export([get_issuing_disputes/1, get_issuing_disputes/2]).
-export([post3d_secure/1, post3d_secure/2]).
-export([post_prices/1, post_prices/2]).
-export([get_prices/1, get_prices/2]).
-export([post_invoices_invoice/1, post_invoices_invoice/2]).
-export([get_invoices_invoice/1, get_invoices_invoice/2]).
-export([delete_invoices_invoice/1, delete_invoices_invoice/2]).
-export([post_identity_verification_sessions_session/1,
         post_identity_verification_sessions_session/2]).
-export([get_identity_verification_sessions_session/1,
         get_identity_verification_sessions_session/2]).
-export([get_balance_transactions_id/1, get_balance_transactions_id/2]).
-export([post_setup_intents_intent_cancel/1, post_setup_intents_intent_cancel/2]).
-export([post_issuing_transactions_transaction/1,
         post_issuing_transactions_transaction/2]).
-export([get_issuing_transactions_transaction/1, get_issuing_transactions_transaction/2]).
-export([post_terminal_connection_tokens/1, post_terminal_connection_tokens/2]).
-export([get_reviews/1, get_reviews/2]).
-export([post_promotion_codes/1, post_promotion_codes/2]).
-export([get_promotion_codes/1, get_promotion_codes/2]).
-export([get_customers_customer_subscriptions_subscription_exposed_id_discount/1,
         get_customers_customer_subscriptions_subscription_exposed_id_discount/2]).
-export([delete_customers_customer_subscriptions_subscription_exposed_id_discount/1,
         delete_customers_customer_subscriptions_subscription_exposed_id_discount/2]).
-export([get_quotes_quote_computed_upfront_line_items/1,
         get_quotes_quote_computed_upfront_line_items/2]).
-export([get_radar_value_list_items_item/1, get_radar_value_list_items_item/2]).
-export([delete_radar_value_list_items_item/1, delete_radar_value_list_items_item/2]).
-export([get_issuer_fraud_records/1, get_issuer_fraud_records/2]).
-export([post_tax_rates_tax_rate/1, post_tax_rates_tax_rate/2]).
-export([get_tax_rates_tax_rate/1, get_tax_rates_tax_rate/2]).
-export([post_recipients/1, post_recipients/2]).
-export([get_recipients/1, get_recipients/2]).
-export([post_plans/1, post_plans/2]).
-export([get_plans/1, get_plans/2]).
-export([post_customers_customer_balance_transactions/1,
         post_customers_customer_balance_transactions/2]).
-export([get_customers_customer_balance_transactions/1,
         get_customers_customer_balance_transactions/2]).
-export([post_reviews_review_approve/1, post_reviews_review_approve/2]).
-export([post_customers_customer_tax_ids/1, post_customers_customer_tax_ids/2]).
-export([get_customers_customer_tax_ids/1, get_customers_customer_tax_ids/2]).
-export([get_tokens_token/1, get_tokens_token/2]).
-export([get_balance_transactions/1, get_balance_transactions/2]).
-export([get_tax_codes_id/1, get_tax_codes_id/2]).
-export([post_accounts_account_reject/1, post_accounts_account_reject/2]).
-export([post_subscriptions_subscription_exposed_id/1,
         post_subscriptions_subscription_exposed_id/2]).
-export([get_subscriptions_subscription_exposed_id/1,
         get_subscriptions_subscription_exposed_id/2]).
-export([delete_subscriptions_subscription_exposed_id/1,
         delete_subscriptions_subscription_exposed_id/2]).
-export([get_country_specs_country/1, get_country_specs_country/2]).
-export([post_invoices_invoice_finalize/1, post_invoices_invoice_finalize/2]).
-export([post_terminal_locations_location/1, post_terminal_locations_location/2]).
-export([get_terminal_locations_location/1, get_terminal_locations_location/2]).
-export([delete_terminal_locations_location/1, delete_terminal_locations_location/2]).
-export([post_account/1, post_account/2]).
-export([get_account/1, get_account/2]).
-export([delete_account/1, delete_account/2]).
-export([post_shipping_rates_shipping_rate_token/1,
         post_shipping_rates_shipping_rate_token/2]).
-export([get_shipping_rates_shipping_rate_token/1,
         get_shipping_rates_shipping_rate_token/2]).
-export([get_invoices_upcoming_lines/1, get_invoices_upcoming_lines/2]).
-export([post_issuing_cardholders/1, post_issuing_cardholders/2]).
-export([get_issuing_cardholders/1, get_issuing_cardholders/2]).
-export([post_customers_customer_sources_id/1, post_customers_customer_sources_id/2]).
-export([get_customers_customer_sources_id/1, get_customers_customer_sources_id/2]).
-export([delete_customers_customer_sources_id/1, delete_customers_customer_sources_id/2]).
-export([get_application_fees/1, get_application_fees/2]).
-export([get_bitcoin_receivers/1, get_bitcoin_receivers/2]).
-export([post_refunds_refund/1, post_refunds_refund/2]).
-export([get_refunds_refund/1, get_refunds_refund/2]).
-export([post_account_login_links/1, post_account_login_links/2]).
-export([post_tax_rates/1, post_tax_rates/2]).
-export([get_tax_rates/1, get_tax_rates/2]).
-export([post_accounts_account_people/1, post_accounts_account_people/2]).
-export([get_accounts_account_people/1, get_accounts_account_people/2]).
-export([post_issuing_disputes_dispute_submit/1, post_issuing_disputes_dispute_submit/2]).
-export([post_sources_source/1, post_sources_source/2]).
-export([get_sources_source/1, get_sources_source/2]).
-export([get_checkout_sessions_session/1, get_checkout_sessions_session/2]).
-export([post_payment_methods_payment_method_detach/1,
         post_payment_methods_payment_method_detach/2]).
-export([post_customers/1, post_customers/2]).
-export([get_customers/1, get_customers/2]).
-export([post_account_bank_accounts/1, post_account_bank_accounts/2]).
-export([post_issuing_disputes_dispute/1, post_issuing_disputes_dispute/2]).
-export([get_issuing_disputes_dispute/1, get_issuing_disputes_dispute/2]).
-export([post_disputes_dispute_close/1, post_disputes_dispute_close/2]).
-export([post_quotes_quote_cancel/1, post_quotes_quote_cancel/2]).
-export([get_customers_customer_payment_methods/1,
         get_customers_customer_payment_methods/2]).
-export([post_refunds/1, post_refunds/2]).
-export([get_refunds/1, get_refunds/2]).
-export([post_credit_notes_id/1, post_credit_notes_id/2]).
-export([get_credit_notes_id/1, get_credit_notes_id/2]).
-export([get_bitcoin_transactions/1, get_bitcoin_transactions/2]).
-export([post_setup_intents/1, post_setup_intents/2]).
-export([get_setup_intents/1, get_setup_intents/2]).
-export([post_payouts_payout_cancel/1, post_payouts_payout_cancel/2]).
-export([post_issuing_authorizations_authorization_approve/1,
         post_issuing_authorizations_authorization_approve/2]).
-export([post_issuing_authorizations_authorization_decline/1,
         post_issuing_authorizations_authorization_decline/2]).
-export([post_reporting_report_runs/1, post_reporting_report_runs/2]).
-export([get_reporting_report_runs/1, get_reporting_report_runs/2]).
-export([post_invoices_invoice_void/1, post_invoices_invoice_void/2]).
-export([post_sources/1, post_sources/2]).
-export([post_billing_portal_configurations/1, post_billing_portal_configurations/2]).
-export([get_billing_portal_configurations/1, get_billing_portal_configurations/2]).
-export([post_quotes/1, post_quotes/2]).
-export([get_quotes/1, get_quotes/2]).
-export([post_transfers_transfer/1, post_transfers_transfer/2]).
-export([get_transfers_transfer/1, get_transfers_transfer/2]).
-export([get_quotes_quote_line_items/1, get_quotes_quote_line_items/2]).
-export([post_invoiceitems_invoiceitem/1, post_invoiceitems_invoiceitem/2]).
-export([get_invoiceitems_invoiceitem/1, get_invoiceitems_invoiceitem/2]).
-export([delete_invoiceitems_invoiceitem/1, delete_invoiceitems_invoiceitem/2]).
-export([post_payment_intents_intent_capture/1, post_payment_intents_intent_capture/2]).
-export([post_issuing_cards/1, post_issuing_cards/2]).
-export([get_issuing_cards/1, get_issuing_cards/2]).
-export([get_sources_source_source_transactions/1,
         get_sources_source_source_transactions/2]).
-export([post_subscription_schedules_schedule_release/1,
         post_subscription_schedules_schedule_release/2]).
-export([post_customers_customer_cards_id/1, post_customers_customer_cards_id/2]).
-export([get_customers_customer_cards_id/1, get_customers_customer_cards_id/2]).
-export([delete_customers_customer_cards_id/1, delete_customers_customer_cards_id/2]).
-export([post_charges_charge_dispute/1, post_charges_charge_dispute/2]).
-export([get_charges_charge_dispute/1, get_charges_charge_dispute/2]).
-export([post_quotes_quote_finalize/1, post_quotes_quote_finalize/2]).
-export([post_skus_id/1, post_skus_id/2]).
-export([get_skus_id/1, get_skus_id/2]).
-export([delete_skus_id/1, delete_skus_id/2]).
-export([post_disputes_dispute/1, post_disputes_dispute/2]).
-export([get_disputes_dispute/1, get_disputes_dispute/2]).
-export([post_terminal_locations/1, post_terminal_locations/2]).
-export([get_terminal_locations/1, get_terminal_locations/2]).
-export([post_subscription_schedules/1, post_subscription_schedules/2]).
-export([get_subscription_schedules/1, get_subscription_schedules/2]).
-export([post_payment_links/1, post_payment_links/2]).
-export([get_payment_links/1, get_payment_links/2]).
-export([post_tokens/1, post_tokens/2]).
-export([post_issuing_cardholders_cardholder/1, post_issuing_cardholders_cardholder/2]).
-export([get_issuing_cardholders_cardholder/1, get_issuing_cardholders_cardholder/2]).
-export([get_application_fees_id/1, get_application_fees_id/2]).
-export([get_exchange_rates_rate_id/1, get_exchange_rates_rate_id/2]).
-export([post_payment_intents_intent_confirm/1, post_payment_intents_intent_confirm/2]).
-export([get_credit_notes_preview/1, get_credit_notes_preview/2]).
-export([get_balance_history_id/1, get_balance_history_id/2]).
-export([post_payouts_payout_reverse/1, post_payouts_payout_reverse/2]).
-export([get_reporting_report_runs_report_run/1, get_reporting_report_runs_report_run/2]).
-export([get_sources_source_source_transactions_source_transaction/1,
         get_sources_source_source_transactions_source_transaction/2]).
-export([post_customers_customer/1, post_customers_customer/2]).
-export([get_customers_customer/1, get_customers_customer/2]).
-export([delete_customers_customer/1, delete_customers_customer/2]).
-export([post_billing_portal_sessions/1, post_billing_portal_sessions/2]).
-export([post_payment_links_payment_link/1, post_payment_links_payment_link/2]).
-export([get_payment_links_payment_link/1, get_payment_links_payment_link/2]).
-export([get_credit_notes_credit_note_lines/1, get_credit_notes_credit_note_lines/2]).
-export([get_sigma_scheduled_query_runs/1, get_sigma_scheduled_query_runs/2]).

-export_type([get_radar_early_fraud_warnings_request/0]).
-export_type([post_charges_charge_refunds_request/0]).
-export_type([get_charges_charge_refunds_request/0]).
-export_type([post_identity_verification_sessions_session_redact_request/0]).
-export_type([post_billing_portal_configurations_configuration_request/0]).
-export_type([get_billing_portal_configurations_configuration_request/0]).
-export_type([post_payment_methods_request/0]).
-export_type([get_payment_methods_request/0]).
-export_type([post_radar_value_lists_value_list_request/0]).
-export_type([get_radar_value_lists_value_list_request/0]).
-export_type([delete_radar_value_lists_value_list_request/0]).
-export_type([post_charges_charge_capture_request/0]).
-export_type([get_disputes_request/0]).
-export_type([post_prices_price_request/0]).
-export_type([get_prices_price_request/0]).
-export_type([post_accounts_request/0]).
-export_type([get_accounts_request/0]).
-export_type([post_identity_verification_sessions_session_cancel_request/0]).
-export_type([post_account_persons_person_request/0]).
-export_type([get_account_persons_person_request/0]).
-export_type([delete_account_persons_person_request/0]).
-export_type([post_issuing_authorizations_authorization_request/0]).
-export_type([get_issuing_authorizations_authorization_request/0]).
-export_type([get_files_file_request/0]).
-export_type([post_issuing_cards_card_request/0]).
-export_type([get_issuing_cards_card_request/0]).
-export_type([post_sources_source_verify_request/0]).
-export_type([post_invoiceitems_request/0]).
-export_type([get_invoiceitems_request/0]).
-export_type([delete_ephemeral_keys_key_request/0]).
-export_type([get_exchange_rates_request/0]).
-export_type([post_setup_intents_intent_request/0]).
-export_type([get_setup_intents_intent_request/0]).
-export_type([post_files_request/0]).
-export_type([get_files_request/0]).
-export_type([post_customers_customer_bank_accounts_id_request/0]).
-export_type([get_customers_customer_bank_accounts_id_request/0]).
-export_type([delete_customers_customer_bank_accounts_id_request/0]).
-export_type([get_issuer_fraud_records_issuer_fraud_record_request/0]).
-export_type([post_accounts_account_people_person_request/0]).
-export_type([get_accounts_account_people_person_request/0]).
-export_type([delete_accounts_account_people_person_request/0]).
-export_type([post_payouts_request/0]).
-export_type([get_payouts_request/0]).
-export_type([post_account_capabilities_capability_request/0]).
-export_type([get_account_capabilities_capability_request/0]).
-export_type([get_sources_source_mandate_notifications_mandate_notification_request/0]).
-export_type([post_application_fees_fee_refunds_id_request/0]).
-export_type([get_application_fees_fee_refunds_id_request/0]).
-export_type([get_customers_customer_discount_request/0]).
-export_type([delete_customers_customer_discount_request/0]).
-export_type([post_coupons_request/0]).
-export_type([get_coupons_request/0]).
-export_type([post_charges_charge_dispute_close_request/0]).
-export_type([post_plans_plan_request/0]).
-export_type([get_plans_plan_request/0]).
-export_type([delete_plans_plan_request/0]).
-export_type([post_customers_customer_bank_accounts_request/0]).
-export_type([get_customers_customer_bank_accounts_request/0]).
-export_type([post_terminal_readers_reader_request/0]).
-export_type([get_terminal_readers_reader_request/0]).
-export_type([delete_terminal_readers_reader_request/0]).
-export_type([post_accounts_account_persons_person_request/0]).
-export_type([get_accounts_account_persons_person_request/0]).
-export_type([delete_accounts_account_persons_person_request/0]).
-export_type([post_credit_notes_id_void_request/0]).
-export_type([post_customers_customer_sources_request/0]).
-export_type([get_customers_customer_sources_request/0]).
-export_type([post_account_links_request/0]).
-export_type([post_payouts_payout_request/0]).
-export_type([get_payouts_payout_request/0]).
-export_type([post_subscription_items_item_request/0]).
-export_type([get_subscription_items_item_request/0]).
-export_type([delete_subscription_items_item_request/0]).
-export_type([post_products_request/0]).
-export_type([get_products_request/0]).
-export_type([get_reporting_report_types_report_type_request/0]).
-export_type([post_quotes_quote_accept_request/0]).
-export_type([get_mandates_mandate_request/0]).
-export_type([post_customers_customer_subscriptions_request/0]).
-export_type([get_customers_customer_subscriptions_request/0]).
-export_type([get_order_returns_id_request/0]).
-export_type([post_transfers_id_reversals_request/0]).
-export_type([get_transfers_id_reversals_request/0]).
-export_type([get_reviews_review_request/0]).
-export_type([post_accounts_account_bank_accounts_id_request/0]).
-export_type([get_accounts_account_bank_accounts_id_request/0]).
-export_type([delete_accounts_account_bank_accounts_id_request/0]).
-export_type([post_issuing_settlements_settlement_request/0]).
-export_type([get_issuing_settlements_settlement_request/0]).
-export_type([post_promotion_codes_promotion_code_request/0]).
-export_type([get_promotion_codes_promotion_code_request/0]).
-export_type([post_subscription_schedules_schedule_cancel_request/0]).
-export_type([post_identity_verification_sessions_request/0]).
-export_type([get_identity_verification_sessions_request/0]).
-export_type([post_radar_value_list_items_request/0]).
-export_type([get_radar_value_list_items_request/0]).
-export_type([get_events_id_request/0]).
-export_type([get_country_specs_request/0]).
-export_type([post_payment_intents_intent_verify_microdeposits_request/0]).
-export_type([post_subscription_items_subscription_item_usage_records_request/0]).
-export_type([get_balance_history_request/0]).
-export_type([get_order_returns_request/0]).
-export_type([post_account_external_accounts_id_request/0]).
-export_type([get_account_external_accounts_id_request/0]).
-export_type([delete_account_external_accounts_id_request/0]).
-export_type([post_apple_pay_domains_request/0]).
-export_type([get_apple_pay_domains_request/0]).
-export_type([post_credit_notes_request/0]).
-export_type([get_credit_notes_request/0]).
-export_type([get_sigma_scheduled_query_runs_scheduled_query_run_request/0]).
-export_type([post_coupons_coupon_request/0]).
-export_type([get_coupons_coupon_request/0]).
-export_type([delete_coupons_coupon_request/0]).
-export_type([get_customers_customer_tax_ids_id_request/0]).
-export_type([delete_customers_customer_tax_ids_id_request/0]).
-export_type([get_radar_early_fraud_warnings_early_fraud_warning_request/0]).
-export_type([get_issuing_settlements_request/0]).
-export_type([post_file_links_request/0]).
-export_type([get_file_links_request/0]).
-export_type([get_identity_verification_reports_report_request/0]).
-export_type([post_transfers_request/0]).
-export_type([get_transfers_request/0]).
-export_type([delete_subscriptions_subscription_exposed_id_discount_request/0]).
-export_type([post_application_fees_id_refunds_request/0]).
-export_type([get_application_fees_id_refunds_request/0]).
-export_type([post_accounts_account_bank_accounts_request/0]).
-export_type([post_accounts_account_request/0]).
-export_type([get_accounts_account_request/0]).
-export_type([delete_accounts_account_request/0]).
-export_type([post_subscription_schedules_schedule_request/0]).
-export_type([get_subscription_schedules_schedule_request/0]).
-export_type([post_invoices_invoice_pay_request/0]).
-export_type([post_transfers_transfer_reversals_id_request/0]).
-export_type([get_transfers_transfer_reversals_id_request/0]).
-export_type([post_topups_topup_request/0]).
-export_type([get_topups_topup_request/0]).
-export_type([post_recipients_id_request/0]).
-export_type([get_recipients_id_request/0]).
-export_type([delete_recipients_id_request/0]).
-export_type([get_invoices_invoice_lines_request/0]).
-export_type([post_accounts_account_external_accounts_id_request/0]).
-export_type([get_accounts_account_external_accounts_id_request/0]).
-export_type([delete_accounts_account_external_accounts_id_request/0]).
-export_type([post_topups_request/0]).
-export_type([get_topups_request/0]).
-export_type([post_orders_id_returns_request/0]).
-export_type([post_orders_id_request/0]).
-export_type([get_orders_id_request/0]).
-export_type([get_apple_pay_domains_domain_request/0]).
-export_type([delete_apple_pay_domains_domain_request/0]).
-export_type([get_issuing_transactions_request/0]).
-export_type([post_charges_charge_refund_request/0]).
-export_type([post_payment_methods_payment_method_attach_request/0]).
-export_type([post_payment_intents_intent_cancel_request/0]).
-export_type([get_accounts_account_capabilities_request/0]).
-export_type([get_credit_notes_preview_lines_request/0]).
-export_type([post_subscriptions_request/0]).
-export_type([get_subscriptions_request/0]).
-export_type([get_setup_attempts_request/0]).
-export_type([post_customers_customer_subscriptions_subscription_exposed_id_request/0]).
-export_type([get_customers_customer_subscriptions_subscription_exposed_id_request/0]).
-export_type([delete_customers_customer_subscriptions_subscription_exposed_id_request/0]).
-export_type([get_bitcoin_receivers_id_request/0]).
-export_type([post_orders_request/0]).
-export_type([get_orders_request/0]).
-export_type([post_ephemeral_keys_request/0]).
-export_type([post_webhook_endpoints_webhook_endpoint_request/0]).
-export_type([get_webhook_endpoints_webhook_endpoint_request/0]).
-export_type([delete_webhook_endpoints_webhook_endpoint_request/0]).
-export_type([post_account_persons_request/0]).
-export_type([get_account_persons_request/0]).
-export_type([get_account_capabilities_request/0]).
-export_type([post_checkout_sessions_session_expire_request/0]).
-export_type([get_bitcoin_receivers_receiver_transactions_request/0]).
-export_type([post_quotes_quote_request/0]).
-export_type([get_quotes_quote_request/0]).
-export_type([post_account_people_request/0]).
-export_type([get_account_people_request/0]).
-export_type([post_setup_intents_intent_confirm_request/0]).
-export_type([post_customers_customer_cards_request/0]).
-export_type([get_customers_customer_cards_request/0]).
-export_type([get_identity_verification_reports_request/0]).
-export_type([post_accounts_account_persons_request/0]).
-export_type([get_accounts_account_persons_request/0]).
-export_type([post_application_fees_id_refund_request/0]).
-export_type([post_payment_intents_request/0]).
-export_type([get_payment_intents_request/0]).
-export_type([post_skus_request/0]).
-export_type([get_skus_request/0]).
-export_type([post_webhook_endpoints_request/0]).
-export_type([get_webhook_endpoints_request/0]).
-export_type([get_balance_request/0]).
-export_type([post_customers_customer_balance_transactions_transaction_request/0]).
-export_type([get_customers_customer_balance_transactions_transaction_request/0]).
-export_type([post_payment_methods_payment_method_request/0]).
-export_type([get_payment_methods_payment_method_request/0]).
-export_type([post_topups_topup_cancel_request/0]).
-export_type([get_events_request/0]).
-export_type([post_charges_charge_refunds_refund_request/0]).
-export_type([get_charges_charge_refunds_refund_request/0]).
-export_type([post_accounts_account_capabilities_capability_request/0]).
-export_type([get_accounts_account_capabilities_capability_request/0]).
-export_type([post_subscription_items_request/0]).
-export_type([get_subscription_items_request/0]).
-export_type([get_quotes_quote_pdf_request/0]).
-export_type([post_account_bank_accounts_id_request/0]).
-export_type([get_account_bank_accounts_id_request/0]).
-export_type([delete_account_bank_accounts_id_request/0]).
-export_type([get_payment_links_payment_link_line_items_request/0]).
-export_type([get_subscription_items_subscription_item_usage_record_summaries_request/0]).
-export_type([post_payment_intents_intent_request/0]).
-export_type([get_payment_intents_intent_request/0]).
-export_type([post_charges_request/0]).
-export_type([get_charges_request/0]).
-export_type([post_accounts_account_external_accounts_request/0]).
-export_type([get_accounts_account_external_accounts_request/0]).
-export_type([get_issuing_authorizations_request/0]).
-export_type([post_products_id_request/0]).
-export_type([get_products_id_request/0]).
-export_type([delete_products_id_request/0]).
-export_type([post_setup_intents_intent_verify_microdeposits_request/0]).
-export_type([get_reporting_report_types_request/0]).
-export_type([post_account_external_accounts_request/0]).
-export_type([get_account_external_accounts_request/0]).
-export_type([post_radar_value_lists_request/0]).
-export_type([get_radar_value_lists_request/0]).
-export_type([post_shipping_rates_request/0]).
-export_type([get_shipping_rates_request/0]).
-export_type([post_file_links_link_request/0]).
-export_type([get_file_links_link_request/0]).
-export_type([get3d_secure_three_d_secure_request/0]).
-export_type([post_invoices_invoice_send_request/0]).
-export_type([get_invoices_upcoming_request/0]).
-export_type([get_checkout_sessions_session_line_items_request/0]).
-export_type([get_tax_codes_request/0]).
-export_type([post_invoices_request/0]).
-export_type([get_invoices_request/0]).
-export_type([post_charges_charge_request/0]).
-export_type([get_charges_charge_request/0]).
-export_type([post_invoices_invoice_mark_uncollectible_request/0]).
-export_type([post_customers_customer_sources_id_verify_request/0]).
-export_type([post_orders_id_pay_request/0]).
-export_type([post_customers_customer_bank_accounts_id_verify_request/0]).
-export_type([post_account_people_person_request/0]).
-export_type([get_account_people_person_request/0]).
-export_type([delete_account_people_person_request/0]).
-export_type([post_checkout_sessions_request/0]).
-export_type([get_checkout_sessions_request/0]).
-export_type([post_accounts_account_login_links_request/0]).
-export_type([post_terminal_readers_request/0]).
-export_type([get_terminal_readers_request/0]).
-export_type([post_issuing_disputes_request/0]).
-export_type([get_issuing_disputes_request/0]).
-export_type([post3d_secure_request/0]).
-export_type([post_prices_request/0]).
-export_type([get_prices_request/0]).
-export_type([post_invoices_invoice_request/0]).
-export_type([get_invoices_invoice_request/0]).
-export_type([delete_invoices_invoice_request/0]).
-export_type([post_identity_verification_sessions_session_request/0]).
-export_type([get_identity_verification_sessions_session_request/0]).
-export_type([get_balance_transactions_id_request/0]).
-export_type([post_setup_intents_intent_cancel_request/0]).
-export_type([post_issuing_transactions_transaction_request/0]).
-export_type([get_issuing_transactions_transaction_request/0]).
-export_type([post_terminal_connection_tokens_request/0]).
-export_type([get_reviews_request/0]).
-export_type([post_promotion_codes_request/0]).
-export_type([get_promotion_codes_request/0]).
-export_type([get_customers_customer_subscriptions_subscription_exposed_id_discount_request/0]).
-export_type([delete_customers_customer_subscriptions_subscription_exposed_id_discount_request/0]).
-export_type([get_quotes_quote_computed_upfront_line_items_request/0]).
-export_type([get_radar_value_list_items_item_request/0]).
-export_type([delete_radar_value_list_items_item_request/0]).
-export_type([get_issuer_fraud_records_request/0]).
-export_type([post_tax_rates_tax_rate_request/0]).
-export_type([get_tax_rates_tax_rate_request/0]).
-export_type([post_recipients_request/0]).
-export_type([get_recipients_request/0]).
-export_type([post_plans_request/0]).
-export_type([get_plans_request/0]).
-export_type([post_customers_customer_balance_transactions_request/0]).
-export_type([get_customers_customer_balance_transactions_request/0]).
-export_type([post_reviews_review_approve_request/0]).
-export_type([post_customers_customer_tax_ids_request/0]).
-export_type([get_customers_customer_tax_ids_request/0]).
-export_type([get_tokens_token_request/0]).
-export_type([get_balance_transactions_request/0]).
-export_type([get_tax_codes_id_request/0]).
-export_type([post_accounts_account_reject_request/0]).
-export_type([post_subscriptions_subscription_exposed_id_request/0]).
-export_type([get_subscriptions_subscription_exposed_id_request/0]).
-export_type([delete_subscriptions_subscription_exposed_id_request/0]).
-export_type([get_country_specs_country_request/0]).
-export_type([post_invoices_invoice_finalize_request/0]).
-export_type([post_terminal_locations_location_request/0]).
-export_type([get_terminal_locations_location_request/0]).
-export_type([delete_terminal_locations_location_request/0]).
-export_type([post_account_request/0]).
-export_type([get_account_request/0]).
-export_type([delete_account_request/0]).
-export_type([post_shipping_rates_shipping_rate_token_request/0]).
-export_type([get_shipping_rates_shipping_rate_token_request/0]).
-export_type([get_invoices_upcoming_lines_request/0]).
-export_type([post_issuing_cardholders_request/0]).
-export_type([get_issuing_cardholders_request/0]).
-export_type([post_customers_customer_sources_id_request/0]).
-export_type([get_customers_customer_sources_id_request/0]).
-export_type([delete_customers_customer_sources_id_request/0]).
-export_type([get_application_fees_request/0]).
-export_type([get_bitcoin_receivers_request/0]).
-export_type([post_refunds_refund_request/0]).
-export_type([get_refunds_refund_request/0]).
-export_type([post_account_login_links_request/0]).
-export_type([post_tax_rates_request/0]).
-export_type([get_tax_rates_request/0]).
-export_type([post_accounts_account_people_request/0]).
-export_type([get_accounts_account_people_request/0]).
-export_type([post_issuing_disputes_dispute_submit_request/0]).
-export_type([post_sources_source_request/0]).
-export_type([get_sources_source_request/0]).
-export_type([get_checkout_sessions_session_request/0]).
-export_type([post_payment_methods_payment_method_detach_request/0]).
-export_type([post_customers_request/0]).
-export_type([get_customers_request/0]).
-export_type([post_account_bank_accounts_request/0]).
-export_type([post_issuing_disputes_dispute_request/0]).
-export_type([get_issuing_disputes_dispute_request/0]).
-export_type([post_disputes_dispute_close_request/0]).
-export_type([post_quotes_quote_cancel_request/0]).
-export_type([get_customers_customer_payment_methods_request/0]).
-export_type([post_refunds_request/0]).
-export_type([get_refunds_request/0]).
-export_type([post_credit_notes_id_request/0]).
-export_type([get_credit_notes_id_request/0]).
-export_type([get_bitcoin_transactions_request/0]).
-export_type([post_setup_intents_request/0]).
-export_type([get_setup_intents_request/0]).
-export_type([post_payouts_payout_cancel_request/0]).
-export_type([post_issuing_authorizations_authorization_approve_request/0]).
-export_type([post_issuing_authorizations_authorization_decline_request/0]).
-export_type([post_reporting_report_runs_request/0]).
-export_type([get_reporting_report_runs_request/0]).
-export_type([post_invoices_invoice_void_request/0]).
-export_type([post_sources_request/0]).
-export_type([post_billing_portal_configurations_request/0]).
-export_type([get_billing_portal_configurations_request/0]).
-export_type([post_quotes_request/0]).
-export_type([get_quotes_request/0]).
-export_type([post_transfers_transfer_request/0]).
-export_type([get_transfers_transfer_request/0]).
-export_type([get_quotes_quote_line_items_request/0]).
-export_type([post_invoiceitems_invoiceitem_request/0]).
-export_type([get_invoiceitems_invoiceitem_request/0]).
-export_type([delete_invoiceitems_invoiceitem_request/0]).
-export_type([post_payment_intents_intent_capture_request/0]).
-export_type([post_issuing_cards_request/0]).
-export_type([get_issuing_cards_request/0]).
-export_type([get_sources_source_source_transactions_request/0]).
-export_type([post_subscription_schedules_schedule_release_request/0]).
-export_type([post_customers_customer_cards_id_request/0]).
-export_type([get_customers_customer_cards_id_request/0]).
-export_type([delete_customers_customer_cards_id_request/0]).
-export_type([post_charges_charge_dispute_request/0]).
-export_type([get_charges_charge_dispute_request/0]).
-export_type([post_quotes_quote_finalize_request/0]).
-export_type([post_skus_id_request/0]).
-export_type([get_skus_id_request/0]).
-export_type([delete_skus_id_request/0]).
-export_type([post_disputes_dispute_request/0]).
-export_type([get_disputes_dispute_request/0]).
-export_type([post_terminal_locations_request/0]).
-export_type([get_terminal_locations_request/0]).
-export_type([post_subscription_schedules_request/0]).
-export_type([get_subscription_schedules_request/0]).
-export_type([post_payment_links_request/0]).
-export_type([get_payment_links_request/0]).
-export_type([post_tokens_request/0]).
-export_type([post_issuing_cardholders_cardholder_request/0]).
-export_type([get_issuing_cardholders_cardholder_request/0]).
-export_type([get_application_fees_id_request/0]).
-export_type([get_exchange_rates_rate_id_request/0]).
-export_type([post_payment_intents_intent_confirm_request/0]).
-export_type([get_credit_notes_preview_request/0]).
-export_type([get_balance_history_id_request/0]).
-export_type([post_payouts_payout_reverse_request/0]).
-export_type([get_reporting_report_runs_report_run_request/0]).
-export_type([get_sources_source_source_transactions_source_transaction_request/0]).
-export_type([post_customers_customer_request/0]).
-export_type([get_customers_customer_request/0]).
-export_type([delete_customers_customer_request/0]).
-export_type([post_billing_portal_sessions_request/0]).
-export_type([post_payment_links_payment_link_request/0]).
-export_type([get_payment_links_payment_link_request/0]).
-export_type([get_credit_notes_credit_note_lines_request/0]).
-export_type([get_sigma_scheduled_query_runs_request/0]).

-type get_radar_early_fraud_warnings_request() ::
    #{query =>
          #{charge => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            payment_intent => binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_charges_charge_refunds_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary()}.
-type get_charges_charge_refunds_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary()}.
-type post_identity_verification_sessions_session_redact_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      session := binary()}.
-type post_billing_portal_configurations_configuration_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      configuration := binary()}.
-type get_billing_portal_configurations_configuration_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      configuration := binary()}.
-type post_payment_methods_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_payment_methods_request() ::
    #{query =>
          #{customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            type :=
                acss_debit |
                afterpay_clearpay |
                alipay |
                au_becs_debit |
                bacs_debit |
                bancontact |
                boleto |
                card |
                eps |
                fpx |
                giropay |
                grabpay |
                ideal |
                klarna |
                oxxo |
                p24 |
                sepa_debit |
                sofort |
                wechat_pay},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_radar_value_lists_value_list_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      value_list := binary()}.
-type get_radar_value_lists_value_list_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      value_list := binary()}.
-type delete_radar_value_lists_value_list_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      value_list := binary()}.
-type post_charges_charge_capture_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary()}.
-type get_disputes_request() ::
    #{query =>
          #{charge => binary(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            payment_intent => binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_prices_price_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      price := binary()}.
-type get_prices_price_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      price := binary()}.
-type post_accounts_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_accounts_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_identity_verification_sessions_session_cancel_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      session := binary()}.
-type post_account_persons_person_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      person := binary()}.
-type get_account_persons_person_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      person := binary()}.
-type delete_account_persons_person_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      person := binary()}.
-type post_issuing_authorizations_authorization_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      authorization := binary()}.
-type get_issuing_authorizations_authorization_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      authorization := binary()}.
-type get_files_file_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      file := binary()}.
-type post_issuing_cards_card_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      card := binary()}.
-type get_issuing_cards_card_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      card := binary()}.
-type post_sources_source_verify_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      source := binary()}.
-type post_invoiceitems_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_invoiceitems_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            invoice => binary(),
            limit => integer(),
            pending => boolean(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type delete_ephemeral_keys_key_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      key := binary()}.
-type get_exchange_rates_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_setup_intents_intent_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type get_setup_intents_intent_request() ::
    #{query => #{client_secret => binary(), expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type post_files_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_files_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            purpose =>
                account_requirement |
                additional_verification |
                business_icon |
                business_logo |
                customer_signature |
                dispute_evidence |
                document_provider_identity_document |
                finance_report_run |
                identity_document |
                identity_document_downloadable |
                pci_document |
                selfie |
                sigma_scheduled_query |
                tax_document_user_upload,
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_customers_customer_bank_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type get_customers_customer_bank_accounts_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type delete_customers_customer_bank_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type get_issuer_fraud_records_issuer_fraud_record_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      issuer_fraud_record := binary()}.
-type post_accounts_account_people_person_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      person := binary()}.
-type get_accounts_account_people_person_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      person := binary()}.
-type delete_accounts_account_people_person_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      person := binary()}.
-type post_payouts_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_payouts_request() ::
    #{query =>
          #{arrival_date =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            destination => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            status => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_account_capabilities_capability_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      capability := binary()}.
-type get_account_capabilities_capability_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      capability := binary()}.
-type get_sources_source_mandate_notifications_mandate_notification_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      mandate_notification := binary(),
      source := binary()}.
-type post_application_fees_fee_refunds_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      fee := binary(),
      id := binary()}.
-type get_application_fees_fee_refunds_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      fee := binary(),
      id := binary()}.
-type get_customers_customer_discount_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type delete_customers_customer_discount_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type post_coupons_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_coupons_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_charges_charge_dispute_close_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary()}.
-type post_plans_plan_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      plan := binary()}.
-type get_plans_plan_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      plan := binary()}.
-type delete_plans_plan_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      plan := binary()}.
-type post_customers_customer_bank_accounts_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_customers_customer_bank_accounts_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type post_terminal_readers_reader_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      reader := binary()}.
-type get_terminal_readers_reader_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      reader := binary()}.
-type delete_terminal_readers_reader_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      reader := binary()}.
-type post_accounts_account_persons_person_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      person := binary()}.
-type get_accounts_account_persons_person_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      person := binary()}.
-type delete_accounts_account_persons_person_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      person := binary()}.
-type post_credit_notes_id_void_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_customers_customer_sources_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_customers_customer_sources_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            object => binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type post_account_links_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type post_payouts_payout_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      payout := binary()}.
-type get_payouts_payout_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      payout := binary()}.
-type post_subscription_items_item_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      item := binary()}.
-type get_subscription_items_item_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      item := binary()}.
-type delete_subscription_items_item_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      item := binary()}.
-type post_products_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_products_request() ::
    #{query =>
          #{active => boolean(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            ids => [binary()],
            limit => integer(),
            shippable => boolean(),
            starting_after => binary(),
            url => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_reporting_report_types_report_type_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      report_type := binary()}.
-type post_quotes_quote_accept_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      quote := binary()}.
-type get_mandates_mandate_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      mandate := binary()}.
-type post_customers_customer_subscriptions_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_customers_customer_subscriptions_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_order_returns_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_transfers_id_reversals_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_transfers_id_reversals_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_reviews_review_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      review := binary()}.
-type post_accounts_account_bank_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      id := binary()}.
-type get_accounts_account_bank_accounts_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      id := binary()}.
-type delete_accounts_account_bank_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      id := binary()}.
-type post_issuing_settlements_settlement_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      settlement := binary()}.
-type get_issuing_settlements_settlement_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      settlement := binary()}.
-type post_promotion_codes_promotion_code_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      promotion_code := binary()}.
-type get_promotion_codes_promotion_code_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      promotion_code := binary()}.
-type post_subscription_schedules_schedule_cancel_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      schedule := binary()}.
-type post_identity_verification_sessions_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_identity_verification_sessions_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            status => canceled | processing | requires_input | verified},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_radar_value_list_items_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_radar_value_list_items_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            value => binary(),
            value_list := binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_events_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_country_specs_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_payment_intents_intent_verify_microdeposits_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type post_subscription_items_subscription_item_usage_records_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      subscription_item := binary()}.
-type get_balance_history_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            currency => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            payout => binary(),
            source => binary(),
            starting_after => binary(),
            type => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_order_returns_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            order => binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_account_external_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_account_external_accounts_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type delete_account_external_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_apple_pay_domains_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_apple_pay_domains_request() ::
    #{query =>
          #{domain_name => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_credit_notes_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_credit_notes_request() ::
    #{query =>
          #{customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            invoice => binary(),
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_sigma_scheduled_query_runs_scheduled_query_run_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      scheduled_query_run := binary()}.
-type post_coupons_coupon_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      coupon := binary()}.
-type get_coupons_coupon_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      coupon := binary()}.
-type delete_coupons_coupon_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      coupon := binary()}.
-type get_customers_customer_tax_ids_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type delete_customers_customer_tax_ids_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type get_radar_early_fraud_warnings_early_fraud_warning_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      early_fraud_warning := binary()}.
-type get_issuing_settlements_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_file_links_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_file_links_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            expired => boolean(),
            file => binary(),
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_identity_verification_reports_report_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      report := binary()}.
-type post_transfers_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_transfers_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            destination => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            transfer_group => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type delete_subscriptions_subscription_exposed_id_discount_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      subscription_exposed_id := binary()}.
-type post_application_fees_id_refunds_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_application_fees_id_refunds_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_accounts_account_bank_accounts_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type post_accounts_account_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type get_accounts_account_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type delete_accounts_account_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type post_subscription_schedules_schedule_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      schedule := binary()}.
-type get_subscription_schedules_schedule_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      schedule := binary()}.
-type post_invoices_invoice_pay_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      invoice := binary()}.
-type post_transfers_transfer_reversals_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary(),
      transfer := binary()}.
-type get_transfers_transfer_reversals_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary(),
      transfer := binary()}.
-type post_topups_topup_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      topup := binary()}.
-type get_topups_topup_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      topup := binary()}.
-type post_recipients_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_recipients_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type delete_recipients_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_invoices_invoice_lines_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      invoice := binary()}.
-type post_accounts_account_external_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      id := binary()}.
-type get_accounts_account_external_accounts_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      id := binary()}.
-type delete_accounts_account_external_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      id := binary()}.
-type post_topups_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_topups_request() ::
    #{query =>
          #{amount =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            status => canceled | failed | pending | succeeded},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_orders_id_returns_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_orders_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_orders_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_apple_pay_domains_domain_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      domain := binary()}.
-type delete_apple_pay_domains_domain_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      domain := binary()}.
-type get_issuing_transactions_request() ::
    #{query =>
          #{card => binary(),
            cardholder => binary(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            type => capture | refund},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_charges_charge_refund_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary()}.
-type post_payment_methods_payment_method_attach_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      payment_method := binary()}.
-type post_payment_intents_intent_cancel_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type get_accounts_account_capabilities_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type get_credit_notes_preview_lines_request() ::
    #{query =>
          #{amount => integer(),
            credit_amount => integer(),
            ending_before => binary(),
            expand => [binary()],
            invoice := binary(),
            limit => integer(),
            lines =>
                [#{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   type := custom_line_item | invoice_line_item,
                   tax_rates => [binary()] | '',
                   quantity => integer(),
                   invoice_line_item => binary(),
                   description => binary(),
                   amount => integer()}],
            memo => binary(),
            metadata => json:value(),
            out_of_band_amount => integer(),
            reason => duplicate | fraudulent | order_change | product_unsatisfactory,
            refund => binary(),
            refund_amount => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_subscriptions_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_subscriptions_request() ::
    #{query =>
          #{collection_method => charge_automatically | send_invoice,
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            current_period_end =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            current_period_start =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            price => binary(),
            starting_after => binary(),
            status =>
                active |
                all |
                canceled |
                ended |
                incomplete |
                incomplete_expired |
                past_due |
                trialing |
                unpaid},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_setup_attempts_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            setup_intent := binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_customers_customer_subscriptions_subscription_exposed_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      subscription_exposed_id := binary()}.
-type get_customers_customer_subscriptions_subscription_exposed_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      subscription_exposed_id := binary()}.
-type delete_customers_customer_subscriptions_subscription_exposed_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      subscription_exposed_id := binary()}.
-type get_bitcoin_receivers_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_orders_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_orders_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            ids => [binary()],
            limit => integer(),
            starting_after => binary(),
            status => binary(),
            status_transitions =>
                #{returned =>
                      #{lte => integer(),
                        lt => integer(),
                        gte => integer(),
                        gt => integer()} |
                      integer(),
                  paid =>
                      #{lte => integer(),
                        lt => integer(),
                        gte => integer(),
                        gt => integer()} |
                      integer(),
                  fulfilled =>
                      #{lte => integer(),
                        lt => integer(),
                        gte => integer(),
                        gt => integer()} |
                      integer(),
                  canceled =>
                      #{lte => integer(),
                        lt => integer(),
                        gte => integer(),
                        gt => integer()} |
                      integer()},
            upstream_ids => [binary()]},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_ephemeral_keys_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type post_webhook_endpoints_webhook_endpoint_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      webhook_endpoint := binary()}.
-type get_webhook_endpoints_webhook_endpoint_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      webhook_endpoint := binary()}.
-type delete_webhook_endpoints_webhook_endpoint_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      webhook_endpoint := binary()}.
-type post_account_persons_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_account_persons_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            relationship =>
                #{representative => boolean(),
                  owner => boolean(),
                  executive => boolean(),
                  director => boolean()},
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_account_capabilities_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_checkout_sessions_session_expire_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      session := binary()}.
-type get_bitcoin_receivers_receiver_transactions_request() ::
    #{query =>
          #{customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      receiver := binary()}.
-type post_quotes_quote_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      quote := binary()}.
-type get_quotes_quote_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      quote := binary()}.
-type post_account_people_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_account_people_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            relationship =>
                #{representative => boolean(),
                  owner => boolean(),
                  executive => boolean(),
                  director => boolean()},
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_setup_intents_intent_confirm_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type post_customers_customer_cards_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_customers_customer_cards_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_identity_verification_reports_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            type => document | id_number,
            verification_session => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_accounts_account_persons_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type get_accounts_account_persons_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            relationship =>
                #{representative => boolean(),
                  owner => boolean(),
                  executive => boolean(),
                  director => boolean()},
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type post_application_fees_id_refund_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_payment_intents_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_payment_intents_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_skus_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_skus_request() ::
    #{query =>
          #{active => boolean(),
            attributes => json:value(),
            ending_before => binary(),
            expand => [binary()],
            ids => [binary()],
            in_stock => boolean(),
            limit => integer(),
            product => binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_webhook_endpoints_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_webhook_endpoints_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_balance_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_customers_customer_balance_transactions_transaction_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      transaction := binary()}.
-type get_customers_customer_balance_transactions_transaction_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      transaction := binary()}.
-type post_payment_methods_payment_method_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      payment_method := binary()}.
-type get_payment_methods_payment_method_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      payment_method := binary()}.
-type post_topups_topup_cancel_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      topup := binary()}.
-type get_events_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            delivery_success => boolean(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            type => binary(),
            types => [binary()]},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_charges_charge_refunds_refund_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary(),
      refund := binary()}.
-type get_charges_charge_refunds_refund_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary(),
      refund := binary()}.
-type post_accounts_account_capabilities_capability_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      capability := binary()}.
-type get_accounts_account_capabilities_capability_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary(),
      capability := binary()}.
-type post_subscription_items_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_subscription_items_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            subscription := binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_quotes_quote_pdf_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      quote := binary()}.
-type post_account_bank_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_account_bank_accounts_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type delete_account_bank_accounts_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_payment_links_payment_link_line_items_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      payment_link := binary()}.
-type get_subscription_items_subscription_item_usage_record_summaries_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      subscription_item := binary()}.
-type post_payment_intents_intent_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type get_payment_intents_intent_request() ::
    #{query => #{client_secret => binary(), expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type post_charges_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_charges_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            payment_intent => binary(),
            starting_after => binary(),
            transfer_group => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_accounts_account_external_accounts_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type get_accounts_account_external_accounts_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type get_issuing_authorizations_request() ::
    #{query =>
          #{card => binary(),
            cardholder => binary(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            status => closed | pending | reversed},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_products_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_products_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type delete_products_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_setup_intents_intent_verify_microdeposits_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type get_reporting_report_types_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_account_external_accounts_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_account_external_accounts_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_radar_value_lists_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_radar_value_lists_request() ::
    #{query =>
          #{alias => binary(),
            contains => binary(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_shipping_rates_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_shipping_rates_request() ::
    #{query =>
          #{active => boolean(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            currency => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_file_links_link_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      link := binary()}.
-type get_file_links_link_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      link := binary()}.
-type get3d_secure_three_d_secure_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      three_d_secure := binary()}.
-type post_invoices_invoice_send_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      invoice := binary()}.
-type get_invoices_upcoming_request() ::
    #{query =>
          #{automatic_tax => #{enabled := boolean()},
            coupon => binary(),
            customer => binary(),
            customer_details =>
                #{tax_ids =>
                      [#{value := binary(),
                         type :=
                             ae_trn | au_abn | au_arn | br_cnpj | br_cpf | ca_bn | ca_gst_hst |
                             ca_pst_bc | ca_pst_mb | ca_pst_sk | ca_qst | ch_vat | cl_tin | es_cif |
                             eu_vat | gb_vat | ge_vat | hk_br | id_npwp | il_vat | in_gst | is_vat |
                             jp_cn | jp_rn | kr_brn | li_uid | mx_rfc | my_frp | my_itn | my_sst |
                             no_vat | nz_gst | ru_inn | ru_kpp | sa_vat | sg_gst | sg_uen | th_vat |
                             tw_vat | ua_vat | us_ein | za_vat}],
                  tax_exempt => '' | exempt | none | reverse,
                  tax => #{ip_address => binary() | ''},
                  shipping =>
                      #{phone => binary(),
                        name := binary(),
                        address :=
                            #{state => binary(),
                              postal_code => binary(),
                              line2 => binary(),
                              line1 => binary(),
                              country => binary(),
                              city => binary()}} |
                      '',
                  address =>
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary()} |
                      ''},
            discounts => [#{discount => binary(), coupon => binary()}] | '',
            expand => [binary()],
            invoice_items =>
                [#{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_rates => [binary()] | '',
                   quantity => integer(),
                   price_data =>
                       #{unit_amount_decimal => binary(),
                         unit_amount => integer(),
                         tax_behavior => exclusive | inclusive | unspecified,
                         product := binary(),
                         currency := binary()},
                   price => binary(),
                   period => #{start := integer(), 'end' := integer()},
                   metadata => json:value() | '',
                   invoiceitem => binary(),
                   discounts => [#{discount => binary(), coupon => binary()}] | '',
                   discountable => boolean(),
                   description => binary(),
                   currency => binary(),
                   amount => integer()}],
            schedule => binary(),
            subscription => binary(),
            subscription_billing_cycle_anchor => now | unchanged | integer(),
            subscription_cancel_at => integer() | '',
            subscription_cancel_at_period_end => boolean(),
            subscription_cancel_now => boolean(),
            subscription_default_tax_rates => [binary()] | '',
            subscription_items =>
                [#{tax_rates => [binary()] | '',
                   quantity => integer(),
                   price_data =>
                       #{unit_amount_decimal => binary(),
                         unit_amount => integer(),
                         tax_behavior => exclusive | inclusive | unspecified,
                         recurring :=
                             #{interval_count => integer(), interval := day | month | week | year},
                         product := binary(),
                         currency := binary()},
                   price => binary(),
                   metadata => json:value() | '',
                   id => binary(),
                   deleted => boolean(),
                   clear_usage => boolean(),
                   billing_thresholds => #{usage_gte := integer()} | ''}],
            subscription_proration_behavior => always_invoice | create_prorations | none,
            subscription_proration_date => integer(),
            subscription_start_date => integer(),
            subscription_trial_end => now | integer(),
            subscription_trial_from_plan => boolean()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_checkout_sessions_session_line_items_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      session := binary()}.
-type get_tax_codes_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_invoices_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_invoices_request() ::
    #{query =>
          #{collection_method => charge_automatically | send_invoice,
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            customer => binary(),
            due_date =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            status => draft | open | paid | uncollectible | void,
            subscription => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_charges_charge_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary()}.
-type get_charges_charge_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary()}.
-type post_invoices_invoice_mark_uncollectible_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      invoice := binary()}.
-type post_customers_customer_sources_id_verify_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type post_orders_id_pay_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_customers_customer_bank_accounts_id_verify_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type post_account_people_person_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      person := binary()}.
-type get_account_people_person_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      person := binary()}.
-type delete_account_people_person_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      person := binary()}.
-type post_checkout_sessions_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_checkout_sessions_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            payment_intent => binary(),
            starting_after => binary(),
            subscription => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_accounts_account_login_links_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type post_terminal_readers_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_terminal_readers_request() ::
    #{query =>
          #{device_type =>
                bbpos_chipper2x | bbpos_wisepad3 | bbpos_wisepos_e | stripe_m2 | verifone_P400,
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            location => binary(),
            starting_after => binary(),
            status => offline | online},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_issuing_disputes_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_issuing_disputes_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            status => expired | lost | submitted | unsubmitted | won,
            transaction => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post3d_secure_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type post_prices_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_prices_request() ::
    #{query =>
          #{active => boolean(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            currency => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            lookup_keys => [binary()],
            product => binary(),
            recurring => #{usage_type => licensed | metered, interval => day | month | week | year},
            starting_after => binary(),
            type => one_time | recurring},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_invoices_invoice_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      invoice := binary()}.
-type get_invoices_invoice_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      invoice := binary()}.
-type delete_invoices_invoice_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      invoice := binary()}.
-type post_identity_verification_sessions_session_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      session := binary()}.
-type get_identity_verification_sessions_session_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      session := binary()}.
-type get_balance_transactions_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_setup_intents_intent_cancel_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type post_issuing_transactions_transaction_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      transaction := binary()}.
-type get_issuing_transactions_transaction_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      transaction := binary()}.
-type post_terminal_connection_tokens_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_reviews_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_promotion_codes_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_promotion_codes_request() ::
    #{query =>
          #{active => boolean(),
            code => binary(),
            coupon => binary(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_customers_customer_subscriptions_subscription_exposed_id_discount_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      subscription_exposed_id := binary()}.
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      subscription_exposed_id := binary()}.
-type get_quotes_quote_computed_upfront_line_items_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      quote := binary()}.
-type get_radar_value_list_items_item_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      item := binary()}.
-type delete_radar_value_list_items_item_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      item := binary()}.
-type get_issuer_fraud_records_request() ::
    #{query =>
          #{charge => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_tax_rates_tax_rate_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      tax_rate := binary()}.
-type get_tax_rates_tax_rate_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      tax_rate := binary()}.
-type post_recipients_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_recipients_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            type => corporation | individual,
            verified => boolean()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_plans_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_plans_request() ::
    #{query =>
          #{active => boolean(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            product => binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_customers_customer_balance_transactions_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_customers_customer_balance_transactions_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type post_reviews_review_approve_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      review := binary()}.
-type post_customers_customer_tax_ids_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_customers_customer_tax_ids_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_tokens_token_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      token := binary()}.
-type get_balance_transactions_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            currency => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            payout => binary(),
            source => binary(),
            starting_after => binary(),
            type => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_tax_codes_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_accounts_account_reject_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type post_subscriptions_subscription_exposed_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      subscription_exposed_id := binary()}.
-type get_subscriptions_subscription_exposed_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      subscription_exposed_id := binary()}.
-type delete_subscriptions_subscription_exposed_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      subscription_exposed_id := binary()}.
-type get_country_specs_country_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      country := binary()}.
-type post_invoices_invoice_finalize_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      invoice := binary()}.
-type post_terminal_locations_location_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      location := binary()}.
-type get_terminal_locations_location_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      location := binary()}.
-type delete_terminal_locations_location_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      location := binary()}.
-type post_account_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_account_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term()}.
-type delete_account_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type post_shipping_rates_shipping_rate_token_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      shipping_rate_token := binary()}.
-type get_shipping_rates_shipping_rate_token_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      shipping_rate_token := binary()}.
-type get_invoices_upcoming_lines_request() ::
    #{query =>
          #{automatic_tax => #{enabled := boolean()},
            coupon => binary(),
            customer => binary(),
            customer_details =>
                #{tax_ids =>
                      [#{value := binary(),
                         type :=
                             ae_trn | au_abn | au_arn | br_cnpj | br_cpf | ca_bn | ca_gst_hst |
                             ca_pst_bc | ca_pst_mb | ca_pst_sk | ca_qst | ch_vat | cl_tin | es_cif |
                             eu_vat | gb_vat | ge_vat | hk_br | id_npwp | il_vat | in_gst | is_vat |
                             jp_cn | jp_rn | kr_brn | li_uid | mx_rfc | my_frp | my_itn | my_sst |
                             no_vat | nz_gst | ru_inn | ru_kpp | sa_vat | sg_gst | sg_uen | th_vat |
                             tw_vat | ua_vat | us_ein | za_vat}],
                  tax_exempt => '' | exempt | none | reverse,
                  tax => #{ip_address => binary() | ''},
                  shipping =>
                      #{phone => binary(),
                        name := binary(),
                        address :=
                            #{state => binary(),
                              postal_code => binary(),
                              line2 => binary(),
                              line1 => binary(),
                              country => binary(),
                              city => binary()}} |
                      '',
                  address =>
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary()} |
                      ''},
            discounts => [#{discount => binary(), coupon => binary()}] | '',
            ending_before => binary(),
            expand => [binary()],
            invoice_items =>
                [#{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_rates => [binary()] | '',
                   quantity => integer(),
                   price_data =>
                       #{unit_amount_decimal => binary(),
                         unit_amount => integer(),
                         tax_behavior => exclusive | inclusive | unspecified,
                         product := binary(),
                         currency := binary()},
                   price => binary(),
                   period => #{start := integer(), 'end' := integer()},
                   metadata => json:value() | '',
                   invoiceitem => binary(),
                   discounts => [#{discount => binary(), coupon => binary()}] | '',
                   discountable => boolean(),
                   description => binary(),
                   currency => binary(),
                   amount => integer()}],
            limit => integer(),
            schedule => binary(),
            starting_after => binary(),
            subscription => binary(),
            subscription_billing_cycle_anchor => now | unchanged | integer(),
            subscription_cancel_at => integer() | '',
            subscription_cancel_at_period_end => boolean(),
            subscription_cancel_now => boolean(),
            subscription_default_tax_rates => [binary()] | '',
            subscription_items =>
                [#{tax_rates => [binary()] | '',
                   quantity => integer(),
                   price_data =>
                       #{unit_amount_decimal => binary(),
                         unit_amount => integer(),
                         tax_behavior => exclusive | inclusive | unspecified,
                         recurring :=
                             #{interval_count => integer(), interval := day | month | week | year},
                         product := binary(),
                         currency := binary()},
                   price => binary(),
                   metadata => json:value() | '',
                   id => binary(),
                   deleted => boolean(),
                   clear_usage => boolean(),
                   billing_thresholds => #{usage_gte := integer()} | ''}],
            subscription_proration_behavior => always_invoice | create_prorations | none,
            subscription_proration_date => integer(),
            subscription_start_date => integer(),
            subscription_trial_end => now | integer(),
            subscription_trial_from_plan => boolean()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_issuing_cardholders_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_issuing_cardholders_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            email => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            phone_number => binary(),
            starting_after => binary(),
            status => active | blocked | inactive,
            type => company | individual},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_customers_customer_sources_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type get_customers_customer_sources_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type delete_customers_customer_sources_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type get_application_fees_request() ::
    #{query =>
          #{charge => binary(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_bitcoin_receivers_request() ::
    #{query =>
          #{active => boolean(),
            ending_before => binary(),
            expand => [binary()],
            filled => boolean(),
            limit => integer(),
            starting_after => binary(),
            uncaptured_funds => boolean()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_refunds_refund_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      refund := binary()}.
-type get_refunds_refund_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      refund := binary()}.
-type post_account_login_links_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type post_tax_rates_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_tax_rates_request() ::
    #{query =>
          #{active => boolean(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            inclusive => boolean(),
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_accounts_account_people_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type get_accounts_account_people_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            relationship =>
                #{representative => boolean(),
                  owner => boolean(),
                  executive => boolean(),
                  director => boolean()},
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      account := binary()}.
-type post_issuing_disputes_dispute_submit_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      dispute := binary()}.
-type post_sources_source_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      source := binary()}.
-type get_sources_source_request() ::
    #{query => #{client_secret => binary(), expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      source := binary()}.
-type get_checkout_sessions_session_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      session := binary()}.
-type post_payment_methods_payment_method_detach_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      payment_method := binary()}.
-type post_customers_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_customers_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            email => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_account_bank_accounts_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type post_issuing_disputes_dispute_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      dispute := binary()}.
-type get_issuing_disputes_dispute_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      dispute := binary()}.
-type post_disputes_dispute_close_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      dispute := binary()}.
-type post_quotes_quote_cancel_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      quote := binary()}.
-type get_customers_customer_payment_methods_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            type :=
                acss_debit |
                afterpay_clearpay |
                alipay |
                au_becs_debit |
                bacs_debit |
                bancontact |
                boleto |
                card |
                eps |
                fpx |
                giropay |
                grabpay |
                ideal |
                klarna |
                oxxo |
                p24 |
                sepa_debit |
                sofort |
                wechat_pay},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type post_refunds_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_refunds_request() ::
    #{query =>
          #{charge => binary(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            payment_intent => binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_credit_notes_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_credit_notes_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_bitcoin_transactions_request() ::
    #{query =>
          #{customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            receiver => binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_setup_intents_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_setup_intents_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            payment_method => binary(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_payouts_payout_cancel_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      payout := binary()}.
-type post_issuing_authorizations_authorization_approve_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      authorization := binary()}.
-type post_issuing_authorizations_authorization_decline_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      authorization := binary()}.
-type post_reporting_report_runs_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_reporting_report_runs_request() ::
    #{query =>
          #{created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_invoices_invoice_void_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      invoice := binary()}.
-type post_sources_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type post_billing_portal_configurations_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_billing_portal_configurations_request() ::
    #{query =>
          #{active => boolean(),
            ending_before => binary(),
            expand => [binary()],
            is_default => boolean(),
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_quotes_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_quotes_request() ::
    #{query =>
          #{customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary(),
            status => accepted | canceled | draft | open},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_transfers_transfer_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      transfer := binary()}.
-type get_transfers_transfer_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      transfer := binary()}.
-type get_quotes_quote_line_items_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      quote := binary()}.
-type post_invoiceitems_invoiceitem_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      invoiceitem := binary()}.
-type get_invoiceitems_invoiceitem_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      invoiceitem := binary()}.
-type delete_invoiceitems_invoiceitem_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      invoiceitem := binary()}.
-type post_payment_intents_intent_capture_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type post_issuing_cards_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_issuing_cards_request() ::
    #{query =>
          #{cardholder => binary(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            ending_before => binary(),
            exp_month => integer(),
            exp_year => integer(),
            expand => [binary()],
            last4 => binary(),
            limit => integer(),
            starting_after => binary(),
            status => active | canceled | inactive,
            type => physical | virtual},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_sources_source_source_transactions_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      source := binary()}.
-type post_subscription_schedules_schedule_release_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      schedule := binary()}.
-type post_customers_customer_cards_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type get_customers_customer_cards_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type delete_customers_customer_cards_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary(),
      id := binary()}.
-type post_charges_charge_dispute_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary()}.
-type get_charges_charge_dispute_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      charge := binary()}.
-type post_quotes_quote_finalize_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      quote := binary()}.
-type post_skus_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_skus_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type delete_skus_id_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_disputes_dispute_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      dispute := binary()}.
-type get_disputes_dispute_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      dispute := binary()}.
-type post_terminal_locations_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_terminal_locations_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_subscription_schedules_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_subscription_schedules_request() ::
    #{query =>
          #{canceled_at =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            completed_at =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            created =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            customer => binary(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            released_at =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer()} |
                integer(),
            scheduled => boolean(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_payment_links_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type get_payment_links_request() ::
    #{query =>
          #{active => boolean(),
            ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.
-type post_tokens_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type post_issuing_cardholders_cardholder_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      cardholder := binary()}.
-type get_issuing_cardholders_cardholder_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      cardholder := binary()}.
-type get_application_fees_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type get_exchange_rates_rate_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      rate_id := binary()}.
-type post_payment_intents_intent_confirm_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      intent := binary()}.
-type get_credit_notes_preview_request() ::
    #{query =>
          #{amount => integer(),
            credit_amount => integer(),
            expand => [binary()],
            invoice := binary(),
            lines =>
                [#{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   type := custom_line_item | invoice_line_item,
                   tax_rates => [binary()] | '',
                   quantity => integer(),
                   invoice_line_item => binary(),
                   description => binary(),
                   amount => integer()}],
            memo => binary(),
            metadata => json:value(),
            out_of_band_amount => integer(),
            reason => duplicate | fraudulent | order_change | product_unsatisfactory,
            refund => binary(),
            refund_amount => integer()},
      header => map(),
      cookie => map(),
      body => term()}.
-type get_balance_history_id_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      id := binary()}.
-type post_payouts_payout_reverse_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      payout := binary()}.
-type get_reporting_report_runs_report_run_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      report_run := binary()}.
-type get_sources_source_source_transactions_source_transaction_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      source := binary(),
      source_transaction := binary()}.
-type post_customers_customer_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type get_customers_customer_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type delete_customers_customer_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      customer := binary()}.
-type post_billing_portal_sessions_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term()}.
-type post_payment_links_payment_link_request() ::
    #{query => map(),
      header => map(),
      cookie => map(),
      body => term(),
      payment_link := binary()}.
-type get_payment_links_payment_link_request() ::
    #{query => #{expand => [binary()]},
      header => map(),
      cookie => map(),
      body => term(),
      payment_link := binary()}.
-type get_credit_notes_credit_note_lines_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term(),
      credit_note := binary()}.
-type get_sigma_scheduled_query_runs_request() ::
    #{query =>
          #{ending_before => binary(),
            expand => [binary()],
            limit => integer(),
            starting_after => binary()},
      header => map(),
      cookie => map(),
      body => term()}.

-spec get_radar_early_fraud_warnings(get_radar_early_fraud_warnings_request()) -> term().
get_radar_early_fraud_warnings(Args) ->
    get_radar_early_fraud_warnings(Args, #{}).

-spec get_radar_early_fraud_warnings(get_radar_early_fraud_warnings_request(),
                                     mhttp:request_options()) ->
                                        term().
get_radar_early_fraud_warnings(Args, Options) ->
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([charge,
                                     ending_before,
                                     expand,
                                     limit,
                                     payment_intent,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refunds(post_charges_charge_refunds_request()) -> term().
post_charges_charge_refunds(Args) ->
    post_charges_charge_refunds(Args, #{}).

-spec post_charges_charge_refunds(post_charges_charge_refunds_request(),
                                  mhttp:request_options()) ->
                                     term().
post_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refunds", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_refunds(get_charges_charge_refunds_request()) -> term().
get_charges_charge_refunds(Args) ->
    get_charges_charge_refunds(Args, #{}).

-spec get_charges_charge_refunds(get_charges_charge_refunds_request(),
                                 mhttp:request_options()) ->
                                    term().
get_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refunds", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_identity_verification_sessions_session_redact(post_identity_verification_sessions_session_redact_request()) ->
                                                          term().
post_identity_verification_sessions_session_redact(Args) ->
    post_identity_verification_sessions_session_redact(Args, #{}).

-spec
    post_identity_verification_sessions_session_redact(post_identity_verification_sessions_session_redact_request(),
                                                       mhttp:request_options()) ->
                                                          term().
post_identity_verification_sessions_session_redact(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s/redact", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_billing_portal_configurations_configuration(post_billing_portal_configurations_configuration_request()) ->
                                                        term().
post_billing_portal_configurations_configuration(Args) ->
    post_billing_portal_configurations_configuration(Args, #{}).

-spec
    post_billing_portal_configurations_configuration(post_billing_portal_configurations_configuration_request(),
                                                     mhttp:request_options()) ->
                                                        term().
post_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations/~s", [VarConfiguration]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_billing_portal_configurations_configuration(get_billing_portal_configurations_configuration_request()) ->
                                                       term().
get_billing_portal_configurations_configuration(Args) ->
    get_billing_portal_configurations_configuration(Args, #{}).

-spec
    get_billing_portal_configurations_configuration(get_billing_portal_configurations_configuration_request(),
                                                    mhttp:request_options()) ->
                                                       term().
get_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations/~s", [VarConfiguration]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods(post_payment_methods_request()) -> term().
post_payment_methods(Args) ->
    post_payment_methods(Args, #{}).

-spec post_payment_methods(post_payment_methods_request(), mhttp:request_options()) ->
                              term().
post_payment_methods(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_methods(get_payment_methods_request()) -> term().
get_payment_methods(Args) ->
    get_payment_methods(Args, #{}).

-spec get_payment_methods(get_payment_methods_request(), mhttp:request_options()) ->
                             term().
get_payment_methods(Args, Options) ->
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([customer, ending_before, expand, limit, starting_after, type],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_lists_value_list(post_radar_value_lists_value_list_request()) ->
                                           term().
post_radar_value_lists_value_list(Args) ->
    post_radar_value_lists_value_list(Args, #{}).

-spec post_radar_value_lists_value_list(post_radar_value_lists_value_list_request(),
                                        mhttp:request_options()) ->
                                           term().
post_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_lists_value_list(get_radar_value_lists_value_list_request()) ->
                                          term().
get_radar_value_lists_value_list(Args) ->
    get_radar_value_lists_value_list(Args, #{}).

-spec get_radar_value_lists_value_list(get_radar_value_lists_value_list_request(),
                                       mhttp:request_options()) ->
                                          term().
get_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_radar_value_lists_value_list(delete_radar_value_lists_value_list_request()) ->
                                           term().
delete_radar_value_lists_value_list(Args) ->
    delete_radar_value_lists_value_list(Args, #{}).

-spec delete_radar_value_lists_value_list(delete_radar_value_lists_value_list_request(),
                                          mhttp:request_options()) ->
                                             term().
delete_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_capture(post_charges_charge_capture_request()) -> term().
post_charges_charge_capture(Args) ->
    post_charges_charge_capture(Args, #{}).

-spec post_charges_charge_capture(post_charges_charge_capture_request(),
                                  mhttp:request_options()) ->
                                     term().
post_charges_charge_capture(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/capture", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_disputes(get_disputes_request()) -> term().
get_disputes(Args) ->
    get_disputes(Args, #{}).

-spec get_disputes(get_disputes_request(), mhttp:request_options()) -> term().
get_disputes(Args, Options) ->
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([charge,
                                     created,
                                     ending_before,
                                     expand,
                                     limit,
                                     payment_intent,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_prices_price(post_prices_price_request()) -> term().
post_prices_price(Args) ->
    post_prices_price(Args, #{}).

-spec post_prices_price(post_prices_price_request(), mhttp:request_options()) -> term().
post_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/prices/~s", [VarPrice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_prices_price(get_prices_price_request()) -> term().
get_prices_price(Args) ->
    get_prices_price(Args, #{}).

-spec get_prices_price(get_prices_price_request(), mhttp:request_options()) -> term().
get_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/prices/~s", [VarPrice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts(post_accounts_request()) -> term().
post_accounts(Args) ->
    post_accounts(Args, #{}).

-spec post_accounts(post_accounts_request(), mhttp:request_options()) -> term().
post_accounts(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts(get_accounts_request()) -> term().
get_accounts(Args) ->
    get_accounts(Args, #{}).

-spec get_accounts(get_accounts_request(), mhttp:request_options()) -> term().
get_accounts(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_identity_verification_sessions_session_cancel(post_identity_verification_sessions_session_cancel_request()) ->
                                                          term().
post_identity_verification_sessions_session_cancel(Args) ->
    post_identity_verification_sessions_session_cancel(Args, #{}).

-spec
    post_identity_verification_sessions_session_cancel(post_identity_verification_sessions_session_cancel_request(),
                                                       mhttp:request_options()) ->
                                                          term().
post_identity_verification_sessions_session_cancel(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s/cancel", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_persons_person(post_account_persons_person_request()) -> term().
post_account_persons_person(Args) ->
    post_account_persons_person(Args, #{}).

-spec post_account_persons_person(post_account_persons_person_request(),
                                  mhttp:request_options()) ->
                                     term().
post_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_persons_person(get_account_persons_person_request()) -> term().
get_account_persons_person(Args) ->
    get_account_persons_person(Args, #{}).

-spec get_account_persons_person(get_account_persons_person_request(),
                                 mhttp:request_options()) ->
                                    term().
get_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_persons_person(delete_account_persons_person_request()) -> term().
delete_account_persons_person(Args) ->
    delete_account_persons_person(Args, #{}).

-spec delete_account_persons_person(delete_account_persons_person_request(),
                                    mhttp:request_options()) ->
                                       term().
delete_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_authorizations_authorization(post_issuing_authorizations_authorization_request()) ->
                                                 term().
post_issuing_authorizations_authorization(Args) ->
    post_issuing_authorizations_authorization(Args, #{}).

-spec
    post_issuing_authorizations_authorization(post_issuing_authorizations_authorization_request(),
                                              mhttp:request_options()) ->
                                                 term().
post_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s", [VarAuthorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_issuing_authorizations_authorization(get_issuing_authorizations_authorization_request()) ->
                                                term().
get_issuing_authorizations_authorization(Args) ->
    get_issuing_authorizations_authorization(Args, #{}).

-spec
    get_issuing_authorizations_authorization(get_issuing_authorizations_authorization_request(),
                                             mhttp:request_options()) ->
                                                term().
get_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s", [VarAuthorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_files_file(get_files_file_request()) -> term().
get_files_file(Args) ->
    get_files_file(Args, #{}).

-spec get_files_file(get_files_file_request(), mhttp:request_options()) -> term().
get_files_file(Args, Options) ->
    VarFile = maps:get(file, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/files/~s", [VarFile]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cards_card(post_issuing_cards_card_request()) -> term().
post_issuing_cards_card(Args) ->
    post_issuing_cards_card(Args, #{}).

-spec post_issuing_cards_card(post_issuing_cards_card_request(),
                              mhttp:request_options()) ->
                                 term().
post_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards/~s", [VarCard]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cards_card(get_issuing_cards_card_request()) -> term().
get_issuing_cards_card(Args) ->
    get_issuing_cards_card(Args, #{}).

-spec get_issuing_cards_card(get_issuing_cards_card_request(), mhttp:request_options()) ->
                                term().
get_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards/~s", [VarCard]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources_source_verify(post_sources_source_verify_request()) -> term().
post_sources_source_verify(Args) ->
    post_sources_source_verify(Args, #{}).

-spec post_sources_source_verify(post_sources_source_verify_request(),
                                 mhttp:request_options()) ->
                                    term().
post_sources_source_verify(Args, Options) ->
    VarSource = maps:get(source, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/~s/verify", [VarSource]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoiceitems(post_invoiceitems_request()) -> term().
post_invoiceitems(Args) ->
    post_invoiceitems(Args, #{}).

-spec post_invoiceitems(post_invoiceitems_request(), mhttp:request_options()) -> term().
post_invoiceitems(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoiceitems(get_invoiceitems_request()) -> term().
get_invoiceitems(Args) ->
    get_invoiceitems(Args, #{}).

-spec get_invoiceitems(get_invoiceitems_request(), mhttp:request_options()) -> term().
get_invoiceitems(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({pending, Value}) ->
                encode_q(form, false, <<"pending">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     customer,
                                     ending_before,
                                     expand,
                                     invoice,
                                     limit,
                                     pending,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_ephemeral_keys_key(delete_ephemeral_keys_key_request()) -> term().
delete_ephemeral_keys_key(Args) ->
    delete_ephemeral_keys_key(Args, #{}).

-spec delete_ephemeral_keys_key(delete_ephemeral_keys_key_request(),
                                mhttp:request_options()) ->
                                   term().
delete_ephemeral_keys_key(Args, Options) ->
    VarKey = maps:get(key, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/ephemeral_keys/~s", [VarKey]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_exchange_rates(get_exchange_rates_request()) -> term().
get_exchange_rates(Args) ->
    get_exchange_rates(Args, #{}).

-spec get_exchange_rates(get_exchange_rates_request(), mhttp:request_options()) -> term().
get_exchange_rates(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/exchange_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent(post_setup_intents_intent_request()) -> term().
post_setup_intents_intent(Args) ->
    post_setup_intents_intent(Args, #{}).

-spec post_setup_intents_intent(post_setup_intents_intent_request(),
                                mhttp:request_options()) ->
                                   term().
post_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_intents_intent(get_setup_intents_intent_request()) -> term().
get_setup_intents_intent(Args) ->
    get_setup_intents_intent(Args, #{}).

-spec get_setup_intents_intent(get_setup_intents_intent_request(),
                               mhttp:request_options()) ->
                                  term().
get_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    EncodeQuery =
        fun ({client_secret, Value}) ->
                encode_q(form, false, <<"client_secret">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([client_secret, expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_files(post_files_request()) -> term().
post_files(Args) ->
    post_files(Args, #{}).

-spec post_files(post_files_request(), mhttp:request_options()) -> term().
post_files(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/files", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_files(get_files_request()) -> term().
get_files(Args) ->
    get_files(Args, #{}).

-spec get_files(get_files_request(), mhttp:request_options()) -> term().
get_files(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({purpose, Value}) ->
                encode_q(form, false, <<"purpose">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     ending_before,
                                     expand,
                                     limit,
                                     purpose,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/files", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_bank_accounts_id(post_customers_customer_bank_accounts_id_request()) ->
                                                term().
post_customers_customer_bank_accounts_id(Args) ->
    post_customers_customer_bank_accounts_id(Args, #{}).

-spec
    post_customers_customer_bank_accounts_id(post_customers_customer_bank_accounts_id_request(),
                                             mhttp:request_options()) ->
                                                term().
post_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_bank_accounts_id(get_customers_customer_bank_accounts_id_request()) ->
                                               term().
get_customers_customer_bank_accounts_id(Args) ->
    get_customers_customer_bank_accounts_id(Args, #{}).

-spec
    get_customers_customer_bank_accounts_id(get_customers_customer_bank_accounts_id_request(),
                                            mhttp:request_options()) ->
                                               term().
get_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_bank_accounts_id(delete_customers_customer_bank_accounts_id_request()) ->
                                                  term().
delete_customers_customer_bank_accounts_id(Args) ->
    delete_customers_customer_bank_accounts_id(Args, #{}).

-spec
    delete_customers_customer_bank_accounts_id(delete_customers_customer_bank_accounts_id_request(),
                                               mhttp:request_options()) ->
                                                  term().
delete_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_issuer_fraud_records_issuer_fraud_record(get_issuer_fraud_records_issuer_fraud_record_request()) ->
                                                    term().
get_issuer_fraud_records_issuer_fraud_record(Args) ->
    get_issuer_fraud_records_issuer_fraud_record(Args, #{}).

-spec
    get_issuer_fraud_records_issuer_fraud_record(get_issuer_fraud_records_issuer_fraud_record_request(),
                                                 mhttp:request_options()) ->
                                                    term().
get_issuer_fraud_records_issuer_fraud_record(Args, Options) ->
    VarIssuerFraudRecord = maps:get(issuer_fraud_record, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuer_fraud_records/~s", [VarIssuerFraudRecord]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_people_person(post_accounts_account_people_person_request()) ->
                                           term().
post_accounts_account_people_person(Args) ->
    post_accounts_account_people_person(Args, #{}).

-spec post_accounts_account_people_person(post_accounts_account_people_person_request(),
                                          mhttp:request_options()) ->
                                             term().
post_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_people_person(get_accounts_account_people_person_request()) ->
                                            term().
get_accounts_account_people_person(Args) ->
    get_accounts_account_people_person(Args, #{}).

-spec get_accounts_account_people_person(get_accounts_account_people_person_request(),
                                         mhttp:request_options()) ->
                                            term().
get_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_accounts_account_people_person(delete_accounts_account_people_person_request()) ->
                                             term().
delete_accounts_account_people_person(Args) ->
    delete_accounts_account_people_person(Args, #{}).

-spec
    delete_accounts_account_people_person(delete_accounts_account_people_person_request(),
                                          mhttp:request_options()) ->
                                             term().
delete_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts(post_payouts_request()) -> term().
post_payouts(Args) ->
    post_payouts(Args, #{}).

-spec post_payouts(post_payouts_request(), mhttp:request_options()) -> term().
post_payouts(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payouts(get_payouts_request()) -> term().
get_payouts(Args) ->
    get_payouts(Args, #{}).

-spec get_payouts(get_payouts_request(), mhttp:request_options()) -> term().
get_payouts(Args, Options) ->
    EncodeQuery =
        fun ({arrival_date, Value}) ->
                encode_q(deepObject, true, <<"arrival_date">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({destination, Value}) ->
                encode_q(form, false, <<"destination">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([arrival_date,
                                     created,
                                     destination,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     status],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_account_capabilities_capability(post_account_capabilities_capability_request()) ->
                                            term().
post_account_capabilities_capability(Args) ->
    post_account_capabilities_capability(Args, #{}).

-spec post_account_capabilities_capability(post_account_capabilities_capability_request(),
                                           mhttp:request_options()) ->
                                              term().
post_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/capabilities/~s", [VarCapability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_account_capabilities_capability(get_account_capabilities_capability_request()) ->
                                           term().
get_account_capabilities_capability(Args) ->
    get_account_capabilities_capability(Args, #{}).

-spec get_account_capabilities_capability(get_account_capabilities_capability_request(),
                                          mhttp:request_options()) ->
                                             term().
get_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/capabilities/~s", [VarCapability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_sources_source_mandate_notifications_mandate_notification(get_sources_source_mandate_notifications_mandate_notification_request()) ->
                                                                     term().
get_sources_source_mandate_notifications_mandate_notification(Args) ->
    get_sources_source_mandate_notifications_mandate_notification(Args, #{}).

-spec
    get_sources_source_mandate_notifications_mandate_notification(get_sources_source_mandate_notifications_mandate_notification_request(),
                                                                  mhttp:request_options()) ->
                                                                     term().
get_sources_source_mandate_notifications_mandate_notification(Args, Options) ->
    VarMandateNotification = maps:get(mandate_notification, Args),
    VarSource = maps:get(source, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/sources/~s/mandate_notifications/~s",
                      [VarSource, VarMandateNotification]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_application_fees_fee_refunds_id(post_application_fees_fee_refunds_id_request()) ->
                                            term().
post_application_fees_fee_refunds_id(Args) ->
    post_application_fees_fee_refunds_id(Args, #{}).

-spec post_application_fees_fee_refunds_id(post_application_fees_fee_refunds_id_request(),
                                           mhttp:request_options()) ->
                                              term().
post_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds/~s", [VarFee, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_application_fees_fee_refunds_id(get_application_fees_fee_refunds_id_request()) ->
                                           term().
get_application_fees_fee_refunds_id(Args) ->
    get_application_fees_fee_refunds_id(Args, #{}).

-spec get_application_fees_fee_refunds_id(get_application_fees_fee_refunds_id_request(),
                                          mhttp:request_options()) ->
                                             term().
get_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds/~s", [VarFee, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_discount(get_customers_customer_discount_request()) ->
                                         term().
get_customers_customer_discount(Args) ->
    get_customers_customer_discount(Args, #{}).

-spec get_customers_customer_discount(get_customers_customer_discount_request(),
                                      mhttp:request_options()) ->
                                         term().
get_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/discount", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_discount(delete_customers_customer_discount_request()) ->
                                            term().
delete_customers_customer_discount(Args) ->
    delete_customers_customer_discount(Args, #{}).

-spec delete_customers_customer_discount(delete_customers_customer_discount_request(),
                                         mhttp:request_options()) ->
                                            term().
delete_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/discount", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_coupons(post_coupons_request()) -> term().
post_coupons(Args) ->
    post_coupons(Args, #{}).

-spec post_coupons(post_coupons_request(), mhttp:request_options()) -> term().
post_coupons(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_coupons(get_coupons_request()) -> term().
get_coupons(Args) ->
    get_coupons(Args, #{}).

-spec get_coupons(get_coupons_request(), mhttp:request_options()) -> term().
get_coupons(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_dispute_close(post_charges_charge_dispute_close_request()) ->
                                           term().
post_charges_charge_dispute_close(Args) ->
    post_charges_charge_dispute_close(Args, #{}).

-spec post_charges_charge_dispute_close(post_charges_charge_dispute_close_request(),
                                        mhttp:request_options()) ->
                                           term().
post_charges_charge_dispute_close(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/dispute/close", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_plans_plan(post_plans_plan_request()) -> term().
post_plans_plan(Args) ->
    post_plans_plan(Args, #{}).

-spec post_plans_plan(post_plans_plan_request(), mhttp:request_options()) -> term().
post_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_plans_plan(get_plans_plan_request()) -> term().
get_plans_plan(Args) ->
    get_plans_plan(Args, #{}).

-spec get_plans_plan(get_plans_plan_request(), mhttp:request_options()) -> term().
get_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_plans_plan(delete_plans_plan_request()) -> term().
delete_plans_plan(Args) ->
    delete_plans_plan(Args, #{}).

-spec delete_plans_plan(delete_plans_plan_request(), mhttp:request_options()) -> term().
delete_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_bank_accounts(post_customers_customer_bank_accounts_request()) ->
                                             term().
post_customers_customer_bank_accounts(Args) ->
    post_customers_customer_bank_accounts(Args, #{}).

-spec
    post_customers_customer_bank_accounts(post_customers_customer_bank_accounts_request(),
                                          mhttp:request_options()) ->
                                             term().
post_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_bank_accounts(get_customers_customer_bank_accounts_request()) ->
                                            term().
get_customers_customer_bank_accounts(Args) ->
    get_customers_customer_bank_accounts(Args, #{}).

-spec get_customers_customer_bank_accounts(get_customers_customer_bank_accounts_request(),
                                           mhttp:request_options()) ->
                                              term().
get_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_readers_reader(post_terminal_readers_reader_request()) -> term().
post_terminal_readers_reader(Args) ->
    post_terminal_readers_reader(Args, #{}).

-spec post_terminal_readers_reader(post_terminal_readers_reader_request(),
                                   mhttp:request_options()) ->
                                      term().
post_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_readers_reader(get_terminal_readers_reader_request()) -> term().
get_terminal_readers_reader(Args) ->
    get_terminal_readers_reader(Args, #{}).

-spec get_terminal_readers_reader(get_terminal_readers_reader_request(),
                                  mhttp:request_options()) ->
                                     term().
get_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_terminal_readers_reader(delete_terminal_readers_reader_request()) -> term().
delete_terminal_readers_reader(Args) ->
    delete_terminal_readers_reader(Args, #{}).

-spec delete_terminal_readers_reader(delete_terminal_readers_reader_request(),
                                     mhttp:request_options()) ->
                                        term().
delete_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_persons_person(post_accounts_account_persons_person_request()) ->
                                            term().
post_accounts_account_persons_person(Args) ->
    post_accounts_account_persons_person(Args, #{}).

-spec post_accounts_account_persons_person(post_accounts_account_persons_person_request(),
                                           mhttp:request_options()) ->
                                              term().
post_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_persons_person(get_accounts_account_persons_person_request()) ->
                                           term().
get_accounts_account_persons_person(Args) ->
    get_accounts_account_persons_person(Args, #{}).

-spec get_accounts_account_persons_person(get_accounts_account_persons_person_request(),
                                          mhttp:request_options()) ->
                                             term().
get_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_accounts_account_persons_person(delete_accounts_account_persons_person_request()) ->
                                              term().
delete_accounts_account_persons_person(Args) ->
    delete_accounts_account_persons_person(Args, #{}).

-spec
    delete_accounts_account_persons_person(delete_accounts_account_persons_person_request(),
                                           mhttp:request_options()) ->
                                              term().
delete_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes_id_void(post_credit_notes_id_void_request()) -> term().
post_credit_notes_id_void(Args) ->
    post_credit_notes_id_void(Args, #{}).

-spec post_credit_notes_id_void(post_credit_notes_id_void_request(),
                                mhttp:request_options()) ->
                                   term().
post_credit_notes_id_void(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/~s/void", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources(post_customers_customer_sources_request()) ->
                                         term().
post_customers_customer_sources(Args) ->
    post_customers_customer_sources(Args, #{}).

-spec post_customers_customer_sources(post_customers_customer_sources_request(),
                                      mhttp:request_options()) ->
                                         term().
post_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_sources(get_customers_customer_sources_request()) -> term().
get_customers_customer_sources(Args) ->
    get_customers_customer_sources(Args, #{}).

-spec get_customers_customer_sources(get_customers_customer_sources_request(),
                                     mhttp:request_options()) ->
                                        term().
get_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({object, Value}) ->
                encode_q(form, false, <<"object">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, object, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_links(post_account_links_request()) -> term().
post_account_links(Args) ->
    post_account_links(Args, #{}).

-spec post_account_links(post_account_links_request(), mhttp:request_options()) -> term().
post_account_links(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout(post_payouts_payout_request()) -> term().
post_payouts_payout(Args) ->
    post_payouts_payout(Args, #{}).

-spec post_payouts_payout(post_payouts_payout_request(), mhttp:request_options()) ->
                             term().
post_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/~s", [VarPayout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payouts_payout(get_payouts_payout_request()) -> term().
get_payouts_payout(Args) ->
    get_payouts_payout(Args, #{}).

-spec get_payouts_payout(get_payouts_payout_request(), mhttp:request_options()) -> term().
get_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/~s", [VarPayout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items_item(post_subscription_items_item_request()) -> term().
post_subscription_items_item(Args) ->
    post_subscription_items_item(Args, #{}).

-spec post_subscription_items_item(post_subscription_items_item_request(),
                                   mhttp:request_options()) ->
                                      term().
post_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items_item(get_subscription_items_item_request()) -> term().
get_subscription_items_item(Args) ->
    get_subscription_items_item(Args, #{}).

-spec get_subscription_items_item(get_subscription_items_item_request(),
                                  mhttp:request_options()) ->
                                     term().
get_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_subscription_items_item(delete_subscription_items_item_request()) -> term().
delete_subscription_items_item(Args) ->
    delete_subscription_items_item(Args, #{}).

-spec delete_subscription_items_item(delete_subscription_items_item_request(),
                                     mhttp:request_options()) ->
                                        term().
delete_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_products(post_products_request()) -> term().
post_products(Args) ->
    post_products(Args, #{}).

-spec post_products(post_products_request(), mhttp:request_options()) -> term().
post_products(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_products(get_products_request()) -> term().
get_products(Args) ->
    get_products(Args, #{}).

-spec get_products(get_products_request(), mhttp:request_options()) -> term().
get_products(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({ids, Value}) ->
                encode_q(deepObject, true, <<"ids">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({shippable, Value}) ->
                encode_q(form, false, <<"shippable">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({url, Value}) ->
                encode_q(form, false, <<"url">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active,
                                     created,
                                     ending_before,
                                     expand,
                                     ids,
                                     limit,
                                     shippable,
                                     starting_after,
                                     url],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_reporting_report_types_report_type(get_reporting_report_types_report_type_request()) ->
                                              term().
get_reporting_report_types_report_type(Args) ->
    get_reporting_report_types_report_type(Args, #{}).

-spec
    get_reporting_report_types_report_type(get_reporting_report_types_report_type_request(),
                                           mhttp:request_options()) ->
                                              term().
get_reporting_report_types_report_type(Args, Options) ->
    VarReportType = maps:get(report_type, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_types/~s", [VarReportType]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_accept(post_quotes_quote_accept_request()) -> term().
post_quotes_quote_accept(Args) ->
    post_quotes_quote_accept(Args, #{}).

-spec post_quotes_quote_accept(post_quotes_quote_accept_request(),
                               mhttp:request_options()) ->
                                  term().
post_quotes_quote_accept(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/accept", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_mandates_mandate(get_mandates_mandate_request()) -> term().
get_mandates_mandate(Args) ->
    get_mandates_mandate(Args, #{}).

-spec get_mandates_mandate(get_mandates_mandate_request(), mhttp:request_options()) ->
                              term().
get_mandates_mandate(Args, Options) ->
    VarMandate = maps:get(mandate, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/mandates/~s", [VarMandate]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_subscriptions(post_customers_customer_subscriptions_request()) ->
                                             term().
post_customers_customer_subscriptions(Args) ->
    post_customers_customer_subscriptions(Args, #{}).

-spec
    post_customers_customer_subscriptions(post_customers_customer_subscriptions_request(),
                                          mhttp:request_options()) ->
                                             term().
post_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/subscriptions", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_subscriptions(get_customers_customer_subscriptions_request()) ->
                                            term().
get_customers_customer_subscriptions(Args) ->
    get_customers_customer_subscriptions(Args, #{}).

-spec get_customers_customer_subscriptions(get_customers_customer_subscriptions_request(),
                                           mhttp:request_options()) ->
                                              term().
get_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/subscriptions", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_order_returns_id(get_order_returns_id_request()) -> term().
get_order_returns_id(Args) ->
    get_order_returns_id(Args, #{}).

-spec get_order_returns_id(get_order_returns_id_request(), mhttp:request_options()) ->
                              term().
get_order_returns_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/order_returns/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_id_reversals(post_transfers_id_reversals_request()) -> term().
post_transfers_id_reversals(Args) ->
    post_transfers_id_reversals(Args, #{}).

-spec post_transfers_id_reversals(post_transfers_id_reversals_request(),
                                  mhttp:request_options()) ->
                                     term().
post_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s/reversals", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_id_reversals(get_transfers_id_reversals_request()) -> term().
get_transfers_id_reversals(Args) ->
    get_transfers_id_reversals(Args, #{}).

-spec get_transfers_id_reversals(get_transfers_id_reversals_request(),
                                 mhttp:request_options()) ->
                                    term().
get_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s/reversals", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reviews_review(get_reviews_review_request()) -> term().
get_reviews_review(Args) ->
    get_reviews_review(Args, #{}).

-spec get_reviews_review(get_reviews_review_request(), mhttp:request_options()) -> term().
get_reviews_review(Args, Options) ->
    VarReview = maps:get(review, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reviews/~s", [VarReview]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_bank_accounts_id(post_accounts_account_bank_accounts_id_request()) ->
                                              term().
post_accounts_account_bank_accounts_id(Args) ->
    post_accounts_account_bank_accounts_id(Args, #{}).

-spec
    post_accounts_account_bank_accounts_id(post_accounts_account_bank_accounts_id_request(),
                                           mhttp:request_options()) ->
                                              term().
post_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_bank_accounts_id(get_accounts_account_bank_accounts_id_request()) ->
                                             term().
get_accounts_account_bank_accounts_id(Args) ->
    get_accounts_account_bank_accounts_id(Args, #{}).

-spec
    get_accounts_account_bank_accounts_id(get_accounts_account_bank_accounts_id_request(),
                                          mhttp:request_options()) ->
                                             term().
get_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_accounts_account_bank_accounts_id(delete_accounts_account_bank_accounts_id_request()) ->
                                                term().
delete_accounts_account_bank_accounts_id(Args) ->
    delete_accounts_account_bank_accounts_id(Args, #{}).

-spec
    delete_accounts_account_bank_accounts_id(delete_accounts_account_bank_accounts_id_request(),
                                             mhttp:request_options()) ->
                                                term().
delete_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_settlements_settlement(post_issuing_settlements_settlement_request()) ->
                                           term().
post_issuing_settlements_settlement(Args) ->
    post_issuing_settlements_settlement(Args, #{}).

-spec post_issuing_settlements_settlement(post_issuing_settlements_settlement_request(),
                                          mhttp:request_options()) ->
                                             term().
post_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/settlements/~s", [VarSettlement]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_settlements_settlement(get_issuing_settlements_settlement_request()) ->
                                            term().
get_issuing_settlements_settlement(Args) ->
    get_issuing_settlements_settlement(Args, #{}).

-spec get_issuing_settlements_settlement(get_issuing_settlements_settlement_request(),
                                         mhttp:request_options()) ->
                                            term().
get_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/settlements/~s", [VarSettlement]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_promotion_codes_promotion_code(post_promotion_codes_promotion_code_request()) ->
                                           term().
post_promotion_codes_promotion_code(Args) ->
    post_promotion_codes_promotion_code(Args, #{}).

-spec post_promotion_codes_promotion_code(post_promotion_codes_promotion_code_request(),
                                          mhttp:request_options()) ->
                                             term().
post_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes/~s", [VarPromotionCode]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_promotion_codes_promotion_code(get_promotion_codes_promotion_code_request()) ->
                                            term().
get_promotion_codes_promotion_code(Args) ->
    get_promotion_codes_promotion_code(Args, #{}).

-spec get_promotion_codes_promotion_code(get_promotion_codes_promotion_code_request(),
                                         mhttp:request_options()) ->
                                            term().
get_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes/~s", [VarPromotionCode]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscription_schedules_schedule_cancel(post_subscription_schedules_schedule_cancel_request()) ->
                                                   term().
post_subscription_schedules_schedule_cancel(Args) ->
    post_subscription_schedules_schedule_cancel(Args, #{}).

-spec
    post_subscription_schedules_schedule_cancel(post_subscription_schedules_schedule_cancel_request(),
                                                mhttp:request_options()) ->
                                                   term().
post_subscription_schedules_schedule_cancel(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/~s/cancel", [VarSchedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_identity_verification_sessions(post_identity_verification_sessions_request()) ->
                                           term().
post_identity_verification_sessions(Args) ->
    post_identity_verification_sessions(Args, #{}).

-spec post_identity_verification_sessions(post_identity_verification_sessions_request(),
                                          mhttp:request_options()) ->
                                             term().
post_identity_verification_sessions(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_sessions(get_identity_verification_sessions_request()) ->
                                            term().
get_identity_verification_sessions(Args) ->
    get_identity_verification_sessions(Args, #{}).

-spec get_identity_verification_sessions(get_identity_verification_sessions_request(),
                                         mhttp:request_options()) ->
                                            term().
get_identity_verification_sessions(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created, ending_before, expand, limit, starting_after, status],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_list_items(post_radar_value_list_items_request()) -> term().
post_radar_value_list_items(Args) ->
    post_radar_value_list_items(Args, #{}).

-spec post_radar_value_list_items(post_radar_value_list_items_request(),
                                  mhttp:request_options()) ->
                                     term().
post_radar_value_list_items(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_list_items(get_radar_value_list_items_request()) -> term().
get_radar_value_list_items(Args) ->
    get_radar_value_list_items(Args, #{}).

-spec get_radar_value_list_items(get_radar_value_list_items_request(),
                                 mhttp:request_options()) ->
                                    term().
get_radar_value_list_items(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({value, Value}) ->
                encode_q(form, false, <<"value">>, Value);
            ({value_list, Value}) ->
                encode_q(form, false, <<"value_list">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     value,
                                     value_list],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_events_id(get_events_id_request()) -> term().
get_events_id(Args) ->
    get_events_id(Args, #{}).

-spec get_events_id(get_events_id_request(), mhttp:request_options()) -> term().
get_events_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/events/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_country_specs(get_country_specs_request()) -> term().
get_country_specs(Args) ->
    get_country_specs(Args, #{}).

-spec get_country_specs(get_country_specs_request(), mhttp:request_options()) -> term().
get_country_specs(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/country_specs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_intents_intent_verify_microdeposits(post_payment_intents_intent_verify_microdeposits_request()) ->
                                                        term().
post_payment_intents_intent_verify_microdeposits(Args) ->
    post_payment_intents_intent_verify_microdeposits(Args, #{}).

-spec
    post_payment_intents_intent_verify_microdeposits(post_payment_intents_intent_verify_microdeposits_request(),
                                                     mhttp:request_options()) ->
                                                        term().
post_payment_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s/verify_microdeposits", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscription_items_subscription_item_usage_records(post_subscription_items_subscription_item_usage_records_request()) ->
                                                               term().
post_subscription_items_subscription_item_usage_records(Args) ->
    post_subscription_items_subscription_item_usage_records(Args, #{}).

-spec
    post_subscription_items_subscription_item_usage_records(post_subscription_items_subscription_item_usage_records_request(),
                                                            mhttp:request_options()) ->
                                                               term().
post_subscription_items_subscription_item_usage_records(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/~s/usage_records", [VarSubscriptionItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_history(get_balance_history_request()) -> term().
get_balance_history(Args) ->
    get_balance_history(Args, #{}).

-spec get_balance_history(get_balance_history_request(), mhttp:request_options()) ->
                             term().
get_balance_history(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payout, Value}) ->
                encode_q(form, false, <<"payout">>, Value);
            ({source, Value}) ->
                encode_q(form, false, <<"source">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     currency,
                                     ending_before,
                                     expand,
                                     limit,
                                     payout,
                                     source,
                                     starting_after,
                                     type],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance/history", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_order_returns(get_order_returns_request()) -> term().
get_order_returns(Args) ->
    get_order_returns(Args, #{}).

-spec get_order_returns(get_order_returns_request(), mhttp:request_options()) -> term().
get_order_returns(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({order, Value}) ->
                encode_q(form, false, <<"order">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created, ending_before, expand, limit, order, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/order_returns", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_external_accounts_id(post_account_external_accounts_id_request()) ->
                                           term().
post_account_external_accounts_id(Args) ->
    post_account_external_accounts_id(Args, #{}).

-spec post_account_external_accounts_id(post_account_external_accounts_id_request(),
                                        mhttp:request_options()) ->
                                           term().
post_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_external_accounts_id(get_account_external_accounts_id_request()) ->
                                          term().
get_account_external_accounts_id(Args) ->
    get_account_external_accounts_id(Args, #{}).

-spec get_account_external_accounts_id(get_account_external_accounts_id_request(),
                                       mhttp:request_options()) ->
                                          term().
get_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_account_external_accounts_id(delete_account_external_accounts_id_request()) ->
                                           term().
delete_account_external_accounts_id(Args) ->
    delete_account_external_accounts_id(Args, #{}).

-spec delete_account_external_accounts_id(delete_account_external_accounts_id_request(),
                                          mhttp:request_options()) ->
                                             term().
delete_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_apple_pay_domains(post_apple_pay_domains_request()) -> term().
post_apple_pay_domains(Args) ->
    post_apple_pay_domains(Args, #{}).

-spec post_apple_pay_domains(post_apple_pay_domains_request(), mhttp:request_options()) ->
                                term().
post_apple_pay_domains(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_apple_pay_domains(get_apple_pay_domains_request()) -> term().
get_apple_pay_domains(Args) ->
    get_apple_pay_domains(Args, #{}).

-spec get_apple_pay_domains(get_apple_pay_domains_request(), mhttp:request_options()) ->
                               term().
get_apple_pay_domains(Args, Options) ->
    EncodeQuery =
        fun ({domain_name, Value}) ->
                encode_q(form, false, <<"domain_name">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([domain_name, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes(post_credit_notes_request()) -> term().
post_credit_notes(Args) ->
    post_credit_notes(Args, #{}).

-spec post_credit_notes(post_credit_notes_request(), mhttp:request_options()) -> term().
post_credit_notes(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes(get_credit_notes_request()) -> term().
get_credit_notes(Args) ->
    get_credit_notes(Args, #{}).

-spec get_credit_notes(get_credit_notes_request(), mhttp:request_options()) -> term().
get_credit_notes(Args, Options) ->
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([customer,
                                     ending_before,
                                     expand,
                                     invoice,
                                     limit,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_sigma_scheduled_query_runs_scheduled_query_run(get_sigma_scheduled_query_runs_scheduled_query_run_request()) ->
                                                          term().
get_sigma_scheduled_query_runs_scheduled_query_run(Args) ->
    get_sigma_scheduled_query_runs_scheduled_query_run(Args, #{}).

-spec
    get_sigma_scheduled_query_runs_scheduled_query_run(get_sigma_scheduled_query_runs_scheduled_query_run_request(),
                                                       mhttp:request_options()) ->
                                                          term().
get_sigma_scheduled_query_runs_scheduled_query_run(Args, Options) ->
    VarScheduledQueryRun = maps:get(scheduled_query_run, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs/~s", [VarScheduledQueryRun]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_coupons_coupon(post_coupons_coupon_request()) -> term().
post_coupons_coupon(Args) ->
    post_coupons_coupon(Args, #{}).

-spec post_coupons_coupon(post_coupons_coupon_request(), mhttp:request_options()) ->
                             term().
post_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_coupons_coupon(get_coupons_coupon_request()) -> term().
get_coupons_coupon(Args) ->
    get_coupons_coupon(Args, #{}).

-spec get_coupons_coupon(get_coupons_coupon_request(), mhttp:request_options()) -> term().
get_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_coupons_coupon(delete_coupons_coupon_request()) -> term().
delete_coupons_coupon(Args) ->
    delete_coupons_coupon(Args, #{}).

-spec delete_coupons_coupon(delete_coupons_coupon_request(), mhttp:request_options()) ->
                               term().
delete_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_tax_ids_id(get_customers_customer_tax_ids_id_request()) ->
                                           term().
get_customers_customer_tax_ids_id(Args) ->
    get_customers_customer_tax_ids_id(Args, #{}).

-spec get_customers_customer_tax_ids_id(get_customers_customer_tax_ids_id_request(),
                                        mhttp:request_options()) ->
                                           term().
get_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_tax_ids_id(delete_customers_customer_tax_ids_id_request()) ->
                                            term().
delete_customers_customer_tax_ids_id(Args) ->
    delete_customers_customer_tax_ids_id(Args, #{}).

-spec delete_customers_customer_tax_ids_id(delete_customers_customer_tax_ids_id_request(),
                                           mhttp:request_options()) ->
                                              term().
delete_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_radar_early_fraud_warnings_early_fraud_warning(get_radar_early_fraud_warnings_early_fraud_warning_request()) ->
                                                          term().
get_radar_early_fraud_warnings_early_fraud_warning(Args) ->
    get_radar_early_fraud_warnings_early_fraud_warning(Args, #{}).

-spec
    get_radar_early_fraud_warnings_early_fraud_warning(get_radar_early_fraud_warnings_early_fraud_warning_request(),
                                                       mhttp:request_options()) ->
                                                          term().
get_radar_early_fraud_warnings_early_fraud_warning(Args, Options) ->
    VarEarlyFraudWarning = maps:get(early_fraud_warning, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings/~s", [VarEarlyFraudWarning]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_settlements(get_issuing_settlements_request()) -> term().
get_issuing_settlements(Args) ->
    get_issuing_settlements(Args, #{}).

-spec get_issuing_settlements(get_issuing_settlements_request(),
                              mhttp:request_options()) ->
                                 term().
get_issuing_settlements(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/settlements", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_file_links(post_file_links_request()) -> term().
post_file_links(Args) ->
    post_file_links(Args, #{}).

-spec post_file_links(post_file_links_request(), mhttp:request_options()) -> term().
post_file_links(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_file_links(get_file_links_request()) -> term().
get_file_links(Args) ->
    get_file_links(Args, #{}).

-spec get_file_links(get_file_links_request(), mhttp:request_options()) -> term().
get_file_links(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({expired, Value}) ->
                encode_q(form, false, <<"expired">>, Value);
            ({file, Value}) ->
                encode_q(form, false, <<"file">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     ending_before,
                                     expand,
                                     expired,
                                     file,
                                     limit,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_identity_verification_reports_report(get_identity_verification_reports_report_request()) ->
                                                term().
get_identity_verification_reports_report(Args) ->
    get_identity_verification_reports_report(Args, #{}).

-spec
    get_identity_verification_reports_report(get_identity_verification_reports_report_request(),
                                             mhttp:request_options()) ->
                                                term().
get_identity_verification_reports_report(Args, Options) ->
    VarReport = maps:get(report, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_reports/~s", [VarReport]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers(post_transfers_request()) -> term().
post_transfers(Args) ->
    post_transfers(Args, #{}).

-spec post_transfers(post_transfers_request(), mhttp:request_options()) -> term().
post_transfers(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers(get_transfers_request()) -> term().
get_transfers(Args) ->
    get_transfers(Args, #{}).

-spec get_transfers(get_transfers_request(), mhttp:request_options()) -> term().
get_transfers(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({destination, Value}) ->
                encode_q(form, false, <<"destination">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({transfer_group, Value}) ->
                encode_q(form, false, <<"transfer_group">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     destination,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     transfer_group],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_subscriptions_subscription_exposed_id_discount(delete_subscriptions_subscription_exposed_id_discount_request()) ->
                                                             term().
delete_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec
    delete_subscriptions_subscription_exposed_id_discount(delete_subscriptions_subscription_exposed_id_discount_request(),
                                                          mhttp:request_options()) ->
                                                             term().
delete_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/~s/discount", [VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_id_refunds(post_application_fees_id_refunds_request()) ->
                                          term().
post_application_fees_id_refunds(Args) ->
    post_application_fees_id_refunds(Args, #{}).

-spec post_application_fees_id_refunds(post_application_fees_id_refunds_request(),
                                       mhttp:request_options()) ->
                                          term().
post_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_id_refunds(get_application_fees_id_refunds_request()) ->
                                         term().
get_application_fees_id_refunds(Args) ->
    get_application_fees_id_refunds(Args, #{}).

-spec get_application_fees_id_refunds(get_application_fees_id_refunds_request(),
                                      mhttp:request_options()) ->
                                         term().
get_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_bank_accounts(post_accounts_account_bank_accounts_request()) ->
                                           term().
post_accounts_account_bank_accounts(Args) ->
    post_accounts_account_bank_accounts(Args, #{}).

-spec post_accounts_account_bank_accounts(post_accounts_account_bank_accounts_request(),
                                          mhttp:request_options()) ->
                                             term().
post_accounts_account_bank_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account(post_accounts_account_request()) -> term().
post_accounts_account(Args) ->
    post_accounts_account(Args, #{}).

-spec post_accounts_account(post_accounts_account_request(), mhttp:request_options()) ->
                               term().
post_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account(get_accounts_account_request()) -> term().
get_accounts_account(Args) ->
    get_accounts_account(Args, #{}).

-spec get_accounts_account(get_accounts_account_request(), mhttp:request_options()) ->
                              term().
get_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account(delete_accounts_account_request()) -> term().
delete_accounts_account(Args) ->
    delete_accounts_account(Args, #{}).

-spec delete_accounts_account(delete_accounts_account_request(),
                              mhttp:request_options()) ->
                                 term().
delete_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscription_schedules_schedule(post_subscription_schedules_schedule_request()) ->
                                            term().
post_subscription_schedules_schedule(Args) ->
    post_subscription_schedules_schedule(Args, #{}).

-spec post_subscription_schedules_schedule(post_subscription_schedules_schedule_request(),
                                           mhttp:request_options()) ->
                                              term().
post_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/~s", [VarSchedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_subscription_schedules_schedule(get_subscription_schedules_schedule_request()) ->
                                           term().
get_subscription_schedules_schedule(Args) ->
    get_subscription_schedules_schedule(Args, #{}).

-spec get_subscription_schedules_schedule(get_subscription_schedules_schedule_request(),
                                          mhttp:request_options()) ->
                                             term().
get_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/~s", [VarSchedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_pay(post_invoices_invoice_pay_request()) -> term().
post_invoices_invoice_pay(Args) ->
    post_invoices_invoice_pay(Args, #{}).

-spec post_invoices_invoice_pay(post_invoices_invoice_pay_request(),
                                mhttp:request_options()) ->
                                   term().
post_invoices_invoice_pay(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/pay", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_transfers_transfer_reversals_id(post_transfers_transfer_reversals_id_request()) ->
                                            term().
post_transfers_transfer_reversals_id(Args) ->
    post_transfers_transfer_reversals_id(Args, #{}).

-spec post_transfers_transfer_reversals_id(post_transfers_transfer_reversals_id_request(),
                                           mhttp:request_options()) ->
                                              term().
post_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s/reversals/~s", [VarTransfer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_transfers_transfer_reversals_id(get_transfers_transfer_reversals_id_request()) ->
                                           term().
get_transfers_transfer_reversals_id(Args) ->
    get_transfers_transfer_reversals_id(Args, #{}).

-spec get_transfers_transfer_reversals_id(get_transfers_transfer_reversals_id_request(),
                                          mhttp:request_options()) ->
                                             term().
get_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s/reversals/~s", [VarTransfer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups_topup(post_topups_topup_request()) -> term().
post_topups_topup(Args) ->
    post_topups_topup(Args, #{}).

-spec post_topups_topup(post_topups_topup_request(), mhttp:request_options()) -> term().
post_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups/~s", [VarTopup]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_topups_topup(get_topups_topup_request()) -> term().
get_topups_topup(Args) ->
    get_topups_topup(Args, #{}).

-spec get_topups_topup(get_topups_topup_request(), mhttp:request_options()) -> term().
get_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups/~s", [VarTopup]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_recipients_id(post_recipients_id_request()) -> term().
post_recipients_id(Args) ->
    post_recipients_id(Args, #{}).

-spec post_recipients_id(post_recipients_id_request(), mhttp:request_options()) -> term().
post_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_recipients_id(get_recipients_id_request()) -> term().
get_recipients_id(Args) ->
    get_recipients_id(Args, #{}).

-spec get_recipients_id(get_recipients_id_request(), mhttp:request_options()) -> term().
get_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_recipients_id(delete_recipients_id_request()) -> term().
delete_recipients_id(Args) ->
    delete_recipients_id(Args, #{}).

-spec delete_recipients_id(delete_recipients_id_request(), mhttp:request_options()) ->
                              term().
delete_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_invoice_lines(get_invoices_invoice_lines_request()) -> term().
get_invoices_invoice_lines(Args) ->
    get_invoices_invoice_lines(Args, #{}).

-spec get_invoices_invoice_lines(get_invoices_invoice_lines_request(),
                                 mhttp:request_options()) ->
                                    term().
get_invoices_invoice_lines(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/lines", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_external_accounts_id(post_accounts_account_external_accounts_id_request()) ->
                                                  term().
post_accounts_account_external_accounts_id(Args) ->
    post_accounts_account_external_accounts_id(Args, #{}).

-spec
    post_accounts_account_external_accounts_id(post_accounts_account_external_accounts_id_request(),
                                               mhttp:request_options()) ->
                                                  term().
post_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_external_accounts_id(get_accounts_account_external_accounts_id_request()) ->
                                                 term().
get_accounts_account_external_accounts_id(Args) ->
    get_accounts_account_external_accounts_id(Args, #{}).

-spec
    get_accounts_account_external_accounts_id(get_accounts_account_external_accounts_id_request(),
                                              mhttp:request_options()) ->
                                                 term().
get_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_accounts_account_external_accounts_id(delete_accounts_account_external_accounts_id_request()) ->
                                                    term().
delete_accounts_account_external_accounts_id(Args) ->
    delete_accounts_account_external_accounts_id(Args, #{}).

-spec
    delete_accounts_account_external_accounts_id(delete_accounts_account_external_accounts_id_request(),
                                                 mhttp:request_options()) ->
                                                    term().
delete_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups(post_topups_request()) -> term().
post_topups(Args) ->
    post_topups(Args, #{}).

-spec post_topups(post_topups_request(), mhttp:request_options()) -> term().
post_topups(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_topups(get_topups_request()) -> term().
get_topups(Args) ->
    get_topups(Args, #{}).

-spec get_topups(get_topups_request(), mhttp:request_options()) -> term().
get_topups(Args, Options) ->
    EncodeQuery =
        fun ({amount, Value}) ->
                encode_q(deepObject, true, <<"amount">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([amount,
                                     created,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     status],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id_returns(post_orders_id_returns_request()) -> term().
post_orders_id_returns(Args) ->
    post_orders_id_returns(Args, #{}).

-spec post_orders_id_returns(post_orders_id_returns_request(), mhttp:request_options()) ->
                                term().
post_orders_id_returns(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/~s/returns", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id(post_orders_id_request()) -> term().
post_orders_id(Args) ->
    post_orders_id(Args, #{}).

-spec post_orders_id(post_orders_id_request(), mhttp:request_options()) -> term().
post_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_orders_id(get_orders_id_request()) -> term().
get_orders_id(Args) ->
    get_orders_id(Args, #{}).

-spec get_orders_id(get_orders_id_request(), mhttp:request_options()) -> term().
get_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_apple_pay_domains_domain(get_apple_pay_domains_domain_request()) -> term().
get_apple_pay_domains_domain(Args) ->
    get_apple_pay_domains_domain(Args, #{}).

-spec get_apple_pay_domains_domain(get_apple_pay_domains_domain_request(),
                                   mhttp:request_options()) ->
                                      term().
get_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains/~s", [VarDomain]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_apple_pay_domains_domain(delete_apple_pay_domains_domain_request()) ->
                                         term().
delete_apple_pay_domains_domain(Args) ->
    delete_apple_pay_domains_domain(Args, #{}).

-spec delete_apple_pay_domains_domain(delete_apple_pay_domains_domain_request(),
                                      mhttp:request_options()) ->
                                         term().
delete_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains/~s", [VarDomain]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_transactions(get_issuing_transactions_request()) -> term().
get_issuing_transactions(Args) ->
    get_issuing_transactions(Args, #{}).

-spec get_issuing_transactions(get_issuing_transactions_request(),
                               mhttp:request_options()) ->
                                  term().
get_issuing_transactions(Args, Options) ->
    EncodeQuery =
        fun ({card, Value}) ->
                encode_q(form, false, <<"card">>, Value);
            ({cardholder, Value}) ->
                encode_q(form, false, <<"cardholder">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([card,
                                     cardholder,
                                     created,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     type],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/transactions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refund(post_charges_charge_refund_request()) -> term().
post_charges_charge_refund(Args) ->
    post_charges_charge_refund(Args, #{}).

-spec post_charges_charge_refund(post_charges_charge_refund_request(),
                                 mhttp:request_options()) ->
                                    term().
post_charges_charge_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refund", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_methods_payment_method_attach(post_payment_methods_payment_method_attach_request()) ->
                                                  term().
post_payment_methods_payment_method_attach(Args) ->
    post_payment_methods_payment_method_attach(Args, #{}).

-spec
    post_payment_methods_payment_method_attach(post_payment_methods_payment_method_attach_request(),
                                               mhttp:request_options()) ->
                                                  term().
post_payment_methods_payment_method_attach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/~s/attach", [VarPaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_cancel(post_payment_intents_intent_cancel_request()) ->
                                            term().
post_payment_intents_intent_cancel(Args) ->
    post_payment_intents_intent_cancel(Args, #{}).

-spec post_payment_intents_intent_cancel(post_payment_intents_intent_cancel_request(),
                                         mhttp:request_options()) ->
                                            term().
post_payment_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s/cancel", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_capabilities(get_accounts_account_capabilities_request()) ->
                                           term().
get_accounts_account_capabilities(Args) ->
    get_accounts_account_capabilities(Args, #{}).

-spec get_accounts_account_capabilities(get_accounts_account_capabilities_request(),
                                        mhttp:request_options()) ->
                                           term().
get_accounts_account_capabilities(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_preview_lines(get_credit_notes_preview_lines_request()) -> term().
get_credit_notes_preview_lines(Args) ->
    get_credit_notes_preview_lines(Args, #{}).

-spec get_credit_notes_preview_lines(get_credit_notes_preview_lines_request(),
                                     mhttp:request_options()) ->
                                        term().
get_credit_notes_preview_lines(Args, Options) ->
    EncodeQuery =
        fun ({amount, Value}) ->
                encode_q(form, false, <<"amount">>, Value);
            ({credit_amount, Value}) ->
                encode_q(form, false, <<"credit_amount">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({lines, Value}) ->
                encode_q(deepObject, true, <<"lines">>, Value);
            ({memo, Value}) ->
                encode_q(form, false, <<"memo">>, Value);
            ({metadata, Value}) ->
                encode_q(deepObject, true, <<"metadata">>, Value);
            ({out_of_band_amount, Value}) ->
                encode_q(form, false, <<"out_of_band_amount">>, Value);
            ({reason, Value}) ->
                encode_q(form, false, <<"reason">>, Value);
            ({refund, Value}) ->
                encode_q(form, false, <<"refund">>, Value);
            ({refund_amount, Value}) ->
                encode_q(form, false, <<"refund_amount">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([amount,
                                     credit_amount,
                                     ending_before,
                                     expand,
                                     invoice,
                                     limit,
                                     lines,
                                     memo,
                                     metadata,
                                     out_of_band_amount,
                                     reason,
                                     refund,
                                     refund_amount,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/preview/lines", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscriptions(post_subscriptions_request()) -> term().
post_subscriptions(Args) ->
    post_subscriptions(Args, #{}).

-spec post_subscriptions(post_subscriptions_request(), mhttp:request_options()) -> term().
post_subscriptions(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscriptions(get_subscriptions_request()) -> term().
get_subscriptions(Args) ->
    get_subscriptions(Args, #{}).

-spec get_subscriptions(get_subscriptions_request(), mhttp:request_options()) -> term().
get_subscriptions(Args, Options) ->
    EncodeQuery =
        fun ({collection_method, Value}) ->
                encode_q(form, false, <<"collection_method">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({current_period_end, Value}) ->
                encode_q(deepObject, true, <<"current_period_end">>, Value);
            ({current_period_start, Value}) ->
                encode_q(deepObject, true, <<"current_period_start">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({price, Value}) ->
                encode_q(form, false, <<"price">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([collection_method,
                                     created,
                                     current_period_end,
                                     current_period_start,
                                     customer,
                                     ending_before,
                                     expand,
                                     limit,
                                     price,
                                     starting_after,
                                     status],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_attempts(get_setup_attempts_request()) -> term().
get_setup_attempts(Args) ->
    get_setup_attempts(Args, #{}).

-spec get_setup_attempts(get_setup_attempts_request(), mhttp:request_options()) -> term().
get_setup_attempts(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({setup_intent, Value}) ->
                encode_q(form, false, <<"setup_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     ending_before,
                                     expand,
                                     limit,
                                     setup_intent,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_attempts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_subscriptions_subscription_exposed_id(post_customers_customer_subscriptions_subscription_exposed_id_request()) ->
                                                                     term().
post_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    post_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    post_customers_customer_subscriptions_subscription_exposed_id(post_customers_customer_subscriptions_subscription_exposed_id_request(),
                                                                  mhttp:request_options()) ->
                                                                     term().
post_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_subscriptions_subscription_exposed_id(get_customers_customer_subscriptions_subscription_exposed_id_request()) ->
                                                                    term().
get_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    get_customers_customer_subscriptions_subscription_exposed_id(get_customers_customer_subscriptions_subscription_exposed_id_request(),
                                                                 mhttp:request_options()) ->
                                                                    term().
get_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id(delete_customers_customer_subscriptions_subscription_exposed_id_request()) ->
                                                                       term().
delete_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id(delete_customers_customer_subscriptions_subscription_exposed_id_request(),
                                                                    mhttp:request_options()) ->
                                                                       term().
delete_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers_id(get_bitcoin_receivers_id_request()) -> term().
get_bitcoin_receivers_id(Args) ->
    get_bitcoin_receivers_id(Args, #{}).

-spec get_bitcoin_receivers_id(get_bitcoin_receivers_id_request(),
                               mhttp:request_options()) ->
                                  term().
get_bitcoin_receivers_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/receivers/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders(post_orders_request()) -> term().
post_orders(Args) ->
    post_orders(Args, #{}).

-spec post_orders(post_orders_request(), mhttp:request_options()) -> term().
post_orders(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_orders(get_orders_request()) -> term().
get_orders(Args) ->
    get_orders(Args, #{}).

-spec get_orders(get_orders_request(), mhttp:request_options()) -> term().
get_orders(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({ids, Value}) ->
                encode_q(deepObject, true, <<"ids">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({status_transitions, Value}) ->
                encode_q(deepObject, true, <<"status_transitions">>, Value);
            ({upstream_ids, Value}) ->
                encode_q(deepObject, true, <<"upstream_ids">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     customer,
                                     ending_before,
                                     expand,
                                     ids,
                                     limit,
                                     starting_after,
                                     status,
                                     status_transitions,
                                     upstream_ids],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_ephemeral_keys(post_ephemeral_keys_request()) -> term().
post_ephemeral_keys(Args) ->
    post_ephemeral_keys(Args, #{}).

-spec post_ephemeral_keys(post_ephemeral_keys_request(), mhttp:request_options()) ->
                             term().
post_ephemeral_keys(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/ephemeral_keys", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_webhook_endpoints_webhook_endpoint(post_webhook_endpoints_webhook_endpoint_request()) ->
                                               term().
post_webhook_endpoints_webhook_endpoint(Args) ->
    post_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec
    post_webhook_endpoints_webhook_endpoint(post_webhook_endpoints_webhook_endpoint_request(),
                                            mhttp:request_options()) ->
                                               term().
post_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_webhook_endpoints_webhook_endpoint(get_webhook_endpoints_webhook_endpoint_request()) ->
                                              term().
get_webhook_endpoints_webhook_endpoint(Args) ->
    get_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec
    get_webhook_endpoints_webhook_endpoint(get_webhook_endpoints_webhook_endpoint_request(),
                                           mhttp:request_options()) ->
                                              term().
get_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_webhook_endpoints_webhook_endpoint(delete_webhook_endpoints_webhook_endpoint_request()) ->
                                                 term().
delete_webhook_endpoints_webhook_endpoint(Args) ->
    delete_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec
    delete_webhook_endpoints_webhook_endpoint(delete_webhook_endpoints_webhook_endpoint_request(),
                                              mhttp:request_options()) ->
                                                 term().
delete_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_persons(post_account_persons_request()) -> term().
post_account_persons(Args) ->
    post_account_persons(Args, #{}).

-spec post_account_persons(post_account_persons_request(), mhttp:request_options()) ->
                              term().
post_account_persons(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_persons(get_account_persons_request()) -> term().
get_account_persons(Args) ->
    get_account_persons(Args, #{}).

-spec get_account_persons(get_account_persons_request(), mhttp:request_options()) ->
                             term().
get_account_persons(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, relationship, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_capabilities(get_account_capabilities_request()) -> term().
get_account_capabilities(Args) ->
    get_account_capabilities(Args, #{}).

-spec get_account_capabilities(get_account_capabilities_request(),
                               mhttp:request_options()) ->
                                  term().
get_account_capabilities(Args, Options) ->
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/capabilities", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_checkout_sessions_session_expire(post_checkout_sessions_session_expire_request()) ->
                                             term().
post_checkout_sessions_session_expire(Args) ->
    post_checkout_sessions_session_expire(Args, #{}).

-spec
    post_checkout_sessions_session_expire(post_checkout_sessions_session_expire_request(),
                                          mhttp:request_options()) ->
                                             term().
post_checkout_sessions_session_expire(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions/~s/expire", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_bitcoin_receivers_receiver_transactions(get_bitcoin_receivers_receiver_transactions_request()) ->
                                                   term().
get_bitcoin_receivers_receiver_transactions(Args) ->
    get_bitcoin_receivers_receiver_transactions(Args, #{}).

-spec
    get_bitcoin_receivers_receiver_transactions(get_bitcoin_receivers_receiver_transactions_request(),
                                                mhttp:request_options()) ->
                                                   term().
get_bitcoin_receivers_receiver_transactions(Args, Options) ->
    VarReceiver = maps:get(receiver, Args),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([customer, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/receivers/~s/transactions", [VarReceiver]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote(post_quotes_quote_request()) -> term().
post_quotes_quote(Args) ->
    post_quotes_quote(Args, #{}).

-spec post_quotes_quote(post_quotes_quote_request(), mhttp:request_options()) -> term().
post_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote(get_quotes_quote_request()) -> term().
get_quotes_quote(Args) ->
    get_quotes_quote(Args, #{}).

-spec get_quotes_quote(get_quotes_quote_request(), mhttp:request_options()) -> term().
get_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_people(post_account_people_request()) -> term().
post_account_people(Args) ->
    post_account_people(Args, #{}).

-spec post_account_people(post_account_people_request(), mhttp:request_options()) ->
                             term().
post_account_people(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_people(get_account_people_request()) -> term().
get_account_people(Args) ->
    get_account_people(Args, #{}).

-spec get_account_people(get_account_people_request(), mhttp:request_options()) -> term().
get_account_people(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, relationship, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_confirm(post_setup_intents_intent_confirm_request()) ->
                                           term().
post_setup_intents_intent_confirm(Args) ->
    post_setup_intents_intent_confirm(Args, #{}).

-spec post_setup_intents_intent_confirm(post_setup_intents_intent_confirm_request(),
                                        mhttp:request_options()) ->
                                           term().
post_setup_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s/confirm", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_cards(post_customers_customer_cards_request()) -> term().
post_customers_customer_cards(Args) ->
    post_customers_customer_cards(Args, #{}).

-spec post_customers_customer_cards(post_customers_customer_cards_request(),
                                    mhttp:request_options()) ->
                                       term().
post_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_cards(get_customers_customer_cards_request()) -> term().
get_customers_customer_cards(Args) ->
    get_customers_customer_cards(Args, #{}).

-spec get_customers_customer_cards(get_customers_customer_cards_request(),
                                   mhttp:request_options()) ->
                                      term().
get_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_reports(get_identity_verification_reports_request()) ->
                                           term().
get_identity_verification_reports(Args) ->
    get_identity_verification_reports(Args, #{}).

-spec get_identity_verification_reports(get_identity_verification_reports_request(),
                                        mhttp:request_options()) ->
                                           term().
get_identity_verification_reports(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({verification_session, Value}) ->
                encode_q(form, false, <<"verification_session">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     type,
                                     verification_session],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_reports", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_persons(post_accounts_account_persons_request()) -> term().
post_accounts_account_persons(Args) ->
    post_accounts_account_persons(Args, #{}).

-spec post_accounts_account_persons(post_accounts_account_persons_request(),
                                    mhttp:request_options()) ->
                                       term().
post_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_persons(get_accounts_account_persons_request()) -> term().
get_accounts_account_persons(Args) ->
    get_accounts_account_persons(Args, #{}).

-spec get_accounts_account_persons(get_accounts_account_persons_request(),
                                   mhttp:request_options()) ->
                                      term().
get_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, relationship, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_id_refund(post_application_fees_id_refund_request()) ->
                                         term().
post_application_fees_id_refund(Args) ->
    post_application_fees_id_refund(Args, #{}).

-spec post_application_fees_id_refund(post_application_fees_id_refund_request(),
                                      mhttp:request_options()) ->
                                         term().
post_application_fees_id_refund(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refund", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents(post_payment_intents_request()) -> term().
post_payment_intents(Args) ->
    post_payment_intents(Args, #{}).

-spec post_payment_intents(post_payment_intents_request(), mhttp:request_options()) ->
                              term().
post_payment_intents(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_intents(get_payment_intents_request()) -> term().
get_payment_intents(Args) ->
    get_payment_intents(Args, #{}).

-spec get_payment_intents(get_payment_intents_request(), mhttp:request_options()) ->
                             term().
get_payment_intents(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     customer,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_skus(post_skus_request()) -> term().
post_skus(Args) ->
    post_skus(Args, #{}).

-spec post_skus(post_skus_request(), mhttp:request_options()) -> term().
post_skus(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_skus(get_skus_request()) -> term().
get_skus(Args) ->
    get_skus(Args, #{}).

-spec get_skus(get_skus_request(), mhttp:request_options()) -> term().
get_skus(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({attributes, Value}) ->
                encode_q(deepObject, true, <<"attributes">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({ids, Value}) ->
                encode_q(deepObject, true, <<"ids">>, Value);
            ({in_stock, Value}) ->
                encode_q(form, false, <<"in_stock">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({product, Value}) ->
                encode_q(form, false, <<"product">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active,
                                     attributes,
                                     ending_before,
                                     expand,
                                     ids,
                                     in_stock,
                                     limit,
                                     product,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_webhook_endpoints(post_webhook_endpoints_request()) -> term().
post_webhook_endpoints(Args) ->
    post_webhook_endpoints(Args, #{}).

-spec post_webhook_endpoints(post_webhook_endpoints_request(), mhttp:request_options()) ->
                                term().
post_webhook_endpoints(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_webhook_endpoints(get_webhook_endpoints_request()) -> term().
get_webhook_endpoints(Args) ->
    get_webhook_endpoints(Args, #{}).

-spec get_webhook_endpoints(get_webhook_endpoints_request(), mhttp:request_options()) ->
                               term().
get_webhook_endpoints(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance(get_balance_request()) -> term().
get_balance(Args) ->
    get_balance(Args, #{}).

-spec get_balance(get_balance_request(), mhttp:request_options()) -> term().
get_balance(Args, Options) ->
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_balance_transactions_transaction(post_customers_customer_balance_transactions_transaction_request()) ->
                                                                term().
post_customers_customer_balance_transactions_transaction(Args) ->
    post_customers_customer_balance_transactions_transaction(Args, #{}).

-spec
    post_customers_customer_balance_transactions_transaction(post_customers_customer_balance_transactions_transaction_request(),
                                                             mhttp:request_options()) ->
                                                                term().
post_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/balance_transactions/~s", [VarCustomer, VarTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_balance_transactions_transaction(get_customers_customer_balance_transactions_transaction_request()) ->
                                                               term().
get_customers_customer_balance_transactions_transaction(Args) ->
    get_customers_customer_balance_transactions_transaction(Args, #{}).

-spec
    get_customers_customer_balance_transactions_transaction(get_customers_customer_balance_transactions_transaction_request(),
                                                            mhttp:request_options()) ->
                                                               term().
get_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/balance_transactions/~s", [VarCustomer, VarTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_methods_payment_method(post_payment_methods_payment_method_request()) ->
                                           term().
post_payment_methods_payment_method(Args) ->
    post_payment_methods_payment_method(Args, #{}).

-spec post_payment_methods_payment_method(post_payment_methods_payment_method_request(),
                                          mhttp:request_options()) ->
                                             term().
post_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/~s", [VarPaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_methods_payment_method(get_payment_methods_payment_method_request()) ->
                                            term().
get_payment_methods_payment_method(Args) ->
    get_payment_methods_payment_method(Args, #{}).

-spec get_payment_methods_payment_method(get_payment_methods_payment_method_request(),
                                         mhttp:request_options()) ->
                                            term().
get_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/~s", [VarPaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups_topup_cancel(post_topups_topup_cancel_request()) -> term().
post_topups_topup_cancel(Args) ->
    post_topups_topup_cancel(Args, #{}).

-spec post_topups_topup_cancel(post_topups_topup_cancel_request(),
                               mhttp:request_options()) ->
                                  term().
post_topups_topup_cancel(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups/~s/cancel", [VarTopup]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_events(get_events_request()) -> term().
get_events(Args) ->
    get_events(Args, #{}).

-spec get_events(get_events_request(), mhttp:request_options()) -> term().
get_events(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({delivery_success, Value}) ->
                encode_q(form, false, <<"delivery_success">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({types, Value}) ->
                encode_q(deepObject, true, <<"types">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     delivery_success,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     type,
                                     types],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/events", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refunds_refund(post_charges_charge_refunds_refund_request()) ->
                                            term().
post_charges_charge_refunds_refund(Args) ->
    post_charges_charge_refunds_refund(Args, #{}).

-spec post_charges_charge_refunds_refund(post_charges_charge_refunds_refund_request(),
                                         mhttp:request_options()) ->
                                            term().
post_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refunds/~s", [VarCharge, VarRefund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_refunds_refund(get_charges_charge_refunds_refund_request()) ->
                                           term().
get_charges_charge_refunds_refund(Args) ->
    get_charges_charge_refunds_refund(Args, #{}).

-spec get_charges_charge_refunds_refund(get_charges_charge_refunds_refund_request(),
                                        mhttp:request_options()) ->
                                           term().
get_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refunds/~s", [VarCharge, VarRefund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_capabilities_capability(post_accounts_account_capabilities_capability_request()) ->
                                                     term().
post_accounts_account_capabilities_capability(Args) ->
    post_accounts_account_capabilities_capability(Args, #{}).

-spec
    post_accounts_account_capabilities_capability(post_accounts_account_capabilities_capability_request(),
                                                  mhttp:request_options()) ->
                                                     term().
post_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities/~s", [VarAccount, VarCapability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_capabilities_capability(get_accounts_account_capabilities_capability_request()) ->
                                                    term().
get_accounts_account_capabilities_capability(Args) ->
    get_accounts_account_capabilities_capability(Args, #{}).

-spec
    get_accounts_account_capabilities_capability(get_accounts_account_capabilities_capability_request(),
                                                 mhttp:request_options()) ->
                                                    term().
get_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities/~s", [VarAccount, VarCapability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items(post_subscription_items_request()) -> term().
post_subscription_items(Args) ->
    post_subscription_items(Args, #{}).

-spec post_subscription_items(post_subscription_items_request(),
                              mhttp:request_options()) ->
                                 term().
post_subscription_items(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items(get_subscription_items_request()) -> term().
get_subscription_items(Args) ->
    get_subscription_items(Args, #{}).

-spec get_subscription_items(get_subscription_items_request(), mhttp:request_options()) ->
                                term().
get_subscription_items(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after, subscription],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_pdf(get_quotes_quote_pdf_request()) -> term().
get_quotes_quote_pdf(Args) ->
    get_quotes_quote_pdf(Args, #{}).

-spec get_quotes_quote_pdf(get_quotes_quote_pdf_request(), mhttp:request_options()) ->
                              term().
get_quotes_quote_pdf(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/pdf", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_bank_accounts_id(post_account_bank_accounts_id_request()) -> term().
post_account_bank_accounts_id(Args) ->
    post_account_bank_accounts_id(Args, #{}).

-spec post_account_bank_accounts_id(post_account_bank_accounts_id_request(),
                                    mhttp:request_options()) ->
                                       term().
post_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_bank_accounts_id(get_account_bank_accounts_id_request()) -> term().
get_account_bank_accounts_id(Args) ->
    get_account_bank_accounts_id(Args, #{}).

-spec get_account_bank_accounts_id(get_account_bank_accounts_id_request(),
                                   mhttp:request_options()) ->
                                      term().
get_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_bank_accounts_id(delete_account_bank_accounts_id_request()) ->
                                         term().
delete_account_bank_accounts_id(Args) ->
    delete_account_bank_accounts_id(Args, #{}).

-spec delete_account_bank_accounts_id(delete_account_bank_accounts_id_request(),
                                      mhttp:request_options()) ->
                                         term().
delete_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_payment_links_payment_link_line_items(get_payment_links_payment_link_line_items_request()) ->
                                                 term().
get_payment_links_payment_link_line_items(Args) ->
    get_payment_links_payment_link_line_items(Args, #{}).

-spec
    get_payment_links_payment_link_line_items(get_payment_links_payment_link_line_items_request(),
                                              mhttp:request_options()) ->
                                                 term().
get_payment_links_payment_link_line_items(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links/~s/line_items", [VarPaymentLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_subscription_items_subscription_item_usage_record_summaries(get_subscription_items_subscription_item_usage_record_summaries_request()) ->
                                                                       term().
get_subscription_items_subscription_item_usage_record_summaries(Args) ->
    get_subscription_items_subscription_item_usage_record_summaries(Args, #{}).

-spec
    get_subscription_items_subscription_item_usage_record_summaries(get_subscription_items_subscription_item_usage_record_summaries_request(),
                                                                    mhttp:request_options()) ->
                                                                       term().
get_subscription_items_subscription_item_usage_record_summaries(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/subscription_items/~s/usage_record_summaries", [VarSubscriptionItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent(post_payment_intents_intent_request()) -> term().
post_payment_intents_intent(Args) ->
    post_payment_intents_intent(Args, #{}).

-spec post_payment_intents_intent(post_payment_intents_intent_request(),
                                  mhttp:request_options()) ->
                                     term().
post_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_intents_intent(get_payment_intents_intent_request()) -> term().
get_payment_intents_intent(Args) ->
    get_payment_intents_intent(Args, #{}).

-spec get_payment_intents_intent(get_payment_intents_intent_request(),
                                 mhttp:request_options()) ->
                                    term().
get_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    EncodeQuery =
        fun ({client_secret, Value}) ->
                encode_q(form, false, <<"client_secret">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([client_secret, expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges(post_charges_request()) -> term().
post_charges(Args) ->
    post_charges(Args, #{}).

-spec post_charges(post_charges_request(), mhttp:request_options()) -> term().
post_charges(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges(get_charges_request()) -> term().
get_charges(Args) ->
    get_charges(Args, #{}).

-spec get_charges(get_charges_request(), mhttp:request_options()) -> term().
get_charges(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({transfer_group, Value}) ->
                encode_q(form, false, <<"transfer_group">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     customer,
                                     ending_before,
                                     expand,
                                     limit,
                                     payment_intent,
                                     starting_after,
                                     transfer_group],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_accounts_account_external_accounts(post_accounts_account_external_accounts_request()) ->
                                               term().
post_accounts_account_external_accounts(Args) ->
    post_accounts_account_external_accounts(Args, #{}).

-spec
    post_accounts_account_external_accounts(post_accounts_account_external_accounts_request(),
                                            mhttp:request_options()) ->
                                               term().
post_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_accounts_account_external_accounts(get_accounts_account_external_accounts_request()) ->
                                              term().
get_accounts_account_external_accounts(Args) ->
    get_accounts_account_external_accounts(Args, #{}).

-spec
    get_accounts_account_external_accounts(get_accounts_account_external_accounts_request(),
                                           mhttp:request_options()) ->
                                              term().
get_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_authorizations(get_issuing_authorizations_request()) -> term().
get_issuing_authorizations(Args) ->
    get_issuing_authorizations(Args, #{}).

-spec get_issuing_authorizations(get_issuing_authorizations_request(),
                                 mhttp:request_options()) ->
                                    term().
get_issuing_authorizations(Args, Options) ->
    EncodeQuery =
        fun ({card, Value}) ->
                encode_q(form, false, <<"card">>, Value);
            ({cardholder, Value}) ->
                encode_q(form, false, <<"cardholder">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([card,
                                     cardholder,
                                     created,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     status],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_products_id(post_products_id_request()) -> term().
post_products_id(Args) ->
    post_products_id(Args, #{}).

-spec post_products_id(post_products_id_request(), mhttp:request_options()) -> term().
post_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_products_id(get_products_id_request()) -> term().
get_products_id(Args) ->
    get_products_id(Args, #{}).

-spec get_products_id(get_products_id_request(), mhttp:request_options()) -> term().
get_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_products_id(delete_products_id_request()) -> term().
delete_products_id(Args) ->
    delete_products_id(Args, #{}).

-spec delete_products_id(delete_products_id_request(), mhttp:request_options()) -> term().
delete_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_setup_intents_intent_verify_microdeposits(post_setup_intents_intent_verify_microdeposits_request()) ->
                                                      term().
post_setup_intents_intent_verify_microdeposits(Args) ->
    post_setup_intents_intent_verify_microdeposits(Args, #{}).

-spec
    post_setup_intents_intent_verify_microdeposits(post_setup_intents_intent_verify_microdeposits_request(),
                                                   mhttp:request_options()) ->
                                                      term().
post_setup_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s/verify_microdeposits", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_types(get_reporting_report_types_request()) -> term().
get_reporting_report_types(Args) ->
    get_reporting_report_types(Args, #{}).

-spec get_reporting_report_types(get_reporting_report_types_request(),
                                 mhttp:request_options()) ->
                                    term().
get_reporting_report_types(Args, Options) ->
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_types", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_external_accounts(post_account_external_accounts_request()) -> term().
post_account_external_accounts(Args) ->
    post_account_external_accounts(Args, #{}).

-spec post_account_external_accounts(post_account_external_accounts_request(),
                                     mhttp:request_options()) ->
                                        term().
post_account_external_accounts(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_external_accounts(get_account_external_accounts_request()) -> term().
get_account_external_accounts(Args) ->
    get_account_external_accounts(Args, #{}).

-spec get_account_external_accounts(get_account_external_accounts_request(),
                                    mhttp:request_options()) ->
                                       term().
get_account_external_accounts(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_lists(post_radar_value_lists_request()) -> term().
post_radar_value_lists(Args) ->
    post_radar_value_lists(Args, #{}).

-spec post_radar_value_lists(post_radar_value_lists_request(), mhttp:request_options()) ->
                                term().
post_radar_value_lists(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_lists(get_radar_value_lists_request()) -> term().
get_radar_value_lists(Args) ->
    get_radar_value_lists(Args, #{}).

-spec get_radar_value_lists(get_radar_value_lists_request(), mhttp:request_options()) ->
                               term().
get_radar_value_lists(Args, Options) ->
    EncodeQuery =
        fun ({alias, Value}) ->
                encode_q(form, false, <<"alias">>, Value);
            ({contains, Value}) ->
                encode_q(form, false, <<"contains">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([alias,
                                     contains,
                                     created,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_shipping_rates(post_shipping_rates_request()) -> term().
post_shipping_rates(Args) ->
    post_shipping_rates(Args, #{}).

-spec post_shipping_rates(post_shipping_rates_request(), mhttp:request_options()) ->
                             term().
post_shipping_rates(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_shipping_rates(get_shipping_rates_request()) -> term().
get_shipping_rates(Args) ->
    get_shipping_rates(Args, #{}).

-spec get_shipping_rates(get_shipping_rates_request(), mhttp:request_options()) -> term().
get_shipping_rates(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active,
                                     created,
                                     currency,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_file_links_link(post_file_links_link_request()) -> term().
post_file_links_link(Args) ->
    post_file_links_link(Args, #{}).

-spec post_file_links_link(post_file_links_link_request(), mhttp:request_options()) ->
                              term().
post_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links/~s", [VarLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_file_links_link(get_file_links_link_request()) -> term().
get_file_links_link(Args) ->
    get_file_links_link(Args, #{}).

-spec get_file_links_link(get_file_links_link_request(), mhttp:request_options()) ->
                             term().
get_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links/~s", [VarLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get3d_secure_three_d_secure(get3d_secure_three_d_secure_request()) -> term().
get3d_secure_three_d_secure(Args) ->
    get3d_secure_three_d_secure(Args, #{}).

-spec get3d_secure_three_d_secure(get3d_secure_three_d_secure_request(),
                                  mhttp:request_options()) ->
                                     term().
get3d_secure_three_d_secure(Args, Options) ->
    VarThreeDSecure = maps:get(three_d_secure, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/3d_secure/~s", [VarThreeDSecure]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_send(post_invoices_invoice_send_request()) -> term().
post_invoices_invoice_send(Args) ->
    post_invoices_invoice_send(Args, #{}).

-spec post_invoices_invoice_send(post_invoices_invoice_send_request(),
                                 mhttp:request_options()) ->
                                    term().
post_invoices_invoice_send(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/send", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_upcoming(get_invoices_upcoming_request()) -> term().
get_invoices_upcoming(Args) ->
    get_invoices_upcoming(Args, #{}).

-spec get_invoices_upcoming(get_invoices_upcoming_request(), mhttp:request_options()) ->
                               term().
get_invoices_upcoming(Args, Options) ->
    EncodeQuery =
        fun ({automatic_tax, Value}) ->
                encode_q(deepObject, true, <<"automatic_tax">>, Value);
            ({coupon, Value}) ->
                encode_q(form, false, <<"coupon">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({customer_details, Value}) ->
                encode_q(deepObject, true, <<"customer_details">>, Value);
            ({discounts, Value}) ->
                encode_q(deepObject, true, <<"discounts">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice_items, Value}) ->
                encode_q(deepObject, true, <<"invoice_items">>, Value);
            ({schedule, Value}) ->
                encode_q(form, false, <<"schedule">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({subscription_billing_cycle_anchor, Value}) ->
                encode_q(deepObject, true, <<"subscription_billing_cycle_anchor">>, Value);
            ({subscription_cancel_at, Value}) ->
                encode_q(deepObject, true, <<"subscription_cancel_at">>, Value);
            ({subscription_cancel_at_period_end, Value}) ->
                encode_q(form, false, <<"subscription_cancel_at_period_end">>, Value);
            ({subscription_cancel_now, Value}) ->
                encode_q(form, false, <<"subscription_cancel_now">>, Value);
            ({subscription_default_tax_rates, Value}) ->
                encode_q(deepObject, true, <<"subscription_default_tax_rates">>, Value);
            ({subscription_items, Value}) ->
                encode_q(deepObject, true, <<"subscription_items">>, Value);
            ({subscription_proration_behavior, Value}) ->
                encode_q(form, false, <<"subscription_proration_behavior">>, Value);
            ({subscription_proration_date, Value}) ->
                encode_q(form, false, <<"subscription_proration_date">>, Value);
            ({subscription_start_date, Value}) ->
                encode_q(form, false, <<"subscription_start_date">>, Value);
            ({subscription_trial_end, Value}) ->
                encode_q(deepObject, true, <<"subscription_trial_end">>, Value);
            ({subscription_trial_from_plan, Value}) ->
                encode_q(form, false, <<"subscription_trial_from_plan">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([automatic_tax,
                                     coupon,
                                     customer,
                                     customer_details,
                                     discounts,
                                     expand,
                                     invoice_items,
                                     schedule,
                                     subscription,
                                     subscription_billing_cycle_anchor,
                                     subscription_cancel_at,
                                     subscription_cancel_at_period_end,
                                     subscription_cancel_now,
                                     subscription_default_tax_rates,
                                     subscription_items,
                                     subscription_proration_behavior,
                                     subscription_proration_date,
                                     subscription_start_date,
                                     subscription_trial_end,
                                     subscription_trial_from_plan],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/upcoming", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_checkout_sessions_session_line_items(get_checkout_sessions_session_line_items_request()) ->
                                                term().
get_checkout_sessions_session_line_items(Args) ->
    get_checkout_sessions_session_line_items(Args, #{}).

-spec
    get_checkout_sessions_session_line_items(get_checkout_sessions_session_line_items_request(),
                                             mhttp:request_options()) ->
                                                term().
get_checkout_sessions_session_line_items(Args, Options) ->
    VarSession = maps:get(session, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions/~s/line_items", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_codes(get_tax_codes_request()) -> term().
get_tax_codes(Args) ->
    get_tax_codes(Args, #{}).

-spec get_tax_codes(get_tax_codes_request(), mhttp:request_options()) -> term().
get_tax_codes(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_codes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices(post_invoices_request()) -> term().
post_invoices(Args) ->
    post_invoices(Args, #{}).

-spec post_invoices(post_invoices_request(), mhttp:request_options()) -> term().
post_invoices(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices(get_invoices_request()) -> term().
get_invoices(Args) ->
    get_invoices(Args, #{}).

-spec get_invoices(get_invoices_request(), mhttp:request_options()) -> term().
get_invoices(Args, Options) ->
    EncodeQuery =
        fun ({collection_method, Value}) ->
                encode_q(form, false, <<"collection_method">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({due_date, Value}) ->
                encode_q(deepObject, true, <<"due_date">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([collection_method,
                                     created,
                                     customer,
                                     due_date,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     status,
                                     subscription],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge(post_charges_charge_request()) -> term().
post_charges_charge(Args) ->
    post_charges_charge(Args, #{}).

-spec post_charges_charge(post_charges_charge_request(), mhttp:request_options()) ->
                             term().
post_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge(get_charges_charge_request()) -> term().
get_charges_charge(Args) ->
    get_charges_charge(Args, #{}).

-spec get_charges_charge(get_charges_charge_request(), mhttp:request_options()) -> term().
get_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_invoices_invoice_mark_uncollectible(post_invoices_invoice_mark_uncollectible_request()) ->
                                                term().
post_invoices_invoice_mark_uncollectible(Args) ->
    post_invoices_invoice_mark_uncollectible(Args, #{}).

-spec
    post_invoices_invoice_mark_uncollectible(post_invoices_invoice_mark_uncollectible_request(),
                                             mhttp:request_options()) ->
                                                term().
post_invoices_invoice_mark_uncollectible(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/mark_uncollectible", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_sources_id_verify(post_customers_customer_sources_id_verify_request()) ->
                                                 term().
post_customers_customer_sources_id_verify(Args) ->
    post_customers_customer_sources_id_verify(Args, #{}).

-spec
    post_customers_customer_sources_id_verify(post_customers_customer_sources_id_verify_request(),
                                              mhttp:request_options()) ->
                                                 term().
post_customers_customer_sources_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s/verify", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id_pay(post_orders_id_pay_request()) -> term().
post_orders_id_pay(Args) ->
    post_orders_id_pay(Args, #{}).

-spec post_orders_id_pay(post_orders_id_pay_request(), mhttp:request_options()) -> term().
post_orders_id_pay(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/~s/pay", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_bank_accounts_id_verify(post_customers_customer_bank_accounts_id_verify_request()) ->
                                                       term().
post_customers_customer_bank_accounts_id_verify(Args) ->
    post_customers_customer_bank_accounts_id_verify(Args, #{}).

-spec
    post_customers_customer_bank_accounts_id_verify(post_customers_customer_bank_accounts_id_verify_request(),
                                                    mhttp:request_options()) ->
                                                       term().
post_customers_customer_bank_accounts_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s/verify", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_people_person(post_account_people_person_request()) -> term().
post_account_people_person(Args) ->
    post_account_people_person(Args, #{}).

-spec post_account_people_person(post_account_people_person_request(),
                                 mhttp:request_options()) ->
                                    term().
post_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_people_person(get_account_people_person_request()) -> term().
get_account_people_person(Args) ->
    get_account_people_person(Args, #{}).

-spec get_account_people_person(get_account_people_person_request(),
                                mhttp:request_options()) ->
                                   term().
get_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_people_person(delete_account_people_person_request()) -> term().
delete_account_people_person(Args) ->
    delete_account_people_person(Args, #{}).

-spec delete_account_people_person(delete_account_people_person_request(),
                                   mhttp:request_options()) ->
                                      term().
delete_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_checkout_sessions(post_checkout_sessions_request()) -> term().
post_checkout_sessions(Args) ->
    post_checkout_sessions(Args, #{}).

-spec post_checkout_sessions(post_checkout_sessions_request(), mhttp:request_options()) ->
                                term().
post_checkout_sessions(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions(get_checkout_sessions_request()) -> term().
get_checkout_sessions(Args) ->
    get_checkout_sessions(Args, #{}).

-spec get_checkout_sessions(get_checkout_sessions_request(), mhttp:request_options()) ->
                               term().
get_checkout_sessions(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before,
                                     expand,
                                     limit,
                                     payment_intent,
                                     starting_after,
                                     subscription],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_login_links(post_accounts_account_login_links_request()) ->
                                           term().
post_accounts_account_login_links(Args) ->
    post_accounts_account_login_links(Args, #{}).

-spec post_accounts_account_login_links(post_accounts_account_login_links_request(),
                                        mhttp:request_options()) ->
                                           term().
post_accounts_account_login_links(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/login_links", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_readers(post_terminal_readers_request()) -> term().
post_terminal_readers(Args) ->
    post_terminal_readers(Args, #{}).

-spec post_terminal_readers(post_terminal_readers_request(), mhttp:request_options()) ->
                               term().
post_terminal_readers(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_readers(get_terminal_readers_request()) -> term().
get_terminal_readers(Args) ->
    get_terminal_readers(Args, #{}).

-spec get_terminal_readers(get_terminal_readers_request(), mhttp:request_options()) ->
                              term().
get_terminal_readers(Args, Options) ->
    EncodeQuery =
        fun ({device_type, Value}) ->
                encode_q(form, false, <<"device_type">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({location, Value}) ->
                encode_q(form, false, <<"location">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([device_type,
                                     ending_before,
                                     expand,
                                     limit,
                                     location,
                                     starting_after,
                                     status],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes(post_issuing_disputes_request()) -> term().
post_issuing_disputes(Args) ->
    post_issuing_disputes(Args, #{}).

-spec post_issuing_disputes(post_issuing_disputes_request(), mhttp:request_options()) ->
                               term().
post_issuing_disputes(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_disputes(get_issuing_disputes_request()) -> term().
get_issuing_disputes(Args) ->
    get_issuing_disputes(Args, #{}).

-spec get_issuing_disputes(get_issuing_disputes_request(), mhttp:request_options()) ->
                              term().
get_issuing_disputes(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({transaction, Value}) ->
                encode_q(form, false, <<"transaction">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     status,
                                     transaction],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post3d_secure(post3d_secure_request()) -> term().
post3d_secure(Args) ->
    post3d_secure(Args, #{}).

-spec post3d_secure(post3d_secure_request(), mhttp:request_options()) -> term().
post3d_secure(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/3d_secure", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_prices(post_prices_request()) -> term().
post_prices(Args) ->
    post_prices(Args, #{}).

-spec post_prices(post_prices_request(), mhttp:request_options()) -> term().
post_prices(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/prices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_prices(get_prices_request()) -> term().
get_prices(Args) ->
    get_prices(Args, #{}).

-spec get_prices(get_prices_request(), mhttp:request_options()) -> term().
get_prices(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({lookup_keys, Value}) ->
                encode_q(deepObject, true, <<"lookup_keys">>, Value);
            ({product, Value}) ->
                encode_q(form, false, <<"product">>, Value);
            ({recurring, Value}) ->
                encode_q(deepObject, true, <<"recurring">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active,
                                     created,
                                     currency,
                                     ending_before,
                                     expand,
                                     limit,
                                     lookup_keys,
                                     product,
                                     recurring,
                                     starting_after,
                                     type],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/prices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice(post_invoices_invoice_request()) -> term().
post_invoices_invoice(Args) ->
    post_invoices_invoice(Args, #{}).

-spec post_invoices_invoice(post_invoices_invoice_request(), mhttp:request_options()) ->
                               term().
post_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_invoice(get_invoices_invoice_request()) -> term().
get_invoices_invoice(Args) ->
    get_invoices_invoice(Args, #{}).

-spec get_invoices_invoice(get_invoices_invoice_request(), mhttp:request_options()) ->
                              term().
get_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_invoices_invoice(delete_invoices_invoice_request()) -> term().
delete_invoices_invoice(Args) ->
    delete_invoices_invoice(Args, #{}).

-spec delete_invoices_invoice(delete_invoices_invoice_request(),
                              mhttp:request_options()) ->
                                 term().
delete_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_identity_verification_sessions_session(post_identity_verification_sessions_session_request()) ->
                                                   term().
post_identity_verification_sessions_session(Args) ->
    post_identity_verification_sessions_session(Args, #{}).

-spec
    post_identity_verification_sessions_session(post_identity_verification_sessions_session_request(),
                                                mhttp:request_options()) ->
                                                   term().
post_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_identity_verification_sessions_session(get_identity_verification_sessions_session_request()) ->
                                                  term().
get_identity_verification_sessions_session(Args) ->
    get_identity_verification_sessions_session(Args, #{}).

-spec
    get_identity_verification_sessions_session(get_identity_verification_sessions_session_request(),
                                               mhttp:request_options()) ->
                                                  term().
get_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_transactions_id(get_balance_transactions_id_request()) -> term().
get_balance_transactions_id(Args) ->
    get_balance_transactions_id(Args, #{}).

-spec get_balance_transactions_id(get_balance_transactions_id_request(),
                                  mhttp:request_options()) ->
                                     term().
get_balance_transactions_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance_transactions/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_cancel(post_setup_intents_intent_cancel_request()) ->
                                          term().
post_setup_intents_intent_cancel(Args) ->
    post_setup_intents_intent_cancel(Args, #{}).

-spec post_setup_intents_intent_cancel(post_setup_intents_intent_cancel_request(),
                                       mhttp:request_options()) ->
                                          term().
post_setup_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s/cancel", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_transactions_transaction(post_issuing_transactions_transaction_request()) ->
                                             term().
post_issuing_transactions_transaction(Args) ->
    post_issuing_transactions_transaction(Args, #{}).

-spec
    post_issuing_transactions_transaction(post_issuing_transactions_transaction_request(),
                                          mhttp:request_options()) ->
                                             term().
post_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/transactions/~s", [VarTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_issuing_transactions_transaction(get_issuing_transactions_transaction_request()) ->
                                            term().
get_issuing_transactions_transaction(Args) ->
    get_issuing_transactions_transaction(Args, #{}).

-spec get_issuing_transactions_transaction(get_issuing_transactions_transaction_request(),
                                           mhttp:request_options()) ->
                                              term().
get_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/transactions/~s", [VarTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_connection_tokens(post_terminal_connection_tokens_request()) ->
                                         term().
post_terminal_connection_tokens(Args) ->
    post_terminal_connection_tokens(Args, #{}).

-spec post_terminal_connection_tokens(post_terminal_connection_tokens_request(),
                                      mhttp:request_options()) ->
                                         term().
post_terminal_connection_tokens(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/connection_tokens", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reviews(get_reviews_request()) -> term().
get_reviews(Args) ->
    get_reviews(Args, #{}).

-spec get_reviews(get_reviews_request(), mhttp:request_options()) -> term().
get_reviews(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reviews", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_promotion_codes(post_promotion_codes_request()) -> term().
post_promotion_codes(Args) ->
    post_promotion_codes(Args, #{}).

-spec post_promotion_codes(post_promotion_codes_request(), mhttp:request_options()) ->
                              term().
post_promotion_codes(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_promotion_codes(get_promotion_codes_request()) -> term().
get_promotion_codes(Args) ->
    get_promotion_codes(Args, #{}).

-spec get_promotion_codes(get_promotion_codes_request(), mhttp:request_options()) ->
                             term().
get_promotion_codes(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({code, Value}) ->
                encode_q(form, false, <<"code">>, Value);
            ({coupon, Value}) ->
                encode_q(form, false, <<"coupon">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active,
                                     code,
                                     coupon,
                                     created,
                                     customer,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_subscriptions_subscription_exposed_id_discount(get_customers_customer_subscriptions_subscription_exposed_id_discount_request()) ->
                                                                             term().
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec
    get_customers_customer_subscriptions_subscription_exposed_id_discount(get_customers_customer_subscriptions_subscription_exposed_id_discount_request(),
                                                                          mhttp:request_options()) ->
                                                                             term().
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s/discount",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(delete_customers_customer_subscriptions_subscription_exposed_id_discount_request()) ->
                                                                                term().
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(delete_customers_customer_subscriptions_subscription_exposed_id_discount_request(),
                                                                             mhttp:request_options()) ->
                                                                                term().
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s/discount",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_quotes_quote_computed_upfront_line_items(get_quotes_quote_computed_upfront_line_items_request()) ->
                                                    term().
get_quotes_quote_computed_upfront_line_items(Args) ->
    get_quotes_quote_computed_upfront_line_items(Args, #{}).

-spec
    get_quotes_quote_computed_upfront_line_items(get_quotes_quote_computed_upfront_line_items_request(),
                                                 mhttp:request_options()) ->
                                                    term().
get_quotes_quote_computed_upfront_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/computed_upfront_line_items", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_list_items_item(get_radar_value_list_items_item_request()) ->
                                         term().
get_radar_value_list_items_item(Args) ->
    get_radar_value_list_items_item(Args, #{}).

-spec get_radar_value_list_items_item(get_radar_value_list_items_item_request(),
                                      mhttp:request_options()) ->
                                         term().
get_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_radar_value_list_items_item(delete_radar_value_list_items_item_request()) ->
                                            term().
delete_radar_value_list_items_item(Args) ->
    delete_radar_value_list_items_item(Args, #{}).

-spec delete_radar_value_list_items_item(delete_radar_value_list_items_item_request(),
                                         mhttp:request_options()) ->
                                            term().
delete_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuer_fraud_records(get_issuer_fraud_records_request()) -> term().
get_issuer_fraud_records(Args) ->
    get_issuer_fraud_records(Args, #{}).

-spec get_issuer_fraud_records(get_issuer_fraud_records_request(),
                               mhttp:request_options()) ->
                                  term().
get_issuer_fraud_records(Args, Options) ->
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([charge, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuer_fraud_records", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tax_rates_tax_rate(post_tax_rates_tax_rate_request()) -> term().
post_tax_rates_tax_rate(Args) ->
    post_tax_rates_tax_rate(Args, #{}).

-spec post_tax_rates_tax_rate(post_tax_rates_tax_rate_request(),
                              mhttp:request_options()) ->
                                 term().
post_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates/~s", [VarTaxRate]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_rates_tax_rate(get_tax_rates_tax_rate_request()) -> term().
get_tax_rates_tax_rate(Args) ->
    get_tax_rates_tax_rate(Args, #{}).

-spec get_tax_rates_tax_rate(get_tax_rates_tax_rate_request(), mhttp:request_options()) ->
                                term().
get_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates/~s", [VarTaxRate]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_recipients(post_recipients_request()) -> term().
post_recipients(Args) ->
    post_recipients(Args, #{}).

-spec post_recipients(post_recipients_request(), mhttp:request_options()) -> term().
post_recipients(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_recipients(get_recipients_request()) -> term().
get_recipients(Args) ->
    get_recipients(Args, #{}).

-spec get_recipients(get_recipients_request(), mhttp:request_options()) -> term().
get_recipients(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({verified, Value}) ->
                encode_q(form, false, <<"verified">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     type,
                                     verified],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_plans(post_plans_request()) -> term().
post_plans(Args) ->
    post_plans(Args, #{}).

-spec post_plans(post_plans_request(), mhttp:request_options()) -> term().
post_plans(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_plans(get_plans_request()) -> term().
get_plans(Args) ->
    get_plans(Args, #{}).

-spec get_plans(get_plans_request(), mhttp:request_options()) -> term().
get_plans(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({product, Value}) ->
                encode_q(form, false, <<"product">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active,
                                     created,
                                     ending_before,
                                     expand,
                                     limit,
                                     product,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_customers_customer_balance_transactions(post_customers_customer_balance_transactions_request()) ->
                                                    term().
post_customers_customer_balance_transactions(Args) ->
    post_customers_customer_balance_transactions(Args, #{}).

-spec
    post_customers_customer_balance_transactions(post_customers_customer_balance_transactions_request(),
                                                 mhttp:request_options()) ->
                                                    term().
post_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/balance_transactions", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_balance_transactions(get_customers_customer_balance_transactions_request()) ->
                                                   term().
get_customers_customer_balance_transactions(Args) ->
    get_customers_customer_balance_transactions(Args, #{}).

-spec
    get_customers_customer_balance_transactions(get_customers_customer_balance_transactions_request(),
                                                mhttp:request_options()) ->
                                                   term().
get_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/balance_transactions", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_reviews_review_approve(post_reviews_review_approve_request()) -> term().
post_reviews_review_approve(Args) ->
    post_reviews_review_approve(Args, #{}).

-spec post_reviews_review_approve(post_reviews_review_approve_request(),
                                  mhttp:request_options()) ->
                                     term().
post_reviews_review_approve(Args, Options) ->
    VarReview = maps:get(review, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reviews/~s/approve", [VarReview]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_tax_ids(post_customers_customer_tax_ids_request()) ->
                                         term().
post_customers_customer_tax_ids(Args) ->
    post_customers_customer_tax_ids(Args, #{}).

-spec post_customers_customer_tax_ids(post_customers_customer_tax_ids_request(),
                                      mhttp:request_options()) ->
                                         term().
post_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_tax_ids(get_customers_customer_tax_ids_request()) -> term().
get_customers_customer_tax_ids(Args) ->
    get_customers_customer_tax_ids(Args, #{}).

-spec get_customers_customer_tax_ids(get_customers_customer_tax_ids_request(),
                                     mhttp:request_options()) ->
                                        term().
get_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tokens_token(get_tokens_token_request()) -> term().
get_tokens_token(Args) ->
    get_tokens_token(Args, #{}).

-spec get_tokens_token(get_tokens_token_request(), mhttp:request_options()) -> term().
get_tokens_token(Args, Options) ->
    VarToken = maps:get(token, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tokens/~s", [VarToken]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_transactions(get_balance_transactions_request()) -> term().
get_balance_transactions(Args) ->
    get_balance_transactions(Args, #{}).

-spec get_balance_transactions(get_balance_transactions_request(),
                               mhttp:request_options()) ->
                                  term().
get_balance_transactions(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payout, Value}) ->
                encode_q(form, false, <<"payout">>, Value);
            ({source, Value}) ->
                encode_q(form, false, <<"source">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     currency,
                                     ending_before,
                                     expand,
                                     limit,
                                     payout,
                                     source,
                                     starting_after,
                                     type],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance_transactions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_codes_id(get_tax_codes_id_request()) -> term().
get_tax_codes_id(Args) ->
    get_tax_codes_id(Args, #{}).

-spec get_tax_codes_id(get_tax_codes_id_request(), mhttp:request_options()) -> term().
get_tax_codes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_codes/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_reject(post_accounts_account_reject_request()) -> term().
post_accounts_account_reject(Args) ->
    post_accounts_account_reject(Args, #{}).

-spec post_accounts_account_reject(post_accounts_account_reject_request(),
                                   mhttp:request_options()) ->
                                      term().
post_accounts_account_reject(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/reject", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscriptions_subscription_exposed_id(post_subscriptions_subscription_exposed_id_request()) ->
                                                  term().
post_subscriptions_subscription_exposed_id(Args) ->
    post_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    post_subscriptions_subscription_exposed_id(post_subscriptions_subscription_exposed_id_request(),
                                               mhttp:request_options()) ->
                                                  term().
post_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_subscriptions_subscription_exposed_id(get_subscriptions_subscription_exposed_id_request()) ->
                                                 term().
get_subscriptions_subscription_exposed_id(Args) ->
    get_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    get_subscriptions_subscription_exposed_id(get_subscriptions_subscription_exposed_id_request(),
                                              mhttp:request_options()) ->
                                                 term().
get_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_subscriptions_subscription_exposed_id(delete_subscriptions_subscription_exposed_id_request()) ->
                                                    term().
delete_subscriptions_subscription_exposed_id(Args) ->
    delete_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    delete_subscriptions_subscription_exposed_id(delete_subscriptions_subscription_exposed_id_request(),
                                                 mhttp:request_options()) ->
                                                    term().
delete_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_country_specs_country(get_country_specs_country_request()) -> term().
get_country_specs_country(Args) ->
    get_country_specs_country(Args, #{}).

-spec get_country_specs_country(get_country_specs_country_request(),
                                mhttp:request_options()) ->
                                   term().
get_country_specs_country(Args, Options) ->
    VarCountry = maps:get(country, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/country_specs/~s", [VarCountry]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_finalize(post_invoices_invoice_finalize_request()) -> term().
post_invoices_invoice_finalize(Args) ->
    post_invoices_invoice_finalize(Args, #{}).

-spec post_invoices_invoice_finalize(post_invoices_invoice_finalize_request(),
                                     mhttp:request_options()) ->
                                        term().
post_invoices_invoice_finalize(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/finalize", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_locations_location(post_terminal_locations_location_request()) ->
                                          term().
post_terminal_locations_location(Args) ->
    post_terminal_locations_location(Args, #{}).

-spec post_terminal_locations_location(post_terminal_locations_location_request(),
                                       mhttp:request_options()) ->
                                          term().
post_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_locations_location(get_terminal_locations_location_request()) ->
                                         term().
get_terminal_locations_location(Args) ->
    get_terminal_locations_location(Args, #{}).

-spec get_terminal_locations_location(get_terminal_locations_location_request(),
                                      mhttp:request_options()) ->
                                         term().
get_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_terminal_locations_location(delete_terminal_locations_location_request()) ->
                                            term().
delete_terminal_locations_location(Args) ->
    delete_terminal_locations_location(Args, #{}).

-spec delete_terminal_locations_location(delete_terminal_locations_location_request(),
                                         mhttp:request_options()) ->
                                            term().
delete_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account(post_account_request()) -> term().
post_account(Args) ->
    post_account(Args, #{}).

-spec post_account(post_account_request(), mhttp:request_options()) -> term().
post_account(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account(get_account_request()) -> term().
get_account(Args) ->
    get_account(Args, #{}).

-spec get_account(get_account_request(), mhttp:request_options()) -> term().
get_account(Args, Options) ->
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account(delete_account_request()) -> term().
delete_account(Args) ->
    delete_account(Args, #{}).

-spec delete_account(delete_account_request(), mhttp:request_options()) -> term().
delete_account(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_shipping_rates_shipping_rate_token(post_shipping_rates_shipping_rate_token_request()) ->
                                               term().
post_shipping_rates_shipping_rate_token(Args) ->
    post_shipping_rates_shipping_rate_token(Args, #{}).

-spec
    post_shipping_rates_shipping_rate_token(post_shipping_rates_shipping_rate_token_request(),
                                            mhttp:request_options()) ->
                                               term().
post_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates/~s", [VarShippingRateToken]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_shipping_rates_shipping_rate_token(get_shipping_rates_shipping_rate_token_request()) ->
                                              term().
get_shipping_rates_shipping_rate_token(Args) ->
    get_shipping_rates_shipping_rate_token(Args, #{}).

-spec
    get_shipping_rates_shipping_rate_token(get_shipping_rates_shipping_rate_token_request(),
                                           mhttp:request_options()) ->
                                              term().
get_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates/~s", [VarShippingRateToken]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_upcoming_lines(get_invoices_upcoming_lines_request()) -> term().
get_invoices_upcoming_lines(Args) ->
    get_invoices_upcoming_lines(Args, #{}).

-spec get_invoices_upcoming_lines(get_invoices_upcoming_lines_request(),
                                  mhttp:request_options()) ->
                                     term().
get_invoices_upcoming_lines(Args, Options) ->
    EncodeQuery =
        fun ({automatic_tax, Value}) ->
                encode_q(deepObject, true, <<"automatic_tax">>, Value);
            ({coupon, Value}) ->
                encode_q(form, false, <<"coupon">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({customer_details, Value}) ->
                encode_q(deepObject, true, <<"customer_details">>, Value);
            ({discounts, Value}) ->
                encode_q(deepObject, true, <<"discounts">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice_items, Value}) ->
                encode_q(deepObject, true, <<"invoice_items">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({schedule, Value}) ->
                encode_q(form, false, <<"schedule">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({subscription_billing_cycle_anchor, Value}) ->
                encode_q(deepObject, true, <<"subscription_billing_cycle_anchor">>, Value);
            ({subscription_cancel_at, Value}) ->
                encode_q(deepObject, true, <<"subscription_cancel_at">>, Value);
            ({subscription_cancel_at_period_end, Value}) ->
                encode_q(form, false, <<"subscription_cancel_at_period_end">>, Value);
            ({subscription_cancel_now, Value}) ->
                encode_q(form, false, <<"subscription_cancel_now">>, Value);
            ({subscription_default_tax_rates, Value}) ->
                encode_q(deepObject, true, <<"subscription_default_tax_rates">>, Value);
            ({subscription_items, Value}) ->
                encode_q(deepObject, true, <<"subscription_items">>, Value);
            ({subscription_proration_behavior, Value}) ->
                encode_q(form, false, <<"subscription_proration_behavior">>, Value);
            ({subscription_proration_date, Value}) ->
                encode_q(form, false, <<"subscription_proration_date">>, Value);
            ({subscription_start_date, Value}) ->
                encode_q(form, false, <<"subscription_start_date">>, Value);
            ({subscription_trial_end, Value}) ->
                encode_q(deepObject, true, <<"subscription_trial_end">>, Value);
            ({subscription_trial_from_plan, Value}) ->
                encode_q(form, false, <<"subscription_trial_from_plan">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([automatic_tax,
                                     coupon,
                                     customer,
                                     customer_details,
                                     discounts,
                                     ending_before,
                                     expand,
                                     invoice_items,
                                     limit,
                                     schedule,
                                     starting_after,
                                     subscription,
                                     subscription_billing_cycle_anchor,
                                     subscription_cancel_at,
                                     subscription_cancel_at_period_end,
                                     subscription_cancel_now,
                                     subscription_default_tax_rates,
                                     subscription_items,
                                     subscription_proration_behavior,
                                     subscription_proration_date,
                                     subscription_start_date,
                                     subscription_trial_end,
                                     subscription_trial_from_plan],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/upcoming/lines", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cardholders(post_issuing_cardholders_request()) -> term().
post_issuing_cardholders(Args) ->
    post_issuing_cardholders(Args, #{}).

-spec post_issuing_cardholders(post_issuing_cardholders_request(),
                               mhttp:request_options()) ->
                                  term().
post_issuing_cardholders(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cardholders(get_issuing_cardholders_request()) -> term().
get_issuing_cardholders(Args) ->
    get_issuing_cardholders(Args, #{}).

-spec get_issuing_cardholders(get_issuing_cardholders_request(),
                              mhttp:request_options()) ->
                                 term().
get_issuing_cardholders(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({email, Value}) ->
                encode_q(form, false, <<"email">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({phone_number, Value}) ->
                encode_q(form, false, <<"phone_number">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     email,
                                     ending_before,
                                     expand,
                                     limit,
                                     phone_number,
                                     starting_after,
                                     status,
                                     type],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources_id(post_customers_customer_sources_id_request()) ->
                                            term().
post_customers_customer_sources_id(Args) ->
    post_customers_customer_sources_id(Args, #{}).

-spec post_customers_customer_sources_id(post_customers_customer_sources_id_request(),
                                         mhttp:request_options()) ->
                                            term().
post_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_sources_id(get_customers_customer_sources_id_request()) ->
                                           term().
get_customers_customer_sources_id(Args) ->
    get_customers_customer_sources_id(Args, #{}).

-spec get_customers_customer_sources_id(get_customers_customer_sources_id_request(),
                                        mhttp:request_options()) ->
                                           term().
get_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    delete_customers_customer_sources_id(delete_customers_customer_sources_id_request()) ->
                                            term().
delete_customers_customer_sources_id(Args) ->
    delete_customers_customer_sources_id(Args, #{}).

-spec delete_customers_customer_sources_id(delete_customers_customer_sources_id_request(),
                                           mhttp:request_options()) ->
                                              term().
delete_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees(get_application_fees_request()) -> term().
get_application_fees(Args) ->
    get_application_fees(Args, #{}).

-spec get_application_fees(get_application_fees_request(), mhttp:request_options()) ->
                              term().
get_application_fees(Args, Options) ->
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([charge, created, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers(get_bitcoin_receivers_request()) -> term().
get_bitcoin_receivers(Args) ->
    get_bitcoin_receivers(Args, #{}).

-spec get_bitcoin_receivers(get_bitcoin_receivers_request(), mhttp:request_options()) ->
                               term().
get_bitcoin_receivers(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({filled, Value}) ->
                encode_q(form, false, <<"filled">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({uncaptured_funds, Value}) ->
                encode_q(form, false, <<"uncaptured_funds">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active,
                                     ending_before,
                                     expand,
                                     filled,
                                     limit,
                                     starting_after,
                                     uncaptured_funds],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/receivers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_refunds_refund(post_refunds_refund_request()) -> term().
post_refunds_refund(Args) ->
    post_refunds_refund(Args, #{}).

-spec post_refunds_refund(post_refunds_refund_request(), mhttp:request_options()) ->
                             term().
post_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds/~s", [VarRefund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_refunds_refund(get_refunds_refund_request()) -> term().
get_refunds_refund(Args) ->
    get_refunds_refund(Args, #{}).

-spec get_refunds_refund(get_refunds_refund_request(), mhttp:request_options()) -> term().
get_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds/~s", [VarRefund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_login_links(post_account_login_links_request()) -> term().
post_account_login_links(Args) ->
    post_account_login_links(Args, #{}).

-spec post_account_login_links(post_account_login_links_request(),
                               mhttp:request_options()) ->
                                  term().
post_account_login_links(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/login_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tax_rates(post_tax_rates_request()) -> term().
post_tax_rates(Args) ->
    post_tax_rates(Args, #{}).

-spec post_tax_rates(post_tax_rates_request(), mhttp:request_options()) -> term().
post_tax_rates(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_rates(get_tax_rates_request()) -> term().
get_tax_rates(Args) ->
    get_tax_rates(Args, #{}).

-spec get_tax_rates(get_tax_rates_request(), mhttp:request_options()) -> term().
get_tax_rates(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({inclusive, Value}) ->
                encode_q(form, false, <<"inclusive">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active,
                                     created,
                                     ending_before,
                                     expand,
                                     inclusive,
                                     limit,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_people(post_accounts_account_people_request()) -> term().
post_accounts_account_people(Args) ->
    post_accounts_account_people(Args, #{}).

-spec post_accounts_account_people(post_accounts_account_people_request(),
                                   mhttp:request_options()) ->
                                      term().
post_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_people(get_accounts_account_people_request()) -> term().
get_accounts_account_people(Args) ->
    get_accounts_account_people(Args, #{}).

-spec get_accounts_account_people(get_accounts_account_people_request(),
                                  mhttp:request_options()) ->
                                     term().
get_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, relationship, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_disputes_dispute_submit(post_issuing_disputes_dispute_submit_request()) ->
                                            term().
post_issuing_disputes_dispute_submit(Args) ->
    post_issuing_disputes_dispute_submit(Args, #{}).

-spec post_issuing_disputes_dispute_submit(post_issuing_disputes_dispute_submit_request(),
                                           mhttp:request_options()) ->
                                              term().
post_issuing_disputes_dispute_submit(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes/~s/submit", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources_source(post_sources_source_request()) -> term().
post_sources_source(Args) ->
    post_sources_source(Args, #{}).

-spec post_sources_source(post_sources_source_request(), mhttp:request_options()) ->
                             term().
post_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/~s", [VarSource]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source(get_sources_source_request()) -> term().
get_sources_source(Args) ->
    get_sources_source(Args, #{}).

-spec get_sources_source(get_sources_source_request(), mhttp:request_options()) -> term().
get_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    EncodeQuery =
        fun ({client_secret, Value}) ->
                encode_q(form, false, <<"client_secret">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([client_secret, expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/~s", [VarSource]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions_session(get_checkout_sessions_session_request()) -> term().
get_checkout_sessions_session(Args) ->
    get_checkout_sessions_session(Args, #{}).

-spec get_checkout_sessions_session(get_checkout_sessions_session_request(),
                                    mhttp:request_options()) ->
                                       term().
get_checkout_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions/~s", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_methods_payment_method_detach(post_payment_methods_payment_method_detach_request()) ->
                                                  term().
post_payment_methods_payment_method_detach(Args) ->
    post_payment_methods_payment_method_detach(Args, #{}).

-spec
    post_payment_methods_payment_method_detach(post_payment_methods_payment_method_detach_request(),
                                               mhttp:request_options()) ->
                                                  term().
post_payment_methods_payment_method_detach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/~s/detach", [VarPaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers(post_customers_request()) -> term().
post_customers(Args) ->
    post_customers(Args, #{}).

-spec post_customers(post_customers_request(), mhttp:request_options()) -> term().
post_customers(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers(get_customers_request()) -> term().
get_customers(Args) ->
    get_customers(Args, #{}).

-spec get_customers(get_customers_request(), mhttp:request_options()) -> term().
get_customers(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({email, Value}) ->
                encode_q(form, false, <<"email">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created, email, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_bank_accounts(post_account_bank_accounts_request()) -> term().
post_account_bank_accounts(Args) ->
    post_account_bank_accounts(Args, #{}).

-spec post_account_bank_accounts(post_account_bank_accounts_request(),
                                 mhttp:request_options()) ->
                                    term().
post_account_bank_accounts(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes_dispute(post_issuing_disputes_dispute_request()) -> term().
post_issuing_disputes_dispute(Args) ->
    post_issuing_disputes_dispute(Args, #{}).

-spec post_issuing_disputes_dispute(post_issuing_disputes_dispute_request(),
                                    mhttp:request_options()) ->
                                       term().
post_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes/~s", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_disputes_dispute(get_issuing_disputes_dispute_request()) -> term().
get_issuing_disputes_dispute(Args) ->
    get_issuing_disputes_dispute(Args, #{}).

-spec get_issuing_disputes_dispute(get_issuing_disputes_dispute_request(),
                                   mhttp:request_options()) ->
                                      term().
get_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes/~s", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_disputes_dispute_close(post_disputes_dispute_close_request()) -> term().
post_disputes_dispute_close(Args) ->
    post_disputes_dispute_close(Args, #{}).

-spec post_disputes_dispute_close(post_disputes_dispute_close_request(),
                                  mhttp:request_options()) ->
                                     term().
post_disputes_dispute_close(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes/~s/close", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_cancel(post_quotes_quote_cancel_request()) -> term().
post_quotes_quote_cancel(Args) ->
    post_quotes_quote_cancel(Args, #{}).

-spec post_quotes_quote_cancel(post_quotes_quote_cancel_request(),
                               mhttp:request_options()) ->
                                  term().
post_quotes_quote_cancel(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/cancel", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_customers_customer_payment_methods(get_customers_customer_payment_methods_request()) ->
                                              term().
get_customers_customer_payment_methods(Args) ->
    get_customers_customer_payment_methods(Args, #{}).

-spec
    get_customers_customer_payment_methods(get_customers_customer_payment_methods_request(),
                                           mhttp:request_options()) ->
                                              term().
get_customers_customer_payment_methods(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after, type],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/payment_methods", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_refunds(post_refunds_request()) -> term().
post_refunds(Args) ->
    post_refunds(Args, #{}).

-spec post_refunds(post_refunds_request(), mhttp:request_options()) -> term().
post_refunds(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_refunds(get_refunds_request()) -> term().
get_refunds(Args) ->
    get_refunds(Args, #{}).

-spec get_refunds(get_refunds_request(), mhttp:request_options()) -> term().
get_refunds(Args, Options) ->
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([charge,
                                     created,
                                     ending_before,
                                     expand,
                                     limit,
                                     payment_intent,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes_id(post_credit_notes_id_request()) -> term().
post_credit_notes_id(Args) ->
    post_credit_notes_id(Args, #{}).

-spec post_credit_notes_id(post_credit_notes_id_request(), mhttp:request_options()) ->
                              term().
post_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_id(get_credit_notes_id_request()) -> term().
get_credit_notes_id(Args) ->
    get_credit_notes_id(Args, #{}).

-spec get_credit_notes_id(get_credit_notes_id_request(), mhttp:request_options()) ->
                             term().
get_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_transactions(get_bitcoin_transactions_request()) -> term().
get_bitcoin_transactions(Args) ->
    get_bitcoin_transactions(Args, #{}).

-spec get_bitcoin_transactions(get_bitcoin_transactions_request(),
                               mhttp:request_options()) ->
                                  term().
get_bitcoin_transactions(Args, Options) ->
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({receiver, Value}) ->
                encode_q(form, false, <<"receiver">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([customer,
                                     ending_before,
                                     expand,
                                     limit,
                                     receiver,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/transactions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents(post_setup_intents_request()) -> term().
post_setup_intents(Args) ->
    post_setup_intents(Args, #{}).

-spec post_setup_intents(post_setup_intents_request(), mhttp:request_options()) -> term().
post_setup_intents(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_intents(get_setup_intents_request()) -> term().
get_setup_intents(Args) ->
    get_setup_intents(Args, #{}).

-spec get_setup_intents(get_setup_intents_request(), mhttp:request_options()) -> term().
get_setup_intents(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_method, Value}) ->
                encode_q(form, false, <<"payment_method">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created,
                                     customer,
                                     ending_before,
                                     expand,
                                     limit,
                                     payment_method,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout_cancel(post_payouts_payout_cancel_request()) -> term().
post_payouts_payout_cancel(Args) ->
    post_payouts_payout_cancel(Args, #{}).

-spec post_payouts_payout_cancel(post_payouts_payout_cancel_request(),
                                 mhttp:request_options()) ->
                                    term().
post_payouts_payout_cancel(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/~s/cancel", [VarPayout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_authorizations_authorization_approve(post_issuing_authorizations_authorization_approve_request()) ->
                                                         term().
post_issuing_authorizations_authorization_approve(Args) ->
    post_issuing_authorizations_authorization_approve(Args, #{}).

-spec
    post_issuing_authorizations_authorization_approve(post_issuing_authorizations_authorization_approve_request(),
                                                      mhttp:request_options()) ->
                                                         term().
post_issuing_authorizations_authorization_approve(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s/approve", [VarAuthorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_authorizations_authorization_decline(post_issuing_authorizations_authorization_decline_request()) ->
                                                         term().
post_issuing_authorizations_authorization_decline(Args) ->
    post_issuing_authorizations_authorization_decline(Args, #{}).

-spec
    post_issuing_authorizations_authorization_decline(post_issuing_authorizations_authorization_decline_request(),
                                                      mhttp:request_options()) ->
                                                         term().
post_issuing_authorizations_authorization_decline(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s/decline", [VarAuthorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_reporting_report_runs(post_reporting_report_runs_request()) -> term().
post_reporting_report_runs(Args) ->
    post_reporting_report_runs(Args, #{}).

-spec post_reporting_report_runs(post_reporting_report_runs_request(),
                                 mhttp:request_options()) ->
                                    term().
post_reporting_report_runs(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_runs(get_reporting_report_runs_request()) -> term().
get_reporting_report_runs(Args) ->
    get_reporting_report_runs(Args, #{}).

-spec get_reporting_report_runs(get_reporting_report_runs_request(),
                                mhttp:request_options()) ->
                                   term().
get_reporting_report_runs(Args, Options) ->
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([created, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_void(post_invoices_invoice_void_request()) -> term().
post_invoices_invoice_void(Args) ->
    post_invoices_invoice_void(Args, #{}).

-spec post_invoices_invoice_void(post_invoices_invoice_void_request(),
                                 mhttp:request_options()) ->
                                    term().
post_invoices_invoice_void(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/void", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources(post_sources_request()) -> term().
post_sources(Args) ->
    post_sources(Args, #{}).

-spec post_sources(post_sources_request(), mhttp:request_options()) -> term().
post_sources(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_configurations(post_billing_portal_configurations_request()) ->
                                            term().
post_billing_portal_configurations(Args) ->
    post_billing_portal_configurations(Args, #{}).

-spec post_billing_portal_configurations(post_billing_portal_configurations_request(),
                                         mhttp:request_options()) ->
                                            term().
post_billing_portal_configurations(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_billing_portal_configurations(get_billing_portal_configurations_request()) ->
                                           term().
get_billing_portal_configurations(Args) ->
    get_billing_portal_configurations(Args, #{}).

-spec get_billing_portal_configurations(get_billing_portal_configurations_request(),
                                        mhttp:request_options()) ->
                                           term().
get_billing_portal_configurations(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({is_default, Value}) ->
                encode_q(form, false, <<"is_default">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active,
                                     ending_before,
                                     expand,
                                     is_default,
                                     limit,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes(post_quotes_request()) -> term().
post_quotes(Args) ->
    post_quotes(Args, #{}).

-spec post_quotes(post_quotes_request(), mhttp:request_options()) -> term().
post_quotes(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes(get_quotes_request()) -> term().
get_quotes(Args) ->
    get_quotes(Args, #{}).

-spec get_quotes(get_quotes_request(), mhttp:request_options()) -> term().
get_quotes(Args, Options) ->
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([customer,
                                     ending_before,
                                     expand,
                                     limit,
                                     starting_after,
                                     status],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_transfer(post_transfers_transfer_request()) -> term().
post_transfers_transfer(Args) ->
    post_transfers_transfer(Args, #{}).

-spec post_transfers_transfer(post_transfers_transfer_request(),
                              mhttp:request_options()) ->
                                 term().
post_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s", [VarTransfer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_transfer(get_transfers_transfer_request()) -> term().
get_transfers_transfer(Args) ->
    get_transfers_transfer(Args, #{}).

-spec get_transfers_transfer(get_transfers_transfer_request(), mhttp:request_options()) ->
                                term().
get_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s", [VarTransfer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_line_items(get_quotes_quote_line_items_request()) -> term().
get_quotes_quote_line_items(Args) ->
    get_quotes_quote_line_items(Args, #{}).

-spec get_quotes_quote_line_items(get_quotes_quote_line_items_request(),
                                  mhttp:request_options()) ->
                                     term().
get_quotes_quote_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/line_items", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoiceitems_invoiceitem(post_invoiceitems_invoiceitem_request()) -> term().
post_invoiceitems_invoiceitem(Args) ->
    post_invoiceitems_invoiceitem(Args, #{}).

-spec post_invoiceitems_invoiceitem(post_invoiceitems_invoiceitem_request(),
                                    mhttp:request_options()) ->
                                       term().
post_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoiceitems_invoiceitem(get_invoiceitems_invoiceitem_request()) -> term().
get_invoiceitems_invoiceitem(Args) ->
    get_invoiceitems_invoiceitem(Args, #{}).

-spec get_invoiceitems_invoiceitem(get_invoiceitems_invoiceitem_request(),
                                   mhttp:request_options()) ->
                                      term().
get_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_invoiceitems_invoiceitem(delete_invoiceitems_invoiceitem_request()) ->
                                         term().
delete_invoiceitems_invoiceitem(Args) ->
    delete_invoiceitems_invoiceitem(Args, #{}).

-spec delete_invoiceitems_invoiceitem(delete_invoiceitems_invoiceitem_request(),
                                      mhttp:request_options()) ->
                                         term().
delete_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_intents_intent_capture(post_payment_intents_intent_capture_request()) ->
                                           term().
post_payment_intents_intent_capture(Args) ->
    post_payment_intents_intent_capture(Args, #{}).

-spec post_payment_intents_intent_capture(post_payment_intents_intent_capture_request(),
                                          mhttp:request_options()) ->
                                             term().
post_payment_intents_intent_capture(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s/capture", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cards(post_issuing_cards_request()) -> term().
post_issuing_cards(Args) ->
    post_issuing_cards(Args, #{}).

-spec post_issuing_cards(post_issuing_cards_request(), mhttp:request_options()) -> term().
post_issuing_cards(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cards(get_issuing_cards_request()) -> term().
get_issuing_cards(Args) ->
    get_issuing_cards(Args, #{}).

-spec get_issuing_cards(get_issuing_cards_request(), mhttp:request_options()) -> term().
get_issuing_cards(Args, Options) ->
    EncodeQuery =
        fun ({cardholder, Value}) ->
                encode_q(form, false, <<"cardholder">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({exp_month, Value}) ->
                encode_q(form, false, <<"exp_month">>, Value);
            ({exp_year, Value}) ->
                encode_q(form, false, <<"exp_year">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({last4, Value}) ->
                encode_q(form, false, <<"last4">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([cardholder,
                                     created,
                                     ending_before,
                                     exp_month,
                                     exp_year,
                                     expand,
                                     last4,
                                     limit,
                                     starting_after,
                                     status,
                                     type],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_sources_source_source_transactions(get_sources_source_source_transactions_request()) ->
                                              term().
get_sources_source_source_transactions(Args) ->
    get_sources_source_source_transactions(Args, #{}).

-spec
    get_sources_source_source_transactions(get_sources_source_source_transactions_request(),
                                           mhttp:request_options()) ->
                                              term().
get_sources_source_source_transactions(Args, Options) ->
    VarSource = maps:get(source, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/~s/source_transactions", [VarSource]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_subscription_schedules_schedule_release(post_subscription_schedules_schedule_release_request()) ->
                                                    term().
post_subscription_schedules_schedule_release(Args) ->
    post_subscription_schedules_schedule_release(Args, #{}).

-spec
    post_subscription_schedules_schedule_release(post_subscription_schedules_schedule_release_request(),
                                                 mhttp:request_options()) ->
                                                    term().
post_subscription_schedules_schedule_release(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/~s/release", [VarSchedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_cards_id(post_customers_customer_cards_id_request()) ->
                                          term().
post_customers_customer_cards_id(Args) ->
    post_customers_customer_cards_id(Args, #{}).

-spec post_customers_customer_cards_id(post_customers_customer_cards_id_request(),
                                       mhttp:request_options()) ->
                                          term().
post_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_cards_id(get_customers_customer_cards_id_request()) ->
                                         term().
get_customers_customer_cards_id(Args) ->
    get_customers_customer_cards_id(Args, #{}).

-spec get_customers_customer_cards_id(get_customers_customer_cards_id_request(),
                                      mhttp:request_options()) ->
                                         term().
get_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_cards_id(delete_customers_customer_cards_id_request()) ->
                                            term().
delete_customers_customer_cards_id(Args) ->
    delete_customers_customer_cards_id(Args, #{}).

-spec delete_customers_customer_cards_id(delete_customers_customer_cards_id_request(),
                                         mhttp:request_options()) ->
                                            term().
delete_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_dispute(post_charges_charge_dispute_request()) -> term().
post_charges_charge_dispute(Args) ->
    post_charges_charge_dispute(Args, #{}).

-spec post_charges_charge_dispute(post_charges_charge_dispute_request(),
                                  mhttp:request_options()) ->
                                     term().
post_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/dispute", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_dispute(get_charges_charge_dispute_request()) -> term().
get_charges_charge_dispute(Args) ->
    get_charges_charge_dispute(Args, #{}).

-spec get_charges_charge_dispute(get_charges_charge_dispute_request(),
                                 mhttp:request_options()) ->
                                    term().
get_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/dispute", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_finalize(post_quotes_quote_finalize_request()) -> term().
post_quotes_quote_finalize(Args) ->
    post_quotes_quote_finalize(Args, #{}).

-spec post_quotes_quote_finalize(post_quotes_quote_finalize_request(),
                                 mhttp:request_options()) ->
                                    term().
post_quotes_quote_finalize(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/finalize", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_skus_id(post_skus_id_request()) -> term().
post_skus_id(Args) ->
    post_skus_id(Args, #{}).

-spec post_skus_id(post_skus_id_request(), mhttp:request_options()) -> term().
post_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_skus_id(get_skus_id_request()) -> term().
get_skus_id(Args) ->
    get_skus_id(Args, #{}).

-spec get_skus_id(get_skus_id_request(), mhttp:request_options()) -> term().
get_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_skus_id(delete_skus_id_request()) -> term().
delete_skus_id(Args) ->
    delete_skus_id(Args, #{}).

-spec delete_skus_id(delete_skus_id_request(), mhttp:request_options()) -> term().
delete_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_disputes_dispute(post_disputes_dispute_request()) -> term().
post_disputes_dispute(Args) ->
    post_disputes_dispute(Args, #{}).

-spec post_disputes_dispute(post_disputes_dispute_request(), mhttp:request_options()) ->
                               term().
post_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes/~s", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_disputes_dispute(get_disputes_dispute_request()) -> term().
get_disputes_dispute(Args) ->
    get_disputes_dispute(Args, #{}).

-spec get_disputes_dispute(get_disputes_dispute_request(), mhttp:request_options()) ->
                              term().
get_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes/~s", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_locations(post_terminal_locations_request()) -> term().
post_terminal_locations(Args) ->
    post_terminal_locations(Args, #{}).

-spec post_terminal_locations(post_terminal_locations_request(),
                              mhttp:request_options()) ->
                                 term().
post_terminal_locations(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_locations(get_terminal_locations_request()) -> term().
get_terminal_locations(Args) ->
    get_terminal_locations(Args, #{}).

-spec get_terminal_locations(get_terminal_locations_request(), mhttp:request_options()) ->
                                term().
get_terminal_locations(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules(post_subscription_schedules_request()) -> term().
post_subscription_schedules(Args) ->
    post_subscription_schedules(Args, #{}).

-spec post_subscription_schedules(post_subscription_schedules_request(),
                                  mhttp:request_options()) ->
                                     term().
post_subscription_schedules(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_schedules(get_subscription_schedules_request()) -> term().
get_subscription_schedules(Args) ->
    get_subscription_schedules(Args, #{}).

-spec get_subscription_schedules(get_subscription_schedules_request(),
                                 mhttp:request_options()) ->
                                    term().
get_subscription_schedules(Args, Options) ->
    EncodeQuery =
        fun ({canceled_at, Value}) ->
                encode_q(deepObject, true, <<"canceled_at">>, Value);
            ({completed_at, Value}) ->
                encode_q(deepObject, true, <<"completed_at">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({released_at, Value}) ->
                encode_q(deepObject, true, <<"released_at">>, Value);
            ({scheduled, Value}) ->
                encode_q(form, false, <<"scheduled">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([canceled_at,
                                     completed_at,
                                     created,
                                     customer,
                                     ending_before,
                                     expand,
                                     limit,
                                     released_at,
                                     scheduled,
                                     starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_links(post_payment_links_request()) -> term().
post_payment_links(Args) ->
    post_payment_links(Args, #{}).

-spec post_payment_links(post_payment_links_request(), mhttp:request_options()) -> term().
post_payment_links(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links(get_payment_links_request()) -> term().
get_payment_links(Args) ->
    get_payment_links(Args, #{}).

-spec get_payment_links(get_payment_links_request(), mhttp:request_options()) -> term().
get_payment_links(Args, Options) ->
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([active, ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tokens(post_tokens_request()) -> term().
post_tokens(Args) ->
    post_tokens(Args, #{}).

-spec post_tokens(post_tokens_request(), mhttp:request_options()) -> term().
post_tokens(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tokens", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_issuing_cardholders_cardholder(post_issuing_cardholders_cardholder_request()) ->
                                           term().
post_issuing_cardholders_cardholder(Args) ->
    post_issuing_cardholders_cardholder(Args, #{}).

-spec post_issuing_cardholders_cardholder(post_issuing_cardholders_cardholder_request(),
                                          mhttp:request_options()) ->
                                             term().
post_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders/~s", [VarCardholder]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cardholders_cardholder(get_issuing_cardholders_cardholder_request()) ->
                                            term().
get_issuing_cardholders_cardholder(Args) ->
    get_issuing_cardholders_cardholder(Args, #{}).

-spec get_issuing_cardholders_cardholder(get_issuing_cardholders_cardholder_request(),
                                         mhttp:request_options()) ->
                                            term().
get_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders/~s", [VarCardholder]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_id(get_application_fees_id_request()) -> term().
get_application_fees_id(Args) ->
    get_application_fees_id(Args, #{}).

-spec get_application_fees_id(get_application_fees_id_request(),
                              mhttp:request_options()) ->
                                 term().
get_application_fees_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_exchange_rates_rate_id(get_exchange_rates_rate_id_request()) -> term().
get_exchange_rates_rate_id(Args) ->
    get_exchange_rates_rate_id(Args, #{}).

-spec get_exchange_rates_rate_id(get_exchange_rates_rate_id_request(),
                                 mhttp:request_options()) ->
                                    term().
get_exchange_rates_rate_id(Args, Options) ->
    VarRateId = maps:get(rate_id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/exchange_rates/~s", [VarRateId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    post_payment_intents_intent_confirm(post_payment_intents_intent_confirm_request()) ->
                                           term().
post_payment_intents_intent_confirm(Args) ->
    post_payment_intents_intent_confirm(Args, #{}).

-spec post_payment_intents_intent_confirm(post_payment_intents_intent_confirm_request(),
                                          mhttp:request_options()) ->
                                             term().
post_payment_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s/confirm", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_preview(get_credit_notes_preview_request()) -> term().
get_credit_notes_preview(Args) ->
    get_credit_notes_preview(Args, #{}).

-spec get_credit_notes_preview(get_credit_notes_preview_request(),
                               mhttp:request_options()) ->
                                  term().
get_credit_notes_preview(Args, Options) ->
    EncodeQuery =
        fun ({amount, Value}) ->
                encode_q(form, false, <<"amount">>, Value);
            ({credit_amount, Value}) ->
                encode_q(form, false, <<"credit_amount">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({lines, Value}) ->
                encode_q(deepObject, true, <<"lines">>, Value);
            ({memo, Value}) ->
                encode_q(form, false, <<"memo">>, Value);
            ({metadata, Value}) ->
                encode_q(deepObject, true, <<"metadata">>, Value);
            ({out_of_band_amount, Value}) ->
                encode_q(form, false, <<"out_of_band_amount">>, Value);
            ({reason, Value}) ->
                encode_q(form, false, <<"reason">>, Value);
            ({refund, Value}) ->
                encode_q(form, false, <<"refund">>, Value);
            ({refund_amount, Value}) ->
                encode_q(form, false, <<"refund_amount">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([amount,
                                     credit_amount,
                                     expand,
                                     invoice,
                                     lines,
                                     memo,
                                     metadata,
                                     out_of_band_amount,
                                     reason,
                                     refund,
                                     refund_amount],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/preview", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_history_id(get_balance_history_id_request()) -> term().
get_balance_history_id(Args) ->
    get_balance_history_id(Args, #{}).

-spec get_balance_history_id(get_balance_history_id_request(), mhttp:request_options()) ->
                                term().
get_balance_history_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance/history/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout_reverse(post_payouts_payout_reverse_request()) -> term().
post_payouts_payout_reverse(Args) ->
    post_payouts_payout_reverse(Args, #{}).

-spec post_payouts_payout_reverse(post_payouts_payout_reverse_request(),
                                  mhttp:request_options()) ->
                                     term().
post_payouts_payout_reverse(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/~s/reverse", [VarPayout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_reporting_report_runs_report_run(get_reporting_report_runs_report_run_request()) ->
                                            term().
get_reporting_report_runs_report_run(Args) ->
    get_reporting_report_runs_report_run(Args, #{}).

-spec get_reporting_report_runs_report_run(get_reporting_report_runs_report_run_request(),
                                           mhttp:request_options()) ->
                                              term().
get_reporting_report_runs_report_run(Args, Options) ->
    VarReportRun = maps:get(report_run, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_runs/~s", [VarReportRun]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec
    get_sources_source_source_transactions_source_transaction(get_sources_source_source_transactions_source_transaction_request()) ->
                                                                 term().
get_sources_source_source_transactions_source_transaction(Args) ->
    get_sources_source_source_transactions_source_transaction(Args, #{}).

-spec
    get_sources_source_source_transactions_source_transaction(get_sources_source_source_transactions_source_transaction_request(),
                                                              mhttp:request_options()) ->
                                                                 term().
get_sources_source_source_transactions_source_transaction(Args, Options) ->
    VarSource = maps:get(source, Args),
    VarSourceTransaction = maps:get(source_transaction, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/sources/~s/source_transactions/~s", [VarSource, VarSourceTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer(post_customers_customer_request()) -> term().
post_customers_customer(Args) ->
    post_customers_customer(Args, #{}).

-spec post_customers_customer(post_customers_customer_request(),
                              mhttp:request_options()) ->
                                 term().
post_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer(get_customers_customer_request()) -> term().
get_customers_customer(Args) ->
    get_customers_customer(Args, #{}).

-spec get_customers_customer(get_customers_customer_request(), mhttp:request_options()) ->
                                term().
get_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer(delete_customers_customer_request()) -> term().
delete_customers_customer(Args) ->
    delete_customers_customer(Args, #{}).

-spec delete_customers_customer(delete_customers_customer_request(),
                                mhttp:request_options()) ->
                                   term().
delete_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_sessions(post_billing_portal_sessions_request()) -> term().
post_billing_portal_sessions(Args) ->
    post_billing_portal_sessions(Args, #{}).

-spec post_billing_portal_sessions(post_billing_portal_sessions_request(),
                                   mhttp:request_options()) ->
                                      term().
post_billing_portal_sessions(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_links_payment_link(post_payment_links_payment_link_request()) ->
                                         term().
post_payment_links_payment_link(Args) ->
    post_payment_links_payment_link(Args, #{}).

-spec post_payment_links_payment_link(post_payment_links_payment_link_request(),
                                      mhttp:request_options()) ->
                                         term().
post_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links/~s", [VarPaymentLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links_payment_link(get_payment_links_payment_link_request()) -> term().
get_payment_links_payment_link(Args) ->
    get_payment_links_payment_link(Args, #{}).

-spec get_payment_links_payment_link(get_payment_links_payment_link_request(),
                                     mhttp:request_options()) ->
                                        term().
get_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    EncodeQuery = fun({expand, Value}) -> encode_q(deepObject, true, <<"expand">>, Value) end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([expand], maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links/~s", [VarPaymentLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_credit_note_lines(get_credit_notes_credit_note_lines_request()) ->
                                            term().
get_credit_notes_credit_note_lines(Args) ->
    get_credit_notes_credit_note_lines(Args, #{}).

-spec get_credit_notes_credit_note_lines(get_credit_notes_credit_note_lines_request(),
                                         mhttp:request_options()) ->
                                            term().
get_credit_notes_credit_note_lines(Args, Options) ->
    VarCreditNote = maps:get(credit_note, Args),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/~s/lines", [VarCreditNote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sigma_scheduled_query_runs(get_sigma_scheduled_query_runs_request()) -> term().
get_sigma_scheduled_query_runs(Args) ->
    get_sigma_scheduled_query_runs(Args, #{}).

-spec get_sigma_scheduled_query_runs(get_sigma_scheduled_query_runs_request(),
                                     mhttp:request_options()) ->
                                        term().
get_sigma_scheduled_query_runs(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value)
        end,

    ReqQuery =
        lists:flatmap(EncodeQuery,
                      maps:to_list(
                          maps:with([ending_before, expand, limit, starting_after],
                                    maps:get(query, Args, #{})))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec encode_q(Style, Explode, Key, Value) -> term()
    when Style :: form | spaceDelimitde | pipeDelimited | deepObject,
         Explode :: boolean(),
         Key :: binary(),
         Value :: term().
encode_q(form, true, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_q(form, true, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_q(form, true, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_q(form, true, Key, Values) when is_list(Values) ->
    lists:map(fun (Value) when is_binary(Value) ->
                      {Key, Value};
                  (Value) when is_integer(Value) ->
                      {Key, integer_to_binary(Value)};
                  (Value) when is_atom(Value) ->
                      {Key, atom_to_binary(Value)}
              end,
              Values);
encode_q(form, true, _Key, Values) when is_map(Values) ->
    maps:fold(fun (Key, Value, Acc) when is_binary(Value) ->
                      [{Key, Value} | Acc];
                  (Key, Value, Acc) when is_integer(Value) ->
                      [{Key, integer_to_binary(Value)} | Acc];
                  (Key, Value, Acc) when is_atom(Value) ->
                      [{Key, atom_to_binary(Key)} | Acc]
              end,
              [],
              Values);
encode_q(form, false, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_q(form, false, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_q(form, false, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_q(form, false, Key, Values) when is_list(Values) ->
    Values1 =
        lists:map(fun (Value) when is_binary(Value) ->
                          Value;
                      (Value) when is_integer(Value) ->
                          integer_to_binary(Value);
                      (Value) when is_atom(Value) ->
                          atom_to_binary(Value)
                  end,
                  Values),
    [{Key,
      unicode:characters_to_binary(
          lists:join(",", Values1))}];
encode_q(form, false, Key, Values) when is_map(Values) ->
    Values1 =
        maps:fold(fun (K, V, Acc) when is_binary(V) ->
                          [[K, $,, V] | Acc];
                      (K, V, Acc) when is_integer(V) ->
                          [[K, $,, integer_to_binary(V)] | Acc];
                      (K, V, Acc) when is_atom(V) ->
                          [[K, $,, atom_to_binary(V)] | Acc]
                  end,
                  [],
                  Values),
    [{Key,
      unicode:characters_to_binary(
          lists:join(",", Values1))}];
%% deepObject MUST not encode primary or array value but Stripe use this style
%% to encode query parameter. So I'm force to extend the spec.
encode_q(deepObject, true, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_q(deepObject, true, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_q(deepObject, true, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_q(deepObject, true, Key, Values) when is_list(Values) ->
    lists:map(fun (Value) when is_binary(Value) ->
                      {<<Key/binary, "[]">>, Value};
                  (Value) when is_integer(Value) ->
                      {<<Key/binary, "[]">>, integer_to_binary(Value)};
                  (Value) when is_atom(Value) ->
                      {<<Key/binary, "[]">>, atom_to_binary(Value)}
              end,
              Values);
encode_q(deepObject, true, Key, Values) when is_map(Values) ->
    maps:fold(fun (K, V, Acc) when is_binary(V) ->
                      K2 = atom_to_binary(K),
                      [{<<Key/binary, $[, K2/binary, $]>>, V} | Acc];
                  (K, V, Acc) when is_integer(V) ->
                      K2 = atom_to_binary(K),
                      [{<<Key/binary, $[, K2/binary, $]>>, integer_to_binary(V)} | Acc];
                  (K, V, Acc) when is_atom(V) ->
                      K2 = atom_to_binary(K),
                      [{<<Key/binary, $[, K2/binary, $]>>, atom_to_binary(V)} | Acc]
              end,
              [],
              Values).
