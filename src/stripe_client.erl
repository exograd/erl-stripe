%% File generated by erl-openapi on "2022-02-25T13:17:16Z".

-module(stripe_client).

-export([get_radar_early_fraud_warnings/1, get_radar_early_fraud_warnings/2]).
-export([post_charges_charge_refunds/1, post_charges_charge_refunds/2]).
-export([get_charges_charge_refunds/1, get_charges_charge_refunds/2]).
-export([post_identity_verification_sessions_session_redact/1,
         post_identity_verification_sessions_session_redact/2]).
-export([post_billing_portal_configurations_configuration/1,
         post_billing_portal_configurations_configuration/2]).
-export([get_billing_portal_configurations_configuration/1,
         get_billing_portal_configurations_configuration/2]).
-export([post_payment_methods/1, post_payment_methods/2]).
-export([get_payment_methods/1, get_payment_methods/2]).
-export([post_radar_value_lists_value_list/1, post_radar_value_lists_value_list/2]).
-export([get_radar_value_lists_value_list/1, get_radar_value_lists_value_list/2]).
-export([delete_radar_value_lists_value_list/1, delete_radar_value_lists_value_list/2]).
-export([post_charges_charge_capture/1, post_charges_charge_capture/2]).
-export([get_disputes/1, get_disputes/2]).
-export([post_prices_price/1, post_prices_price/2]).
-export([get_prices_price/1, get_prices_price/2]).
-export([post_accounts/1, post_accounts/2]).
-export([get_accounts/1, get_accounts/2]).
-export([post_identity_verification_sessions_session_cancel/1,
         post_identity_verification_sessions_session_cancel/2]).
-export([post_account_persons_person/1, post_account_persons_person/2]).
-export([get_account_persons_person/1, get_account_persons_person/2]).
-export([delete_account_persons_person/1, delete_account_persons_person/2]).
-export([post_issuing_authorizations_authorization/1,
         post_issuing_authorizations_authorization/2]).
-export([get_issuing_authorizations_authorization/1,
         get_issuing_authorizations_authorization/2]).
-export([get_files_file/1, get_files_file/2]).
-export([post_issuing_cards_card/1, post_issuing_cards_card/2]).
-export([get_issuing_cards_card/1, get_issuing_cards_card/2]).
-export([post_sources_source_verify/1, post_sources_source_verify/2]).
-export([post_invoiceitems/1, post_invoiceitems/2]).
-export([get_invoiceitems/1, get_invoiceitems/2]).
-export([delete_ephemeral_keys_key/1, delete_ephemeral_keys_key/2]).
-export([get_exchange_rates/1, get_exchange_rates/2]).
-export([post_setup_intents_intent/1, post_setup_intents_intent/2]).
-export([get_setup_intents_intent/1, get_setup_intents_intent/2]).
-export([post_files/1, post_files/2]).
-export([get_files/1, get_files/2]).
-export([post_customers_customer_bank_accounts_id/1,
         post_customers_customer_bank_accounts_id/2]).
-export([get_customers_customer_bank_accounts_id/1,
         get_customers_customer_bank_accounts_id/2]).
-export([delete_customers_customer_bank_accounts_id/1,
         delete_customers_customer_bank_accounts_id/2]).
-export([get_issuer_fraud_records_issuer_fraud_record/1,
         get_issuer_fraud_records_issuer_fraud_record/2]).
-export([post_accounts_account_people_person/1, post_accounts_account_people_person/2]).
-export([get_accounts_account_people_person/1, get_accounts_account_people_person/2]).
-export([delete_accounts_account_people_person/1,
         delete_accounts_account_people_person/2]).
-export([post_payouts/1, post_payouts/2]).
-export([get_payouts/1, get_payouts/2]).
-export([post_account_capabilities_capability/1, post_account_capabilities_capability/2]).
-export([get_account_capabilities_capability/1, get_account_capabilities_capability/2]).
-export([get_sources_source_mandate_notifications_mandate_notification/1,
         get_sources_source_mandate_notifications_mandate_notification/2]).
-export([post_application_fees_fee_refunds_id/1, post_application_fees_fee_refunds_id/2]).
-export([get_application_fees_fee_refunds_id/1, get_application_fees_fee_refunds_id/2]).
-export([get_customers_customer_discount/1, get_customers_customer_discount/2]).
-export([delete_customers_customer_discount/1, delete_customers_customer_discount/2]).
-export([post_coupons/1, post_coupons/2]).
-export([get_coupons/1, get_coupons/2]).
-export([post_charges_charge_dispute_close/1, post_charges_charge_dispute_close/2]).
-export([post_plans_plan/1, post_plans_plan/2]).
-export([get_plans_plan/1, get_plans_plan/2]).
-export([delete_plans_plan/1, delete_plans_plan/2]).
-export([post_customers_customer_bank_accounts/1,
         post_customers_customer_bank_accounts/2]).
-export([get_customers_customer_bank_accounts/1, get_customers_customer_bank_accounts/2]).
-export([post_terminal_readers_reader/1, post_terminal_readers_reader/2]).
-export([get_terminal_readers_reader/1, get_terminal_readers_reader/2]).
-export([delete_terminal_readers_reader/1, delete_terminal_readers_reader/2]).
-export([post_accounts_account_persons_person/1, post_accounts_account_persons_person/2]).
-export([get_accounts_account_persons_person/1, get_accounts_account_persons_person/2]).
-export([delete_accounts_account_persons_person/1,
         delete_accounts_account_persons_person/2]).
-export([post_credit_notes_id_void/1, post_credit_notes_id_void/2]).
-export([post_customers_customer_sources/1, post_customers_customer_sources/2]).
-export([get_customers_customer_sources/1, get_customers_customer_sources/2]).
-export([post_account_links/1, post_account_links/2]).
-export([post_payouts_payout/1, post_payouts_payout/2]).
-export([get_payouts_payout/1, get_payouts_payout/2]).
-export([post_subscription_items_item/1, post_subscription_items_item/2]).
-export([get_subscription_items_item/1, get_subscription_items_item/2]).
-export([delete_subscription_items_item/1, delete_subscription_items_item/2]).
-export([post_products/1, post_products/2]).
-export([get_products/1, get_products/2]).
-export([get_reporting_report_types_report_type/1,
         get_reporting_report_types_report_type/2]).
-export([post_quotes_quote_accept/1, post_quotes_quote_accept/2]).
-export([get_mandates_mandate/1, get_mandates_mandate/2]).
-export([post_customers_customer_subscriptions/1,
         post_customers_customer_subscriptions/2]).
-export([get_customers_customer_subscriptions/1, get_customers_customer_subscriptions/2]).
-export([get_order_returns_id/1, get_order_returns_id/2]).
-export([post_transfers_id_reversals/1, post_transfers_id_reversals/2]).
-export([get_transfers_id_reversals/1, get_transfers_id_reversals/2]).
-export([get_reviews_review/1, get_reviews_review/2]).
-export([post_accounts_account_bank_accounts_id/1,
         post_accounts_account_bank_accounts_id/2]).
-export([get_accounts_account_bank_accounts_id/1,
         get_accounts_account_bank_accounts_id/2]).
-export([delete_accounts_account_bank_accounts_id/1,
         delete_accounts_account_bank_accounts_id/2]).
-export([post_issuing_settlements_settlement/1, post_issuing_settlements_settlement/2]).
-export([get_issuing_settlements_settlement/1, get_issuing_settlements_settlement/2]).
-export([post_promotion_codes_promotion_code/1, post_promotion_codes_promotion_code/2]).
-export([get_promotion_codes_promotion_code/1, get_promotion_codes_promotion_code/2]).
-export([post_subscription_schedules_schedule_cancel/1,
         post_subscription_schedules_schedule_cancel/2]).
-export([post_identity_verification_sessions/1, post_identity_verification_sessions/2]).
-export([get_identity_verification_sessions/1, get_identity_verification_sessions/2]).
-export([post_radar_value_list_items/1, post_radar_value_list_items/2]).
-export([get_radar_value_list_items/1, get_radar_value_list_items/2]).
-export([get_events_id/1, get_events_id/2]).
-export([get_country_specs/1, get_country_specs/2]).
-export([post_payment_intents_intent_verify_microdeposits/1,
         post_payment_intents_intent_verify_microdeposits/2]).
-export([post_subscription_items_subscription_item_usage_records/1,
         post_subscription_items_subscription_item_usage_records/2]).
-export([get_balance_history/1, get_balance_history/2]).
-export([get_order_returns/1, get_order_returns/2]).
-export([post_account_external_accounts_id/1, post_account_external_accounts_id/2]).
-export([get_account_external_accounts_id/1, get_account_external_accounts_id/2]).
-export([delete_account_external_accounts_id/1, delete_account_external_accounts_id/2]).
-export([post_apple_pay_domains/1, post_apple_pay_domains/2]).
-export([get_apple_pay_domains/1, get_apple_pay_domains/2]).
-export([post_credit_notes/1, post_credit_notes/2]).
-export([get_credit_notes/1, get_credit_notes/2]).
-export([get_sigma_scheduled_query_runs_scheduled_query_run/1,
         get_sigma_scheduled_query_runs_scheduled_query_run/2]).
-export([post_coupons_coupon/1, post_coupons_coupon/2]).
-export([get_coupons_coupon/1, get_coupons_coupon/2]).
-export([delete_coupons_coupon/1, delete_coupons_coupon/2]).
-export([get_customers_customer_tax_ids_id/1, get_customers_customer_tax_ids_id/2]).
-export([delete_customers_customer_tax_ids_id/1, delete_customers_customer_tax_ids_id/2]).
-export([get_radar_early_fraud_warnings_early_fraud_warning/1,
         get_radar_early_fraud_warnings_early_fraud_warning/2]).
-export([get_issuing_settlements/1, get_issuing_settlements/2]).
-export([post_file_links/1, post_file_links/2]).
-export([get_file_links/1, get_file_links/2]).
-export([get_identity_verification_reports_report/1,
         get_identity_verification_reports_report/2]).
-export([post_transfers/1, post_transfers/2]).
-export([get_transfers/1, get_transfers/2]).
-export([delete_subscriptions_subscription_exposed_id_discount/1,
         delete_subscriptions_subscription_exposed_id_discount/2]).
-export([post_application_fees_id_refunds/1, post_application_fees_id_refunds/2]).
-export([get_application_fees_id_refunds/1, get_application_fees_id_refunds/2]).
-export([post_accounts_account_bank_accounts/1, post_accounts_account_bank_accounts/2]).
-export([post_accounts_account/1, post_accounts_account/2]).
-export([get_accounts_account/1, get_accounts_account/2]).
-export([delete_accounts_account/1, delete_accounts_account/2]).
-export([post_subscription_schedules_schedule/1, post_subscription_schedules_schedule/2]).
-export([get_subscription_schedules_schedule/1, get_subscription_schedules_schedule/2]).
-export([post_invoices_invoice_pay/1, post_invoices_invoice_pay/2]).
-export([post_transfers_transfer_reversals_id/1, post_transfers_transfer_reversals_id/2]).
-export([get_transfers_transfer_reversals_id/1, get_transfers_transfer_reversals_id/2]).
-export([post_topups_topup/1, post_topups_topup/2]).
-export([get_topups_topup/1, get_topups_topup/2]).
-export([post_recipients_id/1, post_recipients_id/2]).
-export([get_recipients_id/1, get_recipients_id/2]).
-export([delete_recipients_id/1, delete_recipients_id/2]).
-export([get_invoices_invoice_lines/1, get_invoices_invoice_lines/2]).
-export([post_accounts_account_external_accounts_id/1,
         post_accounts_account_external_accounts_id/2]).
-export([get_accounts_account_external_accounts_id/1,
         get_accounts_account_external_accounts_id/2]).
-export([delete_accounts_account_external_accounts_id/1,
         delete_accounts_account_external_accounts_id/2]).
-export([post_topups/1, post_topups/2]).
-export([get_topups/1, get_topups/2]).
-export([post_orders_id_returns/1, post_orders_id_returns/2]).
-export([post_orders_id/1, post_orders_id/2]).
-export([get_orders_id/1, get_orders_id/2]).
-export([get_apple_pay_domains_domain/1, get_apple_pay_domains_domain/2]).
-export([delete_apple_pay_domains_domain/1, delete_apple_pay_domains_domain/2]).
-export([get_issuing_transactions/1, get_issuing_transactions/2]).
-export([post_charges_charge_refund/1, post_charges_charge_refund/2]).
-export([post_payment_methods_payment_method_attach/1,
         post_payment_methods_payment_method_attach/2]).
-export([post_payment_intents_intent_cancel/1, post_payment_intents_intent_cancel/2]).
-export([get_accounts_account_capabilities/1, get_accounts_account_capabilities/2]).
-export([get_credit_notes_preview_lines/1, get_credit_notes_preview_lines/2]).
-export([post_subscriptions/1, post_subscriptions/2]).
-export([get_subscriptions/1, get_subscriptions/2]).
-export([get_setup_attempts/1, get_setup_attempts/2]).
-export([post_customers_customer_subscriptions_subscription_exposed_id/1,
         post_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([get_customers_customer_subscriptions_subscription_exposed_id/1,
         get_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([delete_customers_customer_subscriptions_subscription_exposed_id/1,
         delete_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([get_bitcoin_receivers_id/1, get_bitcoin_receivers_id/2]).
-export([post_orders/1, post_orders/2]).
-export([get_orders/1, get_orders/2]).
-export([post_ephemeral_keys/1, post_ephemeral_keys/2]).
-export([post_webhook_endpoints_webhook_endpoint/1,
         post_webhook_endpoints_webhook_endpoint/2]).
-export([get_webhook_endpoints_webhook_endpoint/1,
         get_webhook_endpoints_webhook_endpoint/2]).
-export([delete_webhook_endpoints_webhook_endpoint/1,
         delete_webhook_endpoints_webhook_endpoint/2]).
-export([post_account_persons/1, post_account_persons/2]).
-export([get_account_persons/1, get_account_persons/2]).
-export([get_account_capabilities/1, get_account_capabilities/2]).
-export([post_checkout_sessions_session_expire/1,
         post_checkout_sessions_session_expire/2]).
-export([get_bitcoin_receivers_receiver_transactions/1,
         get_bitcoin_receivers_receiver_transactions/2]).
-export([post_quotes_quote/1, post_quotes_quote/2]).
-export([get_quotes_quote/1, get_quotes_quote/2]).
-export([post_account_people/1, post_account_people/2]).
-export([get_account_people/1, get_account_people/2]).
-export([post_setup_intents_intent_confirm/1, post_setup_intents_intent_confirm/2]).
-export([post_customers_customer_cards/1, post_customers_customer_cards/2]).
-export([get_customers_customer_cards/1, get_customers_customer_cards/2]).
-export([get_identity_verification_reports/1, get_identity_verification_reports/2]).
-export([post_accounts_account_persons/1, post_accounts_account_persons/2]).
-export([get_accounts_account_persons/1, get_accounts_account_persons/2]).
-export([post_application_fees_id_refund/1, post_application_fees_id_refund/2]).
-export([post_payment_intents/1, post_payment_intents/2]).
-export([get_payment_intents/1, get_payment_intents/2]).
-export([post_skus/1, post_skus/2]).
-export([get_skus/1, get_skus/2]).
-export([post_webhook_endpoints/1, post_webhook_endpoints/2]).
-export([get_webhook_endpoints/1, get_webhook_endpoints/2]).
-export([get_balance/1, get_balance/2]).
-export([post_customers_customer_balance_transactions_transaction/1,
         post_customers_customer_balance_transactions_transaction/2]).
-export([get_customers_customer_balance_transactions_transaction/1,
         get_customers_customer_balance_transactions_transaction/2]).
-export([post_payment_methods_payment_method/1, post_payment_methods_payment_method/2]).
-export([get_payment_methods_payment_method/1, get_payment_methods_payment_method/2]).
-export([post_topups_topup_cancel/1, post_topups_topup_cancel/2]).
-export([get_events/1, get_events/2]).
-export([post_charges_charge_refunds_refund/1, post_charges_charge_refunds_refund/2]).
-export([get_charges_charge_refunds_refund/1, get_charges_charge_refunds_refund/2]).
-export([post_accounts_account_capabilities_capability/1,
         post_accounts_account_capabilities_capability/2]).
-export([get_accounts_account_capabilities_capability/1,
         get_accounts_account_capabilities_capability/2]).
-export([post_subscription_items/1, post_subscription_items/2]).
-export([get_subscription_items/1, get_subscription_items/2]).
-export([get_quotes_quote_pdf/1, get_quotes_quote_pdf/2]).
-export([post_account_bank_accounts_id/1, post_account_bank_accounts_id/2]).
-export([get_account_bank_accounts_id/1, get_account_bank_accounts_id/2]).
-export([delete_account_bank_accounts_id/1, delete_account_bank_accounts_id/2]).
-export([get_payment_links_payment_link_line_items/1,
         get_payment_links_payment_link_line_items/2]).
-export([get_subscription_items_subscription_item_usage_record_summaries/1,
         get_subscription_items_subscription_item_usage_record_summaries/2]).
-export([post_payment_intents_intent/1, post_payment_intents_intent/2]).
-export([get_payment_intents_intent/1, get_payment_intents_intent/2]).
-export([post_charges/1, post_charges/2]).
-export([get_charges/1, get_charges/2]).
-export([post_accounts_account_external_accounts/1,
         post_accounts_account_external_accounts/2]).
-export([get_accounts_account_external_accounts/1,
         get_accounts_account_external_accounts/2]).
-export([get_issuing_authorizations/1, get_issuing_authorizations/2]).
-export([post_products_id/1, post_products_id/2]).
-export([get_products_id/1, get_products_id/2]).
-export([delete_products_id/1, delete_products_id/2]).
-export([post_setup_intents_intent_verify_microdeposits/1,
         post_setup_intents_intent_verify_microdeposits/2]).
-export([get_reporting_report_types/1, get_reporting_report_types/2]).
-export([post_account_external_accounts/1, post_account_external_accounts/2]).
-export([get_account_external_accounts/1, get_account_external_accounts/2]).
-export([post_radar_value_lists/1, post_radar_value_lists/2]).
-export([get_radar_value_lists/1, get_radar_value_lists/2]).
-export([post_shipping_rates/1, post_shipping_rates/2]).
-export([get_shipping_rates/1, get_shipping_rates/2]).
-export([post_file_links_link/1, post_file_links_link/2]).
-export([get_file_links_link/1, get_file_links_link/2]).
-export([get3d_secure_three_d_secure/1, get3d_secure_three_d_secure/2]).
-export([post_invoices_invoice_send/1, post_invoices_invoice_send/2]).
-export([get_invoices_upcoming/1, get_invoices_upcoming/2]).
-export([get_checkout_sessions_session_line_items/1,
         get_checkout_sessions_session_line_items/2]).
-export([get_tax_codes/1, get_tax_codes/2]).
-export([post_invoices/1, post_invoices/2]).
-export([get_invoices/1, get_invoices/2]).
-export([post_charges_charge/1, post_charges_charge/2]).
-export([get_charges_charge/1, get_charges_charge/2]).
-export([post_invoices_invoice_mark_uncollectible/1,
         post_invoices_invoice_mark_uncollectible/2]).
-export([post_customers_customer_sources_id_verify/1,
         post_customers_customer_sources_id_verify/2]).
-export([post_orders_id_pay/1, post_orders_id_pay/2]).
-export([post_customers_customer_bank_accounts_id_verify/1,
         post_customers_customer_bank_accounts_id_verify/2]).
-export([post_account_people_person/1, post_account_people_person/2]).
-export([get_account_people_person/1, get_account_people_person/2]).
-export([delete_account_people_person/1, delete_account_people_person/2]).
-export([post_checkout_sessions/1, post_checkout_sessions/2]).
-export([get_checkout_sessions/1, get_checkout_sessions/2]).
-export([post_accounts_account_login_links/1, post_accounts_account_login_links/2]).
-export([post_terminal_readers/1, post_terminal_readers/2]).
-export([get_terminal_readers/1, get_terminal_readers/2]).
-export([post_issuing_disputes/1, post_issuing_disputes/2]).
-export([get_issuing_disputes/1, get_issuing_disputes/2]).
-export([post3d_secure/1, post3d_secure/2]).
-export([post_prices/1, post_prices/2]).
-export([get_prices/1, get_prices/2]).
-export([post_invoices_invoice/1, post_invoices_invoice/2]).
-export([get_invoices_invoice/1, get_invoices_invoice/2]).
-export([delete_invoices_invoice/1, delete_invoices_invoice/2]).
-export([post_identity_verification_sessions_session/1,
         post_identity_verification_sessions_session/2]).
-export([get_identity_verification_sessions_session/1,
         get_identity_verification_sessions_session/2]).
-export([get_balance_transactions_id/1, get_balance_transactions_id/2]).
-export([post_setup_intents_intent_cancel/1, post_setup_intents_intent_cancel/2]).
-export([post_issuing_transactions_transaction/1,
         post_issuing_transactions_transaction/2]).
-export([get_issuing_transactions_transaction/1, get_issuing_transactions_transaction/2]).
-export([post_terminal_connection_tokens/1, post_terminal_connection_tokens/2]).
-export([get_reviews/1, get_reviews/2]).
-export([post_promotion_codes/1, post_promotion_codes/2]).
-export([get_promotion_codes/1, get_promotion_codes/2]).
-export([get_customers_customer_subscriptions_subscription_exposed_id_discount/1,
         get_customers_customer_subscriptions_subscription_exposed_id_discount/2]).
-export([delete_customers_customer_subscriptions_subscription_exposed_id_discount/1,
         delete_customers_customer_subscriptions_subscription_exposed_id_discount/2]).
-export([get_quotes_quote_computed_upfront_line_items/1,
         get_quotes_quote_computed_upfront_line_items/2]).
-export([get_radar_value_list_items_item/1, get_radar_value_list_items_item/2]).
-export([delete_radar_value_list_items_item/1, delete_radar_value_list_items_item/2]).
-export([get_issuer_fraud_records/1, get_issuer_fraud_records/2]).
-export([post_tax_rates_tax_rate/1, post_tax_rates_tax_rate/2]).
-export([get_tax_rates_tax_rate/1, get_tax_rates_tax_rate/2]).
-export([post_recipients/1, post_recipients/2]).
-export([get_recipients/1, get_recipients/2]).
-export([post_plans/1, post_plans/2]).
-export([get_plans/1, get_plans/2]).
-export([post_customers_customer_balance_transactions/1,
         post_customers_customer_balance_transactions/2]).
-export([get_customers_customer_balance_transactions/1,
         get_customers_customer_balance_transactions/2]).
-export([post_reviews_review_approve/1, post_reviews_review_approve/2]).
-export([post_customers_customer_tax_ids/1, post_customers_customer_tax_ids/2]).
-export([get_customers_customer_tax_ids/1, get_customers_customer_tax_ids/2]).
-export([get_tokens_token/1, get_tokens_token/2]).
-export([get_balance_transactions/1, get_balance_transactions/2]).
-export([get_tax_codes_id/1, get_tax_codes_id/2]).
-export([post_accounts_account_reject/1, post_accounts_account_reject/2]).
-export([post_subscriptions_subscription_exposed_id/1,
         post_subscriptions_subscription_exposed_id/2]).
-export([get_subscriptions_subscription_exposed_id/1,
         get_subscriptions_subscription_exposed_id/2]).
-export([delete_subscriptions_subscription_exposed_id/1,
         delete_subscriptions_subscription_exposed_id/2]).
-export([get_country_specs_country/1, get_country_specs_country/2]).
-export([post_invoices_invoice_finalize/1, post_invoices_invoice_finalize/2]).
-export([post_terminal_locations_location/1, post_terminal_locations_location/2]).
-export([get_terminal_locations_location/1, get_terminal_locations_location/2]).
-export([delete_terminal_locations_location/1, delete_terminal_locations_location/2]).
-export([post_account/1, post_account/2]).
-export([get_account/1, get_account/2]).
-export([delete_account/1, delete_account/2]).
-export([post_shipping_rates_shipping_rate_token/1,
         post_shipping_rates_shipping_rate_token/2]).
-export([get_shipping_rates_shipping_rate_token/1,
         get_shipping_rates_shipping_rate_token/2]).
-export([get_invoices_upcoming_lines/1, get_invoices_upcoming_lines/2]).
-export([post_issuing_cardholders/1, post_issuing_cardholders/2]).
-export([get_issuing_cardholders/1, get_issuing_cardholders/2]).
-export([post_customers_customer_sources_id/1, post_customers_customer_sources_id/2]).
-export([get_customers_customer_sources_id/1, get_customers_customer_sources_id/2]).
-export([delete_customers_customer_sources_id/1, delete_customers_customer_sources_id/2]).
-export([get_application_fees/1, get_application_fees/2]).
-export([get_bitcoin_receivers/1, get_bitcoin_receivers/2]).
-export([post_refunds_refund/1, post_refunds_refund/2]).
-export([get_refunds_refund/1, get_refunds_refund/2]).
-export([post_account_login_links/1, post_account_login_links/2]).
-export([post_tax_rates/1, post_tax_rates/2]).
-export([get_tax_rates/1, get_tax_rates/2]).
-export([post_accounts_account_people/1, post_accounts_account_people/2]).
-export([get_accounts_account_people/1, get_accounts_account_people/2]).
-export([post_issuing_disputes_dispute_submit/1, post_issuing_disputes_dispute_submit/2]).
-export([post_sources_source/1, post_sources_source/2]).
-export([get_sources_source/1, get_sources_source/2]).
-export([get_checkout_sessions_session/1, get_checkout_sessions_session/2]).
-export([post_payment_methods_payment_method_detach/1,
         post_payment_methods_payment_method_detach/2]).
-export([post_customers/1, post_customers/2]).
-export([get_customers/1, get_customers/2]).
-export([post_account_bank_accounts/1, post_account_bank_accounts/2]).
-export([post_issuing_disputes_dispute/1, post_issuing_disputes_dispute/2]).
-export([get_issuing_disputes_dispute/1, get_issuing_disputes_dispute/2]).
-export([post_disputes_dispute_close/1, post_disputes_dispute_close/2]).
-export([post_quotes_quote_cancel/1, post_quotes_quote_cancel/2]).
-export([get_customers_customer_payment_methods/1,
         get_customers_customer_payment_methods/2]).
-export([post_refunds/1, post_refunds/2]).
-export([get_refunds/1, get_refunds/2]).
-export([post_credit_notes_id/1, post_credit_notes_id/2]).
-export([get_credit_notes_id/1, get_credit_notes_id/2]).
-export([get_bitcoin_transactions/1, get_bitcoin_transactions/2]).
-export([post_setup_intents/1, post_setup_intents/2]).
-export([get_setup_intents/1, get_setup_intents/2]).
-export([post_payouts_payout_cancel/1, post_payouts_payout_cancel/2]).
-export([post_issuing_authorizations_authorization_approve/1,
         post_issuing_authorizations_authorization_approve/2]).
-export([post_issuing_authorizations_authorization_decline/1,
         post_issuing_authorizations_authorization_decline/2]).
-export([post_reporting_report_runs/1, post_reporting_report_runs/2]).
-export([get_reporting_report_runs/1, get_reporting_report_runs/2]).
-export([post_invoices_invoice_void/1, post_invoices_invoice_void/2]).
-export([post_sources/1, post_sources/2]).
-export([post_billing_portal_configurations/1, post_billing_portal_configurations/2]).
-export([get_billing_portal_configurations/1, get_billing_portal_configurations/2]).
-export([post_quotes/1, post_quotes/2]).
-export([get_quotes/1, get_quotes/2]).
-export([post_transfers_transfer/1, post_transfers_transfer/2]).
-export([get_transfers_transfer/1, get_transfers_transfer/2]).
-export([get_quotes_quote_line_items/1, get_quotes_quote_line_items/2]).
-export([post_invoiceitems_invoiceitem/1, post_invoiceitems_invoiceitem/2]).
-export([get_invoiceitems_invoiceitem/1, get_invoiceitems_invoiceitem/2]).
-export([delete_invoiceitems_invoiceitem/1, delete_invoiceitems_invoiceitem/2]).
-export([post_payment_intents_intent_capture/1, post_payment_intents_intent_capture/2]).
-export([post_issuing_cards/1, post_issuing_cards/2]).
-export([get_issuing_cards/1, get_issuing_cards/2]).
-export([get_sources_source_source_transactions/1,
         get_sources_source_source_transactions/2]).
-export([post_subscription_schedules_schedule_release/1,
         post_subscription_schedules_schedule_release/2]).
-export([post_customers_customer_cards_id/1, post_customers_customer_cards_id/2]).
-export([get_customers_customer_cards_id/1, get_customers_customer_cards_id/2]).
-export([delete_customers_customer_cards_id/1, delete_customers_customer_cards_id/2]).
-export([post_charges_charge_dispute/1, post_charges_charge_dispute/2]).
-export([get_charges_charge_dispute/1, get_charges_charge_dispute/2]).
-export([post_quotes_quote_finalize/1, post_quotes_quote_finalize/2]).
-export([post_skus_id/1, post_skus_id/2]).
-export([get_skus_id/1, get_skus_id/2]).
-export([delete_skus_id/1, delete_skus_id/2]).
-export([post_disputes_dispute/1, post_disputes_dispute/2]).
-export([get_disputes_dispute/1, get_disputes_dispute/2]).
-export([post_terminal_locations/1, post_terminal_locations/2]).
-export([get_terminal_locations/1, get_terminal_locations/2]).
-export([post_subscription_schedules/1, post_subscription_schedules/2]).
-export([get_subscription_schedules/1, get_subscription_schedules/2]).
-export([post_payment_links/1, post_payment_links/2]).
-export([get_payment_links/1, get_payment_links/2]).
-export([post_tokens/1, post_tokens/2]).
-export([post_issuing_cardholders_cardholder/1, post_issuing_cardholders_cardholder/2]).
-export([get_issuing_cardholders_cardholder/1, get_issuing_cardholders_cardholder/2]).
-export([get_application_fees_id/1, get_application_fees_id/2]).
-export([get_exchange_rates_rate_id/1, get_exchange_rates_rate_id/2]).
-export([post_payment_intents_intent_confirm/1, post_payment_intents_intent_confirm/2]).
-export([get_credit_notes_preview/1, get_credit_notes_preview/2]).
-export([get_balance_history_id/1, get_balance_history_id/2]).
-export([post_payouts_payout_reverse/1, post_payouts_payout_reverse/2]).
-export([get_reporting_report_runs_report_run/1, get_reporting_report_runs_report_run/2]).
-export([get_sources_source_source_transactions_source_transaction/1,
         get_sources_source_source_transactions_source_transaction/2]).
-export([post_customers_customer/1, post_customers_customer/2]).
-export([get_customers_customer/1, get_customers_customer/2]).
-export([delete_customers_customer/1, delete_customers_customer/2]).
-export([post_billing_portal_sessions/1, post_billing_portal_sessions/2]).
-export([post_payment_links_payment_link/1, post_payment_links_payment_link/2]).
-export([get_payment_links_payment_link/1, get_payment_links_payment_link/2]).
-export([get_credit_notes_credit_note_lines/1, get_credit_notes_credit_note_lines/2]).
-export([get_sigma_scheduled_query_runs/1, get_sigma_scheduled_query_runs/2]).

-spec get_radar_early_fraud_warnings(map()) -> term().
get_radar_early_fraud_warnings(Args) ->
    get_radar_early_fraud_warnings(Args, #{}).

-spec get_radar_early_fraud_warnings(map(), mhttp:request_options()) -> term().
get_radar_early_fraud_warnings(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refunds(map()) -> term().
post_charges_charge_refunds(Args) ->
    post_charges_charge_refunds(Args, #{}).

-spec post_charges_charge_refunds(map(), mhttp:request_options()) -> term().
post_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refunds", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_refunds(map()) -> term().
get_charges_charge_refunds(Args) ->
    get_charges_charge_refunds(Args, #{}).

-spec get_charges_charge_refunds(map(), mhttp:request_options()) -> term().
get_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refunds", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_identity_verification_sessions_session_redact(map()) -> term().
post_identity_verification_sessions_session_redact(Args) ->
    post_identity_verification_sessions_session_redact(Args, #{}).

-spec post_identity_verification_sessions_session_redact(map(),
                                                         mhttp:request_options()) ->
                                                            term().
post_identity_verification_sessions_session_redact(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s/redact", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_configurations_configuration(map()) -> term().
post_billing_portal_configurations_configuration(Args) ->
    post_billing_portal_configurations_configuration(Args, #{}).

-spec post_billing_portal_configurations_configuration(map(), mhttp:request_options()) ->
                                                          term().
post_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations/~s", [VarConfiguration]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_billing_portal_configurations_configuration(map()) -> term().
get_billing_portal_configurations_configuration(Args) ->
    get_billing_portal_configurations_configuration(Args, #{}).

-spec get_billing_portal_configurations_configuration(map(), mhttp:request_options()) ->
                                                         term().
get_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations/~s", [VarConfiguration]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods(map()) -> term().
post_payment_methods(Args) ->
    post_payment_methods(Args, #{}).

-spec post_payment_methods(map(), mhttp:request_options()) -> term().
post_payment_methods(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_methods(map()) -> term().
get_payment_methods(Args) ->
    get_payment_methods(Args, #{}).

-spec get_payment_methods(map(), mhttp:request_options()) -> term().
get_payment_methods(Args, Options) ->
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, limit, starting_after, type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_lists_value_list(map()) -> term().
post_radar_value_lists_value_list(Args) ->
    post_radar_value_lists_value_list(Args, #{}).

-spec post_radar_value_lists_value_list(map(), mhttp:request_options()) -> term().
post_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_lists_value_list(map()) -> term().
get_radar_value_lists_value_list(Args) ->
    get_radar_value_lists_value_list(Args, #{}).

-spec get_radar_value_lists_value_list(map(), mhttp:request_options()) -> term().
get_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_radar_value_lists_value_list(map()) -> term().
delete_radar_value_lists_value_list(Args) ->
    delete_radar_value_lists_value_list(Args, #{}).

-spec delete_radar_value_lists_value_list(map(), mhttp:request_options()) -> term().
delete_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_capture(map()) -> term().
post_charges_charge_capture(Args) ->
    post_charges_charge_capture(Args, #{}).

-spec post_charges_charge_capture(map(), mhttp:request_options()) -> term().
post_charges_charge_capture(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/capture", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_disputes(map()) -> term().
get_disputes(Args) ->
    get_disputes(Args, #{}).

-spec get_disputes(map(), mhttp:request_options()) -> term().
get_disputes(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_prices_price(map()) -> term().
post_prices_price(Args) ->
    post_prices_price(Args, #{}).

-spec post_prices_price(map(), mhttp:request_options()) -> term().
post_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/prices/~s", [VarPrice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_prices_price(map()) -> term().
get_prices_price(Args) ->
    get_prices_price(Args, #{}).

-spec get_prices_price(map(), mhttp:request_options()) -> term().
get_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/prices/~s", [VarPrice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts(map()) -> term().
post_accounts(Args) ->
    post_accounts(Args, #{}).

-spec post_accounts(map(), mhttp:request_options()) -> term().
post_accounts(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts(map()) -> term().
get_accounts(Args) ->
    get_accounts(Args, #{}).

-spec get_accounts(map(), mhttp:request_options()) -> term().
get_accounts(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_identity_verification_sessions_session_cancel(map()) -> term().
post_identity_verification_sessions_session_cancel(Args) ->
    post_identity_verification_sessions_session_cancel(Args, #{}).

-spec post_identity_verification_sessions_session_cancel(map(),
                                                         mhttp:request_options()) ->
                                                            term().
post_identity_verification_sessions_session_cancel(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s/cancel", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_persons_person(map()) -> term().
post_account_persons_person(Args) ->
    post_account_persons_person(Args, #{}).

-spec post_account_persons_person(map(), mhttp:request_options()) -> term().
post_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_persons_person(map()) -> term().
get_account_persons_person(Args) ->
    get_account_persons_person(Args, #{}).

-spec get_account_persons_person(map(), mhttp:request_options()) -> term().
get_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_persons_person(map()) -> term().
delete_account_persons_person(Args) ->
    delete_account_persons_person(Args, #{}).

-spec delete_account_persons_person(map(), mhttp:request_options()) -> term().
delete_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_authorizations_authorization(map()) -> term().
post_issuing_authorizations_authorization(Args) ->
    post_issuing_authorizations_authorization(Args, #{}).

-spec post_issuing_authorizations_authorization(map(), mhttp:request_options()) -> term().
post_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s", [VarAuthorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_authorizations_authorization(map()) -> term().
get_issuing_authorizations_authorization(Args) ->
    get_issuing_authorizations_authorization(Args, #{}).

-spec get_issuing_authorizations_authorization(map(), mhttp:request_options()) -> term().
get_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s", [VarAuthorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_files_file(map()) -> term().
get_files_file(Args) ->
    get_files_file(Args, #{}).

-spec get_files_file(map(), mhttp:request_options()) -> term().
get_files_file(Args, Options) ->
    VarFile = maps:get(file, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/files/~s", [VarFile]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cards_card(map()) -> term().
post_issuing_cards_card(Args) ->
    post_issuing_cards_card(Args, #{}).

-spec post_issuing_cards_card(map(), mhttp:request_options()) -> term().
post_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards/~s", [VarCard]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cards_card(map()) -> term().
get_issuing_cards_card(Args) ->
    get_issuing_cards_card(Args, #{}).

-spec get_issuing_cards_card(map(), mhttp:request_options()) -> term().
get_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards/~s", [VarCard]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources_source_verify(map()) -> term().
post_sources_source_verify(Args) ->
    post_sources_source_verify(Args, #{}).

-spec post_sources_source_verify(map(), mhttp:request_options()) -> term().
post_sources_source_verify(Args, Options) ->
    VarSource = maps:get(source, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/~s/verify", [VarSource]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoiceitems(map()) -> term().
post_invoiceitems(Args) ->
    post_invoiceitems(Args, #{}).

-spec post_invoiceitems(map(), mhttp:request_options()) -> term().
post_invoiceitems(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoiceitems(map()) -> term().
get_invoiceitems(Args) ->
    get_invoiceitems(Args, #{}).

-spec get_invoiceitems(map(), mhttp:request_options()) -> term().
get_invoiceitems(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice, _Value}) ->
                {<<"invoice">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({pending, _Value}) ->
                {<<"pending">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 customer,
                                 ending_before,
                                 expand,
                                 invoice,
                                 limit,
                                 pending,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_ephemeral_keys_key(map()) -> term().
delete_ephemeral_keys_key(Args) ->
    delete_ephemeral_keys_key(Args, #{}).

-spec delete_ephemeral_keys_key(map(), mhttp:request_options()) -> term().
delete_ephemeral_keys_key(Args, Options) ->
    VarKey = maps:get(key, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/ephemeral_keys/~s", [VarKey]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_exchange_rates(map()) -> term().
get_exchange_rates(Args) ->
    get_exchange_rates(Args, #{}).

-spec get_exchange_rates(map(), mhttp:request_options()) -> term().
get_exchange_rates(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/exchange_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent(map()) -> term().
post_setup_intents_intent(Args) ->
    post_setup_intents_intent(Args, #{}).

-spec post_setup_intents_intent(map(), mhttp:request_options()) -> term().
post_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_intents_intent(map()) -> term().
get_setup_intents_intent(Args) ->
    get_setup_intents_intent(Args, #{}).

-spec get_setup_intents_intent(map(), mhttp:request_options()) -> term().
get_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    EncodeQuery =
        fun ({client_secret, _Value}) ->
                {<<"client_secret">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([client_secret, expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_files(map()) -> term().
post_files(Args) ->
    post_files(Args, #{}).

-spec post_files(map(), mhttp:request_options()) -> term().
post_files(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/files", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_files(map()) -> term().
get_files(Args) ->
    get_files(Args, #{}).

-spec get_files(map(), mhttp:request_options()) -> term().
get_files(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({purpose, _Value}) ->
                {<<"purpose">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, purpose, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/files", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_bank_accounts_id(map()) -> term().
post_customers_customer_bank_accounts_id(Args) ->
    post_customers_customer_bank_accounts_id(Args, #{}).

-spec post_customers_customer_bank_accounts_id(map(), mhttp:request_options()) -> term().
post_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_bank_accounts_id(map()) -> term().
get_customers_customer_bank_accounts_id(Args) ->
    get_customers_customer_bank_accounts_id(Args, #{}).

-spec get_customers_customer_bank_accounts_id(map(), mhttp:request_options()) -> term().
get_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_bank_accounts_id(map()) -> term().
delete_customers_customer_bank_accounts_id(Args) ->
    delete_customers_customer_bank_accounts_id(Args, #{}).

-spec delete_customers_customer_bank_accounts_id(map(), mhttp:request_options()) ->
                                                    term().
delete_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuer_fraud_records_issuer_fraud_record(map()) -> term().
get_issuer_fraud_records_issuer_fraud_record(Args) ->
    get_issuer_fraud_records_issuer_fraud_record(Args, #{}).

-spec get_issuer_fraud_records_issuer_fraud_record(map(), mhttp:request_options()) ->
                                                      term().
get_issuer_fraud_records_issuer_fraud_record(Args, Options) ->
    VarIssuerFraudRecord = maps:get(issuer_fraud_record, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuer_fraud_records/~s", [VarIssuerFraudRecord]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_people_person(map()) -> term().
post_accounts_account_people_person(Args) ->
    post_accounts_account_people_person(Args, #{}).

-spec post_accounts_account_people_person(map(), mhttp:request_options()) -> term().
post_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_people_person(map()) -> term().
get_accounts_account_people_person(Args) ->
    get_accounts_account_people_person(Args, #{}).

-spec get_accounts_account_people_person(map(), mhttp:request_options()) -> term().
get_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account_people_person(map()) -> term().
delete_accounts_account_people_person(Args) ->
    delete_accounts_account_people_person(Args, #{}).

-spec delete_accounts_account_people_person(map(), mhttp:request_options()) -> term().
delete_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts(map()) -> term().
post_payouts(Args) ->
    post_payouts(Args, #{}).

-spec post_payouts(map(), mhttp:request_options()) -> term().
post_payouts(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payouts(map()) -> term().
get_payouts(Args) ->
    get_payouts(Args, #{}).

-spec get_payouts(map(), mhttp:request_options()) -> term().
get_payouts(Args, Options) ->
    EncodeQuery =
        fun ({arrival_date, _Value}) ->
                {<<"arrival_date">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({destination, _Value}) ->
                {<<"destination">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([arrival_date,
                                 created,
                                 destination,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_capabilities_capability(map()) -> term().
post_account_capabilities_capability(Args) ->
    post_account_capabilities_capability(Args, #{}).

-spec post_account_capabilities_capability(map(), mhttp:request_options()) -> term().
post_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/capabilities/~s", [VarCapability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_capabilities_capability(map()) -> term().
get_account_capabilities_capability(Args) ->
    get_account_capabilities_capability(Args, #{}).

-spec get_account_capabilities_capability(map(), mhttp:request_options()) -> term().
get_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/capabilities/~s", [VarCapability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source_mandate_notifications_mandate_notification(map()) -> term().
get_sources_source_mandate_notifications_mandate_notification(Args) ->
    get_sources_source_mandate_notifications_mandate_notification(Args, #{}).

-spec get_sources_source_mandate_notifications_mandate_notification(map(),
                                                                    mhttp:request_options()) ->
                                                                       term().
get_sources_source_mandate_notifications_mandate_notification(Args, Options) ->
    VarMandateNotification = maps:get(mandate_notification, Args),
    VarSource = maps:get(source, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/sources/~s/mandate_notifications/~s",
                      [VarSource, VarMandateNotification]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_fee_refunds_id(map()) -> term().
post_application_fees_fee_refunds_id(Args) ->
    post_application_fees_fee_refunds_id(Args, #{}).

-spec post_application_fees_fee_refunds_id(map(), mhttp:request_options()) -> term().
post_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds/~s", [VarFee, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_fee_refunds_id(map()) -> term().
get_application_fees_fee_refunds_id(Args) ->
    get_application_fees_fee_refunds_id(Args, #{}).

-spec get_application_fees_fee_refunds_id(map(), mhttp:request_options()) -> term().
get_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds/~s", [VarFee, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_discount(map()) -> term().
get_customers_customer_discount(Args) ->
    get_customers_customer_discount(Args, #{}).

-spec get_customers_customer_discount(map(), mhttp:request_options()) -> term().
get_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/discount", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_discount(map()) -> term().
delete_customers_customer_discount(Args) ->
    delete_customers_customer_discount(Args, #{}).

-spec delete_customers_customer_discount(map(), mhttp:request_options()) -> term().
delete_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/discount", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_coupons(map()) -> term().
post_coupons(Args) ->
    post_coupons(Args, #{}).

-spec post_coupons(map(), mhttp:request_options()) -> term().
post_coupons(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_coupons(map()) -> term().
get_coupons(Args) ->
    get_coupons(Args, #{}).

-spec get_coupons(map(), mhttp:request_options()) -> term().
get_coupons(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_dispute_close(map()) -> term().
post_charges_charge_dispute_close(Args) ->
    post_charges_charge_dispute_close(Args, #{}).

-spec post_charges_charge_dispute_close(map(), mhttp:request_options()) -> term().
post_charges_charge_dispute_close(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/dispute/close", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_plans_plan(map()) -> term().
post_plans_plan(Args) ->
    post_plans_plan(Args, #{}).

-spec post_plans_plan(map(), mhttp:request_options()) -> term().
post_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_plans_plan(map()) -> term().
get_plans_plan(Args) ->
    get_plans_plan(Args, #{}).

-spec get_plans_plan(map(), mhttp:request_options()) -> term().
get_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_plans_plan(map()) -> term().
delete_plans_plan(Args) ->
    delete_plans_plan(Args, #{}).

-spec delete_plans_plan(map(), mhttp:request_options()) -> term().
delete_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_bank_accounts(map()) -> term().
post_customers_customer_bank_accounts(Args) ->
    post_customers_customer_bank_accounts(Args, #{}).

-spec post_customers_customer_bank_accounts(map(), mhttp:request_options()) -> term().
post_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_bank_accounts(map()) -> term().
get_customers_customer_bank_accounts(Args) ->
    get_customers_customer_bank_accounts(Args, #{}).

-spec get_customers_customer_bank_accounts(map(), mhttp:request_options()) -> term().
get_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_readers_reader(map()) -> term().
post_terminal_readers_reader(Args) ->
    post_terminal_readers_reader(Args, #{}).

-spec post_terminal_readers_reader(map(), mhttp:request_options()) -> term().
post_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_readers_reader(map()) -> term().
get_terminal_readers_reader(Args) ->
    get_terminal_readers_reader(Args, #{}).

-spec get_terminal_readers_reader(map(), mhttp:request_options()) -> term().
get_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_terminal_readers_reader(map()) -> term().
delete_terminal_readers_reader(Args) ->
    delete_terminal_readers_reader(Args, #{}).

-spec delete_terminal_readers_reader(map(), mhttp:request_options()) -> term().
delete_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_persons_person(map()) -> term().
post_accounts_account_persons_person(Args) ->
    post_accounts_account_persons_person(Args, #{}).

-spec post_accounts_account_persons_person(map(), mhttp:request_options()) -> term().
post_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_persons_person(map()) -> term().
get_accounts_account_persons_person(Args) ->
    get_accounts_account_persons_person(Args, #{}).

-spec get_accounts_account_persons_person(map(), mhttp:request_options()) -> term().
get_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account_persons_person(map()) -> term().
delete_accounts_account_persons_person(Args) ->
    delete_accounts_account_persons_person(Args, #{}).

-spec delete_accounts_account_persons_person(map(), mhttp:request_options()) -> term().
delete_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes_id_void(map()) -> term().
post_credit_notes_id_void(Args) ->
    post_credit_notes_id_void(Args, #{}).

-spec post_credit_notes_id_void(map(), mhttp:request_options()) -> term().
post_credit_notes_id_void(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/~s/void", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources(map()) -> term().
post_customers_customer_sources(Args) ->
    post_customers_customer_sources(Args, #{}).

-spec post_customers_customer_sources(map(), mhttp:request_options()) -> term().
post_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_sources(map()) -> term().
get_customers_customer_sources(Args) ->
    get_customers_customer_sources(Args, #{}).

-spec get_customers_customer_sources(map(), mhttp:request_options()) -> term().
get_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({object, _Value}) ->
                {<<"object">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, object, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_links(map()) -> term().
post_account_links(Args) ->
    post_account_links(Args, #{}).

-spec post_account_links(map(), mhttp:request_options()) -> term().
post_account_links(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout(map()) -> term().
post_payouts_payout(Args) ->
    post_payouts_payout(Args, #{}).

-spec post_payouts_payout(map(), mhttp:request_options()) -> term().
post_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/~s", [VarPayout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payouts_payout(map()) -> term().
get_payouts_payout(Args) ->
    get_payouts_payout(Args, #{}).

-spec get_payouts_payout(map(), mhttp:request_options()) -> term().
get_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/~s", [VarPayout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items_item(map()) -> term().
post_subscription_items_item(Args) ->
    post_subscription_items_item(Args, #{}).

-spec post_subscription_items_item(map(), mhttp:request_options()) -> term().
post_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items_item(map()) -> term().
get_subscription_items_item(Args) ->
    get_subscription_items_item(Args, #{}).

-spec get_subscription_items_item(map(), mhttp:request_options()) -> term().
get_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_subscription_items_item(map()) -> term().
delete_subscription_items_item(Args) ->
    delete_subscription_items_item(Args, #{}).

-spec delete_subscription_items_item(map(), mhttp:request_options()) -> term().
delete_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_products(map()) -> term().
post_products(Args) ->
    post_products(Args, #{}).

-spec post_products(map(), mhttp:request_options()) -> term().
post_products(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_products(map()) -> term().
get_products(Args) ->
    get_products(Args, #{}).

-spec get_products(map(), mhttp:request_options()) -> term().
get_products(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({ids, _Value}) ->
                {<<"ids">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({shippable, _Value}) ->
                {<<"shippable">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({url, _Value}) ->
                {<<"url">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 ending_before,
                                 expand,
                                 ids,
                                 limit,
                                 shippable,
                                 starting_after,
                                 url],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_types_report_type(map()) -> term().
get_reporting_report_types_report_type(Args) ->
    get_reporting_report_types_report_type(Args, #{}).

-spec get_reporting_report_types_report_type(map(), mhttp:request_options()) -> term().
get_reporting_report_types_report_type(Args, Options) ->
    VarReportType = maps:get(report_type, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_types/~s", [VarReportType]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_accept(map()) -> term().
post_quotes_quote_accept(Args) ->
    post_quotes_quote_accept(Args, #{}).

-spec post_quotes_quote_accept(map(), mhttp:request_options()) -> term().
post_quotes_quote_accept(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/accept", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_mandates_mandate(map()) -> term().
get_mandates_mandate(Args) ->
    get_mandates_mandate(Args, #{}).

-spec get_mandates_mandate(map(), mhttp:request_options()) -> term().
get_mandates_mandate(Args, Options) ->
    VarMandate = maps:get(mandate, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/mandates/~s", [VarMandate]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_subscriptions(map()) -> term().
post_customers_customer_subscriptions(Args) ->
    post_customers_customer_subscriptions(Args, #{}).

-spec post_customers_customer_subscriptions(map(), mhttp:request_options()) -> term().
post_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/subscriptions", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_subscriptions(map()) -> term().
get_customers_customer_subscriptions(Args) ->
    get_customers_customer_subscriptions(Args, #{}).

-spec get_customers_customer_subscriptions(map(), mhttp:request_options()) -> term().
get_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/subscriptions", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_order_returns_id(map()) -> term().
get_order_returns_id(Args) ->
    get_order_returns_id(Args, #{}).

-spec get_order_returns_id(map(), mhttp:request_options()) -> term().
get_order_returns_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/order_returns/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_id_reversals(map()) -> term().
post_transfers_id_reversals(Args) ->
    post_transfers_id_reversals(Args, #{}).

-spec post_transfers_id_reversals(map(), mhttp:request_options()) -> term().
post_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s/reversals", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_id_reversals(map()) -> term().
get_transfers_id_reversals(Args) ->
    get_transfers_id_reversals(Args, #{}).

-spec get_transfers_id_reversals(map(), mhttp:request_options()) -> term().
get_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s/reversals", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reviews_review(map()) -> term().
get_reviews_review(Args) ->
    get_reviews_review(Args, #{}).

-spec get_reviews_review(map(), mhttp:request_options()) -> term().
get_reviews_review(Args, Options) ->
    VarReview = maps:get(review, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reviews/~s", [VarReview]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_bank_accounts_id(map()) -> term().
post_accounts_account_bank_accounts_id(Args) ->
    post_accounts_account_bank_accounts_id(Args, #{}).

-spec post_accounts_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
post_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_bank_accounts_id(map()) -> term().
get_accounts_account_bank_accounts_id(Args) ->
    get_accounts_account_bank_accounts_id(Args, #{}).

-spec get_accounts_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
get_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account_bank_accounts_id(map()) -> term().
delete_accounts_account_bank_accounts_id(Args) ->
    delete_accounts_account_bank_accounts_id(Args, #{}).

-spec delete_accounts_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
delete_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_settlements_settlement(map()) -> term().
post_issuing_settlements_settlement(Args) ->
    post_issuing_settlements_settlement(Args, #{}).

-spec post_issuing_settlements_settlement(map(), mhttp:request_options()) -> term().
post_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/settlements/~s", [VarSettlement]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_settlements_settlement(map()) -> term().
get_issuing_settlements_settlement(Args) ->
    get_issuing_settlements_settlement(Args, #{}).

-spec get_issuing_settlements_settlement(map(), mhttp:request_options()) -> term().
get_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/settlements/~s", [VarSettlement]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_promotion_codes_promotion_code(map()) -> term().
post_promotion_codes_promotion_code(Args) ->
    post_promotion_codes_promotion_code(Args, #{}).

-spec post_promotion_codes_promotion_code(map(), mhttp:request_options()) -> term().
post_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes/~s", [VarPromotionCode]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_promotion_codes_promotion_code(map()) -> term().
get_promotion_codes_promotion_code(Args) ->
    get_promotion_codes_promotion_code(Args, #{}).

-spec get_promotion_codes_promotion_code(map(), mhttp:request_options()) -> term().
get_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes/~s", [VarPromotionCode]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules_schedule_cancel(map()) -> term().
post_subscription_schedules_schedule_cancel(Args) ->
    post_subscription_schedules_schedule_cancel(Args, #{}).

-spec post_subscription_schedules_schedule_cancel(map(), mhttp:request_options()) ->
                                                     term().
post_subscription_schedules_schedule_cancel(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/~s/cancel", [VarSchedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_identity_verification_sessions(map()) -> term().
post_identity_verification_sessions(Args) ->
    post_identity_verification_sessions(Args, #{}).

-spec post_identity_verification_sessions(map(), mhttp:request_options()) -> term().
post_identity_verification_sessions(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_sessions(map()) -> term().
get_identity_verification_sessions(Args) ->
    get_identity_verification_sessions(Args, #{}).

-spec get_identity_verification_sessions(map(), mhttp:request_options()) -> term().
get_identity_verification_sessions(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after, status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_list_items(map()) -> term().
post_radar_value_list_items(Args) ->
    post_radar_value_list_items(Args, #{}).

-spec post_radar_value_list_items(map(), mhttp:request_options()) -> term().
post_radar_value_list_items(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_list_items(map()) -> term().
get_radar_value_list_items(Args) ->
    get_radar_value_list_items(Args, #{}).

-spec get_radar_value_list_items(map(), mhttp:request_options()) -> term().
get_radar_value_list_items(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({value, _Value}) ->
                {<<"value">>, <<>>};
            ({value_list, _Value}) ->
                {<<"value_list">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 value,
                                 value_list],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_events_id(map()) -> term().
get_events_id(Args) ->
    get_events_id(Args, #{}).

-spec get_events_id(map(), mhttp:request_options()) -> term().
get_events_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/events/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_country_specs(map()) -> term().
get_country_specs(Args) ->
    get_country_specs(Args, #{}).

-spec get_country_specs(map(), mhttp:request_options()) -> term().
get_country_specs(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/country_specs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_verify_microdeposits(map()) -> term().
post_payment_intents_intent_verify_microdeposits(Args) ->
    post_payment_intents_intent_verify_microdeposits(Args, #{}).

-spec post_payment_intents_intent_verify_microdeposits(map(), mhttp:request_options()) ->
                                                          term().
post_payment_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s/verify_microdeposits", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items_subscription_item_usage_records(map()) -> term().
post_subscription_items_subscription_item_usage_records(Args) ->
    post_subscription_items_subscription_item_usage_records(Args, #{}).

-spec post_subscription_items_subscription_item_usage_records(map(),
                                                              mhttp:request_options()) ->
                                                                 term().
post_subscription_items_subscription_item_usage_records(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/~s/usage_records", [VarSubscriptionItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_history(map()) -> term().
get_balance_history(Args) ->
    get_balance_history(Args, #{}).

-spec get_balance_history(map(), mhttp:request_options()) -> term().
get_balance_history(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({currency, _Value}) ->
                {<<"currency">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payout, _Value}) ->
                {<<"payout">>, <<>>};
            ({source, _Value}) ->
                {<<"source">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 currency,
                                 ending_before,
                                 expand,
                                 limit,
                                 payout,
                                 source,
                                 starting_after,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance/history", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_order_returns(map()) -> term().
get_order_returns(Args) ->
    get_order_returns(Args, #{}).

-spec get_order_returns(map(), mhttp:request_options()) -> term().
get_order_returns(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({order, _Value}) ->
                {<<"order">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, order, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/order_returns", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_external_accounts_id(map()) -> term().
post_account_external_accounts_id(Args) ->
    post_account_external_accounts_id(Args, #{}).

-spec post_account_external_accounts_id(map(), mhttp:request_options()) -> term().
post_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_external_accounts_id(map()) -> term().
get_account_external_accounts_id(Args) ->
    get_account_external_accounts_id(Args, #{}).

-spec get_account_external_accounts_id(map(), mhttp:request_options()) -> term().
get_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_external_accounts_id(map()) -> term().
delete_account_external_accounts_id(Args) ->
    delete_account_external_accounts_id(Args, #{}).

-spec delete_account_external_accounts_id(map(), mhttp:request_options()) -> term().
delete_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_apple_pay_domains(map()) -> term().
post_apple_pay_domains(Args) ->
    post_apple_pay_domains(Args, #{}).

-spec post_apple_pay_domains(map(), mhttp:request_options()) -> term().
post_apple_pay_domains(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_apple_pay_domains(map()) -> term().
get_apple_pay_domains(Args) ->
    get_apple_pay_domains(Args, #{}).

-spec get_apple_pay_domains(map(), mhttp:request_options()) -> term().
get_apple_pay_domains(Args, Options) ->
    EncodeQuery =
        fun ({domain_name, _Value}) ->
                {<<"domain_name">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([domain_name, ending_before, expand, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes(map()) -> term().
post_credit_notes(Args) ->
    post_credit_notes(Args, #{}).

-spec post_credit_notes(map(), mhttp:request_options()) -> term().
post_credit_notes(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes(map()) -> term().
get_credit_notes(Args) ->
    get_credit_notes(Args, #{}).

-spec get_credit_notes(map(), mhttp:request_options()) -> term().
get_credit_notes(Args, Options) ->
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice, _Value}) ->
                {<<"invoice">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, invoice, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sigma_scheduled_query_runs_scheduled_query_run(map()) -> term().
get_sigma_scheduled_query_runs_scheduled_query_run(Args) ->
    get_sigma_scheduled_query_runs_scheduled_query_run(Args, #{}).

-spec get_sigma_scheduled_query_runs_scheduled_query_run(map(),
                                                         mhttp:request_options()) ->
                                                            term().
get_sigma_scheduled_query_runs_scheduled_query_run(Args, Options) ->
    VarScheduledQueryRun = maps:get(scheduled_query_run, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs/~s", [VarScheduledQueryRun]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_coupons_coupon(map()) -> term().
post_coupons_coupon(Args) ->
    post_coupons_coupon(Args, #{}).

-spec post_coupons_coupon(map(), mhttp:request_options()) -> term().
post_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_coupons_coupon(map()) -> term().
get_coupons_coupon(Args) ->
    get_coupons_coupon(Args, #{}).

-spec get_coupons_coupon(map(), mhttp:request_options()) -> term().
get_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_coupons_coupon(map()) -> term().
delete_coupons_coupon(Args) ->
    delete_coupons_coupon(Args, #{}).

-spec delete_coupons_coupon(map(), mhttp:request_options()) -> term().
delete_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_tax_ids_id(map()) -> term().
get_customers_customer_tax_ids_id(Args) ->
    get_customers_customer_tax_ids_id(Args, #{}).

-spec get_customers_customer_tax_ids_id(map(), mhttp:request_options()) -> term().
get_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_tax_ids_id(map()) -> term().
delete_customers_customer_tax_ids_id(Args) ->
    delete_customers_customer_tax_ids_id(Args, #{}).

-spec delete_customers_customer_tax_ids_id(map(), mhttp:request_options()) -> term().
delete_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_early_fraud_warnings_early_fraud_warning(map()) -> term().
get_radar_early_fraud_warnings_early_fraud_warning(Args) ->
    get_radar_early_fraud_warnings_early_fraud_warning(Args, #{}).

-spec get_radar_early_fraud_warnings_early_fraud_warning(map(),
                                                         mhttp:request_options()) ->
                                                            term().
get_radar_early_fraud_warnings_early_fraud_warning(Args, Options) ->
    VarEarlyFraudWarning = maps:get(early_fraud_warning, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings/~s", [VarEarlyFraudWarning]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_settlements(map()) -> term().
get_issuing_settlements(Args) ->
    get_issuing_settlements(Args, #{}).

-spec get_issuing_settlements(map(), mhttp:request_options()) -> term().
get_issuing_settlements(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/settlements", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_file_links(map()) -> term().
post_file_links(Args) ->
    post_file_links(Args, #{}).

-spec post_file_links(map(), mhttp:request_options()) -> term().
post_file_links(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_file_links(map()) -> term().
get_file_links(Args) ->
    get_file_links(Args, #{}).

-spec get_file_links(map(), mhttp:request_options()) -> term().
get_file_links(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({expired, _Value}) ->
                {<<"expired">>, <<>>};
            ({file, _Value}) ->
                {<<"file">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 expired,
                                 file,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_reports_report(map()) -> term().
get_identity_verification_reports_report(Args) ->
    get_identity_verification_reports_report(Args, #{}).

-spec get_identity_verification_reports_report(map(), mhttp:request_options()) -> term().
get_identity_verification_reports_report(Args, Options) ->
    VarReport = maps:get(report, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_reports/~s", [VarReport]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers(map()) -> term().
post_transfers(Args) ->
    post_transfers(Args, #{}).

-spec post_transfers(map(), mhttp:request_options()) -> term().
post_transfers(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers(map()) -> term().
get_transfers(Args) ->
    get_transfers(Args, #{}).

-spec get_transfers(map(), mhttp:request_options()) -> term().
get_transfers(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({destination, _Value}) ->
                {<<"destination">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({transfer_group, _Value}) ->
                {<<"transfer_group">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 destination,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 transfer_group],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_subscriptions_subscription_exposed_id_discount(map()) -> term().
delete_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec delete_subscriptions_subscription_exposed_id_discount(map(),
                                                            mhttp:request_options()) ->
                                                               term().
delete_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/~s/discount", [VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_id_refunds(map()) -> term().
post_application_fees_id_refunds(Args) ->
    post_application_fees_id_refunds(Args, #{}).

-spec post_application_fees_id_refunds(map(), mhttp:request_options()) -> term().
post_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_id_refunds(map()) -> term().
get_application_fees_id_refunds(Args) ->
    get_application_fees_id_refunds(Args, #{}).

-spec get_application_fees_id_refunds(map(), mhttp:request_options()) -> term().
get_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_bank_accounts(map()) -> term().
post_accounts_account_bank_accounts(Args) ->
    post_accounts_account_bank_accounts(Args, #{}).

-spec post_accounts_account_bank_accounts(map(), mhttp:request_options()) -> term().
post_accounts_account_bank_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account(map()) -> term().
post_accounts_account(Args) ->
    post_accounts_account(Args, #{}).

-spec post_accounts_account(map(), mhttp:request_options()) -> term().
post_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account(map()) -> term().
get_accounts_account(Args) ->
    get_accounts_account(Args, #{}).

-spec get_accounts_account(map(), mhttp:request_options()) -> term().
get_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account(map()) -> term().
delete_accounts_account(Args) ->
    delete_accounts_account(Args, #{}).

-spec delete_accounts_account(map(), mhttp:request_options()) -> term().
delete_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules_schedule(map()) -> term().
post_subscription_schedules_schedule(Args) ->
    post_subscription_schedules_schedule(Args, #{}).

-spec post_subscription_schedules_schedule(map(), mhttp:request_options()) -> term().
post_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/~s", [VarSchedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_schedules_schedule(map()) -> term().
get_subscription_schedules_schedule(Args) ->
    get_subscription_schedules_schedule(Args, #{}).

-spec get_subscription_schedules_schedule(map(), mhttp:request_options()) -> term().
get_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/~s", [VarSchedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_pay(map()) -> term().
post_invoices_invoice_pay(Args) ->
    post_invoices_invoice_pay(Args, #{}).

-spec post_invoices_invoice_pay(map(), mhttp:request_options()) -> term().
post_invoices_invoice_pay(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/pay", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_transfer_reversals_id(map()) -> term().
post_transfers_transfer_reversals_id(Args) ->
    post_transfers_transfer_reversals_id(Args, #{}).

-spec post_transfers_transfer_reversals_id(map(), mhttp:request_options()) -> term().
post_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s/reversals/~s", [VarTransfer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_transfer_reversals_id(map()) -> term().
get_transfers_transfer_reversals_id(Args) ->
    get_transfers_transfer_reversals_id(Args, #{}).

-spec get_transfers_transfer_reversals_id(map(), mhttp:request_options()) -> term().
get_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s/reversals/~s", [VarTransfer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups_topup(map()) -> term().
post_topups_topup(Args) ->
    post_topups_topup(Args, #{}).

-spec post_topups_topup(map(), mhttp:request_options()) -> term().
post_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups/~s", [VarTopup]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_topups_topup(map()) -> term().
get_topups_topup(Args) ->
    get_topups_topup(Args, #{}).

-spec get_topups_topup(map(), mhttp:request_options()) -> term().
get_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups/~s", [VarTopup]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_recipients_id(map()) -> term().
post_recipients_id(Args) ->
    post_recipients_id(Args, #{}).

-spec post_recipients_id(map(), mhttp:request_options()) -> term().
post_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_recipients_id(map()) -> term().
get_recipients_id(Args) ->
    get_recipients_id(Args, #{}).

-spec get_recipients_id(map(), mhttp:request_options()) -> term().
get_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_recipients_id(map()) -> term().
delete_recipients_id(Args) ->
    delete_recipients_id(Args, #{}).

-spec delete_recipients_id(map(), mhttp:request_options()) -> term().
delete_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_invoice_lines(map()) -> term().
get_invoices_invoice_lines(Args) ->
    get_invoices_invoice_lines(Args, #{}).

-spec get_invoices_invoice_lines(map(), mhttp:request_options()) -> term().
get_invoices_invoice_lines(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/lines", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_external_accounts_id(map()) -> term().
post_accounts_account_external_accounts_id(Args) ->
    post_accounts_account_external_accounts_id(Args, #{}).

-spec post_accounts_account_external_accounts_id(map(), mhttp:request_options()) ->
                                                    term().
post_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_external_accounts_id(map()) -> term().
get_accounts_account_external_accounts_id(Args) ->
    get_accounts_account_external_accounts_id(Args, #{}).

-spec get_accounts_account_external_accounts_id(map(), mhttp:request_options()) -> term().
get_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account_external_accounts_id(map()) -> term().
delete_accounts_account_external_accounts_id(Args) ->
    delete_accounts_account_external_accounts_id(Args, #{}).

-spec delete_accounts_account_external_accounts_id(map(), mhttp:request_options()) ->
                                                      term().
delete_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups(map()) -> term().
post_topups(Args) ->
    post_topups(Args, #{}).

-spec post_topups(map(), mhttp:request_options()) -> term().
post_topups(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_topups(map()) -> term().
get_topups(Args) ->
    get_topups(Args, #{}).

-spec get_topups(map(), mhttp:request_options()) -> term().
get_topups(Args, Options) ->
    EncodeQuery =
        fun ({amount, _Value}) ->
                {<<"amount">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([amount,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id_returns(map()) -> term().
post_orders_id_returns(Args) ->
    post_orders_id_returns(Args, #{}).

-spec post_orders_id_returns(map(), mhttp:request_options()) -> term().
post_orders_id_returns(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/~s/returns", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id(map()) -> term().
post_orders_id(Args) ->
    post_orders_id(Args, #{}).

-spec post_orders_id(map(), mhttp:request_options()) -> term().
post_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_orders_id(map()) -> term().
get_orders_id(Args) ->
    get_orders_id(Args, #{}).

-spec get_orders_id(map(), mhttp:request_options()) -> term().
get_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_apple_pay_domains_domain(map()) -> term().
get_apple_pay_domains_domain(Args) ->
    get_apple_pay_domains_domain(Args, #{}).

-spec get_apple_pay_domains_domain(map(), mhttp:request_options()) -> term().
get_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains/~s", [VarDomain]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_apple_pay_domains_domain(map()) -> term().
delete_apple_pay_domains_domain(Args) ->
    delete_apple_pay_domains_domain(Args, #{}).

-spec delete_apple_pay_domains_domain(map(), mhttp:request_options()) -> term().
delete_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains/~s", [VarDomain]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_transactions(map()) -> term().
get_issuing_transactions(Args) ->
    get_issuing_transactions(Args, #{}).

-spec get_issuing_transactions(map(), mhttp:request_options()) -> term().
get_issuing_transactions(Args, Options) ->
    EncodeQuery =
        fun ({card, _Value}) ->
                {<<"card">>, <<>>};
            ({cardholder, _Value}) ->
                {<<"cardholder">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([card,
                                 cardholder,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/transactions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refund(map()) -> term().
post_charges_charge_refund(Args) ->
    post_charges_charge_refund(Args, #{}).

-spec post_charges_charge_refund(map(), mhttp:request_options()) -> term().
post_charges_charge_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refund", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods_payment_method_attach(map()) -> term().
post_payment_methods_payment_method_attach(Args) ->
    post_payment_methods_payment_method_attach(Args, #{}).

-spec post_payment_methods_payment_method_attach(map(), mhttp:request_options()) ->
                                                    term().
post_payment_methods_payment_method_attach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/~s/attach", [VarPaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_cancel(map()) -> term().
post_payment_intents_intent_cancel(Args) ->
    post_payment_intents_intent_cancel(Args, #{}).

-spec post_payment_intents_intent_cancel(map(), mhttp:request_options()) -> term().
post_payment_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s/cancel", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_capabilities(map()) -> term().
get_accounts_account_capabilities(Args) ->
    get_accounts_account_capabilities(Args, #{}).

-spec get_accounts_account_capabilities(map(), mhttp:request_options()) -> term().
get_accounts_account_capabilities(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_preview_lines(map()) -> term().
get_credit_notes_preview_lines(Args) ->
    get_credit_notes_preview_lines(Args, #{}).

-spec get_credit_notes_preview_lines(map(), mhttp:request_options()) -> term().
get_credit_notes_preview_lines(Args, Options) ->
    EncodeQuery =
        fun ({amount, _Value}) ->
                {<<"amount">>, <<>>};
            ({credit_amount, _Value}) ->
                {<<"credit_amount">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice, _Value}) ->
                {<<"invoice">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({lines, _Value}) ->
                {<<"lines">>, <<>>};
            ({memo, _Value}) ->
                {<<"memo">>, <<>>};
            ({metadata, _Value}) ->
                {<<"metadata">>, <<>>};
            ({out_of_band_amount, _Value}) ->
                {<<"out_of_band_amount">>, <<>>};
            ({reason, _Value}) ->
                {<<"reason">>, <<>>};
            ({refund, _Value}) ->
                {<<"refund">>, <<>>};
            ({refund_amount, _Value}) ->
                {<<"refund_amount">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([amount,
                                 credit_amount,
                                 ending_before,
                                 expand,
                                 invoice,
                                 limit,
                                 lines,
                                 memo,
                                 metadata,
                                 out_of_band_amount,
                                 reason,
                                 refund,
                                 refund_amount,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/preview/lines", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscriptions(map()) -> term().
post_subscriptions(Args) ->
    post_subscriptions(Args, #{}).

-spec post_subscriptions(map(), mhttp:request_options()) -> term().
post_subscriptions(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscriptions(map()) -> term().
get_subscriptions(Args) ->
    get_subscriptions(Args, #{}).

-spec get_subscriptions(map(), mhttp:request_options()) -> term().
get_subscriptions(Args, Options) ->
    EncodeQuery =
        fun ({collection_method, _Value}) ->
                {<<"collection_method">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({current_period_end, _Value}) ->
                {<<"current_period_end">>, <<>>};
            ({current_period_start, _Value}) ->
                {<<"current_period_start">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({price, _Value}) ->
                {<<"price">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([collection_method,
                                 created,
                                 current_period_end,
                                 current_period_start,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 price,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_attempts(map()) -> term().
get_setup_attempts(Args) ->
    get_setup_attempts(Args, #{}).

-spec get_setup_attempts(map(), mhttp:request_options()) -> term().
get_setup_attempts(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({setup_intent, _Value}) ->
                {<<"setup_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 setup_intent,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_attempts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_subscriptions_subscription_exposed_id(map()) -> term().
post_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    post_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec post_customers_customer_subscriptions_subscription_exposed_id(map(),
                                                                    mhttp:request_options()) ->
                                                                       term().
post_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_subscriptions_subscription_exposed_id(map()) -> term().
get_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec get_customers_customer_subscriptions_subscription_exposed_id(map(),
                                                                   mhttp:request_options()) ->
                                                                      term().
get_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_subscriptions_subscription_exposed_id(map()) -> term().
delete_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec delete_customers_customer_subscriptions_subscription_exposed_id(map(),
                                                                      mhttp:request_options()) ->
                                                                         term().
delete_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers_id(map()) -> term().
get_bitcoin_receivers_id(Args) ->
    get_bitcoin_receivers_id(Args, #{}).

-spec get_bitcoin_receivers_id(map(), mhttp:request_options()) -> term().
get_bitcoin_receivers_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/receivers/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders(map()) -> term().
post_orders(Args) ->
    post_orders(Args, #{}).

-spec post_orders(map(), mhttp:request_options()) -> term().
post_orders(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_orders(map()) -> term().
get_orders(Args) ->
    get_orders(Args, #{}).

-spec get_orders(map(), mhttp:request_options()) -> term().
get_orders(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({ids, _Value}) ->
                {<<"ids">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({status_transitions, _Value}) ->
                {<<"status_transitions">>, <<>>};
            ({upstream_ids, _Value}) ->
                {<<"upstream_ids">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 customer,
                                 ending_before,
                                 expand,
                                 ids,
                                 limit,
                                 starting_after,
                                 status,
                                 status_transitions,
                                 upstream_ids],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_ephemeral_keys(map()) -> term().
post_ephemeral_keys(Args) ->
    post_ephemeral_keys(Args, #{}).

-spec post_ephemeral_keys(map(), mhttp:request_options()) -> term().
post_ephemeral_keys(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/ephemeral_keys", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_webhook_endpoints_webhook_endpoint(map()) -> term().
post_webhook_endpoints_webhook_endpoint(Args) ->
    post_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec post_webhook_endpoints_webhook_endpoint(map(), mhttp:request_options()) -> term().
post_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_webhook_endpoints_webhook_endpoint(map()) -> term().
get_webhook_endpoints_webhook_endpoint(Args) ->
    get_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec get_webhook_endpoints_webhook_endpoint(map(), mhttp:request_options()) -> term().
get_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_webhook_endpoints_webhook_endpoint(map()) -> term().
delete_webhook_endpoints_webhook_endpoint(Args) ->
    delete_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec delete_webhook_endpoints_webhook_endpoint(map(), mhttp:request_options()) -> term().
delete_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_persons(map()) -> term().
post_account_persons(Args) ->
    post_account_persons(Args, #{}).

-spec post_account_persons(map(), mhttp:request_options()) -> term().
post_account_persons(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_persons(map()) -> term().
get_account_persons(Args) ->
    get_account_persons(Args, #{}).

-spec get_account_persons(map(), mhttp:request_options()) -> term().
get_account_persons(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({relationship, _Value}) ->
                {<<"relationship">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, relationship, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_capabilities(map()) -> term().
get_account_capabilities(Args) ->
    get_account_capabilities(Args, #{}).

-spec get_account_capabilities(map(), mhttp:request_options()) -> term().
get_account_capabilities(Args, Options) ->
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/capabilities", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_checkout_sessions_session_expire(map()) -> term().
post_checkout_sessions_session_expire(Args) ->
    post_checkout_sessions_session_expire(Args, #{}).

-spec post_checkout_sessions_session_expire(map(), mhttp:request_options()) -> term().
post_checkout_sessions_session_expire(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions/~s/expire", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers_receiver_transactions(map()) -> term().
get_bitcoin_receivers_receiver_transactions(Args) ->
    get_bitcoin_receivers_receiver_transactions(Args, #{}).

-spec get_bitcoin_receivers_receiver_transactions(map(), mhttp:request_options()) ->
                                                     term().
get_bitcoin_receivers_receiver_transactions(Args, Options) ->
    VarReceiver = maps:get(receiver, Args),
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/receivers/~s/transactions", [VarReceiver]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote(map()) -> term().
post_quotes_quote(Args) ->
    post_quotes_quote(Args, #{}).

-spec post_quotes_quote(map(), mhttp:request_options()) -> term().
post_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote(map()) -> term().
get_quotes_quote(Args) ->
    get_quotes_quote(Args, #{}).

-spec get_quotes_quote(map(), mhttp:request_options()) -> term().
get_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_people(map()) -> term().
post_account_people(Args) ->
    post_account_people(Args, #{}).

-spec post_account_people(map(), mhttp:request_options()) -> term().
post_account_people(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_people(map()) -> term().
get_account_people(Args) ->
    get_account_people(Args, #{}).

-spec get_account_people(map(), mhttp:request_options()) -> term().
get_account_people(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({relationship, _Value}) ->
                {<<"relationship">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, relationship, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_confirm(map()) -> term().
post_setup_intents_intent_confirm(Args) ->
    post_setup_intents_intent_confirm(Args, #{}).

-spec post_setup_intents_intent_confirm(map(), mhttp:request_options()) -> term().
post_setup_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s/confirm", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_cards(map()) -> term().
post_customers_customer_cards(Args) ->
    post_customers_customer_cards(Args, #{}).

-spec post_customers_customer_cards(map(), mhttp:request_options()) -> term().
post_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_cards(map()) -> term().
get_customers_customer_cards(Args) ->
    get_customers_customer_cards(Args, #{}).

-spec get_customers_customer_cards(map(), mhttp:request_options()) -> term().
get_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_reports(map()) -> term().
get_identity_verification_reports(Args) ->
    get_identity_verification_reports(Args, #{}).

-spec get_identity_verification_reports(map(), mhttp:request_options()) -> term().
get_identity_verification_reports(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>};
            ({verification_session, _Value}) ->
                {<<"verification_session">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 type,
                                 verification_session],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_reports", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_persons(map()) -> term().
post_accounts_account_persons(Args) ->
    post_accounts_account_persons(Args, #{}).

-spec post_accounts_account_persons(map(), mhttp:request_options()) -> term().
post_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_persons(map()) -> term().
get_accounts_account_persons(Args) ->
    get_accounts_account_persons(Args, #{}).

-spec get_accounts_account_persons(map(), mhttp:request_options()) -> term().
get_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({relationship, _Value}) ->
                {<<"relationship">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, relationship, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/persons", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_id_refund(map()) -> term().
post_application_fees_id_refund(Args) ->
    post_application_fees_id_refund(Args, #{}).

-spec post_application_fees_id_refund(map(), mhttp:request_options()) -> term().
post_application_fees_id_refund(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s/refund", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents(map()) -> term().
post_payment_intents(Args) ->
    post_payment_intents(Args, #{}).

-spec post_payment_intents(map(), mhttp:request_options()) -> term().
post_payment_intents(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_intents(map()) -> term().
get_payment_intents(Args) ->
    get_payment_intents(Args, #{}).

-spec get_payment_intents(map(), mhttp:request_options()) -> term().
get_payment_intents(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, customer, ending_before, expand, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_skus(map()) -> term().
post_skus(Args) ->
    post_skus(Args, #{}).

-spec post_skus(map(), mhttp:request_options()) -> term().
post_skus(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_skus(map()) -> term().
get_skus(Args) ->
    get_skus(Args, #{}).

-spec get_skus(map(), mhttp:request_options()) -> term().
get_skus(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({attributes, _Value}) ->
                {<<"attributes">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({ids, _Value}) ->
                {<<"ids">>, <<>>};
            ({in_stock, _Value}) ->
                {<<"in_stock">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({product, _Value}) ->
                {<<"product">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 attributes,
                                 ending_before,
                                 expand,
                                 ids,
                                 in_stock,
                                 limit,
                                 product,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_webhook_endpoints(map()) -> term().
post_webhook_endpoints(Args) ->
    post_webhook_endpoints(Args, #{}).

-spec post_webhook_endpoints(map(), mhttp:request_options()) -> term().
post_webhook_endpoints(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_webhook_endpoints(map()) -> term().
get_webhook_endpoints(Args) ->
    get_webhook_endpoints(Args, #{}).

-spec get_webhook_endpoints(map(), mhttp:request_options()) -> term().
get_webhook_endpoints(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance(map()) -> term().
get_balance(Args) ->
    get_balance(Args, #{}).

-spec get_balance(map(), mhttp:request_options()) -> term().
get_balance(Args, Options) ->
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_balance_transactions_transaction(map()) -> term().
post_customers_customer_balance_transactions_transaction(Args) ->
    post_customers_customer_balance_transactions_transaction(Args, #{}).

-spec post_customers_customer_balance_transactions_transaction(map(),
                                                               mhttp:request_options()) ->
                                                                  term().
post_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/balance_transactions/~s", [VarCustomer, VarTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_balance_transactions_transaction(map()) -> term().
get_customers_customer_balance_transactions_transaction(Args) ->
    get_customers_customer_balance_transactions_transaction(Args, #{}).

-spec get_customers_customer_balance_transactions_transaction(map(),
                                                              mhttp:request_options()) ->
                                                                 term().
get_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/balance_transactions/~s", [VarCustomer, VarTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods_payment_method(map()) -> term().
post_payment_methods_payment_method(Args) ->
    post_payment_methods_payment_method(Args, #{}).

-spec post_payment_methods_payment_method(map(), mhttp:request_options()) -> term().
post_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/~s", [VarPaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_methods_payment_method(map()) -> term().
get_payment_methods_payment_method(Args) ->
    get_payment_methods_payment_method(Args, #{}).

-spec get_payment_methods_payment_method(map(), mhttp:request_options()) -> term().
get_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/~s", [VarPaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups_topup_cancel(map()) -> term().
post_topups_topup_cancel(Args) ->
    post_topups_topup_cancel(Args, #{}).

-spec post_topups_topup_cancel(map(), mhttp:request_options()) -> term().
post_topups_topup_cancel(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/topups/~s/cancel", [VarTopup]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_events(map()) -> term().
get_events(Args) ->
    get_events(Args, #{}).

-spec get_events(map(), mhttp:request_options()) -> term().
get_events(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({delivery_success, _Value}) ->
                {<<"delivery_success">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>};
            ({types, _Value}) ->
                {<<"types">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 delivery_success,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 type,
                                 types],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/events", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refunds_refund(map()) -> term().
post_charges_charge_refunds_refund(Args) ->
    post_charges_charge_refunds_refund(Args, #{}).

-spec post_charges_charge_refunds_refund(map(), mhttp:request_options()) -> term().
post_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refunds/~s", [VarCharge, VarRefund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_refunds_refund(map()) -> term().
get_charges_charge_refunds_refund(Args) ->
    get_charges_charge_refunds_refund(Args, #{}).

-spec get_charges_charge_refunds_refund(map(), mhttp:request_options()) -> term().
get_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/refunds/~s", [VarCharge, VarRefund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_capabilities_capability(map()) -> term().
post_accounts_account_capabilities_capability(Args) ->
    post_accounts_account_capabilities_capability(Args, #{}).

-spec post_accounts_account_capabilities_capability(map(), mhttp:request_options()) ->
                                                       term().
post_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities/~s", [VarAccount, VarCapability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_capabilities_capability(map()) -> term().
get_accounts_account_capabilities_capability(Args) ->
    get_accounts_account_capabilities_capability(Args, #{}).

-spec get_accounts_account_capabilities_capability(map(), mhttp:request_options()) ->
                                                      term().
get_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities/~s", [VarAccount, VarCapability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items(map()) -> term().
post_subscription_items(Args) ->
    post_subscription_items(Args, #{}).

-spec post_subscription_items(map(), mhttp:request_options()) -> term().
post_subscription_items(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items(map()) -> term().
get_subscription_items(Args) ->
    get_subscription_items(Args, #{}).

-spec get_subscription_items(map(), mhttp:request_options()) -> term().
get_subscription_items(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after, subscription],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_pdf(map()) -> term().
get_quotes_quote_pdf(Args) ->
    get_quotes_quote_pdf(Args, #{}).

-spec get_quotes_quote_pdf(map(), mhttp:request_options()) -> term().
get_quotes_quote_pdf(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/pdf", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_bank_accounts_id(map()) -> term().
post_account_bank_accounts_id(Args) ->
    post_account_bank_accounts_id(Args, #{}).

-spec post_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
post_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_bank_accounts_id(map()) -> term().
get_account_bank_accounts_id(Args) ->
    get_account_bank_accounts_id(Args, #{}).

-spec get_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
get_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_bank_accounts_id(map()) -> term().
delete_account_bank_accounts_id(Args) ->
    delete_account_bank_accounts_id(Args, #{}).

-spec delete_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
delete_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links_payment_link_line_items(map()) -> term().
get_payment_links_payment_link_line_items(Args) ->
    get_payment_links_payment_link_line_items(Args, #{}).

-spec get_payment_links_payment_link_line_items(map(), mhttp:request_options()) -> term().
get_payment_links_payment_link_line_items(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links/~s/line_items", [VarPaymentLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items_subscription_item_usage_record_summaries(map()) -> term().
get_subscription_items_subscription_item_usage_record_summaries(Args) ->
    get_subscription_items_subscription_item_usage_record_summaries(Args, #{}).

-spec get_subscription_items_subscription_item_usage_record_summaries(map(),
                                                                      mhttp:request_options()) ->
                                                                         term().
get_subscription_items_subscription_item_usage_record_summaries(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/subscription_items/~s/usage_record_summaries", [VarSubscriptionItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent(map()) -> term().
post_payment_intents_intent(Args) ->
    post_payment_intents_intent(Args, #{}).

-spec post_payment_intents_intent(map(), mhttp:request_options()) -> term().
post_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_intents_intent(map()) -> term().
get_payment_intents_intent(Args) ->
    get_payment_intents_intent(Args, #{}).

-spec get_payment_intents_intent(map(), mhttp:request_options()) -> term().
get_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    EncodeQuery =
        fun ({client_secret, _Value}) ->
                {<<"client_secret">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([client_secret, expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges(map()) -> term().
post_charges(Args) ->
    post_charges(Args, #{}).

-spec post_charges(map(), mhttp:request_options()) -> term().
post_charges(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges(map()) -> term().
get_charges(Args) ->
    get_charges(Args, #{}).

-spec get_charges(map(), mhttp:request_options()) -> term().
get_charges(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({transfer_group, _Value}) ->
                {<<"transfer_group">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after,
                                 transfer_group],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_external_accounts(map()) -> term().
post_accounts_account_external_accounts(Args) ->
    post_accounts_account_external_accounts(Args, #{}).

-spec post_accounts_account_external_accounts(map(), mhttp:request_options()) -> term().
post_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_external_accounts(map()) -> term().
get_accounts_account_external_accounts(Args) ->
    get_accounts_account_external_accounts(Args, #{}).

-spec get_accounts_account_external_accounts(map(), mhttp:request_options()) -> term().
get_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_authorizations(map()) -> term().
get_issuing_authorizations(Args) ->
    get_issuing_authorizations(Args, #{}).

-spec get_issuing_authorizations(map(), mhttp:request_options()) -> term().
get_issuing_authorizations(Args, Options) ->
    EncodeQuery =
        fun ({card, _Value}) ->
                {<<"card">>, <<>>};
            ({cardholder, _Value}) ->
                {<<"cardholder">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([card,
                                 cardholder,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_products_id(map()) -> term().
post_products_id(Args) ->
    post_products_id(Args, #{}).

-spec post_products_id(map(), mhttp:request_options()) -> term().
post_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_products_id(map()) -> term().
get_products_id(Args) ->
    get_products_id(Args, #{}).

-spec get_products_id(map(), mhttp:request_options()) -> term().
get_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_products_id(map()) -> term().
delete_products_id(Args) ->
    delete_products_id(Args, #{}).

-spec delete_products_id(map(), mhttp:request_options()) -> term().
delete_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_verify_microdeposits(map()) -> term().
post_setup_intents_intent_verify_microdeposits(Args) ->
    post_setup_intents_intent_verify_microdeposits(Args, #{}).

-spec post_setup_intents_intent_verify_microdeposits(map(), mhttp:request_options()) ->
                                                        term().
post_setup_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s/verify_microdeposits", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_types(map()) -> term().
get_reporting_report_types(Args) ->
    get_reporting_report_types(Args, #{}).

-spec get_reporting_report_types(map(), mhttp:request_options()) -> term().
get_reporting_report_types(Args, Options) ->
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_types", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_external_accounts(map()) -> term().
post_account_external_accounts(Args) ->
    post_account_external_accounts(Args, #{}).

-spec post_account_external_accounts(map(), mhttp:request_options()) -> term().
post_account_external_accounts(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_external_accounts(map()) -> term().
get_account_external_accounts(Args) ->
    get_account_external_accounts(Args, #{}).

-spec get_account_external_accounts(map(), mhttp:request_options()) -> term().
get_account_external_accounts(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_lists(map()) -> term().
post_radar_value_lists(Args) ->
    post_radar_value_lists(Args, #{}).

-spec post_radar_value_lists(map(), mhttp:request_options()) -> term().
post_radar_value_lists(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_lists(map()) -> term().
get_radar_value_lists(Args) ->
    get_radar_value_lists(Args, #{}).

-spec get_radar_value_lists(map(), mhttp:request_options()) -> term().
get_radar_value_lists(Args, Options) ->
    EncodeQuery =
        fun ({alias, _Value}) ->
                {<<"alias">>, <<>>};
            ({contains, _Value}) ->
                {<<"contains">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([alias,
                                 contains,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_shipping_rates(map()) -> term().
post_shipping_rates(Args) ->
    post_shipping_rates(Args, #{}).

-spec post_shipping_rates(map(), mhttp:request_options()) -> term().
post_shipping_rates(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_shipping_rates(map()) -> term().
get_shipping_rates(Args) ->
    get_shipping_rates(Args, #{}).

-spec get_shipping_rates(map(), mhttp:request_options()) -> term().
get_shipping_rates(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({currency, _Value}) ->
                {<<"currency">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 currency,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_file_links_link(map()) -> term().
post_file_links_link(Args) ->
    post_file_links_link(Args, #{}).

-spec post_file_links_link(map(), mhttp:request_options()) -> term().
post_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links/~s", [VarLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_file_links_link(map()) -> term().
get_file_links_link(Args) ->
    get_file_links_link(Args, #{}).

-spec get_file_links_link(map(), mhttp:request_options()) -> term().
get_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links/~s", [VarLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get3d_secure_three_d_secure(map()) -> term().
get3d_secure_three_d_secure(Args) ->
    get3d_secure_three_d_secure(Args, #{}).

-spec get3d_secure_three_d_secure(map(), mhttp:request_options()) -> term().
get3d_secure_three_d_secure(Args, Options) ->
    VarThreeDSecure = maps:get(three_d_secure, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/3d_secure/~s", [VarThreeDSecure]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_send(map()) -> term().
post_invoices_invoice_send(Args) ->
    post_invoices_invoice_send(Args, #{}).

-spec post_invoices_invoice_send(map(), mhttp:request_options()) -> term().
post_invoices_invoice_send(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/send", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_upcoming(map()) -> term().
get_invoices_upcoming(Args) ->
    get_invoices_upcoming(Args, #{}).

-spec get_invoices_upcoming(map(), mhttp:request_options()) -> term().
get_invoices_upcoming(Args, Options) ->
    EncodeQuery =
        fun ({automatic_tax, _Value}) ->
                {<<"automatic_tax">>, <<>>};
            ({coupon, _Value}) ->
                {<<"coupon">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({customer_details, _Value}) ->
                {<<"customer_details">>, <<>>};
            ({discounts, _Value}) ->
                {<<"discounts">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice_items, _Value}) ->
                {<<"invoice_items">>, <<>>};
            ({schedule, _Value}) ->
                {<<"schedule">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>};
            ({subscription_billing_cycle_anchor, _Value}) ->
                {<<"subscription_billing_cycle_anchor">>, <<>>};
            ({subscription_cancel_at, _Value}) ->
                {<<"subscription_cancel_at">>, <<>>};
            ({subscription_cancel_at_period_end, _Value}) ->
                {<<"subscription_cancel_at_period_end">>, <<>>};
            ({subscription_cancel_now, _Value}) ->
                {<<"subscription_cancel_now">>, <<>>};
            ({subscription_default_tax_rates, _Value}) ->
                {<<"subscription_default_tax_rates">>, <<>>};
            ({subscription_items, _Value}) ->
                {<<"subscription_items">>, <<>>};
            ({subscription_proration_behavior, _Value}) ->
                {<<"subscription_proration_behavior">>, <<>>};
            ({subscription_proration_date, _Value}) ->
                {<<"subscription_proration_date">>, <<>>};
            ({subscription_start_date, _Value}) ->
                {<<"subscription_start_date">>, <<>>};
            ({subscription_trial_end, _Value}) ->
                {<<"subscription_trial_end">>, <<>>};
            ({subscription_trial_from_plan, _Value}) ->
                {<<"subscription_trial_from_plan">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([automatic_tax,
                                 coupon,
                                 customer,
                                 customer_details,
                                 discounts,
                                 expand,
                                 invoice_items,
                                 schedule,
                                 subscription,
                                 subscription_billing_cycle_anchor,
                                 subscription_cancel_at,
                                 subscription_cancel_at_period_end,
                                 subscription_cancel_now,
                                 subscription_default_tax_rates,
                                 subscription_items,
                                 subscription_proration_behavior,
                                 subscription_proration_date,
                                 subscription_start_date,
                                 subscription_trial_end,
                                 subscription_trial_from_plan],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/upcoming", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions_session_line_items(map()) -> term().
get_checkout_sessions_session_line_items(Args) ->
    get_checkout_sessions_session_line_items(Args, #{}).

-spec get_checkout_sessions_session_line_items(map(), mhttp:request_options()) -> term().
get_checkout_sessions_session_line_items(Args, Options) ->
    VarSession = maps:get(session, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions/~s/line_items", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_codes(map()) -> term().
get_tax_codes(Args) ->
    get_tax_codes(Args, #{}).

-spec get_tax_codes(map(), mhttp:request_options()) -> term().
get_tax_codes(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_codes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices(map()) -> term().
post_invoices(Args) ->
    post_invoices(Args, #{}).

-spec post_invoices(map(), mhttp:request_options()) -> term().
post_invoices(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices(map()) -> term().
get_invoices(Args) ->
    get_invoices(Args, #{}).

-spec get_invoices(map(), mhttp:request_options()) -> term().
get_invoices(Args, Options) ->
    EncodeQuery =
        fun ({collection_method, _Value}) ->
                {<<"collection_method">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({due_date, _Value}) ->
                {<<"due_date">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([collection_method,
                                 created,
                                 customer,
                                 due_date,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status,
                                 subscription],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge(map()) -> term().
post_charges_charge(Args) ->
    post_charges_charge(Args, #{}).

-spec post_charges_charge(map(), mhttp:request_options()) -> term().
post_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge(map()) -> term().
get_charges_charge(Args) ->
    get_charges_charge(Args, #{}).

-spec get_charges_charge(map(), mhttp:request_options()) -> term().
get_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_mark_uncollectible(map()) -> term().
post_invoices_invoice_mark_uncollectible(Args) ->
    post_invoices_invoice_mark_uncollectible(Args, #{}).

-spec post_invoices_invoice_mark_uncollectible(map(), mhttp:request_options()) -> term().
post_invoices_invoice_mark_uncollectible(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/mark_uncollectible", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources_id_verify(map()) -> term().
post_customers_customer_sources_id_verify(Args) ->
    post_customers_customer_sources_id_verify(Args, #{}).

-spec post_customers_customer_sources_id_verify(map(), mhttp:request_options()) -> term().
post_customers_customer_sources_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s/verify", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id_pay(map()) -> term().
post_orders_id_pay(Args) ->
    post_orders_id_pay(Args, #{}).

-spec post_orders_id_pay(map(), mhttp:request_options()) -> term().
post_orders_id_pay(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/~s/pay", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_bank_accounts_id_verify(map()) -> term().
post_customers_customer_bank_accounts_id_verify(Args) ->
    post_customers_customer_bank_accounts_id_verify(Args, #{}).

-spec post_customers_customer_bank_accounts_id_verify(map(), mhttp:request_options()) ->
                                                         term().
post_customers_customer_bank_accounts_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s/verify", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_people_person(map()) -> term().
post_account_people_person(Args) ->
    post_account_people_person(Args, #{}).

-spec post_account_people_person(map(), mhttp:request_options()) -> term().
post_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_people_person(map()) -> term().
get_account_people_person(Args) ->
    get_account_people_person(Args, #{}).

-spec get_account_people_person(map(), mhttp:request_options()) -> term().
get_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_people_person(map()) -> term().
delete_account_people_person(Args) ->
    delete_account_people_person(Args, #{}).

-spec delete_account_people_person(map(), mhttp:request_options()) -> term().
delete_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_checkout_sessions(map()) -> term().
post_checkout_sessions(Args) ->
    post_checkout_sessions(Args, #{}).

-spec post_checkout_sessions(map(), mhttp:request_options()) -> term().
post_checkout_sessions(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions(map()) -> term().
get_checkout_sessions(Args) ->
    get_checkout_sessions(Args, #{}).

-spec get_checkout_sessions(map(), mhttp:request_options()) -> term().
get_checkout_sessions(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after,
                                 subscription],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_login_links(map()) -> term().
post_accounts_account_login_links(Args) ->
    post_accounts_account_login_links(Args, #{}).

-spec post_accounts_account_login_links(map(), mhttp:request_options()) -> term().
post_accounts_account_login_links(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/login_links", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_readers(map()) -> term().
post_terminal_readers(Args) ->
    post_terminal_readers(Args, #{}).

-spec post_terminal_readers(map(), mhttp:request_options()) -> term().
post_terminal_readers(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_readers(map()) -> term().
get_terminal_readers(Args) ->
    get_terminal_readers(Args, #{}).

-spec get_terminal_readers(map(), mhttp:request_options()) -> term().
get_terminal_readers(Args, Options) ->
    EncodeQuery =
        fun ({device_type, _Value}) ->
                {<<"device_type">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({location, _Value}) ->
                {<<"location">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([device_type,
                                 ending_before,
                                 expand,
                                 limit,
                                 location,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes(map()) -> term().
post_issuing_disputes(Args) ->
    post_issuing_disputes(Args, #{}).

-spec post_issuing_disputes(map(), mhttp:request_options()) -> term().
post_issuing_disputes(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_disputes(map()) -> term().
get_issuing_disputes(Args) ->
    get_issuing_disputes(Args, #{}).

-spec get_issuing_disputes(map(), mhttp:request_options()) -> term().
get_issuing_disputes(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({transaction, _Value}) ->
                {<<"transaction">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status,
                                 transaction],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post3d_secure(map()) -> term().
post3d_secure(Args) ->
    post3d_secure(Args, #{}).

-spec post3d_secure(map(), mhttp:request_options()) -> term().
post3d_secure(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/3d_secure", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_prices(map()) -> term().
post_prices(Args) ->
    post_prices(Args, #{}).

-spec post_prices(map(), mhttp:request_options()) -> term().
post_prices(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/prices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_prices(map()) -> term().
get_prices(Args) ->
    get_prices(Args, #{}).

-spec get_prices(map(), mhttp:request_options()) -> term().
get_prices(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({currency, _Value}) ->
                {<<"currency">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({lookup_keys, _Value}) ->
                {<<"lookup_keys">>, <<>>};
            ({product, _Value}) ->
                {<<"product">>, <<>>};
            ({recurring, _Value}) ->
                {<<"recurring">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 currency,
                                 ending_before,
                                 expand,
                                 limit,
                                 lookup_keys,
                                 product,
                                 recurring,
                                 starting_after,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/prices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice(map()) -> term().
post_invoices_invoice(Args) ->
    post_invoices_invoice(Args, #{}).

-spec post_invoices_invoice(map(), mhttp:request_options()) -> term().
post_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_invoice(map()) -> term().
get_invoices_invoice(Args) ->
    get_invoices_invoice(Args, #{}).

-spec get_invoices_invoice(map(), mhttp:request_options()) -> term().
get_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_invoices_invoice(map()) -> term().
delete_invoices_invoice(Args) ->
    delete_invoices_invoice(Args, #{}).

-spec delete_invoices_invoice(map(), mhttp:request_options()) -> term().
delete_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_identity_verification_sessions_session(map()) -> term().
post_identity_verification_sessions_session(Args) ->
    post_identity_verification_sessions_session(Args, #{}).

-spec post_identity_verification_sessions_session(map(), mhttp:request_options()) ->
                                                     term().
post_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_sessions_session(map()) -> term().
get_identity_verification_sessions_session(Args) ->
    get_identity_verification_sessions_session(Args, #{}).

-spec get_identity_verification_sessions_session(map(), mhttp:request_options()) ->
                                                    term().
get_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_transactions_id(map()) -> term().
get_balance_transactions_id(Args) ->
    get_balance_transactions_id(Args, #{}).

-spec get_balance_transactions_id(map(), mhttp:request_options()) -> term().
get_balance_transactions_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance_transactions/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_cancel(map()) -> term().
post_setup_intents_intent_cancel(Args) ->
    post_setup_intents_intent_cancel(Args, #{}).

-spec post_setup_intents_intent_cancel(map(), mhttp:request_options()) -> term().
post_setup_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/~s/cancel", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_transactions_transaction(map()) -> term().
post_issuing_transactions_transaction(Args) ->
    post_issuing_transactions_transaction(Args, #{}).

-spec post_issuing_transactions_transaction(map(), mhttp:request_options()) -> term().
post_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/transactions/~s", [VarTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_transactions_transaction(map()) -> term().
get_issuing_transactions_transaction(Args) ->
    get_issuing_transactions_transaction(Args, #{}).

-spec get_issuing_transactions_transaction(map(), mhttp:request_options()) -> term().
get_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/transactions/~s", [VarTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_connection_tokens(map()) -> term().
post_terminal_connection_tokens(Args) ->
    post_terminal_connection_tokens(Args, #{}).

-spec post_terminal_connection_tokens(map(), mhttp:request_options()) -> term().
post_terminal_connection_tokens(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/connection_tokens", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reviews(map()) -> term().
get_reviews(Args) ->
    get_reviews(Args, #{}).

-spec get_reviews(map(), mhttp:request_options()) -> term().
get_reviews(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reviews", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_promotion_codes(map()) -> term().
post_promotion_codes(Args) ->
    post_promotion_codes(Args, #{}).

-spec post_promotion_codes(map(), mhttp:request_options()) -> term().
post_promotion_codes(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_promotion_codes(map()) -> term().
get_promotion_codes(Args) ->
    get_promotion_codes(Args, #{}).

-spec get_promotion_codes(map(), mhttp:request_options()) -> term().
get_promotion_codes(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({code, _Value}) ->
                {<<"code">>, <<>>};
            ({coupon, _Value}) ->
                {<<"coupon">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 code,
                                 coupon,
                                 created,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_subscriptions_subscription_exposed_id_discount(map()) ->
                                                                               term().
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec get_customers_customer_subscriptions_subscription_exposed_id_discount(map(),
                                                                            mhttp:request_options()) ->
                                                                               term().
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s/discount",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_subscriptions_subscription_exposed_id_discount(map()) ->
                                                                                  term().
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec delete_customers_customer_subscriptions_subscription_exposed_id_discount(map(),
                                                                               mhttp:request_options()) ->
                                                                                  term().
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s/discount",
                      [VarCustomer, VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_computed_upfront_line_items(map()) -> term().
get_quotes_quote_computed_upfront_line_items(Args) ->
    get_quotes_quote_computed_upfront_line_items(Args, #{}).

-spec get_quotes_quote_computed_upfront_line_items(map(), mhttp:request_options()) ->
                                                      term().
get_quotes_quote_computed_upfront_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/computed_upfront_line_items", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_list_items_item(map()) -> term().
get_radar_value_list_items_item(Args) ->
    get_radar_value_list_items_item(Args, #{}).

-spec get_radar_value_list_items_item(map(), mhttp:request_options()) -> term().
get_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_radar_value_list_items_item(map()) -> term().
delete_radar_value_list_items_item(Args) ->
    delete_radar_value_list_items_item(Args, #{}).

-spec delete_radar_value_list_items_item(map(), mhttp:request_options()) -> term().
delete_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items/~s", [VarItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuer_fraud_records(map()) -> term().
get_issuer_fraud_records(Args) ->
    get_issuer_fraud_records(Args, #{}).

-spec get_issuer_fraud_records(map(), mhttp:request_options()) -> term().
get_issuer_fraud_records(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuer_fraud_records", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tax_rates_tax_rate(map()) -> term().
post_tax_rates_tax_rate(Args) ->
    post_tax_rates_tax_rate(Args, #{}).

-spec post_tax_rates_tax_rate(map(), mhttp:request_options()) -> term().
post_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates/~s", [VarTaxRate]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_rates_tax_rate(map()) -> term().
get_tax_rates_tax_rate(Args) ->
    get_tax_rates_tax_rate(Args, #{}).

-spec get_tax_rates_tax_rate(map(), mhttp:request_options()) -> term().
get_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates/~s", [VarTaxRate]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_recipients(map()) -> term().
post_recipients(Args) ->
    post_recipients(Args, #{}).

-spec post_recipients(map(), mhttp:request_options()) -> term().
post_recipients(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_recipients(map()) -> term().
get_recipients(Args) ->
    get_recipients(Args, #{}).

-spec get_recipients(map(), mhttp:request_options()) -> term().
get_recipients(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>};
            ({verified, _Value}) ->
                {<<"verified">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 type,
                                 verified],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_plans(map()) -> term().
post_plans(Args) ->
    post_plans(Args, #{}).

-spec post_plans(map(), mhttp:request_options()) -> term().
post_plans(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_plans(map()) -> term().
get_plans(Args) ->
    get_plans(Args, #{}).

-spec get_plans(map(), mhttp:request_options()) -> term().
get_plans(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({product, _Value}) ->
                {<<"product">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 product,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/plans", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_balance_transactions(map()) -> term().
post_customers_customer_balance_transactions(Args) ->
    post_customers_customer_balance_transactions(Args, #{}).

-spec post_customers_customer_balance_transactions(map(), mhttp:request_options()) ->
                                                      term().
post_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/balance_transactions", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_balance_transactions(map()) -> term().
get_customers_customer_balance_transactions(Args) ->
    get_customers_customer_balance_transactions(Args, #{}).

-spec get_customers_customer_balance_transactions(map(), mhttp:request_options()) ->
                                                     term().
get_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/balance_transactions", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_reviews_review_approve(map()) -> term().
post_reviews_review_approve(Args) ->
    post_reviews_review_approve(Args, #{}).

-spec post_reviews_review_approve(map(), mhttp:request_options()) -> term().
post_reviews_review_approve(Args, Options) ->
    VarReview = maps:get(review, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reviews/~s/approve", [VarReview]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_tax_ids(map()) -> term().
post_customers_customer_tax_ids(Args) ->
    post_customers_customer_tax_ids(Args, #{}).

-spec post_customers_customer_tax_ids(map(), mhttp:request_options()) -> term().
post_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_tax_ids(map()) -> term().
get_customers_customer_tax_ids(Args) ->
    get_customers_customer_tax_ids(Args, #{}).

-spec get_customers_customer_tax_ids(map(), mhttp:request_options()) -> term().
get_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tokens_token(map()) -> term().
get_tokens_token(Args) ->
    get_tokens_token(Args, #{}).

-spec get_tokens_token(map(), mhttp:request_options()) -> term().
get_tokens_token(Args, Options) ->
    VarToken = maps:get(token, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tokens/~s", [VarToken]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_transactions(map()) -> term().
get_balance_transactions(Args) ->
    get_balance_transactions(Args, #{}).

-spec get_balance_transactions(map(), mhttp:request_options()) -> term().
get_balance_transactions(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({currency, _Value}) ->
                {<<"currency">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payout, _Value}) ->
                {<<"payout">>, <<>>};
            ({source, _Value}) ->
                {<<"source">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 currency,
                                 ending_before,
                                 expand,
                                 limit,
                                 payout,
                                 source,
                                 starting_after,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance_transactions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_codes_id(map()) -> term().
get_tax_codes_id(Args) ->
    get_tax_codes_id(Args, #{}).

-spec get_tax_codes_id(map(), mhttp:request_options()) -> term().
get_tax_codes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_codes/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_reject(map()) -> term().
post_accounts_account_reject(Args) ->
    post_accounts_account_reject(Args, #{}).

-spec post_accounts_account_reject(map(), mhttp:request_options()) -> term().
post_accounts_account_reject(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/reject", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscriptions_subscription_exposed_id(map()) -> term().
post_subscriptions_subscription_exposed_id(Args) ->
    post_subscriptions_subscription_exposed_id(Args, #{}).

-spec post_subscriptions_subscription_exposed_id(map(), mhttp:request_options()) ->
                                                    term().
post_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscriptions_subscription_exposed_id(map()) -> term().
get_subscriptions_subscription_exposed_id(Args) ->
    get_subscriptions_subscription_exposed_id(Args, #{}).

-spec get_subscriptions_subscription_exposed_id(map(), mhttp:request_options()) -> term().
get_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_subscriptions_subscription_exposed_id(map()) -> term().
delete_subscriptions_subscription_exposed_id(Args) ->
    delete_subscriptions_subscription_exposed_id(Args, #{}).

-spec delete_subscriptions_subscription_exposed_id(map(), mhttp:request_options()) ->
                                                      term().
delete_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_country_specs_country(map()) -> term().
get_country_specs_country(Args) ->
    get_country_specs_country(Args, #{}).

-spec get_country_specs_country(map(), mhttp:request_options()) -> term().
get_country_specs_country(Args, Options) ->
    VarCountry = maps:get(country, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/country_specs/~s", [VarCountry]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_finalize(map()) -> term().
post_invoices_invoice_finalize(Args) ->
    post_invoices_invoice_finalize(Args, #{}).

-spec post_invoices_invoice_finalize(map(), mhttp:request_options()) -> term().
post_invoices_invoice_finalize(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/finalize", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_locations_location(map()) -> term().
post_terminal_locations_location(Args) ->
    post_terminal_locations_location(Args, #{}).

-spec post_terminal_locations_location(map(), mhttp:request_options()) -> term().
post_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_locations_location(map()) -> term().
get_terminal_locations_location(Args) ->
    get_terminal_locations_location(Args, #{}).

-spec get_terminal_locations_location(map(), mhttp:request_options()) -> term().
get_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_terminal_locations_location(map()) -> term().
delete_terminal_locations_location(Args) ->
    delete_terminal_locations_location(Args, #{}).

-spec delete_terminal_locations_location(map(), mhttp:request_options()) -> term().
delete_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account(map()) -> term().
post_account(Args) ->
    post_account(Args, #{}).

-spec post_account(map(), mhttp:request_options()) -> term().
post_account(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account(map()) -> term().
get_account(Args) ->
    get_account(Args, #{}).

-spec get_account(map(), mhttp:request_options()) -> term().
get_account(Args, Options) ->
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account(map()) -> term().
delete_account(Args) ->
    delete_account(Args, #{}).

-spec delete_account(map(), mhttp:request_options()) -> term().
delete_account(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_shipping_rates_shipping_rate_token(map()) -> term().
post_shipping_rates_shipping_rate_token(Args) ->
    post_shipping_rates_shipping_rate_token(Args, #{}).

-spec post_shipping_rates_shipping_rate_token(map(), mhttp:request_options()) -> term().
post_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates/~s", [VarShippingRateToken]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_shipping_rates_shipping_rate_token(map()) -> term().
get_shipping_rates_shipping_rate_token(Args) ->
    get_shipping_rates_shipping_rate_token(Args, #{}).

-spec get_shipping_rates_shipping_rate_token(map(), mhttp:request_options()) -> term().
get_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates/~s", [VarShippingRateToken]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_upcoming_lines(map()) -> term().
get_invoices_upcoming_lines(Args) ->
    get_invoices_upcoming_lines(Args, #{}).

-spec get_invoices_upcoming_lines(map(), mhttp:request_options()) -> term().
get_invoices_upcoming_lines(Args, Options) ->
    EncodeQuery =
        fun ({automatic_tax, _Value}) ->
                {<<"automatic_tax">>, <<>>};
            ({coupon, _Value}) ->
                {<<"coupon">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({customer_details, _Value}) ->
                {<<"customer_details">>, <<>>};
            ({discounts, _Value}) ->
                {<<"discounts">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice_items, _Value}) ->
                {<<"invoice_items">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({schedule, _Value}) ->
                {<<"schedule">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>};
            ({subscription_billing_cycle_anchor, _Value}) ->
                {<<"subscription_billing_cycle_anchor">>, <<>>};
            ({subscription_cancel_at, _Value}) ->
                {<<"subscription_cancel_at">>, <<>>};
            ({subscription_cancel_at_period_end, _Value}) ->
                {<<"subscription_cancel_at_period_end">>, <<>>};
            ({subscription_cancel_now, _Value}) ->
                {<<"subscription_cancel_now">>, <<>>};
            ({subscription_default_tax_rates, _Value}) ->
                {<<"subscription_default_tax_rates">>, <<>>};
            ({subscription_items, _Value}) ->
                {<<"subscription_items">>, <<>>};
            ({subscription_proration_behavior, _Value}) ->
                {<<"subscription_proration_behavior">>, <<>>};
            ({subscription_proration_date, _Value}) ->
                {<<"subscription_proration_date">>, <<>>};
            ({subscription_start_date, _Value}) ->
                {<<"subscription_start_date">>, <<>>};
            ({subscription_trial_end, _Value}) ->
                {<<"subscription_trial_end">>, <<>>};
            ({subscription_trial_from_plan, _Value}) ->
                {<<"subscription_trial_from_plan">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([automatic_tax,
                                 coupon,
                                 customer,
                                 customer_details,
                                 discounts,
                                 ending_before,
                                 expand,
                                 invoice_items,
                                 limit,
                                 schedule,
                                 starting_after,
                                 subscription,
                                 subscription_billing_cycle_anchor,
                                 subscription_cancel_at,
                                 subscription_cancel_at_period_end,
                                 subscription_cancel_now,
                                 subscription_default_tax_rates,
                                 subscription_items,
                                 subscription_proration_behavior,
                                 subscription_proration_date,
                                 subscription_start_date,
                                 subscription_trial_end,
                                 subscription_trial_from_plan],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/upcoming/lines", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cardholders(map()) -> term().
post_issuing_cardholders(Args) ->
    post_issuing_cardholders(Args, #{}).

-spec post_issuing_cardholders(map(), mhttp:request_options()) -> term().
post_issuing_cardholders(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cardholders(map()) -> term().
get_issuing_cardholders(Args) ->
    get_issuing_cardholders(Args, #{}).

-spec get_issuing_cardholders(map(), mhttp:request_options()) -> term().
get_issuing_cardholders(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({email, _Value}) ->
                {<<"email">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({phone_number, _Value}) ->
                {<<"phone_number">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 email,
                                 ending_before,
                                 expand,
                                 limit,
                                 phone_number,
                                 starting_after,
                                 status,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources_id(map()) -> term().
post_customers_customer_sources_id(Args) ->
    post_customers_customer_sources_id(Args, #{}).

-spec post_customers_customer_sources_id(map(), mhttp:request_options()) -> term().
post_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_sources_id(map()) -> term().
get_customers_customer_sources_id(Args) ->
    get_customers_customer_sources_id(Args, #{}).

-spec get_customers_customer_sources_id(map(), mhttp:request_options()) -> term().
get_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_sources_id(map()) -> term().
delete_customers_customer_sources_id(Args) ->
    delete_customers_customer_sources_id(Args, #{}).

-spec delete_customers_customer_sources_id(map(), mhttp:request_options()) -> term().
delete_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees(map()) -> term().
get_application_fees(Args) ->
    get_application_fees(Args, #{}).

-spec get_application_fees(map(), mhttp:request_options()) -> term().
get_application_fees(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge, created, ending_before, expand, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers(map()) -> term().
get_bitcoin_receivers(Args) ->
    get_bitcoin_receivers(Args, #{}).

-spec get_bitcoin_receivers(map(), mhttp:request_options()) -> term().
get_bitcoin_receivers(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({filled, _Value}) ->
                {<<"filled">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({uncaptured_funds, _Value}) ->
                {<<"uncaptured_funds">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 ending_before,
                                 expand,
                                 filled,
                                 limit,
                                 starting_after,
                                 uncaptured_funds],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/receivers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_refunds_refund(map()) -> term().
post_refunds_refund(Args) ->
    post_refunds_refund(Args, #{}).

-spec post_refunds_refund(map(), mhttp:request_options()) -> term().
post_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds/~s", [VarRefund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_refunds_refund(map()) -> term().
get_refunds_refund(Args) ->
    get_refunds_refund(Args, #{}).

-spec get_refunds_refund(map(), mhttp:request_options()) -> term().
get_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds/~s", [VarRefund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_login_links(map()) -> term().
post_account_login_links(Args) ->
    post_account_login_links(Args, #{}).

-spec post_account_login_links(map(), mhttp:request_options()) -> term().
post_account_login_links(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/login_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tax_rates(map()) -> term().
post_tax_rates(Args) ->
    post_tax_rates(Args, #{}).

-spec post_tax_rates(map(), mhttp:request_options()) -> term().
post_tax_rates(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_rates(map()) -> term().
get_tax_rates(Args) ->
    get_tax_rates(Args, #{}).

-spec get_tax_rates(map(), mhttp:request_options()) -> term().
get_tax_rates(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({inclusive, _Value}) ->
                {<<"inclusive">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 ending_before,
                                 expand,
                                 inclusive,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_people(map()) -> term().
post_accounts_account_people(Args) ->
    post_accounts_account_people(Args, #{}).

-spec post_accounts_account_people(map(), mhttp:request_options()) -> term().
post_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_people(map()) -> term().
get_accounts_account_people(Args) ->
    get_accounts_account_people(Args, #{}).

-spec get_accounts_account_people(map(), mhttp:request_options()) -> term().
get_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({relationship, _Value}) ->
                {<<"relationship">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, relationship, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/~s/people", [VarAccount]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes_dispute_submit(map()) -> term().
post_issuing_disputes_dispute_submit(Args) ->
    post_issuing_disputes_dispute_submit(Args, #{}).

-spec post_issuing_disputes_dispute_submit(map(), mhttp:request_options()) -> term().
post_issuing_disputes_dispute_submit(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes/~s/submit", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources_source(map()) -> term().
post_sources_source(Args) ->
    post_sources_source(Args, #{}).

-spec post_sources_source(map(), mhttp:request_options()) -> term().
post_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/~s", [VarSource]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source(map()) -> term().
get_sources_source(Args) ->
    get_sources_source(Args, #{}).

-spec get_sources_source(map(), mhttp:request_options()) -> term().
get_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    EncodeQuery =
        fun ({client_secret, _Value}) ->
                {<<"client_secret">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([client_secret, expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/~s", [VarSource]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions_session(map()) -> term().
get_checkout_sessions_session(Args) ->
    get_checkout_sessions_session(Args, #{}).

-spec get_checkout_sessions_session(map(), mhttp:request_options()) -> term().
get_checkout_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions/~s", [VarSession]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods_payment_method_detach(map()) -> term().
post_payment_methods_payment_method_detach(Args) ->
    post_payment_methods_payment_method_detach(Args, #{}).

-spec post_payment_methods_payment_method_detach(map(), mhttp:request_options()) ->
                                                    term().
post_payment_methods_payment_method_detach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/~s/detach", [VarPaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers(map()) -> term().
post_customers(Args) ->
    post_customers(Args, #{}).

-spec post_customers(map(), mhttp:request_options()) -> term().
post_customers(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers(map()) -> term().
get_customers(Args) ->
    get_customers(Args, #{}).

-spec get_customers(map(), mhttp:request_options()) -> term().
get_customers(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({email, _Value}) ->
                {<<"email">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, email, ending_before, expand, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_bank_accounts(map()) -> term().
post_account_bank_accounts(Args) ->
    post_account_bank_accounts(Args, #{}).

-spec post_account_bank_accounts(map(), mhttp:request_options()) -> term().
post_account_bank_accounts(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes_dispute(map()) -> term().
post_issuing_disputes_dispute(Args) ->
    post_issuing_disputes_dispute(Args, #{}).

-spec post_issuing_disputes_dispute(map(), mhttp:request_options()) -> term().
post_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes/~s", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_disputes_dispute(map()) -> term().
get_issuing_disputes_dispute(Args) ->
    get_issuing_disputes_dispute(Args, #{}).

-spec get_issuing_disputes_dispute(map(), mhttp:request_options()) -> term().
get_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes/~s", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_disputes_dispute_close(map()) -> term().
post_disputes_dispute_close(Args) ->
    post_disputes_dispute_close(Args, #{}).

-spec post_disputes_dispute_close(map(), mhttp:request_options()) -> term().
post_disputes_dispute_close(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes/~s/close", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_cancel(map()) -> term().
post_quotes_quote_cancel(Args) ->
    post_quotes_quote_cancel(Args, #{}).

-spec post_quotes_quote_cancel(map(), mhttp:request_options()) -> term().
post_quotes_quote_cancel(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/cancel", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_payment_methods(map()) -> term().
get_customers_customer_payment_methods(Args) ->
    get_customers_customer_payment_methods(Args, #{}).

-spec get_customers_customer_payment_methods(map(), mhttp:request_options()) -> term().
get_customers_customer_payment_methods(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after, type], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/payment_methods", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_refunds(map()) -> term().
post_refunds(Args) ->
    post_refunds(Args, #{}).

-spec post_refunds(map(), mhttp:request_options()) -> term().
post_refunds(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_refunds(map()) -> term().
get_refunds(Args) ->
    get_refunds(Args, #{}).

-spec get_refunds(map(), mhttp:request_options()) -> term().
get_refunds(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes_id(map()) -> term().
post_credit_notes_id(Args) ->
    post_credit_notes_id(Args, #{}).

-spec post_credit_notes_id(map(), mhttp:request_options()) -> term().
post_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_id(map()) -> term().
get_credit_notes_id(Args) ->
    get_credit_notes_id(Args, #{}).

-spec get_credit_notes_id(map(), mhttp:request_options()) -> term().
get_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_transactions(map()) -> term().
get_bitcoin_transactions(Args) ->
    get_bitcoin_transactions(Args, #{}).

-spec get_bitcoin_transactions(map(), mhttp:request_options()) -> term().
get_bitcoin_transactions(Args, Options) ->
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({receiver, _Value}) ->
                {<<"receiver">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, limit, receiver, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/transactions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents(map()) -> term().
post_setup_intents(Args) ->
    post_setup_intents(Args, #{}).

-spec post_setup_intents(map(), mhttp:request_options()) -> term().
post_setup_intents(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_intents(map()) -> term().
get_setup_intents(Args) ->
    get_setup_intents(Args, #{}).

-spec get_setup_intents(map(), mhttp:request_options()) -> term().
get_setup_intents(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_method, _Value}) ->
                {<<"payment_method">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_method,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout_cancel(map()) -> term().
post_payouts_payout_cancel(Args) ->
    post_payouts_payout_cancel(Args, #{}).

-spec post_payouts_payout_cancel(map(), mhttp:request_options()) -> term().
post_payouts_payout_cancel(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/~s/cancel", [VarPayout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_authorizations_authorization_approve(map()) -> term().
post_issuing_authorizations_authorization_approve(Args) ->
    post_issuing_authorizations_authorization_approve(Args, #{}).

-spec post_issuing_authorizations_authorization_approve(map(), mhttp:request_options()) ->
                                                           term().
post_issuing_authorizations_authorization_approve(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s/approve", [VarAuthorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_authorizations_authorization_decline(map()) -> term().
post_issuing_authorizations_authorization_decline(Args) ->
    post_issuing_authorizations_authorization_decline(Args, #{}).

-spec post_issuing_authorizations_authorization_decline(map(), mhttp:request_options()) ->
                                                           term().
post_issuing_authorizations_authorization_decline(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s/decline", [VarAuthorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_reporting_report_runs(map()) -> term().
post_reporting_report_runs(Args) ->
    post_reporting_report_runs(Args, #{}).

-spec post_reporting_report_runs(map(), mhttp:request_options()) -> term().
post_reporting_report_runs(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_runs(map()) -> term().
get_reporting_report_runs(Args) ->
    get_reporting_report_runs(Args, #{}).

-spec get_reporting_report_runs(map(), mhttp:request_options()) -> term().
get_reporting_report_runs(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_void(map()) -> term().
post_invoices_invoice_void(Args) ->
    post_invoices_invoice_void(Args, #{}).

-spec post_invoices_invoice_void(map(), mhttp:request_options()) -> term().
post_invoices_invoice_void(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/~s/void", [VarInvoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources(map()) -> term().
post_sources(Args) ->
    post_sources(Args, #{}).

-spec post_sources(map(), mhttp:request_options()) -> term().
post_sources(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_configurations(map()) -> term().
post_billing_portal_configurations(Args) ->
    post_billing_portal_configurations(Args, #{}).

-spec post_billing_portal_configurations(map(), mhttp:request_options()) -> term().
post_billing_portal_configurations(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_billing_portal_configurations(map()) -> term().
get_billing_portal_configurations(Args) ->
    get_billing_portal_configurations(Args, #{}).

-spec get_billing_portal_configurations(map(), mhttp:request_options()) -> term().
get_billing_portal_configurations(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({is_default, _Value}) ->
                {<<"is_default">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active, ending_before, expand, is_default, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes(map()) -> term().
post_quotes(Args) ->
    post_quotes(Args, #{}).

-spec post_quotes(map(), mhttp:request_options()) -> term().
post_quotes(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes(map()) -> term().
get_quotes(Args) ->
    get_quotes(Args, #{}).

-spec get_quotes(map(), mhttp:request_options()) -> term().
get_quotes(Args, Options) ->
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, limit, starting_after, status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_transfer(map()) -> term().
post_transfers_transfer(Args) ->
    post_transfers_transfer(Args, #{}).

-spec post_transfers_transfer(map(), mhttp:request_options()) -> term().
post_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s", [VarTransfer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_transfer(map()) -> term().
get_transfers_transfer(Args) ->
    get_transfers_transfer(Args, #{}).

-spec get_transfers_transfer(map(), mhttp:request_options()) -> term().
get_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/~s", [VarTransfer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_line_items(map()) -> term().
get_quotes_quote_line_items(Args) ->
    get_quotes_quote_line_items(Args, #{}).

-spec get_quotes_quote_line_items(map(), mhttp:request_options()) -> term().
get_quotes_quote_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/line_items", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoiceitems_invoiceitem(map()) -> term().
post_invoiceitems_invoiceitem(Args) ->
    post_invoiceitems_invoiceitem(Args, #{}).

-spec post_invoiceitems_invoiceitem(map(), mhttp:request_options()) -> term().
post_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoiceitems_invoiceitem(map()) -> term().
get_invoiceitems_invoiceitem(Args) ->
    get_invoiceitems_invoiceitem(Args, #{}).

-spec get_invoiceitems_invoiceitem(map(), mhttp:request_options()) -> term().
get_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_invoiceitems_invoiceitem(map()) -> term().
delete_invoiceitems_invoiceitem(Args) ->
    delete_invoiceitems_invoiceitem(Args, #{}).

-spec delete_invoiceitems_invoiceitem(map(), mhttp:request_options()) -> term().
delete_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_capture(map()) -> term().
post_payment_intents_intent_capture(Args) ->
    post_payment_intents_intent_capture(Args, #{}).

-spec post_payment_intents_intent_capture(map(), mhttp:request_options()) -> term().
post_payment_intents_intent_capture(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s/capture", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cards(map()) -> term().
post_issuing_cards(Args) ->
    post_issuing_cards(Args, #{}).

-spec post_issuing_cards(map(), mhttp:request_options()) -> term().
post_issuing_cards(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cards(map()) -> term().
get_issuing_cards(Args) ->
    get_issuing_cards(Args, #{}).

-spec get_issuing_cards(map(), mhttp:request_options()) -> term().
get_issuing_cards(Args, Options) ->
    EncodeQuery =
        fun ({cardholder, _Value}) ->
                {<<"cardholder">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({exp_month, _Value}) ->
                {<<"exp_month">>, <<>>};
            ({exp_year, _Value}) ->
                {<<"exp_year">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({last4, _Value}) ->
                {<<"last4">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([cardholder,
                                 created,
                                 ending_before,
                                 exp_month,
                                 exp_year,
                                 expand,
                                 last4,
                                 limit,
                                 starting_after,
                                 status,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source_source_transactions(map()) -> term().
get_sources_source_source_transactions(Args) ->
    get_sources_source_source_transactions(Args, #{}).

-spec get_sources_source_source_transactions(map(), mhttp:request_options()) -> term().
get_sources_source_source_transactions(Args, Options) ->
    VarSource = maps:get(source, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/~s/source_transactions", [VarSource]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules_schedule_release(map()) -> term().
post_subscription_schedules_schedule_release(Args) ->
    post_subscription_schedules_schedule_release(Args, #{}).

-spec post_subscription_schedules_schedule_release(map(), mhttp:request_options()) ->
                                                      term().
post_subscription_schedules_schedule_release(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/~s/release", [VarSchedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_cards_id(map()) -> term().
post_customers_customer_cards_id(Args) ->
    post_customers_customer_cards_id(Args, #{}).

-spec post_customers_customer_cards_id(map(), mhttp:request_options()) -> term().
post_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_cards_id(map()) -> term().
get_customers_customer_cards_id(Args) ->
    get_customers_customer_cards_id(Args, #{}).

-spec get_customers_customer_cards_id(map(), mhttp:request_options()) -> term().
get_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_cards_id(map()) -> term().
delete_customers_customer_cards_id(Args) ->
    delete_customers_customer_cards_id(Args, #{}).

-spec delete_customers_customer_cards_id(map(), mhttp:request_options()) -> term().
delete_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_dispute(map()) -> term().
post_charges_charge_dispute(Args) ->
    post_charges_charge_dispute(Args, #{}).

-spec post_charges_charge_dispute(map(), mhttp:request_options()) -> term().
post_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/dispute", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_dispute(map()) -> term().
get_charges_charge_dispute(Args) ->
    get_charges_charge_dispute(Args, #{}).

-spec get_charges_charge_dispute(map(), mhttp:request_options()) -> term().
get_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/~s/dispute", [VarCharge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_finalize(map()) -> term().
post_quotes_quote_finalize(Args) ->
    post_quotes_quote_finalize(Args, #{}).

-spec post_quotes_quote_finalize(map(), mhttp:request_options()) -> term().
post_quotes_quote_finalize(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/~s/finalize", [VarQuote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_skus_id(map()) -> term().
post_skus_id(Args) ->
    post_skus_id(Args, #{}).

-spec post_skus_id(map(), mhttp:request_options()) -> term().
post_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_skus_id(map()) -> term().
get_skus_id(Args) ->
    get_skus_id(Args, #{}).

-spec get_skus_id(map(), mhttp:request_options()) -> term().
get_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_skus_id(map()) -> term().
delete_skus_id(Args) ->
    delete_skus_id(Args, #{}).

-spec delete_skus_id(map(), mhttp:request_options()) -> term().
delete_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_disputes_dispute(map()) -> term().
post_disputes_dispute(Args) ->
    post_disputes_dispute(Args, #{}).

-spec post_disputes_dispute(map(), mhttp:request_options()) -> term().
post_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes/~s", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_disputes_dispute(map()) -> term().
get_disputes_dispute(Args) ->
    get_disputes_dispute(Args, #{}).

-spec get_disputes_dispute(map(), mhttp:request_options()) -> term().
get_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes/~s", [VarDispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_locations(map()) -> term().
post_terminal_locations(Args) ->
    post_terminal_locations(Args, #{}).

-spec post_terminal_locations(map(), mhttp:request_options()) -> term().
post_terminal_locations(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_locations(map()) -> term().
get_terminal_locations(Args) ->
    get_terminal_locations(Args, #{}).

-spec get_terminal_locations(map(), mhttp:request_options()) -> term().
get_terminal_locations(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules(map()) -> term().
post_subscription_schedules(Args) ->
    post_subscription_schedules(Args, #{}).

-spec post_subscription_schedules(map(), mhttp:request_options()) -> term().
post_subscription_schedules(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_schedules(map()) -> term().
get_subscription_schedules(Args) ->
    get_subscription_schedules(Args, #{}).

-spec get_subscription_schedules(map(), mhttp:request_options()) -> term().
get_subscription_schedules(Args, Options) ->
    EncodeQuery =
        fun ({canceled_at, _Value}) ->
                {<<"canceled_at">>, <<>>};
            ({completed_at, _Value}) ->
                {<<"completed_at">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({released_at, _Value}) ->
                {<<"released_at">>, <<>>};
            ({scheduled, _Value}) ->
                {<<"scheduled">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([canceled_at,
                                 completed_at,
                                 created,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 released_at,
                                 scheduled,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_links(map()) -> term().
post_payment_links(Args) ->
    post_payment_links(Args, #{}).

-spec post_payment_links(map(), mhttp:request_options()) -> term().
post_payment_links(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links(map()) -> term().
get_payment_links(Args) ->
    get_payment_links(Args, #{}).

-spec get_payment_links(map(), mhttp:request_options()) -> term().
get_payment_links(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tokens(map()) -> term().
post_tokens(Args) ->
    post_tokens(Args, #{}).

-spec post_tokens(map(), mhttp:request_options()) -> term().
post_tokens(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/tokens", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cardholders_cardholder(map()) -> term().
post_issuing_cardholders_cardholder(Args) ->
    post_issuing_cardholders_cardholder(Args, #{}).

-spec post_issuing_cardholders_cardholder(map(), mhttp:request_options()) -> term().
post_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders/~s", [VarCardholder]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cardholders_cardholder(map()) -> term().
get_issuing_cardholders_cardholder(Args) ->
    get_issuing_cardholders_cardholder(Args, #{}).

-spec get_issuing_cardholders_cardholder(map(), mhttp:request_options()) -> term().
get_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders/~s", [VarCardholder]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_id(map()) -> term().
get_application_fees_id(Args) ->
    get_application_fees_id(Args, #{}).

-spec get_application_fees_id(map(), mhttp:request_options()) -> term().
get_application_fees_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_exchange_rates_rate_id(map()) -> term().
get_exchange_rates_rate_id(Args) ->
    get_exchange_rates_rate_id(Args, #{}).

-spec get_exchange_rates_rate_id(map(), mhttp:request_options()) -> term().
get_exchange_rates_rate_id(Args, Options) ->
    VarRateId = maps:get(rate_id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/exchange_rates/~s", [VarRateId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_confirm(map()) -> term().
post_payment_intents_intent_confirm(Args) ->
    post_payment_intents_intent_confirm(Args, #{}).

-spec post_payment_intents_intent_confirm(map(), mhttp:request_options()) -> term().
post_payment_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/~s/confirm", [VarIntent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_preview(map()) -> term().
get_credit_notes_preview(Args) ->
    get_credit_notes_preview(Args, #{}).

-spec get_credit_notes_preview(map(), mhttp:request_options()) -> term().
get_credit_notes_preview(Args, Options) ->
    EncodeQuery =
        fun ({amount, _Value}) ->
                {<<"amount">>, <<>>};
            ({credit_amount, _Value}) ->
                {<<"credit_amount">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice, _Value}) ->
                {<<"invoice">>, <<>>};
            ({lines, _Value}) ->
                {<<"lines">>, <<>>};
            ({memo, _Value}) ->
                {<<"memo">>, <<>>};
            ({metadata, _Value}) ->
                {<<"metadata">>, <<>>};
            ({out_of_band_amount, _Value}) ->
                {<<"out_of_band_amount">>, <<>>};
            ({reason, _Value}) ->
                {<<"reason">>, <<>>};
            ({refund, _Value}) ->
                {<<"refund">>, <<>>};
            ({refund_amount, _Value}) ->
                {<<"refund_amount">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([amount,
                                 credit_amount,
                                 expand,
                                 invoice,
                                 lines,
                                 memo,
                                 metadata,
                                 out_of_band_amount,
                                 reason,
                                 refund,
                                 refund_amount],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/preview", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_history_id(map()) -> term().
get_balance_history_id(Args) ->
    get_balance_history_id(Args, #{}).

-spec get_balance_history_id(map(), mhttp:request_options()) -> term().
get_balance_history_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/balance/history/~s", [VarId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout_reverse(map()) -> term().
post_payouts_payout_reverse(Args) ->
    post_payouts_payout_reverse(Args, #{}).

-spec post_payouts_payout_reverse(map(), mhttp:request_options()) -> term().
post_payouts_payout_reverse(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/~s/reverse", [VarPayout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_runs_report_run(map()) -> term().
get_reporting_report_runs_report_run(Args) ->
    get_reporting_report_runs_report_run(Args, #{}).

-spec get_reporting_report_runs_report_run(map(), mhttp:request_options()) -> term().
get_reporting_report_runs_report_run(Args, Options) ->
    VarReportRun = maps:get(report_run, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_runs/~s", [VarReportRun]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source_source_transactions_source_transaction(map()) -> term().
get_sources_source_source_transactions_source_transaction(Args) ->
    get_sources_source_source_transactions_source_transaction(Args, #{}).

-spec get_sources_source_source_transactions_source_transaction(map(),
                                                                mhttp:request_options()) ->
                                                                   term().
get_sources_source_source_transactions_source_transaction(Args, Options) ->
    VarSource = maps:get(source, Args),
    VarSourceTransaction = maps:get(source_transaction, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath =
        io_lib:format("/v1/sources/~s/source_transactions/~s", [VarSource, VarSourceTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer(map()) -> term().
post_customers_customer(Args) ->
    post_customers_customer(Args, #{}).

-spec post_customers_customer(map(), mhttp:request_options()) -> term().
post_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer(map()) -> term().
get_customers_customer(Args) ->
    get_customers_customer(Args, #{}).

-spec get_customers_customer(map(), mhttp:request_options()) -> term().
get_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer(map()) -> term().
delete_customers_customer(Args) ->
    delete_customers_customer(Args, #{}).

-spec delete_customers_customer(map(), mhttp:request_options()) -> term().
delete_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_sessions(map()) -> term().
post_billing_portal_sessions(Args) ->
    post_billing_portal_sessions(Args, #{}).

-spec post_billing_portal_sessions(map(), mhttp:request_options()) -> term().
post_billing_portal_sessions(_Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_links_payment_link(map()) -> term().
post_payment_links_payment_link(Args) ->
    post_payment_links_payment_link(Args, #{}).

-spec post_payment_links_payment_link(map(), mhttp:request_options()) -> term().
post_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links/~s", [VarPaymentLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links_payment_link(map()) -> term().
get_payment_links_payment_link(Args) ->
    get_payment_links_payment_link(Args, #{}).

-spec get_payment_links_payment_link(map(), mhttp:request_options()) -> term().
get_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links/~s", [VarPaymentLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_credit_note_lines(map()) -> term().
get_credit_notes_credit_note_lines(Args) ->
    get_credit_notes_credit_note_lines(Args, #{}).

-spec get_credit_notes_credit_note_lines(map(), mhttp:request_options()) -> term().
get_credit_notes_credit_note_lines(Args, Options) ->
    VarCreditNote = maps:get(credit_note, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/~s/lines", [VarCreditNote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sigma_scheduled_query_runs(map()) -> term().
get_sigma_scheduled_query_runs(Args) ->
    get_sigma_scheduled_query_runs(Args, #{}).

-spec get_sigma_scheduled_query_runs(map(), mhttp:request_options()) -> term().
get_sigma_scheduled_query_runs(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    _ReqBody = [],
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.
