%% File generated by erl-openapi on "2022-02-25T12:01:17Z".

-module(stripe_client).

-spec get_radar_early_fraud_warnings(map()) -> term().
get_radar_early_fraud_warnings(Args) ->
    get_radar_early_fraud_warnings(Args, #{}).

-spec get_radar_early_fraud_warnings(map(), mhttp:request_options()) -> term().
get_radar_early_fraud_warnings(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refunds(map()) -> term().
post_charges_charge_refunds(Args) ->
    post_charges_charge_refunds(Args, #{}).

-spec post_charges_charge_refunds(map(), mhttp:request_options()) -> term().
post_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s/refunds", [Charge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_refunds(map()) -> term().
get_charges_charge_refunds(Args) ->
    get_charges_charge_refunds(Args, #{}).

-spec get_charges_charge_refunds(map(), mhttp:request_options()) -> term().
get_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s/refunds", [Charge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_identity_verification_sessions_session_redact(map()) -> term().
post_identity_verification_sessions_session_redact(Args) ->
    post_identity_verification_sessions_session_redact(Args, #{}).

-spec post_identity_verification_sessions_session_redact(map(),
                                                         mhttp:request_options()) ->
                                                            term().
post_identity_verification_sessions_session_redact(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/%s/redact", [Session]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_configurations_configuration(map()) -> term().
post_billing_portal_configurations_configuration(Args) ->
    post_billing_portal_configurations_configuration(Args, #{}).

-spec post_billing_portal_configurations_configuration(map(), mhttp:request_options()) ->
                                                          term().
post_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations/%s", [Configuration]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_billing_portal_configurations_configuration(map()) -> term().
get_billing_portal_configurations_configuration(Args) ->
    get_billing_portal_configurations_configuration(Args, #{}).

-spec get_billing_portal_configurations_configuration(map(), mhttp:request_options()) ->
                                                         term().
get_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations/%s", [Configuration]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods(map()) -> term().
post_payment_methods(Args) ->
    post_payment_methods(Args, #{}).

-spec post_payment_methods(map(), mhttp:request_options()) -> term().
post_payment_methods(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_methods(map()) -> term().
get_payment_methods(Args) ->
    get_payment_methods(Args, #{}).

-spec get_payment_methods(map(), mhttp:request_options()) -> term().
get_payment_methods(Args, Options) ->
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, limit, starting_after, type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_lists_value_list(map()) -> term().
post_radar_value_lists_value_list(Args) ->
    post_radar_value_lists_value_list(Args, #{}).

-spec post_radar_value_lists_value_list(map(), mhttp:request_options()) -> term().
post_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists/%s", [ValueList]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_lists_value_list(map()) -> term().
get_radar_value_lists_value_list(Args) ->
    get_radar_value_lists_value_list(Args, #{}).

-spec get_radar_value_lists_value_list(map(), mhttp:request_options()) -> term().
get_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists/%s", [ValueList]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_radar_value_lists_value_list(map()) -> term().
delete_radar_value_lists_value_list(Args) ->
    delete_radar_value_lists_value_list(Args, #{}).

-spec delete_radar_value_lists_value_list(map(), mhttp:request_options()) -> term().
delete_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists/%s", [ValueList]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_capture(map()) -> term().
post_charges_charge_capture(Args) ->
    post_charges_charge_capture(Args, #{}).

-spec post_charges_charge_capture(map(), mhttp:request_options()) -> term().
post_charges_charge_capture(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s/capture", [Charge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_disputes(map()) -> term().
get_disputes(Args) ->
    get_disputes(Args, #{}).

-spec get_disputes(map(), mhttp:request_options()) -> term().
get_disputes(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_prices_price(map()) -> term().
post_prices_price(Args) ->
    post_prices_price(Args, #{}).

-spec post_prices_price(map(), mhttp:request_options()) -> term().
post_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/prices/%s", [Price]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_prices_price(map()) -> term().
get_prices_price(Args) ->
    get_prices_price(Args, #{}).

-spec get_prices_price(map(), mhttp:request_options()) -> term().
get_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/prices/%s", [Price]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts(map()) -> term().
post_accounts(Args) ->
    post_accounts(Args, #{}).

-spec post_accounts(map(), mhttp:request_options()) -> term().
post_accounts(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts(map()) -> term().
get_accounts(Args) ->
    get_accounts(Args, #{}).

-spec get_accounts(map(), mhttp:request_options()) -> term().
get_accounts(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_identity_verification_sessions_session_cancel(map()) -> term().
post_identity_verification_sessions_session_cancel(Args) ->
    post_identity_verification_sessions_session_cancel(Args, #{}).

-spec post_identity_verification_sessions_session_cancel(map(),
                                                         mhttp:request_options()) ->
                                                            term().
post_identity_verification_sessions_session_cancel(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/%s/cancel", [Session]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_persons_person(map()) -> term().
post_account_persons_person(Args) ->
    post_account_persons_person(Args, #{}).

-spec post_account_persons_person(map(), mhttp:request_options()) -> term().
post_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons/%s", [Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_persons_person(map()) -> term().
get_account_persons_person(Args) ->
    get_account_persons_person(Args, #{}).

-spec get_account_persons_person(map(), mhttp:request_options()) -> term().
get_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons/%s", [Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_persons_person(map()) -> term().
delete_account_persons_person(Args) ->
    delete_account_persons_person(Args, #{}).

-spec delete_account_persons_person(map(), mhttp:request_options()) -> term().
delete_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons/%s", [Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_authorizations_authorization(map()) -> term().
post_issuing_authorizations_authorization(Args) ->
    post_issuing_authorizations_authorization(Args, #{}).

-spec post_issuing_authorizations_authorization(map(), mhttp:request_options()) -> term().
post_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/%s", [Authorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_authorizations_authorization(map()) -> term().
get_issuing_authorizations_authorization(Args) ->
    get_issuing_authorizations_authorization(Args, #{}).

-spec get_issuing_authorizations_authorization(map(), mhttp:request_options()) -> term().
get_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/%s", [Authorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_files_file(map()) -> term().
get_files_file(Args) ->
    get_files_file(Args, #{}).

-spec get_files_file(map(), mhttp:request_options()) -> term().
get_files_file(Args, Options) ->
    VarFile = maps:get(file, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/files/%s", [File]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cards_card(map()) -> term().
post_issuing_cards_card(Args) ->
    post_issuing_cards_card(Args, #{}).

-spec post_issuing_cards_card(map(), mhttp:request_options()) -> term().
post_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards/%s", [Card]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cards_card(map()) -> term().
get_issuing_cards_card(Args) ->
    get_issuing_cards_card(Args, #{}).

-spec get_issuing_cards_card(map(), mhttp:request_options()) -> term().
get_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards/%s", [Card]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources_source_verify(map()) -> term().
post_sources_source_verify(Args) ->
    post_sources_source_verify(Args, #{}).

-spec post_sources_source_verify(map(), mhttp:request_options()) -> term().
post_sources_source_verify(Args, Options) ->
    VarSource = maps:get(source, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/%s/verify", [Source]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoiceitems(map()) -> term().
post_invoiceitems(Args) ->
    post_invoiceitems(Args, #{}).

-spec post_invoiceitems(map(), mhttp:request_options()) -> term().
post_invoiceitems(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoiceitems(map()) -> term().
get_invoiceitems(Args) ->
    get_invoiceitems(Args, #{}).

-spec get_invoiceitems(map(), mhttp:request_options()) -> term().
get_invoiceitems(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice, _Value}) ->
                {<<"invoice">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({pending, _Value}) ->
                {<<"pending">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 customer,
                                 ending_before,
                                 expand,
                                 invoice,
                                 limit,
                                 pending,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_ephemeral_keys_key(map()) -> term().
delete_ephemeral_keys_key(Args) ->
    delete_ephemeral_keys_key(Args, #{}).

-spec delete_ephemeral_keys_key(map(), mhttp:request_options()) -> term().
delete_ephemeral_keys_key(Args, Options) ->
    VarKey = maps:get(key, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/ephemeral_keys/%s", [Key]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_exchange_rates(map()) -> term().
get_exchange_rates(Args) ->
    get_exchange_rates(Args, #{}).

-spec get_exchange_rates(map(), mhttp:request_options()) -> term().
get_exchange_rates(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/exchange_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent(map()) -> term().
post_setup_intents_intent(Args) ->
    post_setup_intents_intent(Args, #{}).

-spec post_setup_intents_intent(map(), mhttp:request_options()) -> term().
post_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/%s", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_intents_intent(map()) -> term().
get_setup_intents_intent(Args) ->
    get_setup_intents_intent(Args, #{}).

-spec get_setup_intents_intent(map(), mhttp:request_options()) -> term().
get_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    EncodeQuery =
        fun ({client_secret, _Value}) ->
                {<<"client_secret">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([client_secret, expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/%s", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_files(map()) -> term().
post_files(Args) ->
    post_files(Args, #{}).

-spec post_files(map(), mhttp:request_options()) -> term().
post_files(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/files", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_files(map()) -> term().
get_files(Args) ->
    get_files(Args, #{}).

-spec get_files(map(), mhttp:request_options()) -> term().
get_files(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({purpose, _Value}) ->
                {<<"purpose">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, purpose, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/files", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_bank_accounts_id(map()) -> term().
post_customers_customer_bank_accounts_id(Args) ->
    post_customers_customer_bank_accounts_id(Args, #{}).

-spec post_customers_customer_bank_accounts_id(map(), mhttp:request_options()) -> term().
post_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/bank_accounts/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_bank_accounts_id(map()) -> term().
get_customers_customer_bank_accounts_id(Args) ->
    get_customers_customer_bank_accounts_id(Args, #{}).

-spec get_customers_customer_bank_accounts_id(map(), mhttp:request_options()) -> term().
get_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/bank_accounts/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_bank_accounts_id(map()) -> term().
delete_customers_customer_bank_accounts_id(Args) ->
    delete_customers_customer_bank_accounts_id(Args, #{}).

-spec delete_customers_customer_bank_accounts_id(map(), mhttp:request_options()) ->
                                                    term().
delete_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/bank_accounts/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuer_fraud_records_issuer_fraud_record(map()) -> term().
get_issuer_fraud_records_issuer_fraud_record(Args) ->
    get_issuer_fraud_records_issuer_fraud_record(Args, #{}).

-spec get_issuer_fraud_records_issuer_fraud_record(map(), mhttp:request_options()) ->
                                                      term().
get_issuer_fraud_records_issuer_fraud_record(Args, Options) ->
    VarIssuerFraudRecord = maps:get(issuer_fraud_record, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuer_fraud_records/%s", [IssuerFraudRecord]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_people_person(map()) -> term().
post_accounts_account_people_person(Args) ->
    post_accounts_account_people_person(Args, #{}).

-spec post_accounts_account_people_person(map(), mhttp:request_options()) -> term().
post_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/people/%s", [Account, Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_people_person(map()) -> term().
get_accounts_account_people_person(Args) ->
    get_accounts_account_people_person(Args, #{}).

-spec get_accounts_account_people_person(map(), mhttp:request_options()) -> term().
get_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/people/%s", [Account, Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account_people_person(map()) -> term().
delete_accounts_account_people_person(Args) ->
    delete_accounts_account_people_person(Args, #{}).

-spec delete_accounts_account_people_person(map(), mhttp:request_options()) -> term().
delete_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/people/%s", [Account, Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts(map()) -> term().
post_payouts(Args) ->
    post_payouts(Args, #{}).

-spec post_payouts(map(), mhttp:request_options()) -> term().
post_payouts(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payouts(map()) -> term().
get_payouts(Args) ->
    get_payouts(Args, #{}).

-spec get_payouts(map(), mhttp:request_options()) -> term().
get_payouts(Args, Options) ->
    EncodeQuery =
        fun ({arrival_date, _Value}) ->
                {<<"arrival_date">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({destination, _Value}) ->
                {<<"destination">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([arrival_date,
                                 created,
                                 destination,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_capabilities_capability(map()) -> term().
post_account_capabilities_capability(Args) ->
    post_account_capabilities_capability(Args, #{}).

-spec post_account_capabilities_capability(map(), mhttp:request_options()) -> term().
post_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/capabilities/%s", [Capability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_capabilities_capability(map()) -> term().
get_account_capabilities_capability(Args) ->
    get_account_capabilities_capability(Args, #{}).

-spec get_account_capabilities_capability(map(), mhttp:request_options()) -> term().
get_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/capabilities/%s", [Capability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source_mandate_notifications_mandate_notification(map()) -> term().
get_sources_source_mandate_notifications_mandate_notification(Args) ->
    get_sources_source_mandate_notifications_mandate_notification(Args, #{}).

-spec get_sources_source_mandate_notifications_mandate_notification(map(),
                                                                    mhttp:request_options()) ->
                                                                       term().
get_sources_source_mandate_notifications_mandate_notification(Args, Options) ->
    VarMandateNotification = maps:get(mandate_notification, Args),
    VarSource = maps:get(source, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/sources/%s/mandate_notifications/%s", [Source, MandateNotification]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_fee_refunds_id(map()) -> term().
post_application_fees_fee_refunds_id(Args) ->
    post_application_fees_fee_refunds_id(Args, #{}).

-spec post_application_fees_fee_refunds_id(map(), mhttp:request_options()) -> term().
post_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/%s/refunds/%s", [Fee, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_fee_refunds_id(map()) -> term().
get_application_fees_fee_refunds_id(Args) ->
    get_application_fees_fee_refunds_id(Args, #{}).

-spec get_application_fees_fee_refunds_id(map(), mhttp:request_options()) -> term().
get_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/%s/refunds/%s", [Fee, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_discount(map()) -> term().
get_customers_customer_discount(Args) ->
    get_customers_customer_discount(Args, #{}).

-spec get_customers_customer_discount(map(), mhttp:request_options()) -> term().
get_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/discount", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_discount(map()) -> term().
delete_customers_customer_discount(Args) ->
    delete_customers_customer_discount(Args, #{}).

-spec delete_customers_customer_discount(map(), mhttp:request_options()) -> term().
delete_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/discount", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_coupons(map()) -> term().
post_coupons(Args) ->
    post_coupons(Args, #{}).

-spec post_coupons(map(), mhttp:request_options()) -> term().
post_coupons(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_coupons(map()) -> term().
get_coupons(Args) ->
    get_coupons(Args, #{}).

-spec get_coupons(map(), mhttp:request_options()) -> term().
get_coupons(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_dispute_close(map()) -> term().
post_charges_charge_dispute_close(Args) ->
    post_charges_charge_dispute_close(Args, #{}).

-spec post_charges_charge_dispute_close(map(), mhttp:request_options()) -> term().
post_charges_charge_dispute_close(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s/dispute/close", [Charge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_plans_plan(map()) -> term().
post_plans_plan(Args) ->
    post_plans_plan(Args, #{}).

-spec post_plans_plan(map(), mhttp:request_options()) -> term().
post_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/plans/%s", [Plan]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_plans_plan(map()) -> term().
get_plans_plan(Args) ->
    get_plans_plan(Args, #{}).

-spec get_plans_plan(map(), mhttp:request_options()) -> term().
get_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/plans/%s", [Plan]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_plans_plan(map()) -> term().
delete_plans_plan(Args) ->
    delete_plans_plan(Args, #{}).

-spec delete_plans_plan(map(), mhttp:request_options()) -> term().
delete_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/plans/%s", [Plan]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_bank_accounts(map()) -> term().
post_customers_customer_bank_accounts(Args) ->
    post_customers_customer_bank_accounts(Args, #{}).

-spec post_customers_customer_bank_accounts(map(), mhttp:request_options()) -> term().
post_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/bank_accounts", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_bank_accounts(map()) -> term().
get_customers_customer_bank_accounts(Args) ->
    get_customers_customer_bank_accounts(Args, #{}).

-spec get_customers_customer_bank_accounts(map(), mhttp:request_options()) -> term().
get_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/bank_accounts", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_readers_reader(map()) -> term().
post_terminal_readers_reader(Args) ->
    post_terminal_readers_reader(Args, #{}).

-spec post_terminal_readers_reader(map(), mhttp:request_options()) -> term().
post_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers/%s", [Reader]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_readers_reader(map()) -> term().
get_terminal_readers_reader(Args) ->
    get_terminal_readers_reader(Args, #{}).

-spec get_terminal_readers_reader(map(), mhttp:request_options()) -> term().
get_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers/%s", [Reader]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_terminal_readers_reader(map()) -> term().
delete_terminal_readers_reader(Args) ->
    delete_terminal_readers_reader(Args, #{}).

-spec delete_terminal_readers_reader(map(), mhttp:request_options()) -> term().
delete_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers/%s", [Reader]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_persons_person(map()) -> term().
post_accounts_account_persons_person(Args) ->
    post_accounts_account_persons_person(Args, #{}).

-spec post_accounts_account_persons_person(map(), mhttp:request_options()) -> term().
post_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/persons/%s", [Account, Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_persons_person(map()) -> term().
get_accounts_account_persons_person(Args) ->
    get_accounts_account_persons_person(Args, #{}).

-spec get_accounts_account_persons_person(map(), mhttp:request_options()) -> term().
get_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/persons/%s", [Account, Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account_persons_person(map()) -> term().
delete_accounts_account_persons_person(Args) ->
    delete_accounts_account_persons_person(Args, #{}).

-spec delete_accounts_account_persons_person(map(), mhttp:request_options()) -> term().
delete_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/persons/%s", [Account, Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes_id_void(map()) -> term().
post_credit_notes_id_void(Args) ->
    post_credit_notes_id_void(Args, #{}).

-spec post_credit_notes_id_void(map(), mhttp:request_options()) -> term().
post_credit_notes_id_void(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/%s/void", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources(map()) -> term().
post_customers_customer_sources(Args) ->
    post_customers_customer_sources(Args, #{}).

-spec post_customers_customer_sources(map(), mhttp:request_options()) -> term().
post_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/sources", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_sources(map()) -> term().
get_customers_customer_sources(Args) ->
    get_customers_customer_sources(Args, #{}).

-spec get_customers_customer_sources(map(), mhttp:request_options()) -> term().
get_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({object, _Value}) ->
                {<<"object">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, object, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/sources", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_links(map()) -> term().
post_account_links(Args) ->
    post_account_links(Args, #{}).

-spec post_account_links(map(), mhttp:request_options()) -> term().
post_account_links(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout(map()) -> term().
post_payouts_payout(Args) ->
    post_payouts_payout(Args, #{}).

-spec post_payouts_payout(map(), mhttp:request_options()) -> term().
post_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/%s", [Payout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payouts_payout(map()) -> term().
get_payouts_payout(Args) ->
    get_payouts_payout(Args, #{}).

-spec get_payouts_payout(map(), mhttp:request_options()) -> term().
get_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/%s", [Payout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items_item(map()) -> term().
post_subscription_items_item(Args) ->
    post_subscription_items_item(Args, #{}).

-spec post_subscription_items_item(map(), mhttp:request_options()) -> term().
post_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/%s", [Item]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items_item(map()) -> term().
get_subscription_items_item(Args) ->
    get_subscription_items_item(Args, #{}).

-spec get_subscription_items_item(map(), mhttp:request_options()) -> term().
get_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/%s", [Item]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_subscription_items_item(map()) -> term().
delete_subscription_items_item(Args) ->
    delete_subscription_items_item(Args, #{}).

-spec delete_subscription_items_item(map(), mhttp:request_options()) -> term().
delete_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/%s", [Item]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_products(map()) -> term().
post_products(Args) ->
    post_products(Args, #{}).

-spec post_products(map(), mhttp:request_options()) -> term().
post_products(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/products", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_products(map()) -> term().
get_products(Args) ->
    get_products(Args, #{}).

-spec get_products(map(), mhttp:request_options()) -> term().
get_products(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({ids, _Value}) ->
                {<<"ids">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({shippable, _Value}) ->
                {<<"shippable">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({url, _Value}) ->
                {<<"url">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 ending_before,
                                 expand,
                                 ids,
                                 limit,
                                 shippable,
                                 starting_after,
                                 url],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/products", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_types_report_type(map()) -> term().
get_reporting_report_types_report_type(Args) ->
    get_reporting_report_types_report_type(Args, #{}).

-spec get_reporting_report_types_report_type(map(), mhttp:request_options()) -> term().
get_reporting_report_types_report_type(Args, Options) ->
    VarReportType = maps:get(report_type, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_types/%s", [ReportType]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_accept(map()) -> term().
post_quotes_quote_accept(Args) ->
    post_quotes_quote_accept(Args, #{}).

-spec post_quotes_quote_accept(map(), mhttp:request_options()) -> term().
post_quotes_quote_accept(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/%s/accept", [Quote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_mandates_mandate(map()) -> term().
get_mandates_mandate(Args) ->
    get_mandates_mandate(Args, #{}).

-spec get_mandates_mandate(map(), mhttp:request_options()) -> term().
get_mandates_mandate(Args, Options) ->
    VarMandate = maps:get(mandate, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/mandates/%s", [Mandate]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_subscriptions(map()) -> term().
post_customers_customer_subscriptions(Args) ->
    post_customers_customer_subscriptions(Args, #{}).

-spec post_customers_customer_subscriptions(map(), mhttp:request_options()) -> term().
post_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/subscriptions", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_subscriptions(map()) -> term().
get_customers_customer_subscriptions(Args) ->
    get_customers_customer_subscriptions(Args, #{}).

-spec get_customers_customer_subscriptions(map(), mhttp:request_options()) -> term().
get_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/subscriptions", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_order_returns_id(map()) -> term().
get_order_returns_id(Args) ->
    get_order_returns_id(Args, #{}).

-spec get_order_returns_id(map(), mhttp:request_options()) -> term().
get_order_returns_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/order_returns/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_id_reversals(map()) -> term().
post_transfers_id_reversals(Args) ->
    post_transfers_id_reversals(Args, #{}).

-spec post_transfers_id_reversals(map(), mhttp:request_options()) -> term().
post_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/%s/reversals", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_id_reversals(map()) -> term().
get_transfers_id_reversals(Args) ->
    get_transfers_id_reversals(Args, #{}).

-spec get_transfers_id_reversals(map(), mhttp:request_options()) -> term().
get_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/%s/reversals", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reviews_review(map()) -> term().
get_reviews_review(Args) ->
    get_reviews_review(Args, #{}).

-spec get_reviews_review(map(), mhttp:request_options()) -> term().
get_reviews_review(Args, Options) ->
    VarReview = maps:get(review, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/reviews/%s", [Review]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_bank_accounts_id(map()) -> term().
post_accounts_account_bank_accounts_id(Args) ->
    post_accounts_account_bank_accounts_id(Args, #{}).

-spec post_accounts_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
post_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/bank_accounts/%s", [Account, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_bank_accounts_id(map()) -> term().
get_accounts_account_bank_accounts_id(Args) ->
    get_accounts_account_bank_accounts_id(Args, #{}).

-spec get_accounts_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
get_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/bank_accounts/%s", [Account, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account_bank_accounts_id(map()) -> term().
delete_accounts_account_bank_accounts_id(Args) ->
    delete_accounts_account_bank_accounts_id(Args, #{}).

-spec delete_accounts_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
delete_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/bank_accounts/%s", [Account, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_settlements_settlement(map()) -> term().
post_issuing_settlements_settlement(Args) ->
    post_issuing_settlements_settlement(Args, #{}).

-spec post_issuing_settlements_settlement(map(), mhttp:request_options()) -> term().
post_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/settlements/%s", [Settlement]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_settlements_settlement(map()) -> term().
get_issuing_settlements_settlement(Args) ->
    get_issuing_settlements_settlement(Args, #{}).

-spec get_issuing_settlements_settlement(map(), mhttp:request_options()) -> term().
get_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/settlements/%s", [Settlement]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_promotion_codes_promotion_code(map()) -> term().
post_promotion_codes_promotion_code(Args) ->
    post_promotion_codes_promotion_code(Args, #{}).

-spec post_promotion_codes_promotion_code(map(), mhttp:request_options()) -> term().
post_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes/%s", [PromotionCode]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_promotion_codes_promotion_code(map()) -> term().
get_promotion_codes_promotion_code(Args) ->
    get_promotion_codes_promotion_code(Args, #{}).

-spec get_promotion_codes_promotion_code(map(), mhttp:request_options()) -> term().
get_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes/%s", [PromotionCode]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules_schedule_cancel(map()) -> term().
post_subscription_schedules_schedule_cancel(Args) ->
    post_subscription_schedules_schedule_cancel(Args, #{}).

-spec post_subscription_schedules_schedule_cancel(map(), mhttp:request_options()) ->
                                                     term().
post_subscription_schedules_schedule_cancel(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/%s/cancel", [Schedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_identity_verification_sessions(map()) -> term().
post_identity_verification_sessions(Args) ->
    post_identity_verification_sessions(Args, #{}).

-spec post_identity_verification_sessions(map(), mhttp:request_options()) -> term().
post_identity_verification_sessions(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_sessions(map()) -> term().
get_identity_verification_sessions(Args) ->
    get_identity_verification_sessions(Args, #{}).

-spec get_identity_verification_sessions(map(), mhttp:request_options()) -> term().
get_identity_verification_sessions(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after, status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_list_items(map()) -> term().
post_radar_value_list_items(Args) ->
    post_radar_value_list_items(Args, #{}).

-spec post_radar_value_list_items(map(), mhttp:request_options()) -> term().
post_radar_value_list_items(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_list_items(map()) -> term().
get_radar_value_list_items(Args) ->
    get_radar_value_list_items(Args, #{}).

-spec get_radar_value_list_items(map(), mhttp:request_options()) -> term().
get_radar_value_list_items(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({value, _Value}) ->
                {<<"value">>, <<>>};
            ({value_list, _Value}) ->
                {<<"value_list">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 value,
                                 value_list],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_events_id(map()) -> term().
get_events_id(Args) ->
    get_events_id(Args, #{}).

-spec get_events_id(map(), mhttp:request_options()) -> term().
get_events_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/events/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_country_specs(map()) -> term().
get_country_specs(Args) ->
    get_country_specs(Args, #{}).

-spec get_country_specs(map(), mhttp:request_options()) -> term().
get_country_specs(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/country_specs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_verify_microdeposits(map()) -> term().
post_payment_intents_intent_verify_microdeposits(Args) ->
    post_payment_intents_intent_verify_microdeposits(Args, #{}).

-spec post_payment_intents_intent_verify_microdeposits(map(), mhttp:request_options()) ->
                                                          term().
post_payment_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/%s/verify_microdeposits", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items_subscription_item_usage_records(map()) -> term().
post_subscription_items_subscription_item_usage_records(Args) ->
    post_subscription_items_subscription_item_usage_records(Args, #{}).

-spec post_subscription_items_subscription_item_usage_records(map(),
                                                              mhttp:request_options()) ->
                                                                 term().
post_subscription_items_subscription_item_usage_records(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items/%s/usage_records", [SubscriptionItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_history(map()) -> term().
get_balance_history(Args) ->
    get_balance_history(Args, #{}).

-spec get_balance_history(map(), mhttp:request_options()) -> term().
get_balance_history(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({currency, _Value}) ->
                {<<"currency">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payout, _Value}) ->
                {<<"payout">>, <<>>};
            ({source, _Value}) ->
                {<<"source">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 currency,
                                 ending_before,
                                 expand,
                                 limit,
                                 payout,
                                 source,
                                 starting_after,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/balance/history", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_order_returns(map()) -> term().
get_order_returns(Args) ->
    get_order_returns(Args, #{}).

-spec get_order_returns(map(), mhttp:request_options()) -> term().
get_order_returns(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({order, _Value}) ->
                {<<"order">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, order, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/order_returns", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_external_accounts_id(map()) -> term().
post_account_external_accounts_id(Args) ->
    post_account_external_accounts_id(Args, #{}).

-spec post_account_external_accounts_id(map(), mhttp:request_options()) -> term().
post_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_external_accounts_id(map()) -> term().
get_account_external_accounts_id(Args) ->
    get_account_external_accounts_id(Args, #{}).

-spec get_account_external_accounts_id(map(), mhttp:request_options()) -> term().
get_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_external_accounts_id(map()) -> term().
delete_account_external_accounts_id(Args) ->
    delete_account_external_accounts_id(Args, #{}).

-spec delete_account_external_accounts_id(map(), mhttp:request_options()) -> term().
delete_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_apple_pay_domains(map()) -> term().
post_apple_pay_domains(Args) ->
    post_apple_pay_domains(Args, #{}).

-spec post_apple_pay_domains(map(), mhttp:request_options()) -> term().
post_apple_pay_domains(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_apple_pay_domains(map()) -> term().
get_apple_pay_domains(Args) ->
    get_apple_pay_domains(Args, #{}).

-spec get_apple_pay_domains(map(), mhttp:request_options()) -> term().
get_apple_pay_domains(Args, Options) ->
    EncodeQuery =
        fun ({domain_name, _Value}) ->
                {<<"domain_name">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([domain_name, ending_before, expand, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes(map()) -> term().
post_credit_notes(Args) ->
    post_credit_notes(Args, #{}).

-spec post_credit_notes(map(), mhttp:request_options()) -> term().
post_credit_notes(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes(map()) -> term().
get_credit_notes(Args) ->
    get_credit_notes(Args, #{}).

-spec get_credit_notes(map(), mhttp:request_options()) -> term().
get_credit_notes(Args, Options) ->
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice, _Value}) ->
                {<<"invoice">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, invoice, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sigma_scheduled_query_runs_scheduled_query_run(map()) -> term().
get_sigma_scheduled_query_runs_scheduled_query_run(Args) ->
    get_sigma_scheduled_query_runs_scheduled_query_run(Args, #{}).

-spec get_sigma_scheduled_query_runs_scheduled_query_run(map(),
                                                         mhttp:request_options()) ->
                                                            term().
get_sigma_scheduled_query_runs_scheduled_query_run(Args, Options) ->
    VarScheduledQueryRun = maps:get(scheduled_query_run, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs/%s", [ScheduledQueryRun]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_coupons_coupon(map()) -> term().
post_coupons_coupon(Args) ->
    post_coupons_coupon(Args, #{}).

-spec post_coupons_coupon(map(), mhttp:request_options()) -> term().
post_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons/%s", [Coupon]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_coupons_coupon(map()) -> term().
get_coupons_coupon(Args) ->
    get_coupons_coupon(Args, #{}).

-spec get_coupons_coupon(map(), mhttp:request_options()) -> term().
get_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons/%s", [Coupon]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_coupons_coupon(map()) -> term().
delete_coupons_coupon(Args) ->
    delete_coupons_coupon(Args, #{}).

-spec delete_coupons_coupon(map(), mhttp:request_options()) -> term().
delete_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/coupons/%s", [Coupon]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_tax_ids_id(map()) -> term().
get_customers_customer_tax_ids_id(Args) ->
    get_customers_customer_tax_ids_id(Args, #{}).

-spec get_customers_customer_tax_ids_id(map(), mhttp:request_options()) -> term().
get_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/tax_ids/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_tax_ids_id(map()) -> term().
delete_customers_customer_tax_ids_id(Args) ->
    delete_customers_customer_tax_ids_id(Args, #{}).

-spec delete_customers_customer_tax_ids_id(map(), mhttp:request_options()) -> term().
delete_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/tax_ids/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_early_fraud_warnings_early_fraud_warning(map()) -> term().
get_radar_early_fraud_warnings_early_fraud_warning(Args) ->
    get_radar_early_fraud_warnings_early_fraud_warning(Args, #{}).

-spec get_radar_early_fraud_warnings_early_fraud_warning(map(),
                                                         mhttp:request_options()) ->
                                                            term().
get_radar_early_fraud_warnings_early_fraud_warning(Args, Options) ->
    VarEarlyFraudWarning = maps:get(early_fraud_warning, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings/%s", [EarlyFraudWarning]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_settlements(map()) -> term().
get_issuing_settlements(Args) ->
    get_issuing_settlements(Args, #{}).

-spec get_issuing_settlements(map(), mhttp:request_options()) -> term().
get_issuing_settlements(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/settlements", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_file_links(map()) -> term().
post_file_links(Args) ->
    post_file_links(Args, #{}).

-spec post_file_links(map(), mhttp:request_options()) -> term().
post_file_links(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_file_links(map()) -> term().
get_file_links(Args) ->
    get_file_links(Args, #{}).

-spec get_file_links(map(), mhttp:request_options()) -> term().
get_file_links(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({expired, _Value}) ->
                {<<"expired">>, <<>>};
            ({file, _Value}) ->
                {<<"file">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 expired,
                                 file,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_reports_report(map()) -> term().
get_identity_verification_reports_report(Args) ->
    get_identity_verification_reports_report(Args, #{}).

-spec get_identity_verification_reports_report(map(), mhttp:request_options()) -> term().
get_identity_verification_reports_report(Args, Options) ->
    VarReport = maps:get(report, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_reports/%s", [Report]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers(map()) -> term().
post_transfers(Args) ->
    post_transfers(Args, #{}).

-spec post_transfers(map(), mhttp:request_options()) -> term().
post_transfers(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers(map()) -> term().
get_transfers(Args) ->
    get_transfers(Args, #{}).

-spec get_transfers(map(), mhttp:request_options()) -> term().
get_transfers(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({destination, _Value}) ->
                {<<"destination">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({transfer_group, _Value}) ->
                {<<"transfer_group">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 destination,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 transfer_group],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_subscriptions_subscription_exposed_id_discount(map()) -> term().
delete_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec delete_subscriptions_subscription_exposed_id_discount(map(),
                                                            mhttp:request_options()) ->
                                                               term().
delete_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/%s/discount", [SubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_id_refunds(map()) -> term().
post_application_fees_id_refunds(Args) ->
    post_application_fees_id_refunds(Args, #{}).

-spec post_application_fees_id_refunds(map(), mhttp:request_options()) -> term().
post_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/%s/refunds", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_id_refunds(map()) -> term().
get_application_fees_id_refunds(Args) ->
    get_application_fees_id_refunds(Args, #{}).

-spec get_application_fees_id_refunds(map(), mhttp:request_options()) -> term().
get_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/%s/refunds", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_bank_accounts(map()) -> term().
post_accounts_account_bank_accounts(Args) ->
    post_accounts_account_bank_accounts(Args, #{}).

-spec post_accounts_account_bank_accounts(map(), mhttp:request_options()) -> term().
post_accounts_account_bank_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/bank_accounts", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account(map()) -> term().
post_accounts_account(Args) ->
    post_accounts_account(Args, #{}).

-spec post_accounts_account(map(), mhttp:request_options()) -> term().
post_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account(map()) -> term().
get_accounts_account(Args) ->
    get_accounts_account(Args, #{}).

-spec get_accounts_account(map(), mhttp:request_options()) -> term().
get_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account(map()) -> term().
delete_accounts_account(Args) ->
    delete_accounts_account(Args, #{}).

-spec delete_accounts_account(map(), mhttp:request_options()) -> term().
delete_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules_schedule(map()) -> term().
post_subscription_schedules_schedule(Args) ->
    post_subscription_schedules_schedule(Args, #{}).

-spec post_subscription_schedules_schedule(map(), mhttp:request_options()) -> term().
post_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/%s", [Schedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_schedules_schedule(map()) -> term().
get_subscription_schedules_schedule(Args) ->
    get_subscription_schedules_schedule(Args, #{}).

-spec get_subscription_schedules_schedule(map(), mhttp:request_options()) -> term().
get_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/%s", [Schedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_pay(map()) -> term().
post_invoices_invoice_pay(Args) ->
    post_invoices_invoice_pay(Args, #{}).

-spec post_invoices_invoice_pay(map(), mhttp:request_options()) -> term().
post_invoices_invoice_pay(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/%s/pay", [Invoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_transfer_reversals_id(map()) -> term().
post_transfers_transfer_reversals_id(Args) ->
    post_transfers_transfer_reversals_id(Args, #{}).

-spec post_transfers_transfer_reversals_id(map(), mhttp:request_options()) -> term().
post_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/%s/reversals/%s", [Transfer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_transfer_reversals_id(map()) -> term().
get_transfers_transfer_reversals_id(Args) ->
    get_transfers_transfer_reversals_id(Args, #{}).

-spec get_transfers_transfer_reversals_id(map(), mhttp:request_options()) -> term().
get_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/%s/reversals/%s", [Transfer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups_topup(map()) -> term().
post_topups_topup(Args) ->
    post_topups_topup(Args, #{}).

-spec post_topups_topup(map(), mhttp:request_options()) -> term().
post_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/topups/%s", [Topup]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_topups_topup(map()) -> term().
get_topups_topup(Args) ->
    get_topups_topup(Args, #{}).

-spec get_topups_topup(map(), mhttp:request_options()) -> term().
get_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/topups/%s", [Topup]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_recipients_id(map()) -> term().
post_recipients_id(Args) ->
    post_recipients_id(Args, #{}).

-spec post_recipients_id(map(), mhttp:request_options()) -> term().
post_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_recipients_id(map()) -> term().
get_recipients_id(Args) ->
    get_recipients_id(Args, #{}).

-spec get_recipients_id(map(), mhttp:request_options()) -> term().
get_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_recipients_id(map()) -> term().
delete_recipients_id(Args) ->
    delete_recipients_id(Args, #{}).

-spec delete_recipients_id(map(), mhttp:request_options()) -> term().
delete_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_invoice_lines(map()) -> term().
get_invoices_invoice_lines(Args) ->
    get_invoices_invoice_lines(Args, #{}).

-spec get_invoices_invoice_lines(map(), mhttp:request_options()) -> term().
get_invoices_invoice_lines(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/%s/lines", [Invoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_external_accounts_id(map()) -> term().
post_accounts_account_external_accounts_id(Args) ->
    post_accounts_account_external_accounts_id(Args, #{}).

-spec post_accounts_account_external_accounts_id(map(), mhttp:request_options()) ->
                                                    term().
post_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/external_accounts/%s", [Account, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_external_accounts_id(map()) -> term().
get_accounts_account_external_accounts_id(Args) ->
    get_accounts_account_external_accounts_id(Args, #{}).

-spec get_accounts_account_external_accounts_id(map(), mhttp:request_options()) -> term().
get_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/external_accounts/%s", [Account, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_accounts_account_external_accounts_id(map()) -> term().
delete_accounts_account_external_accounts_id(Args) ->
    delete_accounts_account_external_accounts_id(Args, #{}).

-spec delete_accounts_account_external_accounts_id(map(), mhttp:request_options()) ->
                                                      term().
delete_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/external_accounts/%s", [Account, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups(map()) -> term().
post_topups(Args) ->
    post_topups(Args, #{}).

-spec post_topups(map(), mhttp:request_options()) -> term().
post_topups(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/topups", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_topups(map()) -> term().
get_topups(Args) ->
    get_topups(Args, #{}).

-spec get_topups(map(), mhttp:request_options()) -> term().
get_topups(Args, Options) ->
    EncodeQuery =
        fun ({amount, _Value}) ->
                {<<"amount">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([amount,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/topups", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id_returns(map()) -> term().
post_orders_id_returns(Args) ->
    post_orders_id_returns(Args, #{}).

-spec post_orders_id_returns(map(), mhttp:request_options()) -> term().
post_orders_id_returns(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/%s/returns", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id(map()) -> term().
post_orders_id(Args) ->
    post_orders_id(Args, #{}).

-spec post_orders_id(map(), mhttp:request_options()) -> term().
post_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_orders_id(map()) -> term().
get_orders_id(Args) ->
    get_orders_id(Args, #{}).

-spec get_orders_id(map(), mhttp:request_options()) -> term().
get_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_apple_pay_domains_domain(map()) -> term().
get_apple_pay_domains_domain(Args) ->
    get_apple_pay_domains_domain(Args, #{}).

-spec get_apple_pay_domains_domain(map(), mhttp:request_options()) -> term().
get_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains/%s", [Domain]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_apple_pay_domains_domain(map()) -> term().
delete_apple_pay_domains_domain(Args) ->
    delete_apple_pay_domains_domain(Args, #{}).

-spec delete_apple_pay_domains_domain(map(), mhttp:request_options()) -> term().
delete_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/apple_pay/domains/%s", [Domain]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_transactions(map()) -> term().
get_issuing_transactions(Args) ->
    get_issuing_transactions(Args, #{}).

-spec get_issuing_transactions(map(), mhttp:request_options()) -> term().
get_issuing_transactions(Args, Options) ->
    EncodeQuery =
        fun ({card, _Value}) ->
                {<<"card">>, <<>>};
            ({cardholder, _Value}) ->
                {<<"cardholder">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([card,
                                 cardholder,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/transactions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refund(map()) -> term().
post_charges_charge_refund(Args) ->
    post_charges_charge_refund(Args, #{}).

-spec post_charges_charge_refund(map(), mhttp:request_options()) -> term().
post_charges_charge_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s/refund", [Charge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods_payment_method_attach(map()) -> term().
post_payment_methods_payment_method_attach(Args) ->
    post_payment_methods_payment_method_attach(Args, #{}).

-spec post_payment_methods_payment_method_attach(map(), mhttp:request_options()) ->
                                                    term().
post_payment_methods_payment_method_attach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/%s/attach", [PaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_cancel(map()) -> term().
post_payment_intents_intent_cancel(Args) ->
    post_payment_intents_intent_cancel(Args, #{}).

-spec post_payment_intents_intent_cancel(map(), mhttp:request_options()) -> term().
post_payment_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/%s/cancel", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_capabilities(map()) -> term().
get_accounts_account_capabilities(Args) ->
    get_accounts_account_capabilities(Args, #{}).

-spec get_accounts_account_capabilities(map(), mhttp:request_options()) -> term().
get_accounts_account_capabilities(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/capabilities", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_preview_lines(map()) -> term().
get_credit_notes_preview_lines(Args) ->
    get_credit_notes_preview_lines(Args, #{}).

-spec get_credit_notes_preview_lines(map(), mhttp:request_options()) -> term().
get_credit_notes_preview_lines(Args, Options) ->
    EncodeQuery =
        fun ({amount, _Value}) ->
                {<<"amount">>, <<>>};
            ({credit_amount, _Value}) ->
                {<<"credit_amount">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice, _Value}) ->
                {<<"invoice">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({lines, _Value}) ->
                {<<"lines">>, <<>>};
            ({memo, _Value}) ->
                {<<"memo">>, <<>>};
            ({metadata, _Value}) ->
                {<<"metadata">>, <<>>};
            ({out_of_band_amount, _Value}) ->
                {<<"out_of_band_amount">>, <<>>};
            ({reason, _Value}) ->
                {<<"reason">>, <<>>};
            ({refund, _Value}) ->
                {<<"refund">>, <<>>};
            ({refund_amount, _Value}) ->
                {<<"refund_amount">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([amount,
                                 credit_amount,
                                 ending_before,
                                 expand,
                                 invoice,
                                 limit,
                                 lines,
                                 memo,
                                 metadata,
                                 out_of_band_amount,
                                 reason,
                                 refund,
                                 refund_amount,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/preview/lines", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscriptions(map()) -> term().
post_subscriptions(Args) ->
    post_subscriptions(Args, #{}).

-spec post_subscriptions(map(), mhttp:request_options()) -> term().
post_subscriptions(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscriptions(map()) -> term().
get_subscriptions(Args) ->
    get_subscriptions(Args, #{}).

-spec get_subscriptions(map(), mhttp:request_options()) -> term().
get_subscriptions(Args, Options) ->
    EncodeQuery =
        fun ({collection_method, _Value}) ->
                {<<"collection_method">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({current_period_end, _Value}) ->
                {<<"current_period_end">>, <<>>};
            ({current_period_start, _Value}) ->
                {<<"current_period_start">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({price, _Value}) ->
                {<<"price">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([collection_method,
                                 created,
                                 current_period_end,
                                 current_period_start,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 price,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_attempts(map()) -> term().
get_setup_attempts(Args) ->
    get_setup_attempts(Args, #{}).

-spec get_setup_attempts(map(), mhttp:request_options()) -> term().
get_setup_attempts(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({setup_intent, _Value}) ->
                {<<"setup_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 setup_intent,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_attempts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_subscriptions_subscription_exposed_id(map()) -> term().
post_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    post_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec post_customers_customer_subscriptions_subscription_exposed_id(map(),
                                                                    mhttp:request_options()) ->
                                                                       term().
post_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/%s/subscriptions/%s", [Customer, SubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_subscriptions_subscription_exposed_id(map()) -> term().
get_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec get_customers_customer_subscriptions_subscription_exposed_id(map(),
                                                                   mhttp:request_options()) ->
                                                                      term().
get_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/%s/subscriptions/%s", [Customer, SubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_subscriptions_subscription_exposed_id(map()) -> term().
delete_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec delete_customers_customer_subscriptions_subscription_exposed_id(map(),
                                                                      mhttp:request_options()) ->
                                                                         term().
delete_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/%s/subscriptions/%s", [Customer, SubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers_id(map()) -> term().
get_bitcoin_receivers_id(Args) ->
    get_bitcoin_receivers_id(Args, #{}).

-spec get_bitcoin_receivers_id(map(), mhttp:request_options()) -> term().
get_bitcoin_receivers_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/receivers/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders(map()) -> term().
post_orders(Args) ->
    post_orders(Args, #{}).

-spec post_orders(map(), mhttp:request_options()) -> term().
post_orders(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/orders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_orders(map()) -> term().
get_orders(Args) ->
    get_orders(Args, #{}).

-spec get_orders(map(), mhttp:request_options()) -> term().
get_orders(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({ids, _Value}) ->
                {<<"ids">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({status_transitions, _Value}) ->
                {<<"status_transitions">>, <<>>};
            ({upstream_ids, _Value}) ->
                {<<"upstream_ids">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 customer,
                                 ending_before,
                                 expand,
                                 ids,
                                 limit,
                                 starting_after,
                                 status,
                                 status_transitions,
                                 upstream_ids],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/orders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_ephemeral_keys(map()) -> term().
post_ephemeral_keys(Args) ->
    post_ephemeral_keys(Args, #{}).

-spec post_ephemeral_keys(map(), mhttp:request_options()) -> term().
post_ephemeral_keys(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/ephemeral_keys", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_webhook_endpoints_webhook_endpoint(map()) -> term().
post_webhook_endpoints_webhook_endpoint(Args) ->
    post_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec post_webhook_endpoints_webhook_endpoint(map(), mhttp:request_options()) -> term().
post_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints/%s", [WebhookEndpoint]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_webhook_endpoints_webhook_endpoint(map()) -> term().
get_webhook_endpoints_webhook_endpoint(Args) ->
    get_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec get_webhook_endpoints_webhook_endpoint(map(), mhttp:request_options()) -> term().
get_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints/%s", [WebhookEndpoint]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_webhook_endpoints_webhook_endpoint(map()) -> term().
delete_webhook_endpoints_webhook_endpoint(Args) ->
    delete_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec delete_webhook_endpoints_webhook_endpoint(map(), mhttp:request_options()) -> term().
delete_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints/%s", [WebhookEndpoint]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_persons(map()) -> term().
post_account_persons(Args) ->
    post_account_persons(Args, #{}).

-spec post_account_persons(map(), mhttp:request_options()) -> term().
post_account_persons(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_persons(map()) -> term().
get_account_persons(Args) ->
    get_account_persons(Args, #{}).

-spec get_account_persons(map(), mhttp:request_options()) -> term().
get_account_persons(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({relationship, _Value}) ->
                {<<"relationship">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, relationship, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/persons", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_capabilities(map()) -> term().
get_account_capabilities(Args) ->
    get_account_capabilities(Args, #{}).

-spec get_account_capabilities(map(), mhttp:request_options()) -> term().
get_account_capabilities(Args, Options) ->
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/capabilities", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_checkout_sessions_session_expire(map()) -> term().
post_checkout_sessions_session_expire(Args) ->
    post_checkout_sessions_session_expire(Args, #{}).

-spec post_checkout_sessions_session_expire(map(), mhttp:request_options()) -> term().
post_checkout_sessions_session_expire(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions/%s/expire", [Session]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers_receiver_transactions(map()) -> term().
get_bitcoin_receivers_receiver_transactions(Args) ->
    get_bitcoin_receivers_receiver_transactions(Args, #{}).

-spec get_bitcoin_receivers_receiver_transactions(map(), mhttp:request_options()) ->
                                                     term().
get_bitcoin_receivers_receiver_transactions(Args, Options) ->
    VarReceiver = maps:get(receiver, Args),
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/receivers/%s/transactions", [Receiver]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote(map()) -> term().
post_quotes_quote(Args) ->
    post_quotes_quote(Args, #{}).

-spec post_quotes_quote(map(), mhttp:request_options()) -> term().
post_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/%s", [Quote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote(map()) -> term().
get_quotes_quote(Args) ->
    get_quotes_quote(Args, #{}).

-spec get_quotes_quote(map(), mhttp:request_options()) -> term().
get_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/%s", [Quote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_people(map()) -> term().
post_account_people(Args) ->
    post_account_people(Args, #{}).

-spec post_account_people(map(), mhttp:request_options()) -> term().
post_account_people(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_people(map()) -> term().
get_account_people(Args) ->
    get_account_people(Args, #{}).

-spec get_account_people(map(), mhttp:request_options()) -> term().
get_account_people(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({relationship, _Value}) ->
                {<<"relationship">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, relationship, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_confirm(map()) -> term().
post_setup_intents_intent_confirm(Args) ->
    post_setup_intents_intent_confirm(Args, #{}).

-spec post_setup_intents_intent_confirm(map(), mhttp:request_options()) -> term().
post_setup_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/%s/confirm", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_cards(map()) -> term().
post_customers_customer_cards(Args) ->
    post_customers_customer_cards(Args, #{}).

-spec post_customers_customer_cards(map(), mhttp:request_options()) -> term().
post_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/cards", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_cards(map()) -> term().
get_customers_customer_cards(Args) ->
    get_customers_customer_cards(Args, #{}).

-spec get_customers_customer_cards(map(), mhttp:request_options()) -> term().
get_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/cards", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_reports(map()) -> term().
get_identity_verification_reports(Args) ->
    get_identity_verification_reports(Args, #{}).

-spec get_identity_verification_reports(map(), mhttp:request_options()) -> term().
get_identity_verification_reports(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>};
            ({verification_session, _Value}) ->
                {<<"verification_session">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 type,
                                 verification_session],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_reports", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_persons(map()) -> term().
post_accounts_account_persons(Args) ->
    post_accounts_account_persons(Args, #{}).

-spec post_accounts_account_persons(map(), mhttp:request_options()) -> term().
post_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/persons", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_persons(map()) -> term().
get_accounts_account_persons(Args) ->
    get_accounts_account_persons(Args, #{}).

-spec get_accounts_account_persons(map(), mhttp:request_options()) -> term().
get_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({relationship, _Value}) ->
                {<<"relationship">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, relationship, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/persons", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_application_fees_id_refund(map()) -> term().
post_application_fees_id_refund(Args) ->
    post_application_fees_id_refund(Args, #{}).

-spec post_application_fees_id_refund(map(), mhttp:request_options()) -> term().
post_application_fees_id_refund(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/%s/refund", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents(map()) -> term().
post_payment_intents(Args) ->
    post_payment_intents(Args, #{}).

-spec post_payment_intents(map(), mhttp:request_options()) -> term().
post_payment_intents(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_intents(map()) -> term().
get_payment_intents(Args) ->
    get_payment_intents(Args, #{}).

-spec get_payment_intents(map(), mhttp:request_options()) -> term().
get_payment_intents(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, customer, ending_before, expand, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_skus(map()) -> term().
post_skus(Args) ->
    post_skus(Args, #{}).

-spec post_skus(map(), mhttp:request_options()) -> term().
post_skus(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/skus", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_skus(map()) -> term().
get_skus(Args) ->
    get_skus(Args, #{}).

-spec get_skus(map(), mhttp:request_options()) -> term().
get_skus(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({attributes, _Value}) ->
                {<<"attributes">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({ids, _Value}) ->
                {<<"ids">>, <<>>};
            ({in_stock, _Value}) ->
                {<<"in_stock">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({product, _Value}) ->
                {<<"product">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 attributes,
                                 ending_before,
                                 expand,
                                 ids,
                                 in_stock,
                                 limit,
                                 product,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/skus", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_webhook_endpoints(map()) -> term().
post_webhook_endpoints(Args) ->
    post_webhook_endpoints(Args, #{}).

-spec post_webhook_endpoints(map(), mhttp:request_options()) -> term().
post_webhook_endpoints(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_webhook_endpoints(map()) -> term().
get_webhook_endpoints(Args) ->
    get_webhook_endpoints(Args, #{}).

-spec get_webhook_endpoints(map(), mhttp:request_options()) -> term().
get_webhook_endpoints(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance(map()) -> term().
get_balance(Args) ->
    get_balance(Args, #{}).

-spec get_balance(map(), mhttp:request_options()) -> term().
get_balance(Args, Options) ->
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/balance", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_balance_transactions_transaction(map()) -> term().
post_customers_customer_balance_transactions_transaction(Args) ->
    post_customers_customer_balance_transactions_transaction(Args, #{}).

-spec post_customers_customer_balance_transactions_transaction(map(),
                                                               mhttp:request_options()) ->
                                                                  term().
post_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/%s/balance_transactions/%s", [Customer, Transaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_balance_transactions_transaction(map()) -> term().
get_customers_customer_balance_transactions_transaction(Args) ->
    get_customers_customer_balance_transactions_transaction(Args, #{}).

-spec get_customers_customer_balance_transactions_transaction(map(),
                                                              mhttp:request_options()) ->
                                                                 term().
get_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/%s/balance_transactions/%s", [Customer, Transaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods_payment_method(map()) -> term().
post_payment_methods_payment_method(Args) ->
    post_payment_methods_payment_method(Args, #{}).

-spec post_payment_methods_payment_method(map(), mhttp:request_options()) -> term().
post_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/%s", [PaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_methods_payment_method(map()) -> term().
get_payment_methods_payment_method(Args) ->
    get_payment_methods_payment_method(Args, #{}).

-spec get_payment_methods_payment_method(map(), mhttp:request_options()) -> term().
get_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/%s", [PaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_topups_topup_cancel(map()) -> term().
post_topups_topup_cancel(Args) ->
    post_topups_topup_cancel(Args, #{}).

-spec post_topups_topup_cancel(map(), mhttp:request_options()) -> term().
post_topups_topup_cancel(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/topups/%s/cancel", [Topup]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_events(map()) -> term().
get_events(Args) ->
    get_events(Args, #{}).

-spec get_events(map(), mhttp:request_options()) -> term().
get_events(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({delivery_success, _Value}) ->
                {<<"delivery_success">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>};
            ({types, _Value}) ->
                {<<"types">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 delivery_success,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 type,
                                 types],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/events", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_refunds_refund(map()) -> term().
post_charges_charge_refunds_refund(Args) ->
    post_charges_charge_refunds_refund(Args, #{}).

-spec post_charges_charge_refunds_refund(map(), mhttp:request_options()) -> term().
post_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s/refunds/%s", [Charge, Refund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_refunds_refund(map()) -> term().
get_charges_charge_refunds_refund(Args) ->
    get_charges_charge_refunds_refund(Args, #{}).

-spec get_charges_charge_refunds_refund(map(), mhttp:request_options()) -> term().
get_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s/refunds/%s", [Charge, Refund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_capabilities_capability(map()) -> term().
post_accounts_account_capabilities_capability(Args) ->
    post_accounts_account_capabilities_capability(Args, #{}).

-spec post_accounts_account_capabilities_capability(map(), mhttp:request_options()) ->
                                                       term().
post_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/capabilities/%s", [Account, Capability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_capabilities_capability(map()) -> term().
get_accounts_account_capabilities_capability(Args) ->
    get_accounts_account_capabilities_capability(Args, #{}).

-spec get_accounts_account_capabilities_capability(map(), mhttp:request_options()) ->
                                                      term().
get_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/capabilities/%s", [Account, Capability]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_items(map()) -> term().
post_subscription_items(Args) ->
    post_subscription_items(Args, #{}).

-spec post_subscription_items(map(), mhttp:request_options()) -> term().
post_subscription_items(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items(map()) -> term().
get_subscription_items(Args) ->
    get_subscription_items(Args, #{}).

-spec get_subscription_items(map(), mhttp:request_options()) -> term().
get_subscription_items(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after, subscription],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_items", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_pdf(map()) -> term().
get_quotes_quote_pdf(Args) ->
    get_quotes_quote_pdf(Args, #{}).

-spec get_quotes_quote_pdf(map(), mhttp:request_options()) -> term().
get_quotes_quote_pdf(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/%s/pdf", [Quote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_bank_accounts_id(map()) -> term().
post_account_bank_accounts_id(Args) ->
    post_account_bank_accounts_id(Args, #{}).

-spec post_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
post_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_bank_accounts_id(map()) -> term().
get_account_bank_accounts_id(Args) ->
    get_account_bank_accounts_id(Args, #{}).

-spec get_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
get_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_bank_accounts_id(map()) -> term().
delete_account_bank_accounts_id(Args) ->
    delete_account_bank_accounts_id(Args, #{}).

-spec delete_account_bank_accounts_id(map(), mhttp:request_options()) -> term().
delete_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links_payment_link_line_items(map()) -> term().
get_payment_links_payment_link_line_items(Args) ->
    get_payment_links_payment_link_line_items(Args, #{}).

-spec get_payment_links_payment_link_line_items(map(), mhttp:request_options()) -> term().
get_payment_links_payment_link_line_items(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links/%s/line_items", [PaymentLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_items_subscription_item_usage_record_summaries(map()) -> term().
get_subscription_items_subscription_item_usage_record_summaries(Args) ->
    get_subscription_items_subscription_item_usage_record_summaries(Args, #{}).

-spec get_subscription_items_subscription_item_usage_record_summaries(map(),
                                                                      mhttp:request_options()) ->
                                                                         term().
get_subscription_items_subscription_item_usage_record_summaries(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/subscription_items/%s/usage_record_summaries", [SubscriptionItem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent(map()) -> term().
post_payment_intents_intent(Args) ->
    post_payment_intents_intent(Args, #{}).

-spec post_payment_intents_intent(map(), mhttp:request_options()) -> term().
post_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/%s", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_intents_intent(map()) -> term().
get_payment_intents_intent(Args) ->
    get_payment_intents_intent(Args, #{}).

-spec get_payment_intents_intent(map(), mhttp:request_options()) -> term().
get_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    EncodeQuery =
        fun ({client_secret, _Value}) ->
                {<<"client_secret">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([client_secret, expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/%s", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges(map()) -> term().
post_charges(Args) ->
    post_charges(Args, #{}).

-spec post_charges(map(), mhttp:request_options()) -> term().
post_charges(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges(map()) -> term().
get_charges(Args) ->
    get_charges(Args, #{}).

-spec get_charges(map(), mhttp:request_options()) -> term().
get_charges(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({transfer_group, _Value}) ->
                {<<"transfer_group">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after,
                                 transfer_group],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_external_accounts(map()) -> term().
post_accounts_account_external_accounts(Args) ->
    post_accounts_account_external_accounts(Args, #{}).

-spec post_accounts_account_external_accounts(map(), mhttp:request_options()) -> term().
post_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/external_accounts", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_external_accounts(map()) -> term().
get_accounts_account_external_accounts(Args) ->
    get_accounts_account_external_accounts(Args, #{}).

-spec get_accounts_account_external_accounts(map(), mhttp:request_options()) -> term().
get_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/external_accounts", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_authorizations(map()) -> term().
get_issuing_authorizations(Args) ->
    get_issuing_authorizations(Args, #{}).

-spec get_issuing_authorizations(map(), mhttp:request_options()) -> term().
get_issuing_authorizations(Args, Options) ->
    EncodeQuery =
        fun ({card, _Value}) ->
                {<<"card">>, <<>>};
            ({cardholder, _Value}) ->
                {<<"cardholder">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([card,
                                 cardholder,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_products_id(map()) -> term().
post_products_id(Args) ->
    post_products_id(Args, #{}).

-spec post_products_id(map(), mhttp:request_options()) -> term().
post_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/products/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_products_id(map()) -> term().
get_products_id(Args) ->
    get_products_id(Args, #{}).

-spec get_products_id(map(), mhttp:request_options()) -> term().
get_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/products/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_products_id(map()) -> term().
delete_products_id(Args) ->
    delete_products_id(Args, #{}).

-spec delete_products_id(map(), mhttp:request_options()) -> term().
delete_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/products/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_verify_microdeposits(map()) -> term().
post_setup_intents_intent_verify_microdeposits(Args) ->
    post_setup_intents_intent_verify_microdeposits(Args, #{}).

-spec post_setup_intents_intent_verify_microdeposits(map(), mhttp:request_options()) ->
                                                        term().
post_setup_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/%s/verify_microdeposits", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_types(map()) -> term().
get_reporting_report_types(Args) ->
    get_reporting_report_types(Args, #{}).

-spec get_reporting_report_types(map(), mhttp:request_options()) -> term().
get_reporting_report_types(Args, Options) ->
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_types", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_external_accounts(map()) -> term().
post_account_external_accounts(Args) ->
    post_account_external_accounts(Args, #{}).

-spec post_account_external_accounts(map(), mhttp:request_options()) -> term().
post_account_external_accounts(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_external_accounts(map()) -> term().
get_account_external_accounts(Args) ->
    get_account_external_accounts(Args, #{}).

-spec get_account_external_accounts(map(), mhttp:request_options()) -> term().
get_account_external_accounts(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_radar_value_lists(map()) -> term().
post_radar_value_lists(Args) ->
    post_radar_value_lists(Args, #{}).

-spec post_radar_value_lists(map(), mhttp:request_options()) -> term().
post_radar_value_lists(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_lists(map()) -> term().
get_radar_value_lists(Args) ->
    get_radar_value_lists(Args, #{}).

-spec get_radar_value_lists(map(), mhttp:request_options()) -> term().
get_radar_value_lists(Args, Options) ->
    EncodeQuery =
        fun ({alias, _Value}) ->
                {<<"alias">>, <<>>};
            ({contains, _Value}) ->
                {<<"contains">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([alias,
                                 contains,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_shipping_rates(map()) -> term().
post_shipping_rates(Args) ->
    post_shipping_rates(Args, #{}).

-spec post_shipping_rates(map(), mhttp:request_options()) -> term().
post_shipping_rates(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_shipping_rates(map()) -> term().
get_shipping_rates(Args) ->
    get_shipping_rates(Args, #{}).

-spec get_shipping_rates(map(), mhttp:request_options()) -> term().
get_shipping_rates(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({currency, _Value}) ->
                {<<"currency">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 currency,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_file_links_link(map()) -> term().
post_file_links_link(Args) ->
    post_file_links_link(Args, #{}).

-spec post_file_links_link(map(), mhttp:request_options()) -> term().
post_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links/%s", [Link]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_file_links_link(map()) -> term().
get_file_links_link(Args) ->
    get_file_links_link(Args, #{}).

-spec get_file_links_link(map(), mhttp:request_options()) -> term().
get_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/file_links/%s", [Link]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get3d_secure_three_d_secure(map()) -> term().
get3d_secure_three_d_secure(Args) ->
    get3d_secure_three_d_secure(Args, #{}).

-spec get3d_secure_three_d_secure(map(), mhttp:request_options()) -> term().
get3d_secure_three_d_secure(Args, Options) ->
    VarThreeDSecure = maps:get(three_d_secure, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/3d_secure/%s", [ThreeDSecure]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_send(map()) -> term().
post_invoices_invoice_send(Args) ->
    post_invoices_invoice_send(Args, #{}).

-spec post_invoices_invoice_send(map(), mhttp:request_options()) -> term().
post_invoices_invoice_send(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/%s/send", [Invoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_upcoming(map()) -> term().
get_invoices_upcoming(Args) ->
    get_invoices_upcoming(Args, #{}).

-spec get_invoices_upcoming(map(), mhttp:request_options()) -> term().
get_invoices_upcoming(Args, Options) ->
    EncodeQuery =
        fun ({automatic_tax, _Value}) ->
                {<<"automatic_tax">>, <<>>};
            ({coupon, _Value}) ->
                {<<"coupon">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({customer_details, _Value}) ->
                {<<"customer_details">>, <<>>};
            ({discounts, _Value}) ->
                {<<"discounts">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice_items, _Value}) ->
                {<<"invoice_items">>, <<>>};
            ({schedule, _Value}) ->
                {<<"schedule">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>};
            ({subscription_billing_cycle_anchor, _Value}) ->
                {<<"subscription_billing_cycle_anchor">>, <<>>};
            ({subscription_cancel_at, _Value}) ->
                {<<"subscription_cancel_at">>, <<>>};
            ({subscription_cancel_at_period_end, _Value}) ->
                {<<"subscription_cancel_at_period_end">>, <<>>};
            ({subscription_cancel_now, _Value}) ->
                {<<"subscription_cancel_now">>, <<>>};
            ({subscription_default_tax_rates, _Value}) ->
                {<<"subscription_default_tax_rates">>, <<>>};
            ({subscription_items, _Value}) ->
                {<<"subscription_items">>, <<>>};
            ({subscription_proration_behavior, _Value}) ->
                {<<"subscription_proration_behavior">>, <<>>};
            ({subscription_proration_date, _Value}) ->
                {<<"subscription_proration_date">>, <<>>};
            ({subscription_start_date, _Value}) ->
                {<<"subscription_start_date">>, <<>>};
            ({subscription_trial_end, _Value}) ->
                {<<"subscription_trial_end">>, <<>>};
            ({subscription_trial_from_plan, _Value}) ->
                {<<"subscription_trial_from_plan">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([automatic_tax,
                                 coupon,
                                 customer,
                                 customer_details,
                                 discounts,
                                 expand,
                                 invoice_items,
                                 schedule,
                                 subscription,
                                 subscription_billing_cycle_anchor,
                                 subscription_cancel_at,
                                 subscription_cancel_at_period_end,
                                 subscription_cancel_now,
                                 subscription_default_tax_rates,
                                 subscription_items,
                                 subscription_proration_behavior,
                                 subscription_proration_date,
                                 subscription_start_date,
                                 subscription_trial_end,
                                 subscription_trial_from_plan],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/upcoming", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions_session_line_items(map()) -> term().
get_checkout_sessions_session_line_items(Args) ->
    get_checkout_sessions_session_line_items(Args, #{}).

-spec get_checkout_sessions_session_line_items(map(), mhttp:request_options()) -> term().
get_checkout_sessions_session_line_items(Args, Options) ->
    VarSession = maps:get(session, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions/%s/line_items", [Session]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_codes(map()) -> term().
get_tax_codes(Args) ->
    get_tax_codes(Args, #{}).

-spec get_tax_codes(map(), mhttp:request_options()) -> term().
get_tax_codes(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_codes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices(map()) -> term().
post_invoices(Args) ->
    post_invoices(Args, #{}).

-spec post_invoices(map(), mhttp:request_options()) -> term().
post_invoices(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices(map()) -> term().
get_invoices(Args) ->
    get_invoices(Args, #{}).

-spec get_invoices(map(), mhttp:request_options()) -> term().
get_invoices(Args, Options) ->
    EncodeQuery =
        fun ({collection_method, _Value}) ->
                {<<"collection_method">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({due_date, _Value}) ->
                {<<"due_date">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([collection_method,
                                 created,
                                 customer,
                                 due_date,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status,
                                 subscription],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge(map()) -> term().
post_charges_charge(Args) ->
    post_charges_charge(Args, #{}).

-spec post_charges_charge(map(), mhttp:request_options()) -> term().
post_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s", [Charge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge(map()) -> term().
get_charges_charge(Args) ->
    get_charges_charge(Args, #{}).

-spec get_charges_charge(map(), mhttp:request_options()) -> term().
get_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s", [Charge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_mark_uncollectible(map()) -> term().
post_invoices_invoice_mark_uncollectible(Args) ->
    post_invoices_invoice_mark_uncollectible(Args, #{}).

-spec post_invoices_invoice_mark_uncollectible(map(), mhttp:request_options()) -> term().
post_invoices_invoice_mark_uncollectible(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/%s/mark_uncollectible", [Invoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources_id_verify(map()) -> term().
post_customers_customer_sources_id_verify(Args) ->
    post_customers_customer_sources_id_verify(Args, #{}).

-spec post_customers_customer_sources_id_verify(map(), mhttp:request_options()) -> term().
post_customers_customer_sources_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/sources/%s/verify", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_orders_id_pay(map()) -> term().
post_orders_id_pay(Args) ->
    post_orders_id_pay(Args, #{}).

-spec post_orders_id_pay(map(), mhttp:request_options()) -> term().
post_orders_id_pay(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/orders/%s/pay", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_bank_accounts_id_verify(map()) -> term().
post_customers_customer_bank_accounts_id_verify(Args) ->
    post_customers_customer_bank_accounts_id_verify(Args, #{}).

-spec post_customers_customer_bank_accounts_id_verify(map(), mhttp:request_options()) ->
                                                         term().
post_customers_customer_bank_accounts_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/bank_accounts/%s/verify", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_people_person(map()) -> term().
post_account_people_person(Args) ->
    post_account_people_person(Args, #{}).

-spec post_account_people_person(map(), mhttp:request_options()) -> term().
post_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people/%s", [Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account_people_person(map()) -> term().
get_account_people_person(Args) ->
    get_account_people_person(Args, #{}).

-spec get_account_people_person(map(), mhttp:request_options()) -> term().
get_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people/%s", [Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account_people_person(map()) -> term().
delete_account_people_person(Args) ->
    delete_account_people_person(Args, #{}).

-spec delete_account_people_person(map(), mhttp:request_options()) -> term().
delete_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/people/%s", [Person]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_checkout_sessions(map()) -> term().
post_checkout_sessions(Args) ->
    post_checkout_sessions(Args, #{}).

-spec post_checkout_sessions(map(), mhttp:request_options()) -> term().
post_checkout_sessions(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions(map()) -> term().
get_checkout_sessions(Args) ->
    get_checkout_sessions(Args, #{}).

-spec get_checkout_sessions(map(), mhttp:request_options()) -> term().
get_checkout_sessions(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after,
                                 subscription],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_login_links(map()) -> term().
post_accounts_account_login_links(Args) ->
    post_accounts_account_login_links(Args, #{}).

-spec post_accounts_account_login_links(map(), mhttp:request_options()) -> term().
post_accounts_account_login_links(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/login_links", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_readers(map()) -> term().
post_terminal_readers(Args) ->
    post_terminal_readers(Args, #{}).

-spec post_terminal_readers(map(), mhttp:request_options()) -> term().
post_terminal_readers(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_readers(map()) -> term().
get_terminal_readers(Args) ->
    get_terminal_readers(Args, #{}).

-spec get_terminal_readers(map(), mhttp:request_options()) -> term().
get_terminal_readers(Args, Options) ->
    EncodeQuery =
        fun ({device_type, _Value}) ->
                {<<"device_type">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({location, _Value}) ->
                {<<"location">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([device_type,
                                 ending_before,
                                 expand,
                                 limit,
                                 location,
                                 starting_after,
                                 status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes(map()) -> term().
post_issuing_disputes(Args) ->
    post_issuing_disputes(Args, #{}).

-spec post_issuing_disputes(map(), mhttp:request_options()) -> term().
post_issuing_disputes(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_disputes(map()) -> term().
get_issuing_disputes(Args) ->
    get_issuing_disputes(Args, #{}).

-spec get_issuing_disputes(map(), mhttp:request_options()) -> term().
get_issuing_disputes(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({transaction, _Value}) ->
                {<<"transaction">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 status,
                                 transaction],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post3d_secure(map()) -> term().
post3d_secure(Args) ->
    post3d_secure(Args, #{}).

-spec post3d_secure(map(), mhttp:request_options()) -> term().
post3d_secure(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/3d_secure", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_prices(map()) -> term().
post_prices(Args) ->
    post_prices(Args, #{}).

-spec post_prices(map(), mhttp:request_options()) -> term().
post_prices(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/prices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_prices(map()) -> term().
get_prices(Args) ->
    get_prices(Args, #{}).

-spec get_prices(map(), mhttp:request_options()) -> term().
get_prices(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({currency, _Value}) ->
                {<<"currency">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({lookup_keys, _Value}) ->
                {<<"lookup_keys">>, <<>>};
            ({product, _Value}) ->
                {<<"product">>, <<>>};
            ({recurring, _Value}) ->
                {<<"recurring">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 currency,
                                 ending_before,
                                 expand,
                                 limit,
                                 lookup_keys,
                                 product,
                                 recurring,
                                 starting_after,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/prices", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice(map()) -> term().
post_invoices_invoice(Args) ->
    post_invoices_invoice(Args, #{}).

-spec post_invoices_invoice(map(), mhttp:request_options()) -> term().
post_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/%s", [Invoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_invoice(map()) -> term().
get_invoices_invoice(Args) ->
    get_invoices_invoice(Args, #{}).

-spec get_invoices_invoice(map(), mhttp:request_options()) -> term().
get_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/%s", [Invoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_invoices_invoice(map()) -> term().
delete_invoices_invoice(Args) ->
    delete_invoices_invoice(Args, #{}).

-spec delete_invoices_invoice(map(), mhttp:request_options()) -> term().
delete_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/%s", [Invoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_identity_verification_sessions_session(map()) -> term().
post_identity_verification_sessions_session(Args) ->
    post_identity_verification_sessions_session(Args, #{}).

-spec post_identity_verification_sessions_session(map(), mhttp:request_options()) ->
                                                     term().
post_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/%s", [Session]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_identity_verification_sessions_session(map()) -> term().
get_identity_verification_sessions_session(Args) ->
    get_identity_verification_sessions_session(Args, #{}).

-spec get_identity_verification_sessions_session(map(), mhttp:request_options()) ->
                                                    term().
get_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/identity/verification_sessions/%s", [Session]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_transactions_id(map()) -> term().
get_balance_transactions_id(Args) ->
    get_balance_transactions_id(Args, #{}).

-spec get_balance_transactions_id(map(), mhttp:request_options()) -> term().
get_balance_transactions_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/balance_transactions/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents_intent_cancel(map()) -> term().
post_setup_intents_intent_cancel(Args) ->
    post_setup_intents_intent_cancel(Args, #{}).

-spec post_setup_intents_intent_cancel(map(), mhttp:request_options()) -> term().
post_setup_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents/%s/cancel", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_transactions_transaction(map()) -> term().
post_issuing_transactions_transaction(Args) ->
    post_issuing_transactions_transaction(Args, #{}).

-spec post_issuing_transactions_transaction(map(), mhttp:request_options()) -> term().
post_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/transactions/%s", [Transaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_transactions_transaction(map()) -> term().
get_issuing_transactions_transaction(Args) ->
    get_issuing_transactions_transaction(Args, #{}).

-spec get_issuing_transactions_transaction(map(), mhttp:request_options()) -> term().
get_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/transactions/%s", [Transaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_connection_tokens(map()) -> term().
post_terminal_connection_tokens(Args) ->
    post_terminal_connection_tokens(Args, #{}).

-spec post_terminal_connection_tokens(map(), mhttp:request_options()) -> term().
post_terminal_connection_tokens(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/connection_tokens", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reviews(map()) -> term().
get_reviews(Args) ->
    get_reviews(Args, #{}).

-spec get_reviews(map(), mhttp:request_options()) -> term().
get_reviews(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/reviews", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_promotion_codes(map()) -> term().
post_promotion_codes(Args) ->
    post_promotion_codes(Args, #{}).

-spec post_promotion_codes(map(), mhttp:request_options()) -> term().
post_promotion_codes(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_promotion_codes(map()) -> term().
get_promotion_codes(Args) ->
    get_promotion_codes(Args, #{}).

-spec get_promotion_codes(map(), mhttp:request_options()) -> term().
get_promotion_codes(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({code, _Value}) ->
                {<<"code">>, <<>>};
            ({coupon, _Value}) ->
                {<<"coupon">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 code,
                                 coupon,
                                 created,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_subscriptions_subscription_exposed_id_discount(map()) ->
                                                                               term().
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec get_customers_customer_subscriptions_subscription_exposed_id_discount(map(),
                                                                            mhttp:request_options()) ->
                                                                               term().
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/%s/subscriptions/%s/discount",
                      [Customer, SubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_subscriptions_subscription_exposed_id_discount(map()) ->
                                                                                  term().
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec delete_customers_customer_subscriptions_subscription_exposed_id_discount(map(),
                                                                               mhttp:request_options()) ->
                                                                                  term().
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/customers/%s/subscriptions/%s/discount",
                      [Customer, SubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_computed_upfront_line_items(map()) -> term().
get_quotes_quote_computed_upfront_line_items(Args) ->
    get_quotes_quote_computed_upfront_line_items(Args, #{}).

-spec get_quotes_quote_computed_upfront_line_items(map(), mhttp:request_options()) ->
                                                      term().
get_quotes_quote_computed_upfront_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/%s/computed_upfront_line_items", [Quote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_radar_value_list_items_item(map()) -> term().
get_radar_value_list_items_item(Args) ->
    get_radar_value_list_items_item(Args, #{}).

-spec get_radar_value_list_items_item(map(), mhttp:request_options()) -> term().
get_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items/%s", [Item]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_radar_value_list_items_item(map()) -> term().
delete_radar_value_list_items_item(Args) ->
    delete_radar_value_list_items_item(Args, #{}).

-spec delete_radar_value_list_items_item(map(), mhttp:request_options()) -> term().
delete_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/radar/value_list_items/%s", [Item]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuer_fraud_records(map()) -> term().
get_issuer_fraud_records(Args) ->
    get_issuer_fraud_records(Args, #{}).

-spec get_issuer_fraud_records(map(), mhttp:request_options()) -> term().
get_issuer_fraud_records(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuer_fraud_records", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tax_rates_tax_rate(map()) -> term().
post_tax_rates_tax_rate(Args) ->
    post_tax_rates_tax_rate(Args, #{}).

-spec post_tax_rates_tax_rate(map(), mhttp:request_options()) -> term().
post_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates/%s", [TaxRate]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_rates_tax_rate(map()) -> term().
get_tax_rates_tax_rate(Args) ->
    get_tax_rates_tax_rate(Args, #{}).

-spec get_tax_rates_tax_rate(map(), mhttp:request_options()) -> term().
get_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates/%s", [TaxRate]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_recipients(map()) -> term().
post_recipients(Args) ->
    post_recipients(Args, #{}).

-spec post_recipients(map(), mhttp:request_options()) -> term().
post_recipients(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_recipients(map()) -> term().
get_recipients(Args) ->
    get_recipients(Args, #{}).

-spec get_recipients(map(), mhttp:request_options()) -> term().
get_recipients(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>};
            ({verified, _Value}) ->
                {<<"verified">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 ending_before,
                                 expand,
                                 limit,
                                 starting_after,
                                 type,
                                 verified],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/recipients", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_plans(map()) -> term().
post_plans(Args) ->
    post_plans(Args, #{}).

-spec post_plans(map(), mhttp:request_options()) -> term().
post_plans(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/plans", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_plans(map()) -> term().
get_plans(Args) ->
    get_plans(Args, #{}).

-spec get_plans(map(), mhttp:request_options()) -> term().
get_plans(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({product, _Value}) ->
                {<<"product">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 product,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/plans", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_balance_transactions(map()) -> term().
post_customers_customer_balance_transactions(Args) ->
    post_customers_customer_balance_transactions(Args, #{}).

-spec post_customers_customer_balance_transactions(map(), mhttp:request_options()) ->
                                                      term().
post_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/balance_transactions", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_balance_transactions(map()) -> term().
get_customers_customer_balance_transactions(Args) ->
    get_customers_customer_balance_transactions(Args, #{}).

-spec get_customers_customer_balance_transactions(map(), mhttp:request_options()) ->
                                                     term().
get_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/balance_transactions", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_reviews_review_approve(map()) -> term().
post_reviews_review_approve(Args) ->
    post_reviews_review_approve(Args, #{}).

-spec post_reviews_review_approve(map(), mhttp:request_options()) -> term().
post_reviews_review_approve(Args, Options) ->
    VarReview = maps:get(review, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/reviews/%s/approve", [Review]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_tax_ids(map()) -> term().
post_customers_customer_tax_ids(Args) ->
    post_customers_customer_tax_ids(Args, #{}).

-spec post_customers_customer_tax_ids(map(), mhttp:request_options()) -> term().
post_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/tax_ids", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_tax_ids(map()) -> term().
get_customers_customer_tax_ids(Args) ->
    get_customers_customer_tax_ids(Args, #{}).

-spec get_customers_customer_tax_ids(map(), mhttp:request_options()) -> term().
get_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/tax_ids", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tokens_token(map()) -> term().
get_tokens_token(Args) ->
    get_tokens_token(Args, #{}).

-spec get_tokens_token(map(), mhttp:request_options()) -> term().
get_tokens_token(Args, Options) ->
    VarToken = maps:get(token, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/tokens/%s", [Token]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_transactions(map()) -> term().
get_balance_transactions(Args) ->
    get_balance_transactions(Args, #{}).

-spec get_balance_transactions(map(), mhttp:request_options()) -> term().
get_balance_transactions(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({currency, _Value}) ->
                {<<"currency">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payout, _Value}) ->
                {<<"payout">>, <<>>};
            ({source, _Value}) ->
                {<<"source">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 currency,
                                 ending_before,
                                 expand,
                                 limit,
                                 payout,
                                 source,
                                 starting_after,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/balance_transactions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_codes_id(map()) -> term().
get_tax_codes_id(Args) ->
    get_tax_codes_id(Args, #{}).

-spec get_tax_codes_id(map(), mhttp:request_options()) -> term().
get_tax_codes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_codes/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_reject(map()) -> term().
post_accounts_account_reject(Args) ->
    post_accounts_account_reject(Args, #{}).

-spec post_accounts_account_reject(map(), mhttp:request_options()) -> term().
post_accounts_account_reject(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/reject", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscriptions_subscription_exposed_id(map()) -> term().
post_subscriptions_subscription_exposed_id(Args) ->
    post_subscriptions_subscription_exposed_id(Args, #{}).

-spec post_subscriptions_subscription_exposed_id(map(), mhttp:request_options()) ->
                                                    term().
post_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/%s", [SubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscriptions_subscription_exposed_id(map()) -> term().
get_subscriptions_subscription_exposed_id(Args) ->
    get_subscriptions_subscription_exposed_id(Args, #{}).

-spec get_subscriptions_subscription_exposed_id(map(), mhttp:request_options()) -> term().
get_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/%s", [SubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_subscriptions_subscription_exposed_id(map()) -> term().
delete_subscriptions_subscription_exposed_id(Args) ->
    delete_subscriptions_subscription_exposed_id(Args, #{}).

-spec delete_subscriptions_subscription_exposed_id(map(), mhttp:request_options()) ->
                                                      term().
delete_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscriptions/%s", [SubscriptionExposedId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_country_specs_country(map()) -> term().
get_country_specs_country(Args) ->
    get_country_specs_country(Args, #{}).

-spec get_country_specs_country(map(), mhttp:request_options()) -> term().
get_country_specs_country(Args, Options) ->
    VarCountry = maps:get(country, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/country_specs/%s", [Country]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_finalize(map()) -> term().
post_invoices_invoice_finalize(Args) ->
    post_invoices_invoice_finalize(Args, #{}).

-spec post_invoices_invoice_finalize(map(), mhttp:request_options()) -> term().
post_invoices_invoice_finalize(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/%s/finalize", [Invoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_locations_location(map()) -> term().
post_terminal_locations_location(Args) ->
    post_terminal_locations_location(Args, #{}).

-spec post_terminal_locations_location(map(), mhttp:request_options()) -> term().
post_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations/%s", [Location]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_locations_location(map()) -> term().
get_terminal_locations_location(Args) ->
    get_terminal_locations_location(Args, #{}).

-spec get_terminal_locations_location(map(), mhttp:request_options()) -> term().
get_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations/%s", [Location]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_terminal_locations_location(map()) -> term().
delete_terminal_locations_location(Args) ->
    delete_terminal_locations_location(Args, #{}).

-spec delete_terminal_locations_location(map(), mhttp:request_options()) -> term().
delete_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations/%s", [Location]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account(map()) -> term().
post_account(Args) ->
    post_account(Args, #{}).

-spec post_account(map(), mhttp:request_options()) -> term().
post_account(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_account(map()) -> term().
get_account(Args) ->
    get_account(Args, #{}).

-spec get_account(map(), mhttp:request_options()) -> term().
get_account(Args, Options) ->
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_account(map()) -> term().
delete_account(Args) ->
    delete_account(Args, #{}).

-spec delete_account(map(), mhttp:request_options()) -> term().
delete_account(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_shipping_rates_shipping_rate_token(map()) -> term().
post_shipping_rates_shipping_rate_token(Args) ->
    post_shipping_rates_shipping_rate_token(Args, #{}).

-spec post_shipping_rates_shipping_rate_token(map(), mhttp:request_options()) -> term().
post_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates/%s", [ShippingRateToken]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_shipping_rates_shipping_rate_token(map()) -> term().
get_shipping_rates_shipping_rate_token(Args) ->
    get_shipping_rates_shipping_rate_token(Args, #{}).

-spec get_shipping_rates_shipping_rate_token(map(), mhttp:request_options()) -> term().
get_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/shipping_rates/%s", [ShippingRateToken]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoices_upcoming_lines(map()) -> term().
get_invoices_upcoming_lines(Args) ->
    get_invoices_upcoming_lines(Args, #{}).

-spec get_invoices_upcoming_lines(map(), mhttp:request_options()) -> term().
get_invoices_upcoming_lines(Args, Options) ->
    EncodeQuery =
        fun ({automatic_tax, _Value}) ->
                {<<"automatic_tax">>, <<>>};
            ({coupon, _Value}) ->
                {<<"coupon">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({customer_details, _Value}) ->
                {<<"customer_details">>, <<>>};
            ({discounts, _Value}) ->
                {<<"discounts">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice_items, _Value}) ->
                {<<"invoice_items">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({schedule, _Value}) ->
                {<<"schedule">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({subscription, _Value}) ->
                {<<"subscription">>, <<>>};
            ({subscription_billing_cycle_anchor, _Value}) ->
                {<<"subscription_billing_cycle_anchor">>, <<>>};
            ({subscription_cancel_at, _Value}) ->
                {<<"subscription_cancel_at">>, <<>>};
            ({subscription_cancel_at_period_end, _Value}) ->
                {<<"subscription_cancel_at_period_end">>, <<>>};
            ({subscription_cancel_now, _Value}) ->
                {<<"subscription_cancel_now">>, <<>>};
            ({subscription_default_tax_rates, _Value}) ->
                {<<"subscription_default_tax_rates">>, <<>>};
            ({subscription_items, _Value}) ->
                {<<"subscription_items">>, <<>>};
            ({subscription_proration_behavior, _Value}) ->
                {<<"subscription_proration_behavior">>, <<>>};
            ({subscription_proration_date, _Value}) ->
                {<<"subscription_proration_date">>, <<>>};
            ({subscription_start_date, _Value}) ->
                {<<"subscription_start_date">>, <<>>};
            ({subscription_trial_end, _Value}) ->
                {<<"subscription_trial_end">>, <<>>};
            ({subscription_trial_from_plan, _Value}) ->
                {<<"subscription_trial_from_plan">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([automatic_tax,
                                 coupon,
                                 customer,
                                 customer_details,
                                 discounts,
                                 ending_before,
                                 expand,
                                 invoice_items,
                                 limit,
                                 schedule,
                                 starting_after,
                                 subscription,
                                 subscription_billing_cycle_anchor,
                                 subscription_cancel_at,
                                 subscription_cancel_at_period_end,
                                 subscription_cancel_now,
                                 subscription_default_tax_rates,
                                 subscription_items,
                                 subscription_proration_behavior,
                                 subscription_proration_date,
                                 subscription_start_date,
                                 subscription_trial_end,
                                 subscription_trial_from_plan],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/upcoming/lines", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cardholders(map()) -> term().
post_issuing_cardholders(Args) ->
    post_issuing_cardholders(Args, #{}).

-spec post_issuing_cardholders(map(), mhttp:request_options()) -> term().
post_issuing_cardholders(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cardholders(map()) -> term().
get_issuing_cardholders(Args) ->
    get_issuing_cardholders(Args, #{}).

-spec get_issuing_cardholders(map(), mhttp:request_options()) -> term().
get_issuing_cardholders(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({email, _Value}) ->
                {<<"email">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({phone_number, _Value}) ->
                {<<"phone_number">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 email,
                                 ending_before,
                                 expand,
                                 limit,
                                 phone_number,
                                 starting_after,
                                 status,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_sources_id(map()) -> term().
post_customers_customer_sources_id(Args) ->
    post_customers_customer_sources_id(Args, #{}).

-spec post_customers_customer_sources_id(map(), mhttp:request_options()) -> term().
post_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/sources/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_sources_id(map()) -> term().
get_customers_customer_sources_id(Args) ->
    get_customers_customer_sources_id(Args, #{}).

-spec get_customers_customer_sources_id(map(), mhttp:request_options()) -> term().
get_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/sources/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_sources_id(map()) -> term().
delete_customers_customer_sources_id(Args) ->
    delete_customers_customer_sources_id(Args, #{}).

-spec delete_customers_customer_sources_id(map(), mhttp:request_options()) -> term().
delete_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/sources/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees(map()) -> term().
get_application_fees(Args) ->
    get_application_fees(Args, #{}).

-spec get_application_fees(map(), mhttp:request_options()) -> term().
get_application_fees(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge, created, ending_before, expand, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_receivers(map()) -> term().
get_bitcoin_receivers(Args) ->
    get_bitcoin_receivers(Args, #{}).

-spec get_bitcoin_receivers(map(), mhttp:request_options()) -> term().
get_bitcoin_receivers(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({filled, _Value}) ->
                {<<"filled">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({uncaptured_funds, _Value}) ->
                {<<"uncaptured_funds">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 ending_before,
                                 expand,
                                 filled,
                                 limit,
                                 starting_after,
                                 uncaptured_funds],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/receivers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_refunds_refund(map()) -> term().
post_refunds_refund(Args) ->
    post_refunds_refund(Args, #{}).

-spec post_refunds_refund(map(), mhttp:request_options()) -> term().
post_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds/%s", [Refund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_refunds_refund(map()) -> term().
get_refunds_refund(Args) ->
    get_refunds_refund(Args, #{}).

-spec get_refunds_refund(map(), mhttp:request_options()) -> term().
get_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds/%s", [Refund]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_login_links(map()) -> term().
post_account_login_links(Args) ->
    post_account_login_links(Args, #{}).

-spec post_account_login_links(map(), mhttp:request_options()) -> term().
post_account_login_links(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/login_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tax_rates(map()) -> term().
post_tax_rates(Args) ->
    post_tax_rates(Args, #{}).

-spec post_tax_rates(map(), mhttp:request_options()) -> term().
post_tax_rates(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_tax_rates(map()) -> term().
get_tax_rates(Args) ->
    get_tax_rates(Args, #{}).

-spec get_tax_rates(map(), mhttp:request_options()) -> term().
get_tax_rates(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({inclusive, _Value}) ->
                {<<"inclusive">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active,
                                 created,
                                 ending_before,
                                 expand,
                                 inclusive,
                                 limit,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/tax_rates", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_accounts_account_people(map()) -> term().
post_accounts_account_people(Args) ->
    post_accounts_account_people(Args, #{}).

-spec post_accounts_account_people(map(), mhttp:request_options()) -> term().
post_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/people", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_accounts_account_people(map()) -> term().
get_accounts_account_people(Args) ->
    get_accounts_account_people(Args, #{}).

-spec get_accounts_account_people(map(), mhttp:request_options()) -> term().
get_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({relationship, _Value}) ->
                {<<"relationship">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, relationship, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/accounts/%s/people", [Account]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes_dispute_submit(map()) -> term().
post_issuing_disputes_dispute_submit(Args) ->
    post_issuing_disputes_dispute_submit(Args, #{}).

-spec post_issuing_disputes_dispute_submit(map(), mhttp:request_options()) -> term().
post_issuing_disputes_dispute_submit(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes/%s/submit", [Dispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources_source(map()) -> term().
post_sources_source(Args) ->
    post_sources_source(Args, #{}).

-spec post_sources_source(map(), mhttp:request_options()) -> term().
post_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/%s", [Source]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source(map()) -> term().
get_sources_source(Args) ->
    get_sources_source(Args, #{}).

-spec get_sources_source(map(), mhttp:request_options()) -> term().
get_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    EncodeQuery =
        fun ({client_secret, _Value}) ->
                {<<"client_secret">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([client_secret, expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/%s", [Source]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_checkout_sessions_session(map()) -> term().
get_checkout_sessions_session(Args) ->
    get_checkout_sessions_session(Args, #{}).

-spec get_checkout_sessions_session(map(), mhttp:request_options()) -> term().
get_checkout_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/checkout/sessions/%s", [Session]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_methods_payment_method_detach(map()) -> term().
post_payment_methods_payment_method_detach(Args) ->
    post_payment_methods_payment_method_detach(Args, #{}).

-spec post_payment_methods_payment_method_detach(map(), mhttp:request_options()) ->
                                                    term().
post_payment_methods_payment_method_detach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_methods/%s/detach", [PaymentMethod]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers(map()) -> term().
post_customers(Args) ->
    post_customers(Args, #{}).

-spec post_customers(map(), mhttp:request_options()) -> term().
post_customers(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers(map()) -> term().
get_customers(Args) ->
    get_customers(Args, #{}).

-spec get_customers(map(), mhttp:request_options()) -> term().
get_customers(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({email, _Value}) ->
                {<<"email">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, email, ending_before, expand, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_account_bank_accounts(map()) -> term().
post_account_bank_accounts(Args) ->
    post_account_bank_accounts(Args, #{}).

-spec post_account_bank_accounts(map(), mhttp:request_options()) -> term().
post_account_bank_accounts(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/account/bank_accounts", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_disputes_dispute(map()) -> term().
post_issuing_disputes_dispute(Args) ->
    post_issuing_disputes_dispute(Args, #{}).

-spec post_issuing_disputes_dispute(map(), mhttp:request_options()) -> term().
post_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes/%s", [Dispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_disputes_dispute(map()) -> term().
get_issuing_disputes_dispute(Args) ->
    get_issuing_disputes_dispute(Args, #{}).

-spec get_issuing_disputes_dispute(map(), mhttp:request_options()) -> term().
get_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/disputes/%s", [Dispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_disputes_dispute_close(map()) -> term().
post_disputes_dispute_close(Args) ->
    post_disputes_dispute_close(Args, #{}).

-spec post_disputes_dispute_close(map(), mhttp:request_options()) -> term().
post_disputes_dispute_close(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes/%s/close", [Dispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_cancel(map()) -> term().
post_quotes_quote_cancel(Args) ->
    post_quotes_quote_cancel(Args, #{}).

-spec post_quotes_quote_cancel(map(), mhttp:request_options()) -> term().
post_quotes_quote_cancel(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/%s/cancel", [Quote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_payment_methods(map()) -> term().
get_customers_customer_payment_methods(Args) ->
    get_customers_customer_payment_methods(Args, #{}).

-spec get_customers_customer_payment_methods(map(), mhttp:request_options()) -> term().
get_customers_customer_payment_methods(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after, type], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/payment_methods", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_refunds(map()) -> term().
post_refunds(Args) ->
    post_refunds(Args, #{}).

-spec post_refunds(map(), mhttp:request_options()) -> term().
post_refunds(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_refunds(map()) -> term().
get_refunds(Args) ->
    get_refunds(Args, #{}).

-spec get_refunds(map(), mhttp:request_options()) -> term().
get_refunds(Args, Options) ->
    EncodeQuery =
        fun ({charge, _Value}) ->
                {<<"charge">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_intent, _Value}) ->
                {<<"payment_intent">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([charge,
                                 created,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_intent,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/refunds", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_credit_notes_id(map()) -> term().
post_credit_notes_id(Args) ->
    post_credit_notes_id(Args, #{}).

-spec post_credit_notes_id(map(), mhttp:request_options()) -> term().
post_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_id(map()) -> term().
get_credit_notes_id(Args) ->
    get_credit_notes_id(Args, #{}).

-spec get_credit_notes_id(map(), mhttp:request_options()) -> term().
get_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_bitcoin_transactions(map()) -> term().
get_bitcoin_transactions(Args) ->
    get_bitcoin_transactions(Args, #{}).

-spec get_bitcoin_transactions(map(), mhttp:request_options()) -> term().
get_bitcoin_transactions(Args, Options) ->
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({receiver, _Value}) ->
                {<<"receiver">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, limit, receiver, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/bitcoin/transactions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_setup_intents(map()) -> term().
post_setup_intents(Args) ->
    post_setup_intents(Args, #{}).

-spec post_setup_intents(map(), mhttp:request_options()) -> term().
post_setup_intents(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_setup_intents(map()) -> term().
get_setup_intents(Args) ->
    get_setup_intents(Args, #{}).

-spec get_setup_intents(map(), mhttp:request_options()) -> term().
get_setup_intents(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({payment_method, _Value}) ->
                {<<"payment_method">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 payment_method,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/setup_intents", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout_cancel(map()) -> term().
post_payouts_payout_cancel(Args) ->
    post_payouts_payout_cancel(Args, #{}).

-spec post_payouts_payout_cancel(map(), mhttp:request_options()) -> term().
post_payouts_payout_cancel(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/%s/cancel", [Payout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_authorizations_authorization_approve(map()) -> term().
post_issuing_authorizations_authorization_approve(Args) ->
    post_issuing_authorizations_authorization_approve(Args, #{}).

-spec post_issuing_authorizations_authorization_approve(map(), mhttp:request_options()) ->
                                                           term().
post_issuing_authorizations_authorization_approve(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/%s/approve", [Authorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_authorizations_authorization_decline(map()) -> term().
post_issuing_authorizations_authorization_decline(Args) ->
    post_issuing_authorizations_authorization_decline(Args, #{}).

-spec post_issuing_authorizations_authorization_decline(map(), mhttp:request_options()) ->
                                                           term().
post_issuing_authorizations_authorization_decline(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/authorizations/%s/decline", [Authorization]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_reporting_report_runs(map()) -> term().
post_reporting_report_runs(Args) ->
    post_reporting_report_runs(Args, #{}).

-spec post_reporting_report_runs(map(), mhttp:request_options()) -> term().
post_reporting_report_runs(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_runs(map()) -> term().
get_reporting_report_runs(Args) ->
    get_reporting_report_runs(Args, #{}).

-spec get_reporting_report_runs(map(), mhttp:request_options()) -> term().
get_reporting_report_runs(Args, Options) ->
    EncodeQuery =
        fun ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([created, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoices_invoice_void(map()) -> term().
post_invoices_invoice_void(Args) ->
    post_invoices_invoice_void(Args, #{}).

-spec post_invoices_invoice_void(map(), mhttp:request_options()) -> term().
post_invoices_invoice_void(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoices/%s/void", [Invoice]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_sources(map()) -> term().
post_sources(Args) ->
    post_sources(Args, #{}).

-spec post_sources(map(), mhttp:request_options()) -> term().
post_sources(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/sources", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_configurations(map()) -> term().
post_billing_portal_configurations(Args) ->
    post_billing_portal_configurations(Args, #{}).

-spec post_billing_portal_configurations(map(), mhttp:request_options()) -> term().
post_billing_portal_configurations(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_billing_portal_configurations(map()) -> term().
get_billing_portal_configurations(Args) ->
    get_billing_portal_configurations(Args, #{}).

-spec get_billing_portal_configurations(map(), mhttp:request_options()) -> term().
get_billing_portal_configurations(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({is_default, _Value}) ->
                {<<"is_default">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active, ending_before, expand, is_default, limit, starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes(map()) -> term().
post_quotes(Args) ->
    post_quotes(Args, #{}).

-spec post_quotes(map(), mhttp:request_options()) -> term().
post_quotes(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes(map()) -> term().
get_quotes(Args) ->
    get_quotes(Args, #{}).

-spec get_quotes(map(), mhttp:request_options()) -> term().
get_quotes(Args, Options) ->
    EncodeQuery =
        fun ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([customer, ending_before, expand, limit, starting_after, status],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_transfers_transfer(map()) -> term().
post_transfers_transfer(Args) ->
    post_transfers_transfer(Args, #{}).

-spec post_transfers_transfer(map(), mhttp:request_options()) -> term().
post_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/%s", [Transfer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_transfers_transfer(map()) -> term().
get_transfers_transfer(Args) ->
    get_transfers_transfer(Args, #{}).

-spec get_transfers_transfer(map(), mhttp:request_options()) -> term().
get_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/transfers/%s", [Transfer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_quotes_quote_line_items(map()) -> term().
get_quotes_quote_line_items(Args) ->
    get_quotes_quote_line_items(Args, #{}).

-spec get_quotes_quote_line_items(map(), mhttp:request_options()) -> term().
get_quotes_quote_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/%s/line_items", [Quote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_invoiceitems_invoiceitem(map()) -> term().
post_invoiceitems_invoiceitem(Args) ->
    post_invoiceitems_invoiceitem(Args, #{}).

-spec post_invoiceitems_invoiceitem(map(), mhttp:request_options()) -> term().
post_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems/%s", [Invoiceitem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_invoiceitems_invoiceitem(map()) -> term().
get_invoiceitems_invoiceitem(Args) ->
    get_invoiceitems_invoiceitem(Args, #{}).

-spec get_invoiceitems_invoiceitem(map(), mhttp:request_options()) -> term().
get_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems/%s", [Invoiceitem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_invoiceitems_invoiceitem(map()) -> term().
delete_invoiceitems_invoiceitem(Args) ->
    delete_invoiceitems_invoiceitem(Args, #{}).

-spec delete_invoiceitems_invoiceitem(map(), mhttp:request_options()) -> term().
delete_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/invoiceitems/%s", [Invoiceitem]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_capture(map()) -> term().
post_payment_intents_intent_capture(Args) ->
    post_payment_intents_intent_capture(Args, #{}).

-spec post_payment_intents_intent_capture(map(), mhttp:request_options()) -> term().
post_payment_intents_intent_capture(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/%s/capture", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cards(map()) -> term().
post_issuing_cards(Args) ->
    post_issuing_cards(Args, #{}).

-spec post_issuing_cards(map(), mhttp:request_options()) -> term().
post_issuing_cards(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cards(map()) -> term().
get_issuing_cards(Args) ->
    get_issuing_cards(Args, #{}).

-spec get_issuing_cards(map(), mhttp:request_options()) -> term().
get_issuing_cards(Args, Options) ->
    EncodeQuery =
        fun ({cardholder, _Value}) ->
                {<<"cardholder">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({exp_month, _Value}) ->
                {<<"exp_month">>, <<>>};
            ({exp_year, _Value}) ->
                {<<"exp_year">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({last4, _Value}) ->
                {<<"last4">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>};
            ({status, _Value}) ->
                {<<"status">>, <<>>};
            ({type, _Value}) ->
                {<<"type">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([cardholder,
                                 created,
                                 ending_before,
                                 exp_month,
                                 exp_year,
                                 expand,
                                 last4,
                                 limit,
                                 starting_after,
                                 status,
                                 type],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source_source_transactions(map()) -> term().
get_sources_source_source_transactions(Args) ->
    get_sources_source_source_transactions(Args, #{}).

-spec get_sources_source_source_transactions(map(), mhttp:request_options()) -> term().
get_sources_source_source_transactions(Args, Options) ->
    VarSource = maps:get(source, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/sources/%s/source_transactions", [Source]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules_schedule_release(map()) -> term().
post_subscription_schedules_schedule_release(Args) ->
    post_subscription_schedules_schedule_release(Args, #{}).

-spec post_subscription_schedules_schedule_release(map(), mhttp:request_options()) ->
                                                      term().
post_subscription_schedules_schedule_release(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules/%s/release", [Schedule]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer_cards_id(map()) -> term().
post_customers_customer_cards_id(Args) ->
    post_customers_customer_cards_id(Args, #{}).

-spec post_customers_customer_cards_id(map(), mhttp:request_options()) -> term().
post_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/cards/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer_cards_id(map()) -> term().
get_customers_customer_cards_id(Args) ->
    get_customers_customer_cards_id(Args, #{}).

-spec get_customers_customer_cards_id(map(), mhttp:request_options()) -> term().
get_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/cards/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer_cards_id(map()) -> term().
delete_customers_customer_cards_id(Args) ->
    delete_customers_customer_cards_id(Args, #{}).

-spec delete_customers_customer_cards_id(map(), mhttp:request_options()) -> term().
delete_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s/cards/%s", [Customer, Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_charges_charge_dispute(map()) -> term().
post_charges_charge_dispute(Args) ->
    post_charges_charge_dispute(Args, #{}).

-spec post_charges_charge_dispute(map(), mhttp:request_options()) -> term().
post_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s/dispute", [Charge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_charges_charge_dispute(map()) -> term().
get_charges_charge_dispute(Args) ->
    get_charges_charge_dispute(Args, #{}).

-spec get_charges_charge_dispute(map(), mhttp:request_options()) -> term().
get_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/charges/%s/dispute", [Charge]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_quotes_quote_finalize(map()) -> term().
post_quotes_quote_finalize(Args) ->
    post_quotes_quote_finalize(Args, #{}).

-spec post_quotes_quote_finalize(map(), mhttp:request_options()) -> term().
post_quotes_quote_finalize(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/quotes/%s/finalize", [Quote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_skus_id(map()) -> term().
post_skus_id(Args) ->
    post_skus_id(Args, #{}).

-spec post_skus_id(map(), mhttp:request_options()) -> term().
post_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/skus/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_skus_id(map()) -> term().
get_skus_id(Args) ->
    get_skus_id(Args, #{}).

-spec get_skus_id(map(), mhttp:request_options()) -> term().
get_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/skus/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_skus_id(map()) -> term().
delete_skus_id(Args) ->
    delete_skus_id(Args, #{}).

-spec delete_skus_id(map(), mhttp:request_options()) -> term().
delete_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/skus/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_disputes_dispute(map()) -> term().
post_disputes_dispute(Args) ->
    post_disputes_dispute(Args, #{}).

-spec post_disputes_dispute(map(), mhttp:request_options()) -> term().
post_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes/%s", [Dispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_disputes_dispute(map()) -> term().
get_disputes_dispute(Args) ->
    get_disputes_dispute(Args, #{}).

-spec get_disputes_dispute(map(), mhttp:request_options()) -> term().
get_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/disputes/%s", [Dispute]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_terminal_locations(map()) -> term().
post_terminal_locations(Args) ->
    post_terminal_locations(Args, #{}).

-spec post_terminal_locations(map(), mhttp:request_options()) -> term().
post_terminal_locations(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_terminal_locations(map()) -> term().
get_terminal_locations(Args) ->
    get_terminal_locations(Args, #{}).

-spec get_terminal_locations(map(), mhttp:request_options()) -> term().
get_terminal_locations(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_subscription_schedules(map()) -> term().
post_subscription_schedules(Args) ->
    post_subscription_schedules(Args, #{}).

-spec post_subscription_schedules(map(), mhttp:request_options()) -> term().
post_subscription_schedules(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_subscription_schedules(map()) -> term().
get_subscription_schedules(Args) ->
    get_subscription_schedules(Args, #{}).

-spec get_subscription_schedules(map(), mhttp:request_options()) -> term().
get_subscription_schedules(Args, Options) ->
    EncodeQuery =
        fun ({canceled_at, _Value}) ->
                {<<"canceled_at">>, <<>>};
            ({completed_at, _Value}) ->
                {<<"completed_at">>, <<>>};
            ({created, _Value}) ->
                {<<"created">>, <<>>};
            ({customer, _Value}) ->
                {<<"customer">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({released_at, _Value}) ->
                {<<"released_at">>, <<>>};
            ({scheduled, _Value}) ->
                {<<"scheduled">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([canceled_at,
                                 completed_at,
                                 created,
                                 customer,
                                 ending_before,
                                 expand,
                                 limit,
                                 released_at,
                                 scheduled,
                                 starting_after],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_links(map()) -> term().
post_payment_links(Args) ->
    post_payment_links(Args, #{}).

-spec post_payment_links(map(), mhttp:request_options()) -> term().
post_payment_links(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links(map()) -> term().
get_payment_links(Args) ->
    get_payment_links(Args, #{}).

-spec get_payment_links(map(), mhttp:request_options()) -> term().
get_payment_links(Args, Options) ->
    EncodeQuery =
        fun ({active, _Value}) ->
                {<<"active">>, <<>>};
            ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([active, ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_tokens(map()) -> term().
post_tokens(Args) ->
    post_tokens(Args, #{}).

-spec post_tokens(map(), mhttp:request_options()) -> term().
post_tokens(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/tokens", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_issuing_cardholders_cardholder(map()) -> term().
post_issuing_cardholders_cardholder(Args) ->
    post_issuing_cardholders_cardholder(Args, #{}).

-spec post_issuing_cardholders_cardholder(map(), mhttp:request_options()) -> term().
post_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders/%s", [Cardholder]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_issuing_cardholders_cardholder(map()) -> term().
get_issuing_cardholders_cardholder(Args) ->
    get_issuing_cardholders_cardholder(Args, #{}).

-spec get_issuing_cardholders_cardholder(map(), mhttp:request_options()) -> term().
get_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/issuing/cardholders/%s", [Cardholder]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_application_fees_id(map()) -> term().
get_application_fees_id(Args) ->
    get_application_fees_id(Args, #{}).

-spec get_application_fees_id(map(), mhttp:request_options()) -> term().
get_application_fees_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/application_fees/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_exchange_rates_rate_id(map()) -> term().
get_exchange_rates_rate_id(Args) ->
    get_exchange_rates_rate_id(Args, #{}).

-spec get_exchange_rates_rate_id(map(), mhttp:request_options()) -> term().
get_exchange_rates_rate_id(Args, Options) ->
    VarRateId = maps:get(rate_id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/exchange_rates/%s", [RateId]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_intents_intent_confirm(map()) -> term().
post_payment_intents_intent_confirm(Args) ->
    post_payment_intents_intent_confirm(Args, #{}).

-spec post_payment_intents_intent_confirm(map(), mhttp:request_options()) -> term().
post_payment_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_intents/%s/confirm", [Intent]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_preview(map()) -> term().
get_credit_notes_preview(Args) ->
    get_credit_notes_preview(Args, #{}).

-spec get_credit_notes_preview(map(), mhttp:request_options()) -> term().
get_credit_notes_preview(Args, Options) ->
    EncodeQuery =
        fun ({amount, _Value}) ->
                {<<"amount">>, <<>>};
            ({credit_amount, _Value}) ->
                {<<"credit_amount">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({invoice, _Value}) ->
                {<<"invoice">>, <<>>};
            ({lines, _Value}) ->
                {<<"lines">>, <<>>};
            ({memo, _Value}) ->
                {<<"memo">>, <<>>};
            ({metadata, _Value}) ->
                {<<"metadata">>, <<>>};
            ({out_of_band_amount, _Value}) ->
                {<<"out_of_band_amount">>, <<>>};
            ({reason, _Value}) ->
                {<<"reason">>, <<>>};
            ({refund, _Value}) ->
                {<<"refund">>, <<>>};
            ({refund_amount, _Value}) ->
                {<<"refund_amount">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([amount,
                                 credit_amount,
                                 expand,
                                 invoice,
                                 lines,
                                 memo,
                                 metadata,
                                 out_of_band_amount,
                                 reason,
                                 refund,
                                 refund_amount],
                                Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/preview", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_balance_history_id(map()) -> term().
get_balance_history_id(Args) ->
    get_balance_history_id(Args, #{}).

-spec get_balance_history_id(map(), mhttp:request_options()) -> term().
get_balance_history_id(Args, Options) ->
    VarId = maps:get(id, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/balance/history/%s", [Id]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payouts_payout_reverse(map()) -> term().
post_payouts_payout_reverse(Args) ->
    post_payouts_payout_reverse(Args, #{}).

-spec post_payouts_payout_reverse(map(), mhttp:request_options()) -> term().
post_payouts_payout_reverse(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payouts/%s/reverse", [Payout]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_reporting_report_runs_report_run(map()) -> term().
get_reporting_report_runs_report_run(Args) ->
    get_reporting_report_runs_report_run(Args, #{}).

-spec get_reporting_report_runs_report_run(map(), mhttp:request_options()) -> term().
get_reporting_report_runs_report_run(Args, Options) ->
    VarReportRun = maps:get(report_run, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/reporting/report_runs/%s", [ReportRun]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sources_source_source_transactions_source_transaction(map()) -> term().
get_sources_source_source_transactions_source_transaction(Args) ->
    get_sources_source_source_transactions_source_transaction(Args, #{}).

-spec get_sources_source_source_transactions_source_transaction(map(),
                                                                mhttp:request_options()) ->
                                                                   term().
get_sources_source_source_transactions_source_transaction(Args, Options) ->
    VarSource = maps:get(source, Args),
    VarSourceTransaction = maps:get(source_transaction, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath =
        io_lib:format("/v1/sources/%s/source_transactions/%s", [Source, SourceTransaction]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_customers_customer(map()) -> term().
post_customers_customer(Args) ->
    post_customers_customer(Args, #{}).

-spec post_customers_customer(map(), mhttp:request_options()) -> term().
post_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_customers_customer(map()) -> term().
get_customers_customer(Args) ->
    get_customers_customer(Args, #{}).

-spec get_customers_customer(map(), mhttp:request_options()) -> term().
get_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec delete_customers_customer(map()) -> term().
delete_customers_customer(Args) ->
    delete_customers_customer(Args, #{}).

-spec delete_customers_customer(map(), mhttp:request_options()) -> term().
delete_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = delete,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/customers/%s", [Customer]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_billing_portal_sessions(map()) -> term().
post_billing_portal_sessions(Args) ->
    post_billing_portal_sessions(Args, #{}).

-spec post_billing_portal_sessions(map(), mhttp:request_options()) -> term().
post_billing_portal_sessions(Args, Options) ->
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/billing_portal/sessions", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec post_payment_links_payment_link(map()) -> term().
post_payment_links_payment_link(Args) ->
    post_payment_links_payment_link(Args, #{}).

-spec post_payment_links_payment_link(map(), mhttp:request_options()) -> term().
post_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    ReqQuery = [],
    ReqHeader = [],
    ReqMethod = post,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links/%s", [PaymentLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_payment_links_payment_link(map()) -> term().
get_payment_links_payment_link(Args) ->
    get_payment_links_payment_link(Args, #{}).

-spec get_payment_links_payment_link(map(), mhttp:request_options()) -> term().
get_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    EncodeQuery = fun({expand, _Value}) -> {<<"expand">>, <<>>} end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([expand], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/payment_links/%s", [PaymentLink]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_credit_notes_credit_note_lines(map()) -> term().
get_credit_notes_credit_note_lines(Args) ->
    get_credit_notes_credit_note_lines(Args, #{}).

-spec get_credit_notes_credit_note_lines(map(), mhttp:request_options()) -> term().
get_credit_notes_credit_note_lines(Args, Options) ->
    VarCreditNote = maps:get(credit_note, Args),
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/credit_notes/%s/lines", [CreditNote]),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.

-spec get_sigma_scheduled_query_runs(map()) -> term().
get_sigma_scheduled_query_runs(Args) ->
    get_sigma_scheduled_query_runs(Args, #{}).

-spec get_sigma_scheduled_query_runs(map(), mhttp:request_options()) -> term().
get_sigma_scheduled_query_runs(Args, Options) ->
    EncodeQuery =
        fun ({ending_before, _Value}) ->
                {<<"ending_before">>, <<>>};
            ({expand, _Value}) ->
                {<<"expand">>, <<>>};
            ({limit, _Value}) ->
                {<<"limit">>, <<>>};
            ({starting_after, _Value}) ->
                {<<"starting_after">>, <<>>}
        end,

    ReqQuery =
        lists:map(EncodeQuery,
                  maps:to_list(
                      maps:with([ending_before, expand, limit, starting_after], Args))),
    ReqHeader = [],
    ReqMethod = get,
    ReqBody = [],
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs", []),
    Req = #{method => ReqMethod,
            header => ReqHeader,
            target => #{path => ReqPath, query => ReqQuery}},
    case mhttp:send_request(Req, Options) of
        {ok, Response} ->
            Header = mhttp_response:header(Response),
            case mhttp_header:find(Header, <<"Content-Type">>) of
                {ok, HeaderValue} ->
                    case mhttp_media_type:parse(HeaderValue) of
                        {ok, _MediaType} ->
                            case mhttp_response:status(Response) of
                                200 ->
                                    {ok, Response};
                                _ ->
                                    handle_default_here
                            end;
                        {error, Reason} ->
                            {error, {invalid_content_type, Reason}}
                    end;
                error ->
                    {error, missing_content_type}
            end;
        {error, Reason} ->
            {error, {mhttp, Reason}}
    end.
