%% File generated by erl-openapi on "2022-03-08T14:00:13Z".

-module(stripe_client).

-export([encode_q/4, encode_h/4]).
-export([get_radar_early_fraud_warnings/1, get_radar_early_fraud_warnings/2]).
-export([post_charges_charge_refunds/1, post_charges_charge_refunds/2]).
-export([get_charges_charge_refunds/1, get_charges_charge_refunds/2]).
-export([post_identity_verification_sessions_session_redact/1,
         post_identity_verification_sessions_session_redact/2]).
-export([post_billing_portal_configurations_configuration/1,
         post_billing_portal_configurations_configuration/2]).
-export([get_billing_portal_configurations_configuration/1,
         get_billing_portal_configurations_configuration/2]).
-export([post_payment_methods/1, post_payment_methods/2]).
-export([get_payment_methods/1, get_payment_methods/2]).
-export([delete_radar_value_lists_value_list/1, delete_radar_value_lists_value_list/2]).
-export([post_radar_value_lists_value_list/1, post_radar_value_lists_value_list/2]).
-export([get_radar_value_lists_value_list/1, get_radar_value_lists_value_list/2]).
-export([post_charges_charge_capture/1, post_charges_charge_capture/2]).
-export([get_disputes/1, get_disputes/2]).
-export([post_prices_price/1, post_prices_price/2]).
-export([get_prices_price/1, get_prices_price/2]).
-export([post_accounts/1, post_accounts/2]).
-export([get_accounts/1, get_accounts/2]).
-export([post_identity_verification_sessions_session_cancel/1,
         post_identity_verification_sessions_session_cancel/2]).
-export([delete_account_persons_person/1, delete_account_persons_person/2]).
-export([post_account_persons_person/1, post_account_persons_person/2]).
-export([get_account_persons_person/1, get_account_persons_person/2]).
-export([post_issuing_authorizations_authorization/1,
         post_issuing_authorizations_authorization/2]).
-export([get_issuing_authorizations_authorization/1,
         get_issuing_authorizations_authorization/2]).
-export([get_files_file/1, get_files_file/2]).
-export([post_issuing_cards_card/1, post_issuing_cards_card/2]).
-export([get_issuing_cards_card/1, get_issuing_cards_card/2]).
-export([post_sources_source_verify/1, post_sources_source_verify/2]).
-export([post_invoiceitems/1, post_invoiceitems/2]).
-export([get_invoiceitems/1, get_invoiceitems/2]).
-export([delete_ephemeral_keys_key/1, delete_ephemeral_keys_key/2]).
-export([get_exchange_rates/1, get_exchange_rates/2]).
-export([post_setup_intents_intent/1, post_setup_intents_intent/2]).
-export([get_setup_intents_intent/1, get_setup_intents_intent/2]).
-export([post_files/1, post_files/2]).
-export([get_files/1, get_files/2]).
-export([delete_customers_customer_bank_accounts_id/1,
         delete_customers_customer_bank_accounts_id/2]).
-export([post_customers_customer_bank_accounts_id/1,
         post_customers_customer_bank_accounts_id/2]).
-export([get_customers_customer_bank_accounts_id/1,
         get_customers_customer_bank_accounts_id/2]).
-export([get_issuer_fraud_records_issuer_fraud_record/1,
         get_issuer_fraud_records_issuer_fraud_record/2]).
-export([delete_accounts_account_people_person/1,
         delete_accounts_account_people_person/2]).
-export([post_accounts_account_people_person/1, post_accounts_account_people_person/2]).
-export([get_accounts_account_people_person/1, get_accounts_account_people_person/2]).
-export([post_payouts/1, post_payouts/2]).
-export([get_payouts/1, get_payouts/2]).
-export([post_account_capabilities_capability/1, post_account_capabilities_capability/2]).
-export([get_account_capabilities_capability/1, get_account_capabilities_capability/2]).
-export([get_sources_source_mandate_notifications_mandate_notification/1,
         get_sources_source_mandate_notifications_mandate_notification/2]).
-export([post_application_fees_fee_refunds_id/1, post_application_fees_fee_refunds_id/2]).
-export([get_application_fees_fee_refunds_id/1, get_application_fees_fee_refunds_id/2]).
-export([delete_customers_customer_discount/1, delete_customers_customer_discount/2]).
-export([get_customers_customer_discount/1, get_customers_customer_discount/2]).
-export([post_coupons/1, post_coupons/2]).
-export([get_coupons/1, get_coupons/2]).
-export([post_charges_charge_dispute_close/1, post_charges_charge_dispute_close/2]).
-export([delete_plans_plan/1, delete_plans_plan/2]).
-export([post_plans_plan/1, post_plans_plan/2]).
-export([get_plans_plan/1, get_plans_plan/2]).
-export([post_customers_customer_bank_accounts/1,
         post_customers_customer_bank_accounts/2]).
-export([get_customers_customer_bank_accounts/1, get_customers_customer_bank_accounts/2]).
-export([delete_terminal_readers_reader/1, delete_terminal_readers_reader/2]).
-export([post_terminal_readers_reader/1, post_terminal_readers_reader/2]).
-export([get_terminal_readers_reader/1, get_terminal_readers_reader/2]).
-export([delete_accounts_account_persons_person/1,
         delete_accounts_account_persons_person/2]).
-export([post_accounts_account_persons_person/1, post_accounts_account_persons_person/2]).
-export([get_accounts_account_persons_person/1, get_accounts_account_persons_person/2]).
-export([post_credit_notes_id_void/1, post_credit_notes_id_void/2]).
-export([post_customers_customer_sources/1, post_customers_customer_sources/2]).
-export([get_customers_customer_sources/1, get_customers_customer_sources/2]).
-export([post_account_links/1, post_account_links/2]).
-export([post_payouts_payout/1, post_payouts_payout/2]).
-export([get_payouts_payout/1, get_payouts_payout/2]).
-export([delete_subscription_items_item/1, delete_subscription_items_item/2]).
-export([post_subscription_items_item/1, post_subscription_items_item/2]).
-export([get_subscription_items_item/1, get_subscription_items_item/2]).
-export([post_products/1, post_products/2]).
-export([get_products/1, get_products/2]).
-export([get_reporting_report_types_report_type/1,
         get_reporting_report_types_report_type/2]).
-export([post_quotes_quote_accept/1, post_quotes_quote_accept/2]).
-export([get_mandates_mandate/1, get_mandates_mandate/2]).
-export([post_customers_customer_subscriptions/1,
         post_customers_customer_subscriptions/2]).
-export([get_customers_customer_subscriptions/1, get_customers_customer_subscriptions/2]).
-export([get_order_returns_id/1, get_order_returns_id/2]).
-export([post_transfers_id_reversals/1, post_transfers_id_reversals/2]).
-export([get_transfers_id_reversals/1, get_transfers_id_reversals/2]).
-export([get_reviews_review/1, get_reviews_review/2]).
-export([delete_accounts_account_bank_accounts_id/1,
         delete_accounts_account_bank_accounts_id/2]).
-export([post_accounts_account_bank_accounts_id/1,
         post_accounts_account_bank_accounts_id/2]).
-export([get_accounts_account_bank_accounts_id/1,
         get_accounts_account_bank_accounts_id/2]).
-export([post_issuing_settlements_settlement/1, post_issuing_settlements_settlement/2]).
-export([get_issuing_settlements_settlement/1, get_issuing_settlements_settlement/2]).
-export([post_promotion_codes_promotion_code/1, post_promotion_codes_promotion_code/2]).
-export([get_promotion_codes_promotion_code/1, get_promotion_codes_promotion_code/2]).
-export([post_subscription_schedules_schedule_cancel/1,
         post_subscription_schedules_schedule_cancel/2]).
-export([post_identity_verification_sessions/1, post_identity_verification_sessions/2]).
-export([get_identity_verification_sessions/1, get_identity_verification_sessions/2]).
-export([post_radar_value_list_items/1, post_radar_value_list_items/2]).
-export([get_radar_value_list_items/1, get_radar_value_list_items/2]).
-export([get_events_id/1, get_events_id/2]).
-export([get_country_specs/1, get_country_specs/2]).
-export([post_payment_intents_intent_verify_microdeposits/1,
         post_payment_intents_intent_verify_microdeposits/2]).
-export([post_subscription_items_subscription_item_usage_records/1,
         post_subscription_items_subscription_item_usage_records/2]).
-export([get_balance_history/1, get_balance_history/2]).
-export([get_order_returns/1, get_order_returns/2]).
-export([delete_account_external_accounts_id/1, delete_account_external_accounts_id/2]).
-export([post_account_external_accounts_id/1, post_account_external_accounts_id/2]).
-export([get_account_external_accounts_id/1, get_account_external_accounts_id/2]).
-export([post_apple_pay_domains/1, post_apple_pay_domains/2]).
-export([get_apple_pay_domains/1, get_apple_pay_domains/2]).
-export([post_credit_notes/1, post_credit_notes/2]).
-export([get_credit_notes/1, get_credit_notes/2]).
-export([get_sigma_scheduled_query_runs_scheduled_query_run/1,
         get_sigma_scheduled_query_runs_scheduled_query_run/2]).
-export([delete_coupons_coupon/1, delete_coupons_coupon/2]).
-export([post_coupons_coupon/1, post_coupons_coupon/2]).
-export([get_coupons_coupon/1, get_coupons_coupon/2]).
-export([delete_customers_customer_tax_ids_id/1, delete_customers_customer_tax_ids_id/2]).
-export([get_customers_customer_tax_ids_id/1, get_customers_customer_tax_ids_id/2]).
-export([get_radar_early_fraud_warnings_early_fraud_warning/1,
         get_radar_early_fraud_warnings_early_fraud_warning/2]).
-export([get_issuing_settlements/1, get_issuing_settlements/2]).
-export([post_file_links/1, post_file_links/2]).
-export([get_file_links/1, get_file_links/2]).
-export([get_identity_verification_reports_report/1,
         get_identity_verification_reports_report/2]).
-export([post_transfers/1, post_transfers/2]).
-export([get_transfers/1, get_transfers/2]).
-export([delete_subscriptions_subscription_exposed_id_discount/1,
         delete_subscriptions_subscription_exposed_id_discount/2]).
-export([post_application_fees_id_refunds/1, post_application_fees_id_refunds/2]).
-export([get_application_fees_id_refunds/1, get_application_fees_id_refunds/2]).
-export([post_accounts_account_bank_accounts/1, post_accounts_account_bank_accounts/2]).
-export([delete_accounts_account/1, delete_accounts_account/2]).
-export([post_accounts_account/1, post_accounts_account/2]).
-export([get_accounts_account/1, get_accounts_account/2]).
-export([post_subscription_schedules_schedule/1, post_subscription_schedules_schedule/2]).
-export([get_subscription_schedules_schedule/1, get_subscription_schedules_schedule/2]).
-export([post_invoices_invoice_pay/1, post_invoices_invoice_pay/2]).
-export([post_transfers_transfer_reversals_id/1, post_transfers_transfer_reversals_id/2]).
-export([get_transfers_transfer_reversals_id/1, get_transfers_transfer_reversals_id/2]).
-export([post_topups_topup/1, post_topups_topup/2]).
-export([get_topups_topup/1, get_topups_topup/2]).
-export([delete_recipients_id/1, delete_recipients_id/2]).
-export([post_recipients_id/1, post_recipients_id/2]).
-export([get_recipients_id/1, get_recipients_id/2]).
-export([get_invoices_invoice_lines/1, get_invoices_invoice_lines/2]).
-export([delete_accounts_account_external_accounts_id/1,
         delete_accounts_account_external_accounts_id/2]).
-export([post_accounts_account_external_accounts_id/1,
         post_accounts_account_external_accounts_id/2]).
-export([get_accounts_account_external_accounts_id/1,
         get_accounts_account_external_accounts_id/2]).
-export([post_topups/1, post_topups/2]).
-export([get_topups/1, get_topups/2]).
-export([post_orders_id_returns/1, post_orders_id_returns/2]).
-export([post_orders_id/1, post_orders_id/2]).
-export([get_orders_id/1, get_orders_id/2]).
-export([delete_apple_pay_domains_domain/1, delete_apple_pay_domains_domain/2]).
-export([get_apple_pay_domains_domain/1, get_apple_pay_domains_domain/2]).
-export([get_issuing_transactions/1, get_issuing_transactions/2]).
-export([post_charges_charge_refund/1, post_charges_charge_refund/2]).
-export([post_payment_methods_payment_method_attach/1,
         post_payment_methods_payment_method_attach/2]).
-export([post_payment_intents_intent_cancel/1, post_payment_intents_intent_cancel/2]).
-export([get_accounts_account_capabilities/1, get_accounts_account_capabilities/2]).
-export([get_credit_notes_preview_lines/1, get_credit_notes_preview_lines/2]).
-export([post_subscriptions/1, post_subscriptions/2]).
-export([get_subscriptions/1, get_subscriptions/2]).
-export([get_setup_attempts/1, get_setup_attempts/2]).
-export([delete_customers_customer_subscriptions_subscription_exposed_id/1,
         delete_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([post_customers_customer_subscriptions_subscription_exposed_id/1,
         post_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([get_customers_customer_subscriptions_subscription_exposed_id/1,
         get_customers_customer_subscriptions_subscription_exposed_id/2]).
-export([get_bitcoin_receivers_id/1, get_bitcoin_receivers_id/2]).
-export([post_orders/1, post_orders/2]).
-export([get_orders/1, get_orders/2]).
-export([post_ephemeral_keys/1, post_ephemeral_keys/2]).
-export([delete_webhook_endpoints_webhook_endpoint/1,
         delete_webhook_endpoints_webhook_endpoint/2]).
-export([post_webhook_endpoints_webhook_endpoint/1,
         post_webhook_endpoints_webhook_endpoint/2]).
-export([get_webhook_endpoints_webhook_endpoint/1,
         get_webhook_endpoints_webhook_endpoint/2]).
-export([post_account_persons/1, post_account_persons/2]).
-export([get_account_persons/1, get_account_persons/2]).
-export([get_account_capabilities/1, get_account_capabilities/2]).
-export([post_checkout_sessions_session_expire/1,
         post_checkout_sessions_session_expire/2]).
-export([get_bitcoin_receivers_receiver_transactions/1,
         get_bitcoin_receivers_receiver_transactions/2]).
-export([post_quotes_quote/1, post_quotes_quote/2]).
-export([get_quotes_quote/1, get_quotes_quote/2]).
-export([post_account_people/1, post_account_people/2]).
-export([get_account_people/1, get_account_people/2]).
-export([post_setup_intents_intent_confirm/1, post_setup_intents_intent_confirm/2]).
-export([post_customers_customer_cards/1, post_customers_customer_cards/2]).
-export([get_customers_customer_cards/1, get_customers_customer_cards/2]).
-export([get_identity_verification_reports/1, get_identity_verification_reports/2]).
-export([post_accounts_account_persons/1, post_accounts_account_persons/2]).
-export([get_accounts_account_persons/1, get_accounts_account_persons/2]).
-export([post_application_fees_id_refund/1, post_application_fees_id_refund/2]).
-export([post_payment_intents/1, post_payment_intents/2]).
-export([get_payment_intents/1, get_payment_intents/2]).
-export([post_skus/1, post_skus/2]).
-export([get_skus/1, get_skus/2]).
-export([post_webhook_endpoints/1, post_webhook_endpoints/2]).
-export([get_webhook_endpoints/1, get_webhook_endpoints/2]).
-export([get_balance/1, get_balance/2]).
-export([post_customers_customer_balance_transactions_transaction/1,
         post_customers_customer_balance_transactions_transaction/2]).
-export([get_customers_customer_balance_transactions_transaction/1,
         get_customers_customer_balance_transactions_transaction/2]).
-export([post_payment_methods_payment_method/1, post_payment_methods_payment_method/2]).
-export([get_payment_methods_payment_method/1, get_payment_methods_payment_method/2]).
-export([post_topups_topup_cancel/1, post_topups_topup_cancel/2]).
-export([get_events/1, get_events/2]).
-export([post_charges_charge_refunds_refund/1, post_charges_charge_refunds_refund/2]).
-export([get_charges_charge_refunds_refund/1, get_charges_charge_refunds_refund/2]).
-export([post_accounts_account_capabilities_capability/1,
         post_accounts_account_capabilities_capability/2]).
-export([get_accounts_account_capabilities_capability/1,
         get_accounts_account_capabilities_capability/2]).
-export([post_subscription_items/1, post_subscription_items/2]).
-export([get_subscription_items/1, get_subscription_items/2]).
-export([get_quotes_quote_pdf/1, get_quotes_quote_pdf/2]).
-export([delete_account_bank_accounts_id/1, delete_account_bank_accounts_id/2]).
-export([post_account_bank_accounts_id/1, post_account_bank_accounts_id/2]).
-export([get_account_bank_accounts_id/1, get_account_bank_accounts_id/2]).
-export([get_payment_links_payment_link_line_items/1,
         get_payment_links_payment_link_line_items/2]).
-export([get_subscription_items_subscription_item_usage_record_summaries/1,
         get_subscription_items_subscription_item_usage_record_summaries/2]).
-export([post_payment_intents_intent/1, post_payment_intents_intent/2]).
-export([get_payment_intents_intent/1, get_payment_intents_intent/2]).
-export([post_charges/1, post_charges/2]).
-export([get_charges/1, get_charges/2]).
-export([post_accounts_account_external_accounts/1,
         post_accounts_account_external_accounts/2]).
-export([get_accounts_account_external_accounts/1,
         get_accounts_account_external_accounts/2]).
-export([get_issuing_authorizations/1, get_issuing_authorizations/2]).
-export([delete_products_id/1, delete_products_id/2]).
-export([post_products_id/1, post_products_id/2]).
-export([get_products_id/1, get_products_id/2]).
-export([post_setup_intents_intent_verify_microdeposits/1,
         post_setup_intents_intent_verify_microdeposits/2]).
-export([get_reporting_report_types/1, get_reporting_report_types/2]).
-export([post_account_external_accounts/1, post_account_external_accounts/2]).
-export([get_account_external_accounts/1, get_account_external_accounts/2]).
-export([post_radar_value_lists/1, post_radar_value_lists/2]).
-export([get_radar_value_lists/1, get_radar_value_lists/2]).
-export([post_shipping_rates/1, post_shipping_rates/2]).
-export([get_shipping_rates/1, get_shipping_rates/2]).
-export([post_file_links_link/1, post_file_links_link/2]).
-export([get_file_links_link/1, get_file_links_link/2]).
-export([get3d_secure_three_d_secure/1, get3d_secure_three_d_secure/2]).
-export([post_invoices_invoice_send/1, post_invoices_invoice_send/2]).
-export([get_invoices_upcoming/1, get_invoices_upcoming/2]).
-export([get_checkout_sessions_session_line_items/1,
         get_checkout_sessions_session_line_items/2]).
-export([get_tax_codes/1, get_tax_codes/2]).
-export([post_invoices/1, post_invoices/2]).
-export([get_invoices/1, get_invoices/2]).
-export([post_charges_charge/1, post_charges_charge/2]).
-export([get_charges_charge/1, get_charges_charge/2]).
-export([post_invoices_invoice_mark_uncollectible/1,
         post_invoices_invoice_mark_uncollectible/2]).
-export([post_customers_customer_sources_id_verify/1,
         post_customers_customer_sources_id_verify/2]).
-export([post_orders_id_pay/1, post_orders_id_pay/2]).
-export([post_customers_customer_bank_accounts_id_verify/1,
         post_customers_customer_bank_accounts_id_verify/2]).
-export([delete_account_people_person/1, delete_account_people_person/2]).
-export([post_account_people_person/1, post_account_people_person/2]).
-export([get_account_people_person/1, get_account_people_person/2]).
-export([post_checkout_sessions/1, post_checkout_sessions/2]).
-export([get_checkout_sessions/1, get_checkout_sessions/2]).
-export([post_accounts_account_login_links/1, post_accounts_account_login_links/2]).
-export([post_terminal_readers/1, post_terminal_readers/2]).
-export([get_terminal_readers/1, get_terminal_readers/2]).
-export([post_issuing_disputes/1, post_issuing_disputes/2]).
-export([get_issuing_disputes/1, get_issuing_disputes/2]).
-export([post3d_secure/1, post3d_secure/2]).
-export([post_prices/1, post_prices/2]).
-export([get_prices/1, get_prices/2]).
-export([delete_invoices_invoice/1, delete_invoices_invoice/2]).
-export([post_invoices_invoice/1, post_invoices_invoice/2]).
-export([get_invoices_invoice/1, get_invoices_invoice/2]).
-export([post_identity_verification_sessions_session/1,
         post_identity_verification_sessions_session/2]).
-export([get_identity_verification_sessions_session/1,
         get_identity_verification_sessions_session/2]).
-export([get_balance_transactions_id/1, get_balance_transactions_id/2]).
-export([post_setup_intents_intent_cancel/1, post_setup_intents_intent_cancel/2]).
-export([post_issuing_transactions_transaction/1,
         post_issuing_transactions_transaction/2]).
-export([get_issuing_transactions_transaction/1, get_issuing_transactions_transaction/2]).
-export([post_terminal_connection_tokens/1, post_terminal_connection_tokens/2]).
-export([get_reviews/1, get_reviews/2]).
-export([post_promotion_codes/1, post_promotion_codes/2]).
-export([get_promotion_codes/1, get_promotion_codes/2]).
-export([delete_customers_customer_subscriptions_subscription_exposed_id_discount/1,
         delete_customers_customer_subscriptions_subscription_exposed_id_discount/2]).
-export([get_customers_customer_subscriptions_subscription_exposed_id_discount/1,
         get_customers_customer_subscriptions_subscription_exposed_id_discount/2]).
-export([get_quotes_quote_computed_upfront_line_items/1,
         get_quotes_quote_computed_upfront_line_items/2]).
-export([delete_radar_value_list_items_item/1, delete_radar_value_list_items_item/2]).
-export([get_radar_value_list_items_item/1, get_radar_value_list_items_item/2]).
-export([get_issuer_fraud_records/1, get_issuer_fraud_records/2]).
-export([post_tax_rates_tax_rate/1, post_tax_rates_tax_rate/2]).
-export([get_tax_rates_tax_rate/1, get_tax_rates_tax_rate/2]).
-export([post_recipients/1, post_recipients/2]).
-export([get_recipients/1, get_recipients/2]).
-export([post_plans/1, post_plans/2]).
-export([get_plans/1, get_plans/2]).
-export([post_customers_customer_balance_transactions/1,
         post_customers_customer_balance_transactions/2]).
-export([get_customers_customer_balance_transactions/1,
         get_customers_customer_balance_transactions/2]).
-export([post_reviews_review_approve/1, post_reviews_review_approve/2]).
-export([post_customers_customer_tax_ids/1, post_customers_customer_tax_ids/2]).
-export([get_customers_customer_tax_ids/1, get_customers_customer_tax_ids/2]).
-export([get_tokens_token/1, get_tokens_token/2]).
-export([get_balance_transactions/1, get_balance_transactions/2]).
-export([get_tax_codes_id/1, get_tax_codes_id/2]).
-export([post_accounts_account_reject/1, post_accounts_account_reject/2]).
-export([delete_subscriptions_subscription_exposed_id/1,
         delete_subscriptions_subscription_exposed_id/2]).
-export([post_subscriptions_subscription_exposed_id/1,
         post_subscriptions_subscription_exposed_id/2]).
-export([get_subscriptions_subscription_exposed_id/1,
         get_subscriptions_subscription_exposed_id/2]).
-export([get_country_specs_country/1, get_country_specs_country/2]).
-export([post_invoices_invoice_finalize/1, post_invoices_invoice_finalize/2]).
-export([delete_terminal_locations_location/1, delete_terminal_locations_location/2]).
-export([post_terminal_locations_location/1, post_terminal_locations_location/2]).
-export([get_terminal_locations_location/1, get_terminal_locations_location/2]).
-export([delete_account/1, delete_account/2]).
-export([post_account/1, post_account/2]).
-export([get_account/1, get_account/2]).
-export([post_shipping_rates_shipping_rate_token/1,
         post_shipping_rates_shipping_rate_token/2]).
-export([get_shipping_rates_shipping_rate_token/1,
         get_shipping_rates_shipping_rate_token/2]).
-export([get_invoices_upcoming_lines/1, get_invoices_upcoming_lines/2]).
-export([post_issuing_cardholders/1, post_issuing_cardholders/2]).
-export([get_issuing_cardholders/1, get_issuing_cardholders/2]).
-export([delete_customers_customer_sources_id/1, delete_customers_customer_sources_id/2]).
-export([post_customers_customer_sources_id/1, post_customers_customer_sources_id/2]).
-export([get_customers_customer_sources_id/1, get_customers_customer_sources_id/2]).
-export([get_application_fees/1, get_application_fees/2]).
-export([get_bitcoin_receivers/1, get_bitcoin_receivers/2]).
-export([post_refunds_refund/1, post_refunds_refund/2]).
-export([get_refunds_refund/1, get_refunds_refund/2]).
-export([post_account_login_links/1, post_account_login_links/2]).
-export([post_tax_rates/1, post_tax_rates/2]).
-export([get_tax_rates/1, get_tax_rates/2]).
-export([post_accounts_account_people/1, post_accounts_account_people/2]).
-export([get_accounts_account_people/1, get_accounts_account_people/2]).
-export([post_issuing_disputes_dispute_submit/1, post_issuing_disputes_dispute_submit/2]).
-export([post_sources_source/1, post_sources_source/2]).
-export([get_sources_source/1, get_sources_source/2]).
-export([get_checkout_sessions_session/1, get_checkout_sessions_session/2]).
-export([post_payment_methods_payment_method_detach/1,
         post_payment_methods_payment_method_detach/2]).
-export([post_customers/1, post_customers/2]).
-export([get_customers/1, get_customers/2]).
-export([post_account_bank_accounts/1, post_account_bank_accounts/2]).
-export([post_issuing_disputes_dispute/1, post_issuing_disputes_dispute/2]).
-export([get_issuing_disputes_dispute/1, get_issuing_disputes_dispute/2]).
-export([post_disputes_dispute_close/1, post_disputes_dispute_close/2]).
-export([post_quotes_quote_cancel/1, post_quotes_quote_cancel/2]).
-export([get_customers_customer_payment_methods/1,
         get_customers_customer_payment_methods/2]).
-export([post_refunds/1, post_refunds/2]).
-export([get_refunds/1, get_refunds/2]).
-export([post_credit_notes_id/1, post_credit_notes_id/2]).
-export([get_credit_notes_id/1, get_credit_notes_id/2]).
-export([get_bitcoin_transactions/1, get_bitcoin_transactions/2]).
-export([post_setup_intents/1, post_setup_intents/2]).
-export([get_setup_intents/1, get_setup_intents/2]).
-export([post_payouts_payout_cancel/1, post_payouts_payout_cancel/2]).
-export([post_issuing_authorizations_authorization_approve/1,
         post_issuing_authorizations_authorization_approve/2]).
-export([post_issuing_authorizations_authorization_decline/1,
         post_issuing_authorizations_authorization_decline/2]).
-export([post_reporting_report_runs/1, post_reporting_report_runs/2]).
-export([get_reporting_report_runs/1, get_reporting_report_runs/2]).
-export([post_invoices_invoice_void/1, post_invoices_invoice_void/2]).
-export([post_sources/1, post_sources/2]).
-export([post_billing_portal_configurations/1, post_billing_portal_configurations/2]).
-export([get_billing_portal_configurations/1, get_billing_portal_configurations/2]).
-export([post_quotes/1, post_quotes/2]).
-export([get_quotes/1, get_quotes/2]).
-export([post_transfers_transfer/1, post_transfers_transfer/2]).
-export([get_transfers_transfer/1, get_transfers_transfer/2]).
-export([get_quotes_quote_line_items/1, get_quotes_quote_line_items/2]).
-export([delete_invoiceitems_invoiceitem/1, delete_invoiceitems_invoiceitem/2]).
-export([post_invoiceitems_invoiceitem/1, post_invoiceitems_invoiceitem/2]).
-export([get_invoiceitems_invoiceitem/1, get_invoiceitems_invoiceitem/2]).
-export([post_payment_intents_intent_capture/1, post_payment_intents_intent_capture/2]).
-export([post_issuing_cards/1, post_issuing_cards/2]).
-export([get_issuing_cards/1, get_issuing_cards/2]).
-export([get_sources_source_source_transactions/1,
         get_sources_source_source_transactions/2]).
-export([post_subscription_schedules_schedule_release/1,
         post_subscription_schedules_schedule_release/2]).
-export([delete_customers_customer_cards_id/1, delete_customers_customer_cards_id/2]).
-export([post_customers_customer_cards_id/1, post_customers_customer_cards_id/2]).
-export([get_customers_customer_cards_id/1, get_customers_customer_cards_id/2]).
-export([post_charges_charge_dispute/1, post_charges_charge_dispute/2]).
-export([get_charges_charge_dispute/1, get_charges_charge_dispute/2]).
-export([post_quotes_quote_finalize/1, post_quotes_quote_finalize/2]).
-export([delete_skus_id/1, delete_skus_id/2]).
-export([post_skus_id/1, post_skus_id/2]).
-export([get_skus_id/1, get_skus_id/2]).
-export([post_disputes_dispute/1, post_disputes_dispute/2]).
-export([get_disputes_dispute/1, get_disputes_dispute/2]).
-export([post_terminal_locations/1, post_terminal_locations/2]).
-export([get_terminal_locations/1, get_terminal_locations/2]).
-export([post_subscription_schedules/1, post_subscription_schedules/2]).
-export([get_subscription_schedules/1, get_subscription_schedules/2]).
-export([post_payment_links/1, post_payment_links/2]).
-export([get_payment_links/1, get_payment_links/2]).
-export([post_tokens/1, post_tokens/2]).
-export([post_issuing_cardholders_cardholder/1, post_issuing_cardholders_cardholder/2]).
-export([get_issuing_cardholders_cardholder/1, get_issuing_cardholders_cardholder/2]).
-export([get_application_fees_id/1, get_application_fees_id/2]).
-export([get_exchange_rates_rate_id/1, get_exchange_rates_rate_id/2]).
-export([post_payment_intents_intent_confirm/1, post_payment_intents_intent_confirm/2]).
-export([get_credit_notes_preview/1, get_credit_notes_preview/2]).
-export([get_balance_history_id/1, get_balance_history_id/2]).
-export([post_payouts_payout_reverse/1, post_payouts_payout_reverse/2]).
-export([get_reporting_report_runs_report_run/1, get_reporting_report_runs_report_run/2]).
-export([get_sources_source_source_transactions_source_transaction/1,
         get_sources_source_source_transactions_source_transaction/2]).
-export([delete_customers_customer/1, delete_customers_customer/2]).
-export([post_customers_customer/1, post_customers_customer/2]).
-export([get_customers_customer/1, get_customers_customer/2]).
-export([post_billing_portal_sessions/1, post_billing_portal_sessions/2]).
-export([post_payment_links_payment_link/1, post_payment_links_payment_link/2]).
-export([get_payment_links_payment_link/1, get_payment_links_payment_link/2]).
-export([get_credit_notes_credit_note_lines/1, get_credit_notes_credit_note_lines/2]).
-export([get_sigma_scheduled_query_runs/1, get_sigma_scheduled_query_runs/2]).

-export_type([options/0, result/1, error/0, error_reason/0]).
-export_type([get_radar_early_fraud_warnings_request/0,
              get_radar_early_fraud_warnings_request_query/0,
              get_radar_early_fraud_warnings_request_header/0,
              get_radar_early_fraud_warnings_request_cookie/0,
              get_radar_early_fraud_warnings_request_body/0,
              get_radar_early_fraud_warnings_response/0]).
-export_type([post_charges_charge_refunds_request/0,
              post_charges_charge_refunds_request_query/0,
              post_charges_charge_refunds_request_header/0,
              post_charges_charge_refunds_request_cookie/0,
              post_charges_charge_refunds_request_body/0, post_charges_charge_refunds_response/0]).
-export_type([get_charges_charge_refunds_request/0,
              get_charges_charge_refunds_request_query/0,
              get_charges_charge_refunds_request_header/0,
              get_charges_charge_refunds_request_cookie/0,
              get_charges_charge_refunds_request_body/0, get_charges_charge_refunds_response/0]).
-export_type([post_identity_verification_sessions_session_redact_request/0,
              post_identity_verification_sessions_session_redact_request_query/0,
              post_identity_verification_sessions_session_redact_request_header/0,
              post_identity_verification_sessions_session_redact_request_cookie/0,
              post_identity_verification_sessions_session_redact_request_body/0,
              post_identity_verification_sessions_session_redact_response/0]).
-export_type([post_billing_portal_configurations_configuration_request/0,
              post_billing_portal_configurations_configuration_request_query/0,
              post_billing_portal_configurations_configuration_request_header/0,
              post_billing_portal_configurations_configuration_request_cookie/0,
              post_billing_portal_configurations_configuration_request_body/0,
              post_billing_portal_configurations_configuration_response/0]).
-export_type([get_billing_portal_configurations_configuration_request/0,
              get_billing_portal_configurations_configuration_request_query/0,
              get_billing_portal_configurations_configuration_request_header/0,
              get_billing_portal_configurations_configuration_request_cookie/0,
              get_billing_portal_configurations_configuration_request_body/0,
              get_billing_portal_configurations_configuration_response/0]).
-export_type([post_payment_methods_request/0, post_payment_methods_request_query/0,
              post_payment_methods_request_header/0, post_payment_methods_request_cookie/0,
              post_payment_methods_request_body/0, post_payment_methods_response/0]).
-export_type([get_payment_methods_request/0, get_payment_methods_request_query/0,
              get_payment_methods_request_header/0, get_payment_methods_request_cookie/0,
              get_payment_methods_request_body/0, get_payment_methods_response/0]).
-export_type([delete_radar_value_lists_value_list_request/0,
              delete_radar_value_lists_value_list_request_query/0,
              delete_radar_value_lists_value_list_request_header/0,
              delete_radar_value_lists_value_list_request_cookie/0,
              delete_radar_value_lists_value_list_request_body/0,
              delete_radar_value_lists_value_list_response/0]).
-export_type([post_radar_value_lists_value_list_request/0,
              post_radar_value_lists_value_list_request_query/0,
              post_radar_value_lists_value_list_request_header/0,
              post_radar_value_lists_value_list_request_cookie/0,
              post_radar_value_lists_value_list_request_body/0,
              post_radar_value_lists_value_list_response/0]).
-export_type([get_radar_value_lists_value_list_request/0,
              get_radar_value_lists_value_list_request_query/0,
              get_radar_value_lists_value_list_request_header/0,
              get_radar_value_lists_value_list_request_cookie/0,
              get_radar_value_lists_value_list_request_body/0,
              get_radar_value_lists_value_list_response/0]).
-export_type([post_charges_charge_capture_request/0,
              post_charges_charge_capture_request_query/0,
              post_charges_charge_capture_request_header/0,
              post_charges_charge_capture_request_cookie/0,
              post_charges_charge_capture_request_body/0, post_charges_charge_capture_response/0]).
-export_type([get_disputes_request/0, get_disputes_request_query/0,
              get_disputes_request_header/0, get_disputes_request_cookie/0,
              get_disputes_request_body/0, get_disputes_response/0]).
-export_type([post_prices_price_request/0, post_prices_price_request_query/0,
              post_prices_price_request_header/0, post_prices_price_request_cookie/0,
              post_prices_price_request_body/0, post_prices_price_response/0]).
-export_type([get_prices_price_request/0, get_prices_price_request_query/0,
              get_prices_price_request_header/0, get_prices_price_request_cookie/0,
              get_prices_price_request_body/0, get_prices_price_response/0]).
-export_type([post_accounts_request/0, post_accounts_request_query/0,
              post_accounts_request_header/0, post_accounts_request_cookie/0,
              post_accounts_request_body/0, post_accounts_response/0]).
-export_type([get_accounts_request/0, get_accounts_request_query/0,
              get_accounts_request_header/0, get_accounts_request_cookie/0,
              get_accounts_request_body/0, get_accounts_response/0]).
-export_type([post_identity_verification_sessions_session_cancel_request/0,
              post_identity_verification_sessions_session_cancel_request_query/0,
              post_identity_verification_sessions_session_cancel_request_header/0,
              post_identity_verification_sessions_session_cancel_request_cookie/0,
              post_identity_verification_sessions_session_cancel_request_body/0,
              post_identity_verification_sessions_session_cancel_response/0]).
-export_type([delete_account_persons_person_request/0,
              delete_account_persons_person_request_query/0,
              delete_account_persons_person_request_header/0,
              delete_account_persons_person_request_cookie/0,
              delete_account_persons_person_request_body/0,
              delete_account_persons_person_response/0]).
-export_type([post_account_persons_person_request/0,
              post_account_persons_person_request_query/0,
              post_account_persons_person_request_header/0,
              post_account_persons_person_request_cookie/0,
              post_account_persons_person_request_body/0, post_account_persons_person_response/0]).
-export_type([get_account_persons_person_request/0,
              get_account_persons_person_request_query/0,
              get_account_persons_person_request_header/0,
              get_account_persons_person_request_cookie/0,
              get_account_persons_person_request_body/0, get_account_persons_person_response/0]).
-export_type([post_issuing_authorizations_authorization_request/0,
              post_issuing_authorizations_authorization_request_query/0,
              post_issuing_authorizations_authorization_request_header/0,
              post_issuing_authorizations_authorization_request_cookie/0,
              post_issuing_authorizations_authorization_request_body/0,
              post_issuing_authorizations_authorization_response/0]).
-export_type([get_issuing_authorizations_authorization_request/0,
              get_issuing_authorizations_authorization_request_query/0,
              get_issuing_authorizations_authorization_request_header/0,
              get_issuing_authorizations_authorization_request_cookie/0,
              get_issuing_authorizations_authorization_request_body/0,
              get_issuing_authorizations_authorization_response/0]).
-export_type([get_files_file_request/0, get_files_file_request_query/0,
              get_files_file_request_header/0, get_files_file_request_cookie/0,
              get_files_file_request_body/0, get_files_file_response/0]).
-export_type([post_issuing_cards_card_request/0, post_issuing_cards_card_request_query/0,
              post_issuing_cards_card_request_header/0, post_issuing_cards_card_request_cookie/0,
              post_issuing_cards_card_request_body/0, post_issuing_cards_card_response/0]).
-export_type([get_issuing_cards_card_request/0, get_issuing_cards_card_request_query/0,
              get_issuing_cards_card_request_header/0, get_issuing_cards_card_request_cookie/0,
              get_issuing_cards_card_request_body/0, get_issuing_cards_card_response/0]).
-export_type([post_sources_source_verify_request/0,
              post_sources_source_verify_request_query/0,
              post_sources_source_verify_request_header/0,
              post_sources_source_verify_request_cookie/0,
              post_sources_source_verify_request_body/0, post_sources_source_verify_response/0]).
-export_type([post_invoiceitems_request/0, post_invoiceitems_request_query/0,
              post_invoiceitems_request_header/0, post_invoiceitems_request_cookie/0,
              post_invoiceitems_request_body/0, post_invoiceitems_response/0]).
-export_type([get_invoiceitems_request/0, get_invoiceitems_request_query/0,
              get_invoiceitems_request_header/0, get_invoiceitems_request_cookie/0,
              get_invoiceitems_request_body/0, get_invoiceitems_response/0]).
-export_type([delete_ephemeral_keys_key_request/0,
              delete_ephemeral_keys_key_request_query/0, delete_ephemeral_keys_key_request_header/0,
              delete_ephemeral_keys_key_request_cookie/0, delete_ephemeral_keys_key_request_body/0,
              delete_ephemeral_keys_key_response/0]).
-export_type([get_exchange_rates_request/0, get_exchange_rates_request_query/0,
              get_exchange_rates_request_header/0, get_exchange_rates_request_cookie/0,
              get_exchange_rates_request_body/0, get_exchange_rates_response/0]).
-export_type([post_setup_intents_intent_request/0,
              post_setup_intents_intent_request_query/0, post_setup_intents_intent_request_header/0,
              post_setup_intents_intent_request_cookie/0, post_setup_intents_intent_request_body/0,
              post_setup_intents_intent_response/0]).
-export_type([get_setup_intents_intent_request/0,
              get_setup_intents_intent_request_query/0, get_setup_intents_intent_request_header/0,
              get_setup_intents_intent_request_cookie/0, get_setup_intents_intent_request_body/0,
              get_setup_intents_intent_response/0]).
-export_type([post_files_request/0, post_files_request_query/0,
              post_files_request_header/0, post_files_request_cookie/0, post_files_request_body/0,
              post_files_response/0]).
-export_type([get_files_request/0, get_files_request_query/0, get_files_request_header/0,
              get_files_request_cookie/0, get_files_request_body/0, get_files_response/0]).
-export_type([delete_customers_customer_bank_accounts_id_request/0,
              delete_customers_customer_bank_accounts_id_request_query/0,
              delete_customers_customer_bank_accounts_id_request_header/0,
              delete_customers_customer_bank_accounts_id_request_cookie/0,
              delete_customers_customer_bank_accounts_id_request_body/0,
              delete_customers_customer_bank_accounts_id_response/0]).
-export_type([post_customers_customer_bank_accounts_id_request/0,
              post_customers_customer_bank_accounts_id_request_query/0,
              post_customers_customer_bank_accounts_id_request_header/0,
              post_customers_customer_bank_accounts_id_request_cookie/0,
              post_customers_customer_bank_accounts_id_request_body/0,
              post_customers_customer_bank_accounts_id_response/0]).
-export_type([get_customers_customer_bank_accounts_id_request/0,
              get_customers_customer_bank_accounts_id_request_query/0,
              get_customers_customer_bank_accounts_id_request_header/0,
              get_customers_customer_bank_accounts_id_request_cookie/0,
              get_customers_customer_bank_accounts_id_request_body/0,
              get_customers_customer_bank_accounts_id_response/0]).
-export_type([get_issuer_fraud_records_issuer_fraud_record_request/0,
              get_issuer_fraud_records_issuer_fraud_record_request_query/0,
              get_issuer_fraud_records_issuer_fraud_record_request_header/0,
              get_issuer_fraud_records_issuer_fraud_record_request_cookie/0,
              get_issuer_fraud_records_issuer_fraud_record_request_body/0,
              get_issuer_fraud_records_issuer_fraud_record_response/0]).
-export_type([delete_accounts_account_people_person_request/0,
              delete_accounts_account_people_person_request_query/0,
              delete_accounts_account_people_person_request_header/0,
              delete_accounts_account_people_person_request_cookie/0,
              delete_accounts_account_people_person_request_body/0,
              delete_accounts_account_people_person_response/0]).
-export_type([post_accounts_account_people_person_request/0,
              post_accounts_account_people_person_request_query/0,
              post_accounts_account_people_person_request_header/0,
              post_accounts_account_people_person_request_cookie/0,
              post_accounts_account_people_person_request_body/0,
              post_accounts_account_people_person_response/0]).
-export_type([get_accounts_account_people_person_request/0,
              get_accounts_account_people_person_request_query/0,
              get_accounts_account_people_person_request_header/0,
              get_accounts_account_people_person_request_cookie/0,
              get_accounts_account_people_person_request_body/0,
              get_accounts_account_people_person_response/0]).
-export_type([post_payouts_request/0, post_payouts_request_query/0,
              post_payouts_request_header/0, post_payouts_request_cookie/0,
              post_payouts_request_body/0, post_payouts_response/0]).
-export_type([get_payouts_request/0, get_payouts_request_query/0,
              get_payouts_request_header/0, get_payouts_request_cookie/0,
              get_payouts_request_body/0, get_payouts_response/0]).
-export_type([post_account_capabilities_capability_request/0,
              post_account_capabilities_capability_request_query/0,
              post_account_capabilities_capability_request_header/0,
              post_account_capabilities_capability_request_cookie/0,
              post_account_capabilities_capability_request_body/0,
              post_account_capabilities_capability_response/0]).
-export_type([get_account_capabilities_capability_request/0,
              get_account_capabilities_capability_request_query/0,
              get_account_capabilities_capability_request_header/0,
              get_account_capabilities_capability_request_cookie/0,
              get_account_capabilities_capability_request_body/0,
              get_account_capabilities_capability_response/0]).
-export_type([get_sources_source_mandate_notifications_mandate_notification_request/0,
              get_sources_source_mandate_notifications_mandate_notification_request_query/0,
              get_sources_source_mandate_notifications_mandate_notification_request_header/0,
              get_sources_source_mandate_notifications_mandate_notification_request_cookie/0,
              get_sources_source_mandate_notifications_mandate_notification_request_body/0,
              get_sources_source_mandate_notifications_mandate_notification_response/0]).
-export_type([post_application_fees_fee_refunds_id_request/0,
              post_application_fees_fee_refunds_id_request_query/0,
              post_application_fees_fee_refunds_id_request_header/0,
              post_application_fees_fee_refunds_id_request_cookie/0,
              post_application_fees_fee_refunds_id_request_body/0,
              post_application_fees_fee_refunds_id_response/0]).
-export_type([get_application_fees_fee_refunds_id_request/0,
              get_application_fees_fee_refunds_id_request_query/0,
              get_application_fees_fee_refunds_id_request_header/0,
              get_application_fees_fee_refunds_id_request_cookie/0,
              get_application_fees_fee_refunds_id_request_body/0,
              get_application_fees_fee_refunds_id_response/0]).
-export_type([delete_customers_customer_discount_request/0,
              delete_customers_customer_discount_request_query/0,
              delete_customers_customer_discount_request_header/0,
              delete_customers_customer_discount_request_cookie/0,
              delete_customers_customer_discount_request_body/0,
              delete_customers_customer_discount_response/0]).
-export_type([get_customers_customer_discount_request/0,
              get_customers_customer_discount_request_query/0,
              get_customers_customer_discount_request_header/0,
              get_customers_customer_discount_request_cookie/0,
              get_customers_customer_discount_request_body/0,
              get_customers_customer_discount_response/0]).
-export_type([post_coupons_request/0, post_coupons_request_query/0,
              post_coupons_request_header/0, post_coupons_request_cookie/0,
              post_coupons_request_body/0, post_coupons_response/0]).
-export_type([get_coupons_request/0, get_coupons_request_query/0,
              get_coupons_request_header/0, get_coupons_request_cookie/0,
              get_coupons_request_body/0, get_coupons_response/0]).
-export_type([post_charges_charge_dispute_close_request/0,
              post_charges_charge_dispute_close_request_query/0,
              post_charges_charge_dispute_close_request_header/0,
              post_charges_charge_dispute_close_request_cookie/0,
              post_charges_charge_dispute_close_request_body/0,
              post_charges_charge_dispute_close_response/0]).
-export_type([delete_plans_plan_request/0, delete_plans_plan_request_query/0,
              delete_plans_plan_request_header/0, delete_plans_plan_request_cookie/0,
              delete_plans_plan_request_body/0, delete_plans_plan_response/0]).
-export_type([post_plans_plan_request/0, post_plans_plan_request_query/0,
              post_plans_plan_request_header/0, post_plans_plan_request_cookie/0,
              post_plans_plan_request_body/0, post_plans_plan_response/0]).
-export_type([get_plans_plan_request/0, get_plans_plan_request_query/0,
              get_plans_plan_request_header/0, get_plans_plan_request_cookie/0,
              get_plans_plan_request_body/0, get_plans_plan_response/0]).
-export_type([post_customers_customer_bank_accounts_request/0,
              post_customers_customer_bank_accounts_request_query/0,
              post_customers_customer_bank_accounts_request_header/0,
              post_customers_customer_bank_accounts_request_cookie/0,
              post_customers_customer_bank_accounts_request_body/0,
              post_customers_customer_bank_accounts_response/0]).
-export_type([get_customers_customer_bank_accounts_request/0,
              get_customers_customer_bank_accounts_request_query/0,
              get_customers_customer_bank_accounts_request_header/0,
              get_customers_customer_bank_accounts_request_cookie/0,
              get_customers_customer_bank_accounts_request_body/0,
              get_customers_customer_bank_accounts_response/0]).
-export_type([delete_terminal_readers_reader_request/0,
              delete_terminal_readers_reader_request_query/0,
              delete_terminal_readers_reader_request_header/0,
              delete_terminal_readers_reader_request_cookie/0,
              delete_terminal_readers_reader_request_body/0,
              delete_terminal_readers_reader_response/0]).
-export_type([post_terminal_readers_reader_request/0,
              post_terminal_readers_reader_request_query/0,
              post_terminal_readers_reader_request_header/0,
              post_terminal_readers_reader_request_cookie/0,
              post_terminal_readers_reader_request_body/0,
              post_terminal_readers_reader_response/0]).
-export_type([get_terminal_readers_reader_request/0,
              get_terminal_readers_reader_request_query/0,
              get_terminal_readers_reader_request_header/0,
              get_terminal_readers_reader_request_cookie/0,
              get_terminal_readers_reader_request_body/0, get_terminal_readers_reader_response/0]).
-export_type([delete_accounts_account_persons_person_request/0,
              delete_accounts_account_persons_person_request_query/0,
              delete_accounts_account_persons_person_request_header/0,
              delete_accounts_account_persons_person_request_cookie/0,
              delete_accounts_account_persons_person_request_body/0,
              delete_accounts_account_persons_person_response/0]).
-export_type([post_accounts_account_persons_person_request/0,
              post_accounts_account_persons_person_request_query/0,
              post_accounts_account_persons_person_request_header/0,
              post_accounts_account_persons_person_request_cookie/0,
              post_accounts_account_persons_person_request_body/0,
              post_accounts_account_persons_person_response/0]).
-export_type([get_accounts_account_persons_person_request/0,
              get_accounts_account_persons_person_request_query/0,
              get_accounts_account_persons_person_request_header/0,
              get_accounts_account_persons_person_request_cookie/0,
              get_accounts_account_persons_person_request_body/0,
              get_accounts_account_persons_person_response/0]).
-export_type([post_credit_notes_id_void_request/0,
              post_credit_notes_id_void_request_query/0, post_credit_notes_id_void_request_header/0,
              post_credit_notes_id_void_request_cookie/0, post_credit_notes_id_void_request_body/0,
              post_credit_notes_id_void_response/0]).
-export_type([post_customers_customer_sources_request/0,
              post_customers_customer_sources_request_query/0,
              post_customers_customer_sources_request_header/0,
              post_customers_customer_sources_request_cookie/0,
              post_customers_customer_sources_request_body/0,
              post_customers_customer_sources_response/0]).
-export_type([get_customers_customer_sources_request/0,
              get_customers_customer_sources_request_query/0,
              get_customers_customer_sources_request_header/0,
              get_customers_customer_sources_request_cookie/0,
              get_customers_customer_sources_request_body/0,
              get_customers_customer_sources_response/0]).
-export_type([post_account_links_request/0, post_account_links_request_query/0,
              post_account_links_request_header/0, post_account_links_request_cookie/0,
              post_account_links_request_body/0, post_account_links_response/0]).
-export_type([post_payouts_payout_request/0, post_payouts_payout_request_query/0,
              post_payouts_payout_request_header/0, post_payouts_payout_request_cookie/0,
              post_payouts_payout_request_body/0, post_payouts_payout_response/0]).
-export_type([get_payouts_payout_request/0, get_payouts_payout_request_query/0,
              get_payouts_payout_request_header/0, get_payouts_payout_request_cookie/0,
              get_payouts_payout_request_body/0, get_payouts_payout_response/0]).
-export_type([delete_subscription_items_item_request/0,
              delete_subscription_items_item_request_query/0,
              delete_subscription_items_item_request_header/0,
              delete_subscription_items_item_request_cookie/0,
              delete_subscription_items_item_request_body/0,
              delete_subscription_items_item_response/0]).
-export_type([post_subscription_items_item_request/0,
              post_subscription_items_item_request_query/0,
              post_subscription_items_item_request_header/0,
              post_subscription_items_item_request_cookie/0,
              post_subscription_items_item_request_body/0,
              post_subscription_items_item_response/0]).
-export_type([get_subscription_items_item_request/0,
              get_subscription_items_item_request_query/0,
              get_subscription_items_item_request_header/0,
              get_subscription_items_item_request_cookie/0,
              get_subscription_items_item_request_body/0, get_subscription_items_item_response/0]).
-export_type([post_products_request/0, post_products_request_query/0,
              post_products_request_header/0, post_products_request_cookie/0,
              post_products_request_body/0, post_products_response/0]).
-export_type([get_products_request/0, get_products_request_query/0,
              get_products_request_header/0, get_products_request_cookie/0,
              get_products_request_body/0, get_products_response/0]).
-export_type([get_reporting_report_types_report_type_request/0,
              get_reporting_report_types_report_type_request_query/0,
              get_reporting_report_types_report_type_request_header/0,
              get_reporting_report_types_report_type_request_cookie/0,
              get_reporting_report_types_report_type_request_body/0,
              get_reporting_report_types_report_type_response/0]).
-export_type([post_quotes_quote_accept_request/0,
              post_quotes_quote_accept_request_query/0, post_quotes_quote_accept_request_header/0,
              post_quotes_quote_accept_request_cookie/0, post_quotes_quote_accept_request_body/0,
              post_quotes_quote_accept_response/0]).
-export_type([get_mandates_mandate_request/0, get_mandates_mandate_request_query/0,
              get_mandates_mandate_request_header/0, get_mandates_mandate_request_cookie/0,
              get_mandates_mandate_request_body/0, get_mandates_mandate_response/0]).
-export_type([post_customers_customer_subscriptions_request/0,
              post_customers_customer_subscriptions_request_query/0,
              post_customers_customer_subscriptions_request_header/0,
              post_customers_customer_subscriptions_request_cookie/0,
              post_customers_customer_subscriptions_request_body/0,
              post_customers_customer_subscriptions_response/0]).
-export_type([get_customers_customer_subscriptions_request/0,
              get_customers_customer_subscriptions_request_query/0,
              get_customers_customer_subscriptions_request_header/0,
              get_customers_customer_subscriptions_request_cookie/0,
              get_customers_customer_subscriptions_request_body/0,
              get_customers_customer_subscriptions_response/0]).
-export_type([get_order_returns_id_request/0, get_order_returns_id_request_query/0,
              get_order_returns_id_request_header/0, get_order_returns_id_request_cookie/0,
              get_order_returns_id_request_body/0, get_order_returns_id_response/0]).
-export_type([post_transfers_id_reversals_request/0,
              post_transfers_id_reversals_request_query/0,
              post_transfers_id_reversals_request_header/0,
              post_transfers_id_reversals_request_cookie/0,
              post_transfers_id_reversals_request_body/0, post_transfers_id_reversals_response/0]).
-export_type([get_transfers_id_reversals_request/0,
              get_transfers_id_reversals_request_query/0,
              get_transfers_id_reversals_request_header/0,
              get_transfers_id_reversals_request_cookie/0,
              get_transfers_id_reversals_request_body/0, get_transfers_id_reversals_response/0]).
-export_type([get_reviews_review_request/0, get_reviews_review_request_query/0,
              get_reviews_review_request_header/0, get_reviews_review_request_cookie/0,
              get_reviews_review_request_body/0, get_reviews_review_response/0]).
-export_type([delete_accounts_account_bank_accounts_id_request/0,
              delete_accounts_account_bank_accounts_id_request_query/0,
              delete_accounts_account_bank_accounts_id_request_header/0,
              delete_accounts_account_bank_accounts_id_request_cookie/0,
              delete_accounts_account_bank_accounts_id_request_body/0,
              delete_accounts_account_bank_accounts_id_response/0]).
-export_type([post_accounts_account_bank_accounts_id_request/0,
              post_accounts_account_bank_accounts_id_request_query/0,
              post_accounts_account_bank_accounts_id_request_header/0,
              post_accounts_account_bank_accounts_id_request_cookie/0,
              post_accounts_account_bank_accounts_id_request_body/0,
              post_accounts_account_bank_accounts_id_response/0]).
-export_type([get_accounts_account_bank_accounts_id_request/0,
              get_accounts_account_bank_accounts_id_request_query/0,
              get_accounts_account_bank_accounts_id_request_header/0,
              get_accounts_account_bank_accounts_id_request_cookie/0,
              get_accounts_account_bank_accounts_id_request_body/0,
              get_accounts_account_bank_accounts_id_response/0]).
-export_type([post_issuing_settlements_settlement_request/0,
              post_issuing_settlements_settlement_request_query/0,
              post_issuing_settlements_settlement_request_header/0,
              post_issuing_settlements_settlement_request_cookie/0,
              post_issuing_settlements_settlement_request_body/0,
              post_issuing_settlements_settlement_response/0]).
-export_type([get_issuing_settlements_settlement_request/0,
              get_issuing_settlements_settlement_request_query/0,
              get_issuing_settlements_settlement_request_header/0,
              get_issuing_settlements_settlement_request_cookie/0,
              get_issuing_settlements_settlement_request_body/0,
              get_issuing_settlements_settlement_response/0]).
-export_type([post_promotion_codes_promotion_code_request/0,
              post_promotion_codes_promotion_code_request_query/0,
              post_promotion_codes_promotion_code_request_header/0,
              post_promotion_codes_promotion_code_request_cookie/0,
              post_promotion_codes_promotion_code_request_body/0,
              post_promotion_codes_promotion_code_response/0]).
-export_type([get_promotion_codes_promotion_code_request/0,
              get_promotion_codes_promotion_code_request_query/0,
              get_promotion_codes_promotion_code_request_header/0,
              get_promotion_codes_promotion_code_request_cookie/0,
              get_promotion_codes_promotion_code_request_body/0,
              get_promotion_codes_promotion_code_response/0]).
-export_type([post_subscription_schedules_schedule_cancel_request/0,
              post_subscription_schedules_schedule_cancel_request_query/0,
              post_subscription_schedules_schedule_cancel_request_header/0,
              post_subscription_schedules_schedule_cancel_request_cookie/0,
              post_subscription_schedules_schedule_cancel_request_body/0,
              post_subscription_schedules_schedule_cancel_response/0]).
-export_type([post_identity_verification_sessions_request/0,
              post_identity_verification_sessions_request_query/0,
              post_identity_verification_sessions_request_header/0,
              post_identity_verification_sessions_request_cookie/0,
              post_identity_verification_sessions_request_body/0,
              post_identity_verification_sessions_response/0]).
-export_type([get_identity_verification_sessions_request/0,
              get_identity_verification_sessions_request_query/0,
              get_identity_verification_sessions_request_header/0,
              get_identity_verification_sessions_request_cookie/0,
              get_identity_verification_sessions_request_body/0,
              get_identity_verification_sessions_response/0]).
-export_type([post_radar_value_list_items_request/0,
              post_radar_value_list_items_request_query/0,
              post_radar_value_list_items_request_header/0,
              post_radar_value_list_items_request_cookie/0,
              post_radar_value_list_items_request_body/0, post_radar_value_list_items_response/0]).
-export_type([get_radar_value_list_items_request/0,
              get_radar_value_list_items_request_query/0,
              get_radar_value_list_items_request_header/0,
              get_radar_value_list_items_request_cookie/0,
              get_radar_value_list_items_request_body/0, get_radar_value_list_items_response/0]).
-export_type([get_events_id_request/0, get_events_id_request_query/0,
              get_events_id_request_header/0, get_events_id_request_cookie/0,
              get_events_id_request_body/0, get_events_id_response/0]).
-export_type([get_country_specs_request/0, get_country_specs_request_query/0,
              get_country_specs_request_header/0, get_country_specs_request_cookie/0,
              get_country_specs_request_body/0, get_country_specs_response/0]).
-export_type([post_payment_intents_intent_verify_microdeposits_request/0,
              post_payment_intents_intent_verify_microdeposits_request_query/0,
              post_payment_intents_intent_verify_microdeposits_request_header/0,
              post_payment_intents_intent_verify_microdeposits_request_cookie/0,
              post_payment_intents_intent_verify_microdeposits_request_body/0,
              post_payment_intents_intent_verify_microdeposits_response/0]).
-export_type([post_subscription_items_subscription_item_usage_records_request/0,
              post_subscription_items_subscription_item_usage_records_request_query/0,
              post_subscription_items_subscription_item_usage_records_request_header/0,
              post_subscription_items_subscription_item_usage_records_request_cookie/0,
              post_subscription_items_subscription_item_usage_records_request_body/0,
              post_subscription_items_subscription_item_usage_records_response/0]).
-export_type([get_balance_history_request/0, get_balance_history_request_query/0,
              get_balance_history_request_header/0, get_balance_history_request_cookie/0,
              get_balance_history_request_body/0, get_balance_history_response/0]).
-export_type([get_order_returns_request/0, get_order_returns_request_query/0,
              get_order_returns_request_header/0, get_order_returns_request_cookie/0,
              get_order_returns_request_body/0, get_order_returns_response/0]).
-export_type([delete_account_external_accounts_id_request/0,
              delete_account_external_accounts_id_request_query/0,
              delete_account_external_accounts_id_request_header/0,
              delete_account_external_accounts_id_request_cookie/0,
              delete_account_external_accounts_id_request_body/0,
              delete_account_external_accounts_id_response/0]).
-export_type([post_account_external_accounts_id_request/0,
              post_account_external_accounts_id_request_query/0,
              post_account_external_accounts_id_request_header/0,
              post_account_external_accounts_id_request_cookie/0,
              post_account_external_accounts_id_request_body/0,
              post_account_external_accounts_id_response/0]).
-export_type([get_account_external_accounts_id_request/0,
              get_account_external_accounts_id_request_query/0,
              get_account_external_accounts_id_request_header/0,
              get_account_external_accounts_id_request_cookie/0,
              get_account_external_accounts_id_request_body/0,
              get_account_external_accounts_id_response/0]).
-export_type([post_apple_pay_domains_request/0, post_apple_pay_domains_request_query/0,
              post_apple_pay_domains_request_header/0, post_apple_pay_domains_request_cookie/0,
              post_apple_pay_domains_request_body/0, post_apple_pay_domains_response/0]).
-export_type([get_apple_pay_domains_request/0, get_apple_pay_domains_request_query/0,
              get_apple_pay_domains_request_header/0, get_apple_pay_domains_request_cookie/0,
              get_apple_pay_domains_request_body/0, get_apple_pay_domains_response/0]).
-export_type([post_credit_notes_request/0, post_credit_notes_request_query/0,
              post_credit_notes_request_header/0, post_credit_notes_request_cookie/0,
              post_credit_notes_request_body/0, post_credit_notes_response/0]).
-export_type([get_credit_notes_request/0, get_credit_notes_request_query/0,
              get_credit_notes_request_header/0, get_credit_notes_request_cookie/0,
              get_credit_notes_request_body/0, get_credit_notes_response/0]).
-export_type([get_sigma_scheduled_query_runs_scheduled_query_run_request/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_request_query/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_request_header/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_request_cookie/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_request_body/0,
              get_sigma_scheduled_query_runs_scheduled_query_run_response/0]).
-export_type([delete_coupons_coupon_request/0, delete_coupons_coupon_request_query/0,
              delete_coupons_coupon_request_header/0, delete_coupons_coupon_request_cookie/0,
              delete_coupons_coupon_request_body/0, delete_coupons_coupon_response/0]).
-export_type([post_coupons_coupon_request/0, post_coupons_coupon_request_query/0,
              post_coupons_coupon_request_header/0, post_coupons_coupon_request_cookie/0,
              post_coupons_coupon_request_body/0, post_coupons_coupon_response/0]).
-export_type([get_coupons_coupon_request/0, get_coupons_coupon_request_query/0,
              get_coupons_coupon_request_header/0, get_coupons_coupon_request_cookie/0,
              get_coupons_coupon_request_body/0, get_coupons_coupon_response/0]).
-export_type([delete_customers_customer_tax_ids_id_request/0,
              delete_customers_customer_tax_ids_id_request_query/0,
              delete_customers_customer_tax_ids_id_request_header/0,
              delete_customers_customer_tax_ids_id_request_cookie/0,
              delete_customers_customer_tax_ids_id_request_body/0,
              delete_customers_customer_tax_ids_id_response/0]).
-export_type([get_customers_customer_tax_ids_id_request/0,
              get_customers_customer_tax_ids_id_request_query/0,
              get_customers_customer_tax_ids_id_request_header/0,
              get_customers_customer_tax_ids_id_request_cookie/0,
              get_customers_customer_tax_ids_id_request_body/0,
              get_customers_customer_tax_ids_id_response/0]).
-export_type([get_radar_early_fraud_warnings_early_fraud_warning_request/0,
              get_radar_early_fraud_warnings_early_fraud_warning_request_query/0,
              get_radar_early_fraud_warnings_early_fraud_warning_request_header/0,
              get_radar_early_fraud_warnings_early_fraud_warning_request_cookie/0,
              get_radar_early_fraud_warnings_early_fraud_warning_request_body/0,
              get_radar_early_fraud_warnings_early_fraud_warning_response/0]).
-export_type([get_issuing_settlements_request/0, get_issuing_settlements_request_query/0,
              get_issuing_settlements_request_header/0, get_issuing_settlements_request_cookie/0,
              get_issuing_settlements_request_body/0, get_issuing_settlements_response/0]).
-export_type([post_file_links_request/0, post_file_links_request_query/0,
              post_file_links_request_header/0, post_file_links_request_cookie/0,
              post_file_links_request_body/0, post_file_links_response/0]).
-export_type([get_file_links_request/0, get_file_links_request_query/0,
              get_file_links_request_header/0, get_file_links_request_cookie/0,
              get_file_links_request_body/0, get_file_links_response/0]).
-export_type([get_identity_verification_reports_report_request/0,
              get_identity_verification_reports_report_request_query/0,
              get_identity_verification_reports_report_request_header/0,
              get_identity_verification_reports_report_request_cookie/0,
              get_identity_verification_reports_report_request_body/0,
              get_identity_verification_reports_report_response/0]).
-export_type([post_transfers_request/0, post_transfers_request_query/0,
              post_transfers_request_header/0, post_transfers_request_cookie/0,
              post_transfers_request_body/0, post_transfers_response/0]).
-export_type([get_transfers_request/0, get_transfers_request_query/0,
              get_transfers_request_header/0, get_transfers_request_cookie/0,
              get_transfers_request_body/0, get_transfers_response/0]).
-export_type([delete_subscriptions_subscription_exposed_id_discount_request/0,
              delete_subscriptions_subscription_exposed_id_discount_request_query/0,
              delete_subscriptions_subscription_exposed_id_discount_request_header/0,
              delete_subscriptions_subscription_exposed_id_discount_request_cookie/0,
              delete_subscriptions_subscription_exposed_id_discount_request_body/0,
              delete_subscriptions_subscription_exposed_id_discount_response/0]).
-export_type([post_application_fees_id_refunds_request/0,
              post_application_fees_id_refunds_request_query/0,
              post_application_fees_id_refunds_request_header/0,
              post_application_fees_id_refunds_request_cookie/0,
              post_application_fees_id_refunds_request_body/0,
              post_application_fees_id_refunds_response/0]).
-export_type([get_application_fees_id_refunds_request/0,
              get_application_fees_id_refunds_request_query/0,
              get_application_fees_id_refunds_request_header/0,
              get_application_fees_id_refunds_request_cookie/0,
              get_application_fees_id_refunds_request_body/0,
              get_application_fees_id_refunds_response/0]).
-export_type([post_accounts_account_bank_accounts_request/0,
              post_accounts_account_bank_accounts_request_query/0,
              post_accounts_account_bank_accounts_request_header/0,
              post_accounts_account_bank_accounts_request_cookie/0,
              post_accounts_account_bank_accounts_request_body/0,
              post_accounts_account_bank_accounts_response/0]).
-export_type([delete_accounts_account_request/0, delete_accounts_account_request_query/0,
              delete_accounts_account_request_header/0, delete_accounts_account_request_cookie/0,
              delete_accounts_account_request_body/0, delete_accounts_account_response/0]).
-export_type([post_accounts_account_request/0, post_accounts_account_request_query/0,
              post_accounts_account_request_header/0, post_accounts_account_request_cookie/0,
              post_accounts_account_request_body/0, post_accounts_account_response/0]).
-export_type([get_accounts_account_request/0, get_accounts_account_request_query/0,
              get_accounts_account_request_header/0, get_accounts_account_request_cookie/0,
              get_accounts_account_request_body/0, get_accounts_account_response/0]).
-export_type([post_subscription_schedules_schedule_request/0,
              post_subscription_schedules_schedule_request_query/0,
              post_subscription_schedules_schedule_request_header/0,
              post_subscription_schedules_schedule_request_cookie/0,
              post_subscription_schedules_schedule_request_body/0,
              post_subscription_schedules_schedule_response/0]).
-export_type([get_subscription_schedules_schedule_request/0,
              get_subscription_schedules_schedule_request_query/0,
              get_subscription_schedules_schedule_request_header/0,
              get_subscription_schedules_schedule_request_cookie/0,
              get_subscription_schedules_schedule_request_body/0,
              get_subscription_schedules_schedule_response/0]).
-export_type([post_invoices_invoice_pay_request/0,
              post_invoices_invoice_pay_request_query/0, post_invoices_invoice_pay_request_header/0,
              post_invoices_invoice_pay_request_cookie/0, post_invoices_invoice_pay_request_body/0,
              post_invoices_invoice_pay_response/0]).
-export_type([post_transfers_transfer_reversals_id_request/0,
              post_transfers_transfer_reversals_id_request_query/0,
              post_transfers_transfer_reversals_id_request_header/0,
              post_transfers_transfer_reversals_id_request_cookie/0,
              post_transfers_transfer_reversals_id_request_body/0,
              post_transfers_transfer_reversals_id_response/0]).
-export_type([get_transfers_transfer_reversals_id_request/0,
              get_transfers_transfer_reversals_id_request_query/0,
              get_transfers_transfer_reversals_id_request_header/0,
              get_transfers_transfer_reversals_id_request_cookie/0,
              get_transfers_transfer_reversals_id_request_body/0,
              get_transfers_transfer_reversals_id_response/0]).
-export_type([post_topups_topup_request/0, post_topups_topup_request_query/0,
              post_topups_topup_request_header/0, post_topups_topup_request_cookie/0,
              post_topups_topup_request_body/0, post_topups_topup_response/0]).
-export_type([get_topups_topup_request/0, get_topups_topup_request_query/0,
              get_topups_topup_request_header/0, get_topups_topup_request_cookie/0,
              get_topups_topup_request_body/0, get_topups_topup_response/0]).
-export_type([delete_recipients_id_request/0, delete_recipients_id_request_query/0,
              delete_recipients_id_request_header/0, delete_recipients_id_request_cookie/0,
              delete_recipients_id_request_body/0, delete_recipients_id_response/0]).
-export_type([post_recipients_id_request/0, post_recipients_id_request_query/0,
              post_recipients_id_request_header/0, post_recipients_id_request_cookie/0,
              post_recipients_id_request_body/0, post_recipients_id_response/0]).
-export_type([get_recipients_id_request/0, get_recipients_id_request_query/0,
              get_recipients_id_request_header/0, get_recipients_id_request_cookie/0,
              get_recipients_id_request_body/0, get_recipients_id_response/0]).
-export_type([get_invoices_invoice_lines_request/0,
              get_invoices_invoice_lines_request_query/0,
              get_invoices_invoice_lines_request_header/0,
              get_invoices_invoice_lines_request_cookie/0,
              get_invoices_invoice_lines_request_body/0, get_invoices_invoice_lines_response/0]).
-export_type([delete_accounts_account_external_accounts_id_request/0,
              delete_accounts_account_external_accounts_id_request_query/0,
              delete_accounts_account_external_accounts_id_request_header/0,
              delete_accounts_account_external_accounts_id_request_cookie/0,
              delete_accounts_account_external_accounts_id_request_body/0,
              delete_accounts_account_external_accounts_id_response/0]).
-export_type([post_accounts_account_external_accounts_id_request/0,
              post_accounts_account_external_accounts_id_request_query/0,
              post_accounts_account_external_accounts_id_request_header/0,
              post_accounts_account_external_accounts_id_request_cookie/0,
              post_accounts_account_external_accounts_id_request_body/0,
              post_accounts_account_external_accounts_id_response/0]).
-export_type([get_accounts_account_external_accounts_id_request/0,
              get_accounts_account_external_accounts_id_request_query/0,
              get_accounts_account_external_accounts_id_request_header/0,
              get_accounts_account_external_accounts_id_request_cookie/0,
              get_accounts_account_external_accounts_id_request_body/0,
              get_accounts_account_external_accounts_id_response/0]).
-export_type([post_topups_request/0, post_topups_request_query/0,
              post_topups_request_header/0, post_topups_request_cookie/0,
              post_topups_request_body/0, post_topups_response/0]).
-export_type([get_topups_request/0, get_topups_request_query/0,
              get_topups_request_header/0, get_topups_request_cookie/0, get_topups_request_body/0,
              get_topups_response/0]).
-export_type([post_orders_id_returns_request/0, post_orders_id_returns_request_query/0,
              post_orders_id_returns_request_header/0, post_orders_id_returns_request_cookie/0,
              post_orders_id_returns_request_body/0, post_orders_id_returns_response/0]).
-export_type([post_orders_id_request/0, post_orders_id_request_query/0,
              post_orders_id_request_header/0, post_orders_id_request_cookie/0,
              post_orders_id_request_body/0, post_orders_id_response/0]).
-export_type([get_orders_id_request/0, get_orders_id_request_query/0,
              get_orders_id_request_header/0, get_orders_id_request_cookie/0,
              get_orders_id_request_body/0, get_orders_id_response/0]).
-export_type([delete_apple_pay_domains_domain_request/0,
              delete_apple_pay_domains_domain_request_query/0,
              delete_apple_pay_domains_domain_request_header/0,
              delete_apple_pay_domains_domain_request_cookie/0,
              delete_apple_pay_domains_domain_request_body/0,
              delete_apple_pay_domains_domain_response/0]).
-export_type([get_apple_pay_domains_domain_request/0,
              get_apple_pay_domains_domain_request_query/0,
              get_apple_pay_domains_domain_request_header/0,
              get_apple_pay_domains_domain_request_cookie/0,
              get_apple_pay_domains_domain_request_body/0,
              get_apple_pay_domains_domain_response/0]).
-export_type([get_issuing_transactions_request/0,
              get_issuing_transactions_request_query/0, get_issuing_transactions_request_header/0,
              get_issuing_transactions_request_cookie/0, get_issuing_transactions_request_body/0,
              get_issuing_transactions_response/0]).
-export_type([post_charges_charge_refund_request/0,
              post_charges_charge_refund_request_query/0,
              post_charges_charge_refund_request_header/0,
              post_charges_charge_refund_request_cookie/0,
              post_charges_charge_refund_request_body/0, post_charges_charge_refund_response/0]).
-export_type([post_payment_methods_payment_method_attach_request/0,
              post_payment_methods_payment_method_attach_request_query/0,
              post_payment_methods_payment_method_attach_request_header/0,
              post_payment_methods_payment_method_attach_request_cookie/0,
              post_payment_methods_payment_method_attach_request_body/0,
              post_payment_methods_payment_method_attach_response/0]).
-export_type([post_payment_intents_intent_cancel_request/0,
              post_payment_intents_intent_cancel_request_query/0,
              post_payment_intents_intent_cancel_request_header/0,
              post_payment_intents_intent_cancel_request_cookie/0,
              post_payment_intents_intent_cancel_request_body/0,
              post_payment_intents_intent_cancel_response/0]).
-export_type([get_accounts_account_capabilities_request/0,
              get_accounts_account_capabilities_request_query/0,
              get_accounts_account_capabilities_request_header/0,
              get_accounts_account_capabilities_request_cookie/0,
              get_accounts_account_capabilities_request_body/0,
              get_accounts_account_capabilities_response/0]).
-export_type([get_credit_notes_preview_lines_request/0,
              get_credit_notes_preview_lines_request_query/0,
              get_credit_notes_preview_lines_request_header/0,
              get_credit_notes_preview_lines_request_cookie/0,
              get_credit_notes_preview_lines_request_body/0,
              get_credit_notes_preview_lines_response/0]).
-export_type([post_subscriptions_request/0, post_subscriptions_request_query/0,
              post_subscriptions_request_header/0, post_subscriptions_request_cookie/0,
              post_subscriptions_request_body/0, post_subscriptions_response/0]).
-export_type([get_subscriptions_request/0, get_subscriptions_request_query/0,
              get_subscriptions_request_header/0, get_subscriptions_request_cookie/0,
              get_subscriptions_request_body/0, get_subscriptions_response/0]).
-export_type([get_setup_attempts_request/0, get_setup_attempts_request_query/0,
              get_setup_attempts_request_header/0, get_setup_attempts_request_cookie/0,
              get_setup_attempts_request_body/0, get_setup_attempts_response/0]).
-export_type([delete_customers_customer_subscriptions_subscription_exposed_id_request/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_request_query/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_request_header/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_request_cookie/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_request_body/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_response/0]).
-export_type([post_customers_customer_subscriptions_subscription_exposed_id_request/0,
              post_customers_customer_subscriptions_subscription_exposed_id_request_query/0,
              post_customers_customer_subscriptions_subscription_exposed_id_request_header/0,
              post_customers_customer_subscriptions_subscription_exposed_id_request_cookie/0,
              post_customers_customer_subscriptions_subscription_exposed_id_request_body/0,
              post_customers_customer_subscriptions_subscription_exposed_id_response/0]).
-export_type([get_customers_customer_subscriptions_subscription_exposed_id_request/0,
              get_customers_customer_subscriptions_subscription_exposed_id_request_query/0,
              get_customers_customer_subscriptions_subscription_exposed_id_request_header/0,
              get_customers_customer_subscriptions_subscription_exposed_id_request_cookie/0,
              get_customers_customer_subscriptions_subscription_exposed_id_request_body/0,
              get_customers_customer_subscriptions_subscription_exposed_id_response/0]).
-export_type([get_bitcoin_receivers_id_request/0,
              get_bitcoin_receivers_id_request_query/0, get_bitcoin_receivers_id_request_header/0,
              get_bitcoin_receivers_id_request_cookie/0, get_bitcoin_receivers_id_request_body/0,
              get_bitcoin_receivers_id_response/0]).
-export_type([post_orders_request/0, post_orders_request_query/0,
              post_orders_request_header/0, post_orders_request_cookie/0,
              post_orders_request_body/0, post_orders_response/0]).
-export_type([get_orders_request/0, get_orders_request_query/0,
              get_orders_request_header/0, get_orders_request_cookie/0, get_orders_request_body/0,
              get_orders_response/0]).
-export_type([post_ephemeral_keys_request/0, post_ephemeral_keys_request_query/0,
              post_ephemeral_keys_request_header/0, post_ephemeral_keys_request_cookie/0,
              post_ephemeral_keys_request_body/0, post_ephemeral_keys_response/0]).
-export_type([delete_webhook_endpoints_webhook_endpoint_request/0,
              delete_webhook_endpoints_webhook_endpoint_request_query/0,
              delete_webhook_endpoints_webhook_endpoint_request_header/0,
              delete_webhook_endpoints_webhook_endpoint_request_cookie/0,
              delete_webhook_endpoints_webhook_endpoint_request_body/0,
              delete_webhook_endpoints_webhook_endpoint_response/0]).
-export_type([post_webhook_endpoints_webhook_endpoint_request/0,
              post_webhook_endpoints_webhook_endpoint_request_query/0,
              post_webhook_endpoints_webhook_endpoint_request_header/0,
              post_webhook_endpoints_webhook_endpoint_request_cookie/0,
              post_webhook_endpoints_webhook_endpoint_request_body/0,
              post_webhook_endpoints_webhook_endpoint_response/0]).
-export_type([get_webhook_endpoints_webhook_endpoint_request/0,
              get_webhook_endpoints_webhook_endpoint_request_query/0,
              get_webhook_endpoints_webhook_endpoint_request_header/0,
              get_webhook_endpoints_webhook_endpoint_request_cookie/0,
              get_webhook_endpoints_webhook_endpoint_request_body/0,
              get_webhook_endpoints_webhook_endpoint_response/0]).
-export_type([post_account_persons_request/0, post_account_persons_request_query/0,
              post_account_persons_request_header/0, post_account_persons_request_cookie/0,
              post_account_persons_request_body/0, post_account_persons_response/0]).
-export_type([get_account_persons_request/0, get_account_persons_request_query/0,
              get_account_persons_request_header/0, get_account_persons_request_cookie/0,
              get_account_persons_request_body/0, get_account_persons_response/0]).
-export_type([get_account_capabilities_request/0,
              get_account_capabilities_request_query/0, get_account_capabilities_request_header/0,
              get_account_capabilities_request_cookie/0, get_account_capabilities_request_body/0,
              get_account_capabilities_response/0]).
-export_type([post_checkout_sessions_session_expire_request/0,
              post_checkout_sessions_session_expire_request_query/0,
              post_checkout_sessions_session_expire_request_header/0,
              post_checkout_sessions_session_expire_request_cookie/0,
              post_checkout_sessions_session_expire_request_body/0,
              post_checkout_sessions_session_expire_response/0]).
-export_type([get_bitcoin_receivers_receiver_transactions_request/0,
              get_bitcoin_receivers_receiver_transactions_request_query/0,
              get_bitcoin_receivers_receiver_transactions_request_header/0,
              get_bitcoin_receivers_receiver_transactions_request_cookie/0,
              get_bitcoin_receivers_receiver_transactions_request_body/0,
              get_bitcoin_receivers_receiver_transactions_response/0]).
-export_type([post_quotes_quote_request/0, post_quotes_quote_request_query/0,
              post_quotes_quote_request_header/0, post_quotes_quote_request_cookie/0,
              post_quotes_quote_request_body/0, post_quotes_quote_response/0]).
-export_type([get_quotes_quote_request/0, get_quotes_quote_request_query/0,
              get_quotes_quote_request_header/0, get_quotes_quote_request_cookie/0,
              get_quotes_quote_request_body/0, get_quotes_quote_response/0]).
-export_type([post_account_people_request/0, post_account_people_request_query/0,
              post_account_people_request_header/0, post_account_people_request_cookie/0,
              post_account_people_request_body/0, post_account_people_response/0]).
-export_type([get_account_people_request/0, get_account_people_request_query/0,
              get_account_people_request_header/0, get_account_people_request_cookie/0,
              get_account_people_request_body/0, get_account_people_response/0]).
-export_type([post_setup_intents_intent_confirm_request/0,
              post_setup_intents_intent_confirm_request_query/0,
              post_setup_intents_intent_confirm_request_header/0,
              post_setup_intents_intent_confirm_request_cookie/0,
              post_setup_intents_intent_confirm_request_body/0,
              post_setup_intents_intent_confirm_response/0]).
-export_type([post_customers_customer_cards_request/0,
              post_customers_customer_cards_request_query/0,
              post_customers_customer_cards_request_header/0,
              post_customers_customer_cards_request_cookie/0,
              post_customers_customer_cards_request_body/0,
              post_customers_customer_cards_response/0]).
-export_type([get_customers_customer_cards_request/0,
              get_customers_customer_cards_request_query/0,
              get_customers_customer_cards_request_header/0,
              get_customers_customer_cards_request_cookie/0,
              get_customers_customer_cards_request_body/0,
              get_customers_customer_cards_response/0]).
-export_type([get_identity_verification_reports_request/0,
              get_identity_verification_reports_request_query/0,
              get_identity_verification_reports_request_header/0,
              get_identity_verification_reports_request_cookie/0,
              get_identity_verification_reports_request_body/0,
              get_identity_verification_reports_response/0]).
-export_type([post_accounts_account_persons_request/0,
              post_accounts_account_persons_request_query/0,
              post_accounts_account_persons_request_header/0,
              post_accounts_account_persons_request_cookie/0,
              post_accounts_account_persons_request_body/0,
              post_accounts_account_persons_response/0]).
-export_type([get_accounts_account_persons_request/0,
              get_accounts_account_persons_request_query/0,
              get_accounts_account_persons_request_header/0,
              get_accounts_account_persons_request_cookie/0,
              get_accounts_account_persons_request_body/0,
              get_accounts_account_persons_response/0]).
-export_type([post_application_fees_id_refund_request/0,
              post_application_fees_id_refund_request_query/0,
              post_application_fees_id_refund_request_header/0,
              post_application_fees_id_refund_request_cookie/0,
              post_application_fees_id_refund_request_body/0,
              post_application_fees_id_refund_response/0]).
-export_type([post_payment_intents_request/0, post_payment_intents_request_query/0,
              post_payment_intents_request_header/0, post_payment_intents_request_cookie/0,
              post_payment_intents_request_body/0, post_payment_intents_response/0]).
-export_type([get_payment_intents_request/0, get_payment_intents_request_query/0,
              get_payment_intents_request_header/0, get_payment_intents_request_cookie/0,
              get_payment_intents_request_body/0, get_payment_intents_response/0]).
-export_type([post_skus_request/0, post_skus_request_query/0, post_skus_request_header/0,
              post_skus_request_cookie/0, post_skus_request_body/0, post_skus_response/0]).
-export_type([get_skus_request/0, get_skus_request_query/0, get_skus_request_header/0,
              get_skus_request_cookie/0, get_skus_request_body/0, get_skus_response/0]).
-export_type([post_webhook_endpoints_request/0, post_webhook_endpoints_request_query/0,
              post_webhook_endpoints_request_header/0, post_webhook_endpoints_request_cookie/0,
              post_webhook_endpoints_request_body/0, post_webhook_endpoints_response/0]).
-export_type([get_webhook_endpoints_request/0, get_webhook_endpoints_request_query/0,
              get_webhook_endpoints_request_header/0, get_webhook_endpoints_request_cookie/0,
              get_webhook_endpoints_request_body/0, get_webhook_endpoints_response/0]).
-export_type([get_balance_request/0, get_balance_request_query/0,
              get_balance_request_header/0, get_balance_request_cookie/0,
              get_balance_request_body/0, get_balance_response/0]).
-export_type([post_customers_customer_balance_transactions_transaction_request/0,
              post_customers_customer_balance_transactions_transaction_request_query/0,
              post_customers_customer_balance_transactions_transaction_request_header/0,
              post_customers_customer_balance_transactions_transaction_request_cookie/0,
              post_customers_customer_balance_transactions_transaction_request_body/0,
              post_customers_customer_balance_transactions_transaction_response/0]).
-export_type([get_customers_customer_balance_transactions_transaction_request/0,
              get_customers_customer_balance_transactions_transaction_request_query/0,
              get_customers_customer_balance_transactions_transaction_request_header/0,
              get_customers_customer_balance_transactions_transaction_request_cookie/0,
              get_customers_customer_balance_transactions_transaction_request_body/0,
              get_customers_customer_balance_transactions_transaction_response/0]).
-export_type([post_payment_methods_payment_method_request/0,
              post_payment_methods_payment_method_request_query/0,
              post_payment_methods_payment_method_request_header/0,
              post_payment_methods_payment_method_request_cookie/0,
              post_payment_methods_payment_method_request_body/0,
              post_payment_methods_payment_method_response/0]).
-export_type([get_payment_methods_payment_method_request/0,
              get_payment_methods_payment_method_request_query/0,
              get_payment_methods_payment_method_request_header/0,
              get_payment_methods_payment_method_request_cookie/0,
              get_payment_methods_payment_method_request_body/0,
              get_payment_methods_payment_method_response/0]).
-export_type([post_topups_topup_cancel_request/0,
              post_topups_topup_cancel_request_query/0, post_topups_topup_cancel_request_header/0,
              post_topups_topup_cancel_request_cookie/0, post_topups_topup_cancel_request_body/0,
              post_topups_topup_cancel_response/0]).
-export_type([get_events_request/0, get_events_request_query/0,
              get_events_request_header/0, get_events_request_cookie/0, get_events_request_body/0,
              get_events_response/0]).
-export_type([post_charges_charge_refunds_refund_request/0,
              post_charges_charge_refunds_refund_request_query/0,
              post_charges_charge_refunds_refund_request_header/0,
              post_charges_charge_refunds_refund_request_cookie/0,
              post_charges_charge_refunds_refund_request_body/0,
              post_charges_charge_refunds_refund_response/0]).
-export_type([get_charges_charge_refunds_refund_request/0,
              get_charges_charge_refunds_refund_request_query/0,
              get_charges_charge_refunds_refund_request_header/0,
              get_charges_charge_refunds_refund_request_cookie/0,
              get_charges_charge_refunds_refund_request_body/0,
              get_charges_charge_refunds_refund_response/0]).
-export_type([post_accounts_account_capabilities_capability_request/0,
              post_accounts_account_capabilities_capability_request_query/0,
              post_accounts_account_capabilities_capability_request_header/0,
              post_accounts_account_capabilities_capability_request_cookie/0,
              post_accounts_account_capabilities_capability_request_body/0,
              post_accounts_account_capabilities_capability_response/0]).
-export_type([get_accounts_account_capabilities_capability_request/0,
              get_accounts_account_capabilities_capability_request_query/0,
              get_accounts_account_capabilities_capability_request_header/0,
              get_accounts_account_capabilities_capability_request_cookie/0,
              get_accounts_account_capabilities_capability_request_body/0,
              get_accounts_account_capabilities_capability_response/0]).
-export_type([post_subscription_items_request/0, post_subscription_items_request_query/0,
              post_subscription_items_request_header/0, post_subscription_items_request_cookie/0,
              post_subscription_items_request_body/0, post_subscription_items_response/0]).
-export_type([get_subscription_items_request/0, get_subscription_items_request_query/0,
              get_subscription_items_request_header/0, get_subscription_items_request_cookie/0,
              get_subscription_items_request_body/0, get_subscription_items_response/0]).
-export_type([get_quotes_quote_pdf_request/0, get_quotes_quote_pdf_request_query/0,
              get_quotes_quote_pdf_request_header/0, get_quotes_quote_pdf_request_cookie/0,
              get_quotes_quote_pdf_request_body/0, get_quotes_quote_pdf_response/0]).
-export_type([delete_account_bank_accounts_id_request/0,
              delete_account_bank_accounts_id_request_query/0,
              delete_account_bank_accounts_id_request_header/0,
              delete_account_bank_accounts_id_request_cookie/0,
              delete_account_bank_accounts_id_request_body/0,
              delete_account_bank_accounts_id_response/0]).
-export_type([post_account_bank_accounts_id_request/0,
              post_account_bank_accounts_id_request_query/0,
              post_account_bank_accounts_id_request_header/0,
              post_account_bank_accounts_id_request_cookie/0,
              post_account_bank_accounts_id_request_body/0,
              post_account_bank_accounts_id_response/0]).
-export_type([get_account_bank_accounts_id_request/0,
              get_account_bank_accounts_id_request_query/0,
              get_account_bank_accounts_id_request_header/0,
              get_account_bank_accounts_id_request_cookie/0,
              get_account_bank_accounts_id_request_body/0,
              get_account_bank_accounts_id_response/0]).
-export_type([get_payment_links_payment_link_line_items_request/0,
              get_payment_links_payment_link_line_items_request_query/0,
              get_payment_links_payment_link_line_items_request_header/0,
              get_payment_links_payment_link_line_items_request_cookie/0,
              get_payment_links_payment_link_line_items_request_body/0,
              get_payment_links_payment_link_line_items_response/0]).
-export_type([get_subscription_items_subscription_item_usage_record_summaries_request/0,
              get_subscription_items_subscription_item_usage_record_summaries_request_query/0,
              get_subscription_items_subscription_item_usage_record_summaries_request_header/0,
              get_subscription_items_subscription_item_usage_record_summaries_request_cookie/0,
              get_subscription_items_subscription_item_usage_record_summaries_request_body/0,
              get_subscription_items_subscription_item_usage_record_summaries_response/0]).
-export_type([post_payment_intents_intent_request/0,
              post_payment_intents_intent_request_query/0,
              post_payment_intents_intent_request_header/0,
              post_payment_intents_intent_request_cookie/0,
              post_payment_intents_intent_request_body/0, post_payment_intents_intent_response/0]).
-export_type([get_payment_intents_intent_request/0,
              get_payment_intents_intent_request_query/0,
              get_payment_intents_intent_request_header/0,
              get_payment_intents_intent_request_cookie/0,
              get_payment_intents_intent_request_body/0, get_payment_intents_intent_response/0]).
-export_type([post_charges_request/0, post_charges_request_query/0,
              post_charges_request_header/0, post_charges_request_cookie/0,
              post_charges_request_body/0, post_charges_response/0]).
-export_type([get_charges_request/0, get_charges_request_query/0,
              get_charges_request_header/0, get_charges_request_cookie/0,
              get_charges_request_body/0, get_charges_response/0]).
-export_type([post_accounts_account_external_accounts_request/0,
              post_accounts_account_external_accounts_request_query/0,
              post_accounts_account_external_accounts_request_header/0,
              post_accounts_account_external_accounts_request_cookie/0,
              post_accounts_account_external_accounts_request_body/0,
              post_accounts_account_external_accounts_response/0]).
-export_type([get_accounts_account_external_accounts_request/0,
              get_accounts_account_external_accounts_request_query/0,
              get_accounts_account_external_accounts_request_header/0,
              get_accounts_account_external_accounts_request_cookie/0,
              get_accounts_account_external_accounts_request_body/0,
              get_accounts_account_external_accounts_response/0]).
-export_type([get_issuing_authorizations_request/0,
              get_issuing_authorizations_request_query/0,
              get_issuing_authorizations_request_header/0,
              get_issuing_authorizations_request_cookie/0,
              get_issuing_authorizations_request_body/0, get_issuing_authorizations_response/0]).
-export_type([delete_products_id_request/0, delete_products_id_request_query/0,
              delete_products_id_request_header/0, delete_products_id_request_cookie/0,
              delete_products_id_request_body/0, delete_products_id_response/0]).
-export_type([post_products_id_request/0, post_products_id_request_query/0,
              post_products_id_request_header/0, post_products_id_request_cookie/0,
              post_products_id_request_body/0, post_products_id_response/0]).
-export_type([get_products_id_request/0, get_products_id_request_query/0,
              get_products_id_request_header/0, get_products_id_request_cookie/0,
              get_products_id_request_body/0, get_products_id_response/0]).
-export_type([post_setup_intents_intent_verify_microdeposits_request/0,
              post_setup_intents_intent_verify_microdeposits_request_query/0,
              post_setup_intents_intent_verify_microdeposits_request_header/0,
              post_setup_intents_intent_verify_microdeposits_request_cookie/0,
              post_setup_intents_intent_verify_microdeposits_request_body/0,
              post_setup_intents_intent_verify_microdeposits_response/0]).
-export_type([get_reporting_report_types_request/0,
              get_reporting_report_types_request_query/0,
              get_reporting_report_types_request_header/0,
              get_reporting_report_types_request_cookie/0,
              get_reporting_report_types_request_body/0, get_reporting_report_types_response/0]).
-export_type([post_account_external_accounts_request/0,
              post_account_external_accounts_request_query/0,
              post_account_external_accounts_request_header/0,
              post_account_external_accounts_request_cookie/0,
              post_account_external_accounts_request_body/0,
              post_account_external_accounts_response/0]).
-export_type([get_account_external_accounts_request/0,
              get_account_external_accounts_request_query/0,
              get_account_external_accounts_request_header/0,
              get_account_external_accounts_request_cookie/0,
              get_account_external_accounts_request_body/0,
              get_account_external_accounts_response/0]).
-export_type([post_radar_value_lists_request/0, post_radar_value_lists_request_query/0,
              post_radar_value_lists_request_header/0, post_radar_value_lists_request_cookie/0,
              post_radar_value_lists_request_body/0, post_radar_value_lists_response/0]).
-export_type([get_radar_value_lists_request/0, get_radar_value_lists_request_query/0,
              get_radar_value_lists_request_header/0, get_radar_value_lists_request_cookie/0,
              get_radar_value_lists_request_body/0, get_radar_value_lists_response/0]).
-export_type([post_shipping_rates_request/0, post_shipping_rates_request_query/0,
              post_shipping_rates_request_header/0, post_shipping_rates_request_cookie/0,
              post_shipping_rates_request_body/0, post_shipping_rates_response/0]).
-export_type([get_shipping_rates_request/0, get_shipping_rates_request_query/0,
              get_shipping_rates_request_header/0, get_shipping_rates_request_cookie/0,
              get_shipping_rates_request_body/0, get_shipping_rates_response/0]).
-export_type([post_file_links_link_request/0, post_file_links_link_request_query/0,
              post_file_links_link_request_header/0, post_file_links_link_request_cookie/0,
              post_file_links_link_request_body/0, post_file_links_link_response/0]).
-export_type([get_file_links_link_request/0, get_file_links_link_request_query/0,
              get_file_links_link_request_header/0, get_file_links_link_request_cookie/0,
              get_file_links_link_request_body/0, get_file_links_link_response/0]).
-export_type([get3d_secure_three_d_secure_request/0,
              get3d_secure_three_d_secure_request_query/0,
              get3d_secure_three_d_secure_request_header/0,
              get3d_secure_three_d_secure_request_cookie/0,
              get3d_secure_three_d_secure_request_body/0, get3d_secure_three_d_secure_response/0]).
-export_type([post_invoices_invoice_send_request/0,
              post_invoices_invoice_send_request_query/0,
              post_invoices_invoice_send_request_header/0,
              post_invoices_invoice_send_request_cookie/0,
              post_invoices_invoice_send_request_body/0, post_invoices_invoice_send_response/0]).
-export_type([get_invoices_upcoming_request/0, get_invoices_upcoming_request_query/0,
              get_invoices_upcoming_request_header/0, get_invoices_upcoming_request_cookie/0,
              get_invoices_upcoming_request_body/0, get_invoices_upcoming_response/0]).
-export_type([get_checkout_sessions_session_line_items_request/0,
              get_checkout_sessions_session_line_items_request_query/0,
              get_checkout_sessions_session_line_items_request_header/0,
              get_checkout_sessions_session_line_items_request_cookie/0,
              get_checkout_sessions_session_line_items_request_body/0,
              get_checkout_sessions_session_line_items_response/0]).
-export_type([get_tax_codes_request/0, get_tax_codes_request_query/0,
              get_tax_codes_request_header/0, get_tax_codes_request_cookie/0,
              get_tax_codes_request_body/0, get_tax_codes_response/0]).
-export_type([post_invoices_request/0, post_invoices_request_query/0,
              post_invoices_request_header/0, post_invoices_request_cookie/0,
              post_invoices_request_body/0, post_invoices_response/0]).
-export_type([get_invoices_request/0, get_invoices_request_query/0,
              get_invoices_request_header/0, get_invoices_request_cookie/0,
              get_invoices_request_body/0, get_invoices_response/0]).
-export_type([post_charges_charge_request/0, post_charges_charge_request_query/0,
              post_charges_charge_request_header/0, post_charges_charge_request_cookie/0,
              post_charges_charge_request_body/0, post_charges_charge_response/0]).
-export_type([get_charges_charge_request/0, get_charges_charge_request_query/0,
              get_charges_charge_request_header/0, get_charges_charge_request_cookie/0,
              get_charges_charge_request_body/0, get_charges_charge_response/0]).
-export_type([post_invoices_invoice_mark_uncollectible_request/0,
              post_invoices_invoice_mark_uncollectible_request_query/0,
              post_invoices_invoice_mark_uncollectible_request_header/0,
              post_invoices_invoice_mark_uncollectible_request_cookie/0,
              post_invoices_invoice_mark_uncollectible_request_body/0,
              post_invoices_invoice_mark_uncollectible_response/0]).
-export_type([post_customers_customer_sources_id_verify_request/0,
              post_customers_customer_sources_id_verify_request_query/0,
              post_customers_customer_sources_id_verify_request_header/0,
              post_customers_customer_sources_id_verify_request_cookie/0,
              post_customers_customer_sources_id_verify_request_body/0,
              post_customers_customer_sources_id_verify_response/0]).
-export_type([post_orders_id_pay_request/0, post_orders_id_pay_request_query/0,
              post_orders_id_pay_request_header/0, post_orders_id_pay_request_cookie/0,
              post_orders_id_pay_request_body/0, post_orders_id_pay_response/0]).
-export_type([post_customers_customer_bank_accounts_id_verify_request/0,
              post_customers_customer_bank_accounts_id_verify_request_query/0,
              post_customers_customer_bank_accounts_id_verify_request_header/0,
              post_customers_customer_bank_accounts_id_verify_request_cookie/0,
              post_customers_customer_bank_accounts_id_verify_request_body/0,
              post_customers_customer_bank_accounts_id_verify_response/0]).
-export_type([delete_account_people_person_request/0,
              delete_account_people_person_request_query/0,
              delete_account_people_person_request_header/0,
              delete_account_people_person_request_cookie/0,
              delete_account_people_person_request_body/0,
              delete_account_people_person_response/0]).
-export_type([post_account_people_person_request/0,
              post_account_people_person_request_query/0,
              post_account_people_person_request_header/0,
              post_account_people_person_request_cookie/0,
              post_account_people_person_request_body/0, post_account_people_person_response/0]).
-export_type([get_account_people_person_request/0,
              get_account_people_person_request_query/0, get_account_people_person_request_header/0,
              get_account_people_person_request_cookie/0, get_account_people_person_request_body/0,
              get_account_people_person_response/0]).
-export_type([post_checkout_sessions_request/0, post_checkout_sessions_request_query/0,
              post_checkout_sessions_request_header/0, post_checkout_sessions_request_cookie/0,
              post_checkout_sessions_request_body/0, post_checkout_sessions_response/0]).
-export_type([get_checkout_sessions_request/0, get_checkout_sessions_request_query/0,
              get_checkout_sessions_request_header/0, get_checkout_sessions_request_cookie/0,
              get_checkout_sessions_request_body/0, get_checkout_sessions_response/0]).
-export_type([post_accounts_account_login_links_request/0,
              post_accounts_account_login_links_request_query/0,
              post_accounts_account_login_links_request_header/0,
              post_accounts_account_login_links_request_cookie/0,
              post_accounts_account_login_links_request_body/0,
              post_accounts_account_login_links_response/0]).
-export_type([post_terminal_readers_request/0, post_terminal_readers_request_query/0,
              post_terminal_readers_request_header/0, post_terminal_readers_request_cookie/0,
              post_terminal_readers_request_body/0, post_terminal_readers_response/0]).
-export_type([get_terminal_readers_request/0, get_terminal_readers_request_query/0,
              get_terminal_readers_request_header/0, get_terminal_readers_request_cookie/0,
              get_terminal_readers_request_body/0, get_terminal_readers_response/0]).
-export_type([post_issuing_disputes_request/0, post_issuing_disputes_request_query/0,
              post_issuing_disputes_request_header/0, post_issuing_disputes_request_cookie/0,
              post_issuing_disputes_request_body/0, post_issuing_disputes_response/0]).
-export_type([get_issuing_disputes_request/0, get_issuing_disputes_request_query/0,
              get_issuing_disputes_request_header/0, get_issuing_disputes_request_cookie/0,
              get_issuing_disputes_request_body/0, get_issuing_disputes_response/0]).
-export_type([post3d_secure_request/0, post3d_secure_request_query/0,
              post3d_secure_request_header/0, post3d_secure_request_cookie/0,
              post3d_secure_request_body/0, post3d_secure_response/0]).
-export_type([post_prices_request/0, post_prices_request_query/0,
              post_prices_request_header/0, post_prices_request_cookie/0,
              post_prices_request_body/0, post_prices_response/0]).
-export_type([get_prices_request/0, get_prices_request_query/0,
              get_prices_request_header/0, get_prices_request_cookie/0, get_prices_request_body/0,
              get_prices_response/0]).
-export_type([delete_invoices_invoice_request/0, delete_invoices_invoice_request_query/0,
              delete_invoices_invoice_request_header/0, delete_invoices_invoice_request_cookie/0,
              delete_invoices_invoice_request_body/0, delete_invoices_invoice_response/0]).
-export_type([post_invoices_invoice_request/0, post_invoices_invoice_request_query/0,
              post_invoices_invoice_request_header/0, post_invoices_invoice_request_cookie/0,
              post_invoices_invoice_request_body/0, post_invoices_invoice_response/0]).
-export_type([get_invoices_invoice_request/0, get_invoices_invoice_request_query/0,
              get_invoices_invoice_request_header/0, get_invoices_invoice_request_cookie/0,
              get_invoices_invoice_request_body/0, get_invoices_invoice_response/0]).
-export_type([post_identity_verification_sessions_session_request/0,
              post_identity_verification_sessions_session_request_query/0,
              post_identity_verification_sessions_session_request_header/0,
              post_identity_verification_sessions_session_request_cookie/0,
              post_identity_verification_sessions_session_request_body/0,
              post_identity_verification_sessions_session_response/0]).
-export_type([get_identity_verification_sessions_session_request/0,
              get_identity_verification_sessions_session_request_query/0,
              get_identity_verification_sessions_session_request_header/0,
              get_identity_verification_sessions_session_request_cookie/0,
              get_identity_verification_sessions_session_request_body/0,
              get_identity_verification_sessions_session_response/0]).
-export_type([get_balance_transactions_id_request/0,
              get_balance_transactions_id_request_query/0,
              get_balance_transactions_id_request_header/0,
              get_balance_transactions_id_request_cookie/0,
              get_balance_transactions_id_request_body/0, get_balance_transactions_id_response/0]).
-export_type([post_setup_intents_intent_cancel_request/0,
              post_setup_intents_intent_cancel_request_query/0,
              post_setup_intents_intent_cancel_request_header/0,
              post_setup_intents_intent_cancel_request_cookie/0,
              post_setup_intents_intent_cancel_request_body/0,
              post_setup_intents_intent_cancel_response/0]).
-export_type([post_issuing_transactions_transaction_request/0,
              post_issuing_transactions_transaction_request_query/0,
              post_issuing_transactions_transaction_request_header/0,
              post_issuing_transactions_transaction_request_cookie/0,
              post_issuing_transactions_transaction_request_body/0,
              post_issuing_transactions_transaction_response/0]).
-export_type([get_issuing_transactions_transaction_request/0,
              get_issuing_transactions_transaction_request_query/0,
              get_issuing_transactions_transaction_request_header/0,
              get_issuing_transactions_transaction_request_cookie/0,
              get_issuing_transactions_transaction_request_body/0,
              get_issuing_transactions_transaction_response/0]).
-export_type([post_terminal_connection_tokens_request/0,
              post_terminal_connection_tokens_request_query/0,
              post_terminal_connection_tokens_request_header/0,
              post_terminal_connection_tokens_request_cookie/0,
              post_terminal_connection_tokens_request_body/0,
              post_terminal_connection_tokens_response/0]).
-export_type([get_reviews_request/0, get_reviews_request_query/0,
              get_reviews_request_header/0, get_reviews_request_cookie/0,
              get_reviews_request_body/0, get_reviews_response/0]).
-export_type([post_promotion_codes_request/0, post_promotion_codes_request_query/0,
              post_promotion_codes_request_header/0, post_promotion_codes_request_cookie/0,
              post_promotion_codes_request_body/0, post_promotion_codes_response/0]).
-export_type([get_promotion_codes_request/0, get_promotion_codes_request_query/0,
              get_promotion_codes_request_header/0, get_promotion_codes_request_cookie/0,
              get_promotion_codes_request_body/0, get_promotion_codes_response/0]).
-export_type([delete_customers_customer_subscriptions_subscription_exposed_id_discount_request/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_query/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_header/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_body/0,
              delete_customers_customer_subscriptions_subscription_exposed_id_discount_response/0]).
-export_type([get_customers_customer_subscriptions_subscription_exposed_id_discount_request/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_request_query/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_request_header/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_request_body/0,
              get_customers_customer_subscriptions_subscription_exposed_id_discount_response/0]).
-export_type([get_quotes_quote_computed_upfront_line_items_request/0,
              get_quotes_quote_computed_upfront_line_items_request_query/0,
              get_quotes_quote_computed_upfront_line_items_request_header/0,
              get_quotes_quote_computed_upfront_line_items_request_cookie/0,
              get_quotes_quote_computed_upfront_line_items_request_body/0,
              get_quotes_quote_computed_upfront_line_items_response/0]).
-export_type([delete_radar_value_list_items_item_request/0,
              delete_radar_value_list_items_item_request_query/0,
              delete_radar_value_list_items_item_request_header/0,
              delete_radar_value_list_items_item_request_cookie/0,
              delete_radar_value_list_items_item_request_body/0,
              delete_radar_value_list_items_item_response/0]).
-export_type([get_radar_value_list_items_item_request/0,
              get_radar_value_list_items_item_request_query/0,
              get_radar_value_list_items_item_request_header/0,
              get_radar_value_list_items_item_request_cookie/0,
              get_radar_value_list_items_item_request_body/0,
              get_radar_value_list_items_item_response/0]).
-export_type([get_issuer_fraud_records_request/0,
              get_issuer_fraud_records_request_query/0, get_issuer_fraud_records_request_header/0,
              get_issuer_fraud_records_request_cookie/0, get_issuer_fraud_records_request_body/0,
              get_issuer_fraud_records_response/0]).
-export_type([post_tax_rates_tax_rate_request/0, post_tax_rates_tax_rate_request_query/0,
              post_tax_rates_tax_rate_request_header/0, post_tax_rates_tax_rate_request_cookie/0,
              post_tax_rates_tax_rate_request_body/0, post_tax_rates_tax_rate_response/0]).
-export_type([get_tax_rates_tax_rate_request/0, get_tax_rates_tax_rate_request_query/0,
              get_tax_rates_tax_rate_request_header/0, get_tax_rates_tax_rate_request_cookie/0,
              get_tax_rates_tax_rate_request_body/0, get_tax_rates_tax_rate_response/0]).
-export_type([post_recipients_request/0, post_recipients_request_query/0,
              post_recipients_request_header/0, post_recipients_request_cookie/0,
              post_recipients_request_body/0, post_recipients_response/0]).
-export_type([get_recipients_request/0, get_recipients_request_query/0,
              get_recipients_request_header/0, get_recipients_request_cookie/0,
              get_recipients_request_body/0, get_recipients_response/0]).
-export_type([post_plans_request/0, post_plans_request_query/0,
              post_plans_request_header/0, post_plans_request_cookie/0, post_plans_request_body/0,
              post_plans_response/0]).
-export_type([get_plans_request/0, get_plans_request_query/0, get_plans_request_header/0,
              get_plans_request_cookie/0, get_plans_request_body/0, get_plans_response/0]).
-export_type([post_customers_customer_balance_transactions_request/0,
              post_customers_customer_balance_transactions_request_query/0,
              post_customers_customer_balance_transactions_request_header/0,
              post_customers_customer_balance_transactions_request_cookie/0,
              post_customers_customer_balance_transactions_request_body/0,
              post_customers_customer_balance_transactions_response/0]).
-export_type([get_customers_customer_balance_transactions_request/0,
              get_customers_customer_balance_transactions_request_query/0,
              get_customers_customer_balance_transactions_request_header/0,
              get_customers_customer_balance_transactions_request_cookie/0,
              get_customers_customer_balance_transactions_request_body/0,
              get_customers_customer_balance_transactions_response/0]).
-export_type([post_reviews_review_approve_request/0,
              post_reviews_review_approve_request_query/0,
              post_reviews_review_approve_request_header/0,
              post_reviews_review_approve_request_cookie/0,
              post_reviews_review_approve_request_body/0, post_reviews_review_approve_response/0]).
-export_type([post_customers_customer_tax_ids_request/0,
              post_customers_customer_tax_ids_request_query/0,
              post_customers_customer_tax_ids_request_header/0,
              post_customers_customer_tax_ids_request_cookie/0,
              post_customers_customer_tax_ids_request_body/0,
              post_customers_customer_tax_ids_response/0]).
-export_type([get_customers_customer_tax_ids_request/0,
              get_customers_customer_tax_ids_request_query/0,
              get_customers_customer_tax_ids_request_header/0,
              get_customers_customer_tax_ids_request_cookie/0,
              get_customers_customer_tax_ids_request_body/0,
              get_customers_customer_tax_ids_response/0]).
-export_type([get_tokens_token_request/0, get_tokens_token_request_query/0,
              get_tokens_token_request_header/0, get_tokens_token_request_cookie/0,
              get_tokens_token_request_body/0, get_tokens_token_response/0]).
-export_type([get_balance_transactions_request/0,
              get_balance_transactions_request_query/0, get_balance_transactions_request_header/0,
              get_balance_transactions_request_cookie/0, get_balance_transactions_request_body/0,
              get_balance_transactions_response/0]).
-export_type([get_tax_codes_id_request/0, get_tax_codes_id_request_query/0,
              get_tax_codes_id_request_header/0, get_tax_codes_id_request_cookie/0,
              get_tax_codes_id_request_body/0, get_tax_codes_id_response/0]).
-export_type([post_accounts_account_reject_request/0,
              post_accounts_account_reject_request_query/0,
              post_accounts_account_reject_request_header/0,
              post_accounts_account_reject_request_cookie/0,
              post_accounts_account_reject_request_body/0,
              post_accounts_account_reject_response/0]).
-export_type([delete_subscriptions_subscription_exposed_id_request/0,
              delete_subscriptions_subscription_exposed_id_request_query/0,
              delete_subscriptions_subscription_exposed_id_request_header/0,
              delete_subscriptions_subscription_exposed_id_request_cookie/0,
              delete_subscriptions_subscription_exposed_id_request_body/0,
              delete_subscriptions_subscription_exposed_id_response/0]).
-export_type([post_subscriptions_subscription_exposed_id_request/0,
              post_subscriptions_subscription_exposed_id_request_query/0,
              post_subscriptions_subscription_exposed_id_request_header/0,
              post_subscriptions_subscription_exposed_id_request_cookie/0,
              post_subscriptions_subscription_exposed_id_request_body/0,
              post_subscriptions_subscription_exposed_id_response/0]).
-export_type([get_subscriptions_subscription_exposed_id_request/0,
              get_subscriptions_subscription_exposed_id_request_query/0,
              get_subscriptions_subscription_exposed_id_request_header/0,
              get_subscriptions_subscription_exposed_id_request_cookie/0,
              get_subscriptions_subscription_exposed_id_request_body/0,
              get_subscriptions_subscription_exposed_id_response/0]).
-export_type([get_country_specs_country_request/0,
              get_country_specs_country_request_query/0, get_country_specs_country_request_header/0,
              get_country_specs_country_request_cookie/0, get_country_specs_country_request_body/0,
              get_country_specs_country_response/0]).
-export_type([post_invoices_invoice_finalize_request/0,
              post_invoices_invoice_finalize_request_query/0,
              post_invoices_invoice_finalize_request_header/0,
              post_invoices_invoice_finalize_request_cookie/0,
              post_invoices_invoice_finalize_request_body/0,
              post_invoices_invoice_finalize_response/0]).
-export_type([delete_terminal_locations_location_request/0,
              delete_terminal_locations_location_request_query/0,
              delete_terminal_locations_location_request_header/0,
              delete_terminal_locations_location_request_cookie/0,
              delete_terminal_locations_location_request_body/0,
              delete_terminal_locations_location_response/0]).
-export_type([post_terminal_locations_location_request/0,
              post_terminal_locations_location_request_query/0,
              post_terminal_locations_location_request_header/0,
              post_terminal_locations_location_request_cookie/0,
              post_terminal_locations_location_request_body/0,
              post_terminal_locations_location_response/0]).
-export_type([get_terminal_locations_location_request/0,
              get_terminal_locations_location_request_query/0,
              get_terminal_locations_location_request_header/0,
              get_terminal_locations_location_request_cookie/0,
              get_terminal_locations_location_request_body/0,
              get_terminal_locations_location_response/0]).
-export_type([delete_account_request/0, delete_account_request_query/0,
              delete_account_request_header/0, delete_account_request_cookie/0,
              delete_account_request_body/0, delete_account_response/0]).
-export_type([post_account_request/0, post_account_request_query/0,
              post_account_request_header/0, post_account_request_cookie/0,
              post_account_request_body/0, post_account_response/0]).
-export_type([get_account_request/0, get_account_request_query/0,
              get_account_request_header/0, get_account_request_cookie/0,
              get_account_request_body/0, get_account_response/0]).
-export_type([post_shipping_rates_shipping_rate_token_request/0,
              post_shipping_rates_shipping_rate_token_request_query/0,
              post_shipping_rates_shipping_rate_token_request_header/0,
              post_shipping_rates_shipping_rate_token_request_cookie/0,
              post_shipping_rates_shipping_rate_token_request_body/0,
              post_shipping_rates_shipping_rate_token_response/0]).
-export_type([get_shipping_rates_shipping_rate_token_request/0,
              get_shipping_rates_shipping_rate_token_request_query/0,
              get_shipping_rates_shipping_rate_token_request_header/0,
              get_shipping_rates_shipping_rate_token_request_cookie/0,
              get_shipping_rates_shipping_rate_token_request_body/0,
              get_shipping_rates_shipping_rate_token_response/0]).
-export_type([get_invoices_upcoming_lines_request/0,
              get_invoices_upcoming_lines_request_query/0,
              get_invoices_upcoming_lines_request_header/0,
              get_invoices_upcoming_lines_request_cookie/0,
              get_invoices_upcoming_lines_request_body/0, get_invoices_upcoming_lines_response/0]).
-export_type([post_issuing_cardholders_request/0,
              post_issuing_cardholders_request_query/0, post_issuing_cardholders_request_header/0,
              post_issuing_cardholders_request_cookie/0, post_issuing_cardholders_request_body/0,
              post_issuing_cardholders_response/0]).
-export_type([get_issuing_cardholders_request/0, get_issuing_cardholders_request_query/0,
              get_issuing_cardholders_request_header/0, get_issuing_cardholders_request_cookie/0,
              get_issuing_cardholders_request_body/0, get_issuing_cardholders_response/0]).
-export_type([delete_customers_customer_sources_id_request/0,
              delete_customers_customer_sources_id_request_query/0,
              delete_customers_customer_sources_id_request_header/0,
              delete_customers_customer_sources_id_request_cookie/0,
              delete_customers_customer_sources_id_request_body/0,
              delete_customers_customer_sources_id_response/0]).
-export_type([post_customers_customer_sources_id_request/0,
              post_customers_customer_sources_id_request_query/0,
              post_customers_customer_sources_id_request_header/0,
              post_customers_customer_sources_id_request_cookie/0,
              post_customers_customer_sources_id_request_body/0,
              post_customers_customer_sources_id_response/0]).
-export_type([get_customers_customer_sources_id_request/0,
              get_customers_customer_sources_id_request_query/0,
              get_customers_customer_sources_id_request_header/0,
              get_customers_customer_sources_id_request_cookie/0,
              get_customers_customer_sources_id_request_body/0,
              get_customers_customer_sources_id_response/0]).
-export_type([get_application_fees_request/0, get_application_fees_request_query/0,
              get_application_fees_request_header/0, get_application_fees_request_cookie/0,
              get_application_fees_request_body/0, get_application_fees_response/0]).
-export_type([get_bitcoin_receivers_request/0, get_bitcoin_receivers_request_query/0,
              get_bitcoin_receivers_request_header/0, get_bitcoin_receivers_request_cookie/0,
              get_bitcoin_receivers_request_body/0, get_bitcoin_receivers_response/0]).
-export_type([post_refunds_refund_request/0, post_refunds_refund_request_query/0,
              post_refunds_refund_request_header/0, post_refunds_refund_request_cookie/0,
              post_refunds_refund_request_body/0, post_refunds_refund_response/0]).
-export_type([get_refunds_refund_request/0, get_refunds_refund_request_query/0,
              get_refunds_refund_request_header/0, get_refunds_refund_request_cookie/0,
              get_refunds_refund_request_body/0, get_refunds_refund_response/0]).
-export_type([post_account_login_links_request/0,
              post_account_login_links_request_query/0, post_account_login_links_request_header/0,
              post_account_login_links_request_cookie/0, post_account_login_links_request_body/0,
              post_account_login_links_response/0]).
-export_type([post_tax_rates_request/0, post_tax_rates_request_query/0,
              post_tax_rates_request_header/0, post_tax_rates_request_cookie/0,
              post_tax_rates_request_body/0, post_tax_rates_response/0]).
-export_type([get_tax_rates_request/0, get_tax_rates_request_query/0,
              get_tax_rates_request_header/0, get_tax_rates_request_cookie/0,
              get_tax_rates_request_body/0, get_tax_rates_response/0]).
-export_type([post_accounts_account_people_request/0,
              post_accounts_account_people_request_query/0,
              post_accounts_account_people_request_header/0,
              post_accounts_account_people_request_cookie/0,
              post_accounts_account_people_request_body/0,
              post_accounts_account_people_response/0]).
-export_type([get_accounts_account_people_request/0,
              get_accounts_account_people_request_query/0,
              get_accounts_account_people_request_header/0,
              get_accounts_account_people_request_cookie/0,
              get_accounts_account_people_request_body/0, get_accounts_account_people_response/0]).
-export_type([post_issuing_disputes_dispute_submit_request/0,
              post_issuing_disputes_dispute_submit_request_query/0,
              post_issuing_disputes_dispute_submit_request_header/0,
              post_issuing_disputes_dispute_submit_request_cookie/0,
              post_issuing_disputes_dispute_submit_request_body/0,
              post_issuing_disputes_dispute_submit_response/0]).
-export_type([post_sources_source_request/0, post_sources_source_request_query/0,
              post_sources_source_request_header/0, post_sources_source_request_cookie/0,
              post_sources_source_request_body/0, post_sources_source_response/0]).
-export_type([get_sources_source_request/0, get_sources_source_request_query/0,
              get_sources_source_request_header/0, get_sources_source_request_cookie/0,
              get_sources_source_request_body/0, get_sources_source_response/0]).
-export_type([get_checkout_sessions_session_request/0,
              get_checkout_sessions_session_request_query/0,
              get_checkout_sessions_session_request_header/0,
              get_checkout_sessions_session_request_cookie/0,
              get_checkout_sessions_session_request_body/0,
              get_checkout_sessions_session_response/0]).
-export_type([post_payment_methods_payment_method_detach_request/0,
              post_payment_methods_payment_method_detach_request_query/0,
              post_payment_methods_payment_method_detach_request_header/0,
              post_payment_methods_payment_method_detach_request_cookie/0,
              post_payment_methods_payment_method_detach_request_body/0,
              post_payment_methods_payment_method_detach_response/0]).
-export_type([post_customers_request/0, post_customers_request_query/0,
              post_customers_request_header/0, post_customers_request_cookie/0,
              post_customers_request_body/0, post_customers_response/0]).
-export_type([get_customers_request/0, get_customers_request_query/0,
              get_customers_request_header/0, get_customers_request_cookie/0,
              get_customers_request_body/0, get_customers_response/0]).
-export_type([post_account_bank_accounts_request/0,
              post_account_bank_accounts_request_query/0,
              post_account_bank_accounts_request_header/0,
              post_account_bank_accounts_request_cookie/0,
              post_account_bank_accounts_request_body/0, post_account_bank_accounts_response/0]).
-export_type([post_issuing_disputes_dispute_request/0,
              post_issuing_disputes_dispute_request_query/0,
              post_issuing_disputes_dispute_request_header/0,
              post_issuing_disputes_dispute_request_cookie/0,
              post_issuing_disputes_dispute_request_body/0,
              post_issuing_disputes_dispute_response/0]).
-export_type([get_issuing_disputes_dispute_request/0,
              get_issuing_disputes_dispute_request_query/0,
              get_issuing_disputes_dispute_request_header/0,
              get_issuing_disputes_dispute_request_cookie/0,
              get_issuing_disputes_dispute_request_body/0,
              get_issuing_disputes_dispute_response/0]).
-export_type([post_disputes_dispute_close_request/0,
              post_disputes_dispute_close_request_query/0,
              post_disputes_dispute_close_request_header/0,
              post_disputes_dispute_close_request_cookie/0,
              post_disputes_dispute_close_request_body/0, post_disputes_dispute_close_response/0]).
-export_type([post_quotes_quote_cancel_request/0,
              post_quotes_quote_cancel_request_query/0, post_quotes_quote_cancel_request_header/0,
              post_quotes_quote_cancel_request_cookie/0, post_quotes_quote_cancel_request_body/0,
              post_quotes_quote_cancel_response/0]).
-export_type([get_customers_customer_payment_methods_request/0,
              get_customers_customer_payment_methods_request_query/0,
              get_customers_customer_payment_methods_request_header/0,
              get_customers_customer_payment_methods_request_cookie/0,
              get_customers_customer_payment_methods_request_body/0,
              get_customers_customer_payment_methods_response/0]).
-export_type([post_refunds_request/0, post_refunds_request_query/0,
              post_refunds_request_header/0, post_refunds_request_cookie/0,
              post_refunds_request_body/0, post_refunds_response/0]).
-export_type([get_refunds_request/0, get_refunds_request_query/0,
              get_refunds_request_header/0, get_refunds_request_cookie/0,
              get_refunds_request_body/0, get_refunds_response/0]).
-export_type([post_credit_notes_id_request/0, post_credit_notes_id_request_query/0,
              post_credit_notes_id_request_header/0, post_credit_notes_id_request_cookie/0,
              post_credit_notes_id_request_body/0, post_credit_notes_id_response/0]).
-export_type([get_credit_notes_id_request/0, get_credit_notes_id_request_query/0,
              get_credit_notes_id_request_header/0, get_credit_notes_id_request_cookie/0,
              get_credit_notes_id_request_body/0, get_credit_notes_id_response/0]).
-export_type([get_bitcoin_transactions_request/0,
              get_bitcoin_transactions_request_query/0, get_bitcoin_transactions_request_header/0,
              get_bitcoin_transactions_request_cookie/0, get_bitcoin_transactions_request_body/0,
              get_bitcoin_transactions_response/0]).
-export_type([post_setup_intents_request/0, post_setup_intents_request_query/0,
              post_setup_intents_request_header/0, post_setup_intents_request_cookie/0,
              post_setup_intents_request_body/0, post_setup_intents_response/0]).
-export_type([get_setup_intents_request/0, get_setup_intents_request_query/0,
              get_setup_intents_request_header/0, get_setup_intents_request_cookie/0,
              get_setup_intents_request_body/0, get_setup_intents_response/0]).
-export_type([post_payouts_payout_cancel_request/0,
              post_payouts_payout_cancel_request_query/0,
              post_payouts_payout_cancel_request_header/0,
              post_payouts_payout_cancel_request_cookie/0,
              post_payouts_payout_cancel_request_body/0, post_payouts_payout_cancel_response/0]).
-export_type([post_issuing_authorizations_authorization_approve_request/0,
              post_issuing_authorizations_authorization_approve_request_query/0,
              post_issuing_authorizations_authorization_approve_request_header/0,
              post_issuing_authorizations_authorization_approve_request_cookie/0,
              post_issuing_authorizations_authorization_approve_request_body/0,
              post_issuing_authorizations_authorization_approve_response/0]).
-export_type([post_issuing_authorizations_authorization_decline_request/0,
              post_issuing_authorizations_authorization_decline_request_query/0,
              post_issuing_authorizations_authorization_decline_request_header/0,
              post_issuing_authorizations_authorization_decline_request_cookie/0,
              post_issuing_authorizations_authorization_decline_request_body/0,
              post_issuing_authorizations_authorization_decline_response/0]).
-export_type([post_reporting_report_runs_request/0,
              post_reporting_report_runs_request_query/0,
              post_reporting_report_runs_request_header/0,
              post_reporting_report_runs_request_cookie/0,
              post_reporting_report_runs_request_body/0, post_reporting_report_runs_response/0]).
-export_type([get_reporting_report_runs_request/0,
              get_reporting_report_runs_request_query/0, get_reporting_report_runs_request_header/0,
              get_reporting_report_runs_request_cookie/0, get_reporting_report_runs_request_body/0,
              get_reporting_report_runs_response/0]).
-export_type([post_invoices_invoice_void_request/0,
              post_invoices_invoice_void_request_query/0,
              post_invoices_invoice_void_request_header/0,
              post_invoices_invoice_void_request_cookie/0,
              post_invoices_invoice_void_request_body/0, post_invoices_invoice_void_response/0]).
-export_type([post_sources_request/0, post_sources_request_query/0,
              post_sources_request_header/0, post_sources_request_cookie/0,
              post_sources_request_body/0, post_sources_response/0]).
-export_type([post_billing_portal_configurations_request/0,
              post_billing_portal_configurations_request_query/0,
              post_billing_portal_configurations_request_header/0,
              post_billing_portal_configurations_request_cookie/0,
              post_billing_portal_configurations_request_body/0,
              post_billing_portal_configurations_response/0]).
-export_type([get_billing_portal_configurations_request/0,
              get_billing_portal_configurations_request_query/0,
              get_billing_portal_configurations_request_header/0,
              get_billing_portal_configurations_request_cookie/0,
              get_billing_portal_configurations_request_body/0,
              get_billing_portal_configurations_response/0]).
-export_type([post_quotes_request/0, post_quotes_request_query/0,
              post_quotes_request_header/0, post_quotes_request_cookie/0,
              post_quotes_request_body/0, post_quotes_response/0]).
-export_type([get_quotes_request/0, get_quotes_request_query/0,
              get_quotes_request_header/0, get_quotes_request_cookie/0, get_quotes_request_body/0,
              get_quotes_response/0]).
-export_type([post_transfers_transfer_request/0, post_transfers_transfer_request_query/0,
              post_transfers_transfer_request_header/0, post_transfers_transfer_request_cookie/0,
              post_transfers_transfer_request_body/0, post_transfers_transfer_response/0]).
-export_type([get_transfers_transfer_request/0, get_transfers_transfer_request_query/0,
              get_transfers_transfer_request_header/0, get_transfers_transfer_request_cookie/0,
              get_transfers_transfer_request_body/0, get_transfers_transfer_response/0]).
-export_type([get_quotes_quote_line_items_request/0,
              get_quotes_quote_line_items_request_query/0,
              get_quotes_quote_line_items_request_header/0,
              get_quotes_quote_line_items_request_cookie/0,
              get_quotes_quote_line_items_request_body/0, get_quotes_quote_line_items_response/0]).
-export_type([delete_invoiceitems_invoiceitem_request/0,
              delete_invoiceitems_invoiceitem_request_query/0,
              delete_invoiceitems_invoiceitem_request_header/0,
              delete_invoiceitems_invoiceitem_request_cookie/0,
              delete_invoiceitems_invoiceitem_request_body/0,
              delete_invoiceitems_invoiceitem_response/0]).
-export_type([post_invoiceitems_invoiceitem_request/0,
              post_invoiceitems_invoiceitem_request_query/0,
              post_invoiceitems_invoiceitem_request_header/0,
              post_invoiceitems_invoiceitem_request_cookie/0,
              post_invoiceitems_invoiceitem_request_body/0,
              post_invoiceitems_invoiceitem_response/0]).
-export_type([get_invoiceitems_invoiceitem_request/0,
              get_invoiceitems_invoiceitem_request_query/0,
              get_invoiceitems_invoiceitem_request_header/0,
              get_invoiceitems_invoiceitem_request_cookie/0,
              get_invoiceitems_invoiceitem_request_body/0,
              get_invoiceitems_invoiceitem_response/0]).
-export_type([post_payment_intents_intent_capture_request/0,
              post_payment_intents_intent_capture_request_query/0,
              post_payment_intents_intent_capture_request_header/0,
              post_payment_intents_intent_capture_request_cookie/0,
              post_payment_intents_intent_capture_request_body/0,
              post_payment_intents_intent_capture_response/0]).
-export_type([post_issuing_cards_request/0, post_issuing_cards_request_query/0,
              post_issuing_cards_request_header/0, post_issuing_cards_request_cookie/0,
              post_issuing_cards_request_body/0, post_issuing_cards_response/0]).
-export_type([get_issuing_cards_request/0, get_issuing_cards_request_query/0,
              get_issuing_cards_request_header/0, get_issuing_cards_request_cookie/0,
              get_issuing_cards_request_body/0, get_issuing_cards_response/0]).
-export_type([get_sources_source_source_transactions_request/0,
              get_sources_source_source_transactions_request_query/0,
              get_sources_source_source_transactions_request_header/0,
              get_sources_source_source_transactions_request_cookie/0,
              get_sources_source_source_transactions_request_body/0,
              get_sources_source_source_transactions_response/0]).
-export_type([post_subscription_schedules_schedule_release_request/0,
              post_subscription_schedules_schedule_release_request_query/0,
              post_subscription_schedules_schedule_release_request_header/0,
              post_subscription_schedules_schedule_release_request_cookie/0,
              post_subscription_schedules_schedule_release_request_body/0,
              post_subscription_schedules_schedule_release_response/0]).
-export_type([delete_customers_customer_cards_id_request/0,
              delete_customers_customer_cards_id_request_query/0,
              delete_customers_customer_cards_id_request_header/0,
              delete_customers_customer_cards_id_request_cookie/0,
              delete_customers_customer_cards_id_request_body/0,
              delete_customers_customer_cards_id_response/0]).
-export_type([post_customers_customer_cards_id_request/0,
              post_customers_customer_cards_id_request_query/0,
              post_customers_customer_cards_id_request_header/0,
              post_customers_customer_cards_id_request_cookie/0,
              post_customers_customer_cards_id_request_body/0,
              post_customers_customer_cards_id_response/0]).
-export_type([get_customers_customer_cards_id_request/0,
              get_customers_customer_cards_id_request_query/0,
              get_customers_customer_cards_id_request_header/0,
              get_customers_customer_cards_id_request_cookie/0,
              get_customers_customer_cards_id_request_body/0,
              get_customers_customer_cards_id_response/0]).
-export_type([post_charges_charge_dispute_request/0,
              post_charges_charge_dispute_request_query/0,
              post_charges_charge_dispute_request_header/0,
              post_charges_charge_dispute_request_cookie/0,
              post_charges_charge_dispute_request_body/0, post_charges_charge_dispute_response/0]).
-export_type([get_charges_charge_dispute_request/0,
              get_charges_charge_dispute_request_query/0,
              get_charges_charge_dispute_request_header/0,
              get_charges_charge_dispute_request_cookie/0,
              get_charges_charge_dispute_request_body/0, get_charges_charge_dispute_response/0]).
-export_type([post_quotes_quote_finalize_request/0,
              post_quotes_quote_finalize_request_query/0,
              post_quotes_quote_finalize_request_header/0,
              post_quotes_quote_finalize_request_cookie/0,
              post_quotes_quote_finalize_request_body/0, post_quotes_quote_finalize_response/0]).
-export_type([delete_skus_id_request/0, delete_skus_id_request_query/0,
              delete_skus_id_request_header/0, delete_skus_id_request_cookie/0,
              delete_skus_id_request_body/0, delete_skus_id_response/0]).
-export_type([post_skus_id_request/0, post_skus_id_request_query/0,
              post_skus_id_request_header/0, post_skus_id_request_cookie/0,
              post_skus_id_request_body/0, post_skus_id_response/0]).
-export_type([get_skus_id_request/0, get_skus_id_request_query/0,
              get_skus_id_request_header/0, get_skus_id_request_cookie/0,
              get_skus_id_request_body/0, get_skus_id_response/0]).
-export_type([post_disputes_dispute_request/0, post_disputes_dispute_request_query/0,
              post_disputes_dispute_request_header/0, post_disputes_dispute_request_cookie/0,
              post_disputes_dispute_request_body/0, post_disputes_dispute_response/0]).
-export_type([get_disputes_dispute_request/0, get_disputes_dispute_request_query/0,
              get_disputes_dispute_request_header/0, get_disputes_dispute_request_cookie/0,
              get_disputes_dispute_request_body/0, get_disputes_dispute_response/0]).
-export_type([post_terminal_locations_request/0, post_terminal_locations_request_query/0,
              post_terminal_locations_request_header/0, post_terminal_locations_request_cookie/0,
              post_terminal_locations_request_body/0, post_terminal_locations_response/0]).
-export_type([get_terminal_locations_request/0, get_terminal_locations_request_query/0,
              get_terminal_locations_request_header/0, get_terminal_locations_request_cookie/0,
              get_terminal_locations_request_body/0, get_terminal_locations_response/0]).
-export_type([post_subscription_schedules_request/0,
              post_subscription_schedules_request_query/0,
              post_subscription_schedules_request_header/0,
              post_subscription_schedules_request_cookie/0,
              post_subscription_schedules_request_body/0, post_subscription_schedules_response/0]).
-export_type([get_subscription_schedules_request/0,
              get_subscription_schedules_request_query/0,
              get_subscription_schedules_request_header/0,
              get_subscription_schedules_request_cookie/0,
              get_subscription_schedules_request_body/0, get_subscription_schedules_response/0]).
-export_type([post_payment_links_request/0, post_payment_links_request_query/0,
              post_payment_links_request_header/0, post_payment_links_request_cookie/0,
              post_payment_links_request_body/0, post_payment_links_response/0]).
-export_type([get_payment_links_request/0, get_payment_links_request_query/0,
              get_payment_links_request_header/0, get_payment_links_request_cookie/0,
              get_payment_links_request_body/0, get_payment_links_response/0]).
-export_type([post_tokens_request/0, post_tokens_request_query/0,
              post_tokens_request_header/0, post_tokens_request_cookie/0,
              post_tokens_request_body/0, post_tokens_response/0]).
-export_type([post_issuing_cardholders_cardholder_request/0,
              post_issuing_cardholders_cardholder_request_query/0,
              post_issuing_cardholders_cardholder_request_header/0,
              post_issuing_cardholders_cardholder_request_cookie/0,
              post_issuing_cardholders_cardholder_request_body/0,
              post_issuing_cardholders_cardholder_response/0]).
-export_type([get_issuing_cardholders_cardholder_request/0,
              get_issuing_cardholders_cardholder_request_query/0,
              get_issuing_cardholders_cardholder_request_header/0,
              get_issuing_cardholders_cardholder_request_cookie/0,
              get_issuing_cardholders_cardholder_request_body/0,
              get_issuing_cardholders_cardholder_response/0]).
-export_type([get_application_fees_id_request/0, get_application_fees_id_request_query/0,
              get_application_fees_id_request_header/0, get_application_fees_id_request_cookie/0,
              get_application_fees_id_request_body/0, get_application_fees_id_response/0]).
-export_type([get_exchange_rates_rate_id_request/0,
              get_exchange_rates_rate_id_request_query/0,
              get_exchange_rates_rate_id_request_header/0,
              get_exchange_rates_rate_id_request_cookie/0,
              get_exchange_rates_rate_id_request_body/0, get_exchange_rates_rate_id_response/0]).
-export_type([post_payment_intents_intent_confirm_request/0,
              post_payment_intents_intent_confirm_request_query/0,
              post_payment_intents_intent_confirm_request_header/0,
              post_payment_intents_intent_confirm_request_cookie/0,
              post_payment_intents_intent_confirm_request_body/0,
              post_payment_intents_intent_confirm_response/0]).
-export_type([get_credit_notes_preview_request/0,
              get_credit_notes_preview_request_query/0, get_credit_notes_preview_request_header/0,
              get_credit_notes_preview_request_cookie/0, get_credit_notes_preview_request_body/0,
              get_credit_notes_preview_response/0]).
-export_type([get_balance_history_id_request/0, get_balance_history_id_request_query/0,
              get_balance_history_id_request_header/0, get_balance_history_id_request_cookie/0,
              get_balance_history_id_request_body/0, get_balance_history_id_response/0]).
-export_type([post_payouts_payout_reverse_request/0,
              post_payouts_payout_reverse_request_query/0,
              post_payouts_payout_reverse_request_header/0,
              post_payouts_payout_reverse_request_cookie/0,
              post_payouts_payout_reverse_request_body/0, post_payouts_payout_reverse_response/0]).
-export_type([get_reporting_report_runs_report_run_request/0,
              get_reporting_report_runs_report_run_request_query/0,
              get_reporting_report_runs_report_run_request_header/0,
              get_reporting_report_runs_report_run_request_cookie/0,
              get_reporting_report_runs_report_run_request_body/0,
              get_reporting_report_runs_report_run_response/0]).
-export_type([get_sources_source_source_transactions_source_transaction_request/0,
              get_sources_source_source_transactions_source_transaction_request_query/0,
              get_sources_source_source_transactions_source_transaction_request_header/0,
              get_sources_source_source_transactions_source_transaction_request_cookie/0,
              get_sources_source_source_transactions_source_transaction_request_body/0,
              get_sources_source_source_transactions_source_transaction_response/0]).
-export_type([delete_customers_customer_request/0,
              delete_customers_customer_request_query/0, delete_customers_customer_request_header/0,
              delete_customers_customer_request_cookie/0, delete_customers_customer_request_body/0,
              delete_customers_customer_response/0]).
-export_type([post_customers_customer_request/0, post_customers_customer_request_query/0,
              post_customers_customer_request_header/0, post_customers_customer_request_cookie/0,
              post_customers_customer_request_body/0, post_customers_customer_response/0]).
-export_type([get_customers_customer_request/0, get_customers_customer_request_query/0,
              get_customers_customer_request_header/0, get_customers_customer_request_cookie/0,
              get_customers_customer_request_body/0, get_customers_customer_response/0]).
-export_type([post_billing_portal_sessions_request/0,
              post_billing_portal_sessions_request_query/0,
              post_billing_portal_sessions_request_header/0,
              post_billing_portal_sessions_request_cookie/0,
              post_billing_portal_sessions_request_body/0,
              post_billing_portal_sessions_response/0]).
-export_type([post_payment_links_payment_link_request/0,
              post_payment_links_payment_link_request_query/0,
              post_payment_links_payment_link_request_header/0,
              post_payment_links_payment_link_request_cookie/0,
              post_payment_links_payment_link_request_body/0,
              post_payment_links_payment_link_response/0]).
-export_type([get_payment_links_payment_link_request/0,
              get_payment_links_payment_link_request_query/0,
              get_payment_links_payment_link_request_header/0,
              get_payment_links_payment_link_request_cookie/0,
              get_payment_links_payment_link_request_body/0,
              get_payment_links_payment_link_response/0]).
-export_type([get_credit_notes_credit_note_lines_request/0,
              get_credit_notes_credit_note_lines_request_query/0,
              get_credit_notes_credit_note_lines_request_header/0,
              get_credit_notes_credit_note_lines_request_cookie/0,
              get_credit_notes_credit_note_lines_request_body/0,
              get_credit_notes_credit_note_lines_response/0]).
-export_type([get_sigma_scheduled_query_runs_request/0,
              get_sigma_scheduled_query_runs_request_query/0,
              get_sigma_scheduled_query_runs_request_header/0,
              get_sigma_scheduled_query_runs_request_cookie/0,
              get_sigma_scheduled_query_runs_request_body/0,
              get_sigma_scheduled_query_runs_response/0]).

-type options() ::
    #{request_options => mhttp:request_options(),
      host => uri:host(),
      scheme => uri:scheme(),
      port => uri:port_number()}.
-type result(T) :: {ok, T, mhttp:response()} | {error, error()}.
-type error() ::
    #{reason := error_reason(),
      request => mhttp:request(),
      response => mhttp:response()}.
-type error_reason() ::
    {mhttp, mhttp:error_reason()} |
    missing_content_type |
    unsupported_content_type |
    {invalid_content_type, mhttp_media_type:error_reason()} |
    {invalid_payload, {json, json:error()}} |
    {invalid_payload, {jsv, [jsv:value_error()]}}.
-type get_radar_early_fraud_warnings_request() ::
    #{query => get_radar_early_fraud_warnings_request_query(),
      header => get_radar_early_fraud_warnings_request_header(),
      cookie => get_radar_early_fraud_warnings_request_cookie(),
      body => {binary(), get_radar_early_fraud_warnings_request_body()}}.
-type get_radar_early_fraud_warnings_request_query() ::
    #{charge => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary()}.
-type get_radar_early_fraud_warnings_request_header() :: map().
-type get_radar_early_fraud_warnings_request_cookie() :: map().
-type get_radar_early_fraud_warnings_request_body() :: #{}.
-type get_radar_early_fraud_warnings_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:radar_early_fraud_warning()],
      _ := json:value()}.
-type post_charges_charge_refunds_request() ::
    #{charge := binary(),
      query => post_charges_charge_refunds_request_query(),
      header => post_charges_charge_refunds_request_header(),
      cookie => post_charges_charge_refunds_request_cookie(),
      body => {binary(), post_charges_charge_refunds_request_body()}}.
-type post_charges_charge_refunds_request_query() :: map().
-type post_charges_charge_refunds_request_header() :: map().
-type post_charges_charge_refunds_request_cookie() :: map().
-type post_charges_charge_refunds_request_body() ::
    #{reverse_transfer => boolean(),
      refund_application_fee => boolean(),
      reason => duplicate | fraudulent | requested_by_customer,
      payment_intent => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      amount => integer()}.
-type post_charges_charge_refunds_response() ::
    stripe_model:error() | stripe_model:refund().
-type get_charges_charge_refunds_request() ::
    #{charge := binary(),
      query => get_charges_charge_refunds_request_query(),
      header => get_charges_charge_refunds_request_header(),
      cookie => get_charges_charge_refunds_request_cookie(),
      body => {binary(), get_charges_charge_refunds_request_body()}}.
-type get_charges_charge_refunds_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_charges_charge_refunds_request_header() :: map().
-type get_charges_charge_refunds_request_cookie() :: map().
-type get_charges_charge_refunds_request_body() :: #{}.
-type get_charges_charge_refunds_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:refund()],
      _ := json:value()}.
-type post_identity_verification_sessions_session_redact_request() ::
    #{session := binary(),
      query => post_identity_verification_sessions_session_redact_request_query(),
      header => post_identity_verification_sessions_session_redact_request_header(),
      cookie => post_identity_verification_sessions_session_redact_request_cookie(),
      body => {binary(), post_identity_verification_sessions_session_redact_request_body()}}.
-type post_identity_verification_sessions_session_redact_request_query() :: map().
-type post_identity_verification_sessions_session_redact_request_header() :: map().
-type post_identity_verification_sessions_session_redact_request_cookie() :: map().
-type post_identity_verification_sessions_session_redact_request_body() ::
    #{expand => [binary()]}.
-type post_identity_verification_sessions_session_redact_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type post_billing_portal_configurations_configuration_request() ::
    #{configuration := binary(),
      query => post_billing_portal_configurations_configuration_request_query(),
      header => post_billing_portal_configurations_configuration_request_header(),
      cookie => post_billing_portal_configurations_configuration_request_cookie(),
      body => {binary(), post_billing_portal_configurations_configuration_request_body()}}.
-type post_billing_portal_configurations_configuration_request_query() :: map().
-type post_billing_portal_configurations_configuration_request_header() :: map().
-type post_billing_portal_configurations_configuration_request_cookie() :: map().
-type post_billing_portal_configurations_configuration_request_body() ::
    #{metadata => json:value() | '',
      features =>
          #{subscription_update =>
                #{proration_behavior => always_invoice | create_prorations | none,
                  products =>
                      [#{product := binary(),
                         prices := [binary()],
                         _ := json:value()}] |
                      '',
                  enabled => boolean(),
                  default_allowed_updates => [price | promotion_code | quantity] | '',
                  _ := json:value()},
            subscription_pause => #{enabled => boolean(), _ := json:value()},
            subscription_cancel =>
                #{proration_behavior => always_invoice | create_prorations | none,
                  mode => at_period_end | immediately,
                  enabled => boolean(),
                  cancellation_reason =>
                      #{options =>
                            [customer_service |
                             low_quality |
                             missing_features |
                             other |
                             switched_service |
                             too_complex |
                             too_expensive |
                             unused] |
                            '',
                        enabled := boolean(),
                        _ := json:value()},
                  _ := json:value()},
            payment_method_update => #{enabled := boolean(), _ := json:value()},
            invoice_history => #{enabled := boolean(), _ := json:value()},
            customer_update =>
                #{enabled => boolean(),
                  allowed_updates => [address | email | phone | shipping | tax_id] | '',
                  _ := json:value()},
            _ := json:value()},
      expand => [binary()],
      default_return_url => binary() | '',
      business_profile =>
          #{terms_of_service_url => binary(),
            privacy_policy_url => binary(),
            headline => binary(),
            _ := json:value()},
      active => boolean()}.
-type post_billing_portal_configurations_configuration_response() ::
    stripe_model:error() | stripe_model:billing_portal_configuration().
-type get_billing_portal_configurations_configuration_request() ::
    #{configuration := binary(),
      query => get_billing_portal_configurations_configuration_request_query(),
      header => get_billing_portal_configurations_configuration_request_header(),
      cookie => get_billing_portal_configurations_configuration_request_cookie(),
      body => {binary(), get_billing_portal_configurations_configuration_request_body()}}.
-type get_billing_portal_configurations_configuration_request_query() ::
    #{expand => [binary()]}.
-type get_billing_portal_configurations_configuration_request_header() :: map().
-type get_billing_portal_configurations_configuration_request_cookie() :: map().
-type get_billing_portal_configurations_configuration_request_body() :: #{}.
-type get_billing_portal_configurations_configuration_response() ::
    stripe_model:error() | stripe_model:billing_portal_configuration().
-type post_payment_methods_request() ::
    #{query => post_payment_methods_request_query(),
      header => post_payment_methods_request_header(),
      cookie => post_payment_methods_request_cookie(),
      body => {binary(), post_payment_methods_request_body()}}.
-type post_payment_methods_request_query() :: map().
-type post_payment_methods_request_header() :: map().
-type post_payment_methods_request_cookie() :: map().
-type post_payment_methods_request_body() ::
    #{wechat_pay => #{_ := json:value()},
      type =>
          acss_debit |
          afterpay_clearpay |
          alipay |
          au_becs_debit |
          bacs_debit |
          bancontact |
          boleto |
          card |
          eps |
          fpx |
          giropay |
          grabpay |
          ideal |
          klarna |
          oxxo |
          p24 |
          sepa_debit |
          sofort |
          wechat_pay,
      sofort => #{country := 'AT' | 'BE' | 'DE' | 'ES' | 'IT' | 'NL', _ := json:value()},
      sepa_debit => #{iban := binary(), _ := json:value()},
      payment_method => binary(),
      p24 =>
          #{bank =>
                alior_bank |
                bank_millennium |
                bank_nowy_bfg_sa |
                bank_pekao_sa |
                banki_spbdzielcze |
                blik |
                bnp_paribas |
                boz |
                citi_handlowy |
                credit_agricole |
                envelobank |
                etransfer_pocztowy24 |
                getin_bank |
                ideabank |
                ing |
                inteligo |
                mbank_mtransfer |
                nest_przelew |
                noble_pay |
                pbac_z_ipko |
                plus_bank |
                santander_przelew24 |
                tmobile_usbugi_bankowe |
                toyota_bank |
                volkswagen_bank,
            _ := json:value()},
      oxxo => #{_ := json:value()},
      metadata => json:value(),
      klarna =>
          #{dob =>
                #{year := integer(),
                  month := integer(),
                  day := integer(),
                  _ := json:value()},
            _ := json:value()},
      interac_present => #{_ := json:value()},
      ideal =>
          #{bank =>
                abn_amro |
                asn_bank |
                bunq |
                handelsbanken |
                ing |
                knab |
                moneyou |
                rabobank |
                regiobank |
                revolut |
                sns_bank |
                triodos_bank |
                van_lanschot,
            _ := json:value()},
      grabpay => #{_ := json:value()},
      giropay => #{_ := json:value()},
      fpx =>
          #{bank :=
                affin_bank |
                agrobank |
                alliance_bank |
                ambank |
                bank_islam |
                bank_muamalat |
                bank_rakyat |
                bsn |
                cimb |
                deutsche_bank |
                hong_leong_bank |
                hsbc |
                kfh |
                maybank2e |
                maybank2u |
                ocbc |
                pb_enterprise |
                public_bank |
                rhb |
                standard_chartered |
                uob,
            _ := json:value()},
      expand => [binary()],
      eps =>
          #{bank =>
                arzte_und_apotheker_bank | austrian_anadi_bank_ag | bank_austria |
                bankhaus_carl_spangler | bankhaus_schelhammer_und_schattera_ag | bawag_psk_ag |
                bks_bank_ag | brull_kallmus_bank_ag | btv_vier_lander_bank |
                capital_bank_grawe_gruppe_ag | dolomitenbank | easybank_ag |
                erste_bank_und_sparkassen | hypo_alpeadriabank_international_ag |
                hypo_bank_burgenland_aktiengesellschaft | hypo_noe_lb_fur_niederosterreich_u_wien |
                hypo_oberosterreich_salzburg_steiermark | hypo_tirol_bank_ag |
                hypo_vorarlberg_bank_ag | marchfelder_bank | oberbank_ag |
                raiffeisen_bankengruppe_osterreich | schoellerbank_ag | sparda_bank_wien |
                volksbank_gruppe | volkskreditbank_ag | vr_bank_braunau,
            _ := json:value()},
      customer => binary(),
      card =>
          #{number := binary(),
            exp_year := integer(),
            exp_month := integer(),
            cvc => binary(),
            _ := json:value()} |
          #{token := binary(), _ := json:value()},
      boleto => #{tax_id := binary(), _ := json:value()},
      billing_details =>
          #{phone => binary(),
            name => binary(),
            email => binary() | '',
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()} |
                '',
            _ := json:value()},
      bancontact => #{_ := json:value()},
      bacs_debit =>
          #{sort_code => binary(),
            account_number => binary(),
            _ := json:value()},
      au_becs_debit =>
          #{bsb_number := binary(),
            account_number := binary(),
            _ := json:value()},
      alipay => #{_ := json:value()},
      afterpay_clearpay => #{_ := json:value()},
      acss_debit =>
          #{transit_number := binary(),
            institution_number := binary(),
            account_number := binary(),
            _ := json:value()}}.
-type post_payment_methods_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type get_payment_methods_request() ::
    #{query => get_payment_methods_request_query(),
      header => get_payment_methods_request_header(),
      cookie => get_payment_methods_request_cookie(),
      body => {binary(), get_payment_methods_request_body()}}.
-type get_payment_methods_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type :=
          acss_debit |
          afterpay_clearpay |
          alipay |
          au_becs_debit |
          bacs_debit |
          bancontact |
          boleto |
          card |
          eps |
          fpx |
          giropay |
          grabpay |
          ideal |
          klarna |
          oxxo |
          p24 |
          sepa_debit |
          sofort |
          wechat_pay}.
-type get_payment_methods_request_header() :: map().
-type get_payment_methods_request_cookie() :: map().
-type get_payment_methods_request_body() :: #{}.
-type get_payment_methods_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payment_method()],
      _ := json:value()}.
-type delete_radar_value_lists_value_list_request() ::
    #{value_list := binary(),
      query => delete_radar_value_lists_value_list_request_query(),
      header => delete_radar_value_lists_value_list_request_header(),
      cookie => delete_radar_value_lists_value_list_request_cookie(),
      body => {binary(), delete_radar_value_lists_value_list_request_body()}}.
-type delete_radar_value_lists_value_list_request_query() :: map().
-type delete_radar_value_lists_value_list_request_header() :: map().
-type delete_radar_value_lists_value_list_request_cookie() :: map().
-type delete_radar_value_lists_value_list_request_body() :: #{}.
-type delete_radar_value_lists_value_list_response() ::
    stripe_model:error() | stripe_model:deleted_radar_value_list().
-type post_radar_value_lists_value_list_request() ::
    #{value_list := binary(),
      query => post_radar_value_lists_value_list_request_query(),
      header => post_radar_value_lists_value_list_request_header(),
      cookie => post_radar_value_lists_value_list_request_cookie(),
      body => {binary(), post_radar_value_lists_value_list_request_body()}}.
-type post_radar_value_lists_value_list_request_query() :: map().
-type post_radar_value_lists_value_list_request_header() :: map().
-type post_radar_value_lists_value_list_request_cookie() :: map().
-type post_radar_value_lists_value_list_request_body() ::
    #{name => binary(),
      metadata => json:value(),
      expand => [binary()],
      alias => binary()}.
-type post_radar_value_lists_value_list_response() ::
    stripe_model:error() | stripe_model:radar_value_list().
-type get_radar_value_lists_value_list_request() ::
    #{value_list := binary(),
      query => get_radar_value_lists_value_list_request_query(),
      header => get_radar_value_lists_value_list_request_header(),
      cookie => get_radar_value_lists_value_list_request_cookie(),
      body => {binary(), get_radar_value_lists_value_list_request_body()}}.
-type get_radar_value_lists_value_list_request_query() :: #{expand => [binary()]}.
-type get_radar_value_lists_value_list_request_header() :: map().
-type get_radar_value_lists_value_list_request_cookie() :: map().
-type get_radar_value_lists_value_list_request_body() :: #{}.
-type get_radar_value_lists_value_list_response() ::
    stripe_model:error() | stripe_model:radar_value_list().
-type post_charges_charge_capture_request() ::
    #{charge := binary(),
      query => post_charges_charge_capture_request_query(),
      header => post_charges_charge_capture_request_header(),
      cookie => post_charges_charge_capture_request_cookie(),
      body => {binary(), post_charges_charge_capture_request_body()}}.
-type post_charges_charge_capture_request_query() :: map().
-type post_charges_charge_capture_request_header() :: map().
-type post_charges_charge_capture_request_cookie() :: map().
-type post_charges_charge_capture_request_body() ::
    #{transfer_group => binary(),
      transfer_data => #{amount => integer(), _ := json:value()},
      statement_descriptor_suffix => binary(),
      statement_descriptor => binary(),
      receipt_email => binary(),
      expand => [binary()],
      application_fee_amount => integer(),
      application_fee => integer(),
      amount => integer()}.
-type post_charges_charge_capture_response() ::
    stripe_model:error() | stripe_model:charge().
-type get_disputes_request() ::
    #{query => get_disputes_request_query(),
      header => get_disputes_request_header(),
      cookie => get_disputes_request_cookie(),
      body => {binary(), get_disputes_request_body()}}.
-type get_disputes_request_query() ::
    #{charge => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary()}.
-type get_disputes_request_header() :: map().
-type get_disputes_request_cookie() :: map().
-type get_disputes_request_body() :: #{}.
-type get_disputes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:dispute()],
      _ := json:value()}.
-type post_prices_price_request() ::
    #{price := binary(),
      query => post_prices_price_request_query(),
      header => post_prices_price_request_header(),
      cookie => post_prices_price_request_cookie(),
      body => {binary(), post_prices_price_request_body()}}.
-type post_prices_price_request_query() :: map().
-type post_prices_price_request_header() :: map().
-type post_prices_price_request_cookie() :: map().
-type post_prices_price_request_body() ::
    #{transfer_lookup_key => boolean(),
      tax_behavior => exclusive | inclusive | unspecified,
      nickname => binary(),
      metadata => json:value() | '',
      lookup_key => binary(),
      expand => [binary()],
      active => boolean()}.
-type post_prices_price_response() :: stripe_model:error() | stripe_model:price().
-type get_prices_price_request() ::
    #{price := binary(),
      query => get_prices_price_request_query(),
      header => get_prices_price_request_header(),
      cookie => get_prices_price_request_cookie(),
      body => {binary(), get_prices_price_request_body()}}.
-type get_prices_price_request_query() :: #{expand => [binary()]}.
-type get_prices_price_request_header() :: map().
-type get_prices_price_request_cookie() :: map().
-type get_prices_price_request_body() :: #{}.
-type get_prices_price_response() :: stripe_model:error() | stripe_model:price().
-type post_accounts_request() ::
    #{query => post_accounts_request_query(),
      header => post_accounts_request_header(),
      cookie => post_accounts_request_cookie(),
      body => {binary(), post_accounts_request_body()}}.
-type post_accounts_request_query() :: map().
-type post_accounts_request_header() :: map().
-type post_accounts_request_cookie() :: map().
-type post_accounts_request_body() ::
    #{type => custom | express | standard,
      tos_acceptance =>
          #{user_agent => binary(),
            service_agreement => binary(),
            ip => binary(),
            date => integer(),
            _ := json:value()},
      settings =>
          #{payouts =>
                #{statement_descriptor => binary(),
                  schedule =>
                      #{weekly_anchor =>
                            friday | monday | saturday | sunday | thursday | tuesday | wednesday,
                        monthly_anchor => integer(),
                        interval => daily | manual | monthly | weekly,
                        delay_days => minimum | integer(),
                        _ := json:value()},
                  debit_negative_balances => boolean(),
                  _ := json:value()},
            payments =>
                #{statement_descriptor_kanji => binary(),
                  statement_descriptor_kana => binary(),
                  statement_descriptor => binary(),
                  _ := json:value()},
            card_payments =>
                #{statement_descriptor_prefix => binary(),
                  decline_on =>
                      #{cvc_failure => boolean(),
                        avs_failure => boolean(),
                        _ := json:value()},
                  _ := json:value()},
            card_issuing =>
                #{tos_acceptance =>
                      #{user_agent => binary(),
                        ip => binary(),
                        date => integer(),
                        _ := json:value()},
                  _ := json:value()},
            branding =>
                #{secondary_color => binary(),
                  primary_color => binary(),
                  logo => binary(),
                  icon => binary(),
                  _ := json:value()},
            _ := json:value()},
      metadata => json:value() | '',
      individual =>
          #{verification =>
                #{document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  additional_document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  _ := json:value()},
            ssn_last_4 => binary(),
            political_exposure => existing | none,
            phone => binary(),
            metadata => json:value() | '',
            maiden_name => binary(),
            last_name_kanji => binary(),
            last_name_kana => binary(),
            last_name => binary(),
            id_number => binary(),
            gender => binary(),
            full_name_aliases => [binary()] | '',
            first_name_kanji => binary(),
            first_name_kana => binary(),
            first_name => binary(),
            email => binary(),
            dob =>
                #{year := integer(),
                  month := integer(),
                  day := integer(),
                  _ := json:value()} |
                '',
            address_kanji =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address_kana =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      external_account => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{proof_of_registration => #{files => [binary()], _ := json:value()},
            company_tax_id_verification => #{files => [binary()], _ := json:value()},
            company_registration_verification => #{files => [binary()], _ := json:value()},
            company_ministerial_decree => #{files => [binary()], _ := json:value()},
            company_memorandum_of_association => #{files => [binary()], _ := json:value()},
            company_license => #{files => [binary()], _ := json:value()},
            bank_account_ownership_verification => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      default_currency => binary(),
      country => binary(),
      company =>
          #{verification =>
                #{document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  _ := json:value()},
            vat_id => binary(),
            tax_id_registrar => binary(),
            tax_id => binary(),
            structure =>
                '' |
                free_zone_establishment |
                free_zone_llc |
                government_instrumentality |
                governmental_unit |
                incorporated_non_profit |
                limited_liability_partnership |
                llc |
                multi_member_llc |
                private_company |
                private_corporation |
                private_partnership |
                public_company |
                public_corporation |
                public_partnership |
                single_member_llc |
                sole_establishment |
                sole_proprietorship |
                tax_exempt_government_instrumentality |
                unincorporated_association |
                unincorporated_non_profit,
            registration_number => binary(),
            phone => binary(),
            ownership_declaration =>
                #{user_agent => binary(),
                  ip => binary(),
                  date => integer(),
                  _ := json:value()},
            owners_provided => boolean(),
            name_kanji => binary(),
            name_kana => binary(),
            name => binary(),
            executives_provided => boolean(),
            directors_provided => boolean(),
            address_kanji =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address_kana =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      capabilities =>
          #{transfers => #{requested => boolean(), _ := json:value()},
            tax_reporting_us_1099_misc => #{requested => boolean(), _ := json:value()},
            tax_reporting_us_1099_k => #{requested => boolean(), _ := json:value()},
            sofort_payments => #{requested => boolean(), _ := json:value()},
            sepa_debit_payments => #{requested => boolean(), _ := json:value()},
            p24_payments => #{requested => boolean(), _ := json:value()},
            oxxo_payments => #{requested => boolean(), _ := json:value()},
            legacy_payments => #{requested => boolean(), _ := json:value()},
            klarna_payments => #{requested => boolean(), _ := json:value()},
            jcb_payments => #{requested => boolean(), _ := json:value()},
            ideal_payments => #{requested => boolean(), _ := json:value()},
            grabpay_payments => #{requested => boolean(), _ := json:value()},
            giropay_payments => #{requested => boolean(), _ := json:value()},
            fpx_payments => #{requested => boolean(), _ := json:value()},
            eps_payments => #{requested => boolean(), _ := json:value()},
            cartes_bancaires_payments => #{requested => boolean(), _ := json:value()},
            card_payments => #{requested => boolean(), _ := json:value()},
            card_issuing => #{requested => boolean(), _ := json:value()},
            boleto_payments => #{requested => boolean(), _ := json:value()},
            bancontact_payments => #{requested => boolean(), _ := json:value()},
            bacs_debit_payments => #{requested => boolean(), _ := json:value()},
            au_becs_debit_payments => #{requested => boolean(), _ := json:value()},
            afterpay_clearpay_payments => #{requested => boolean(), _ := json:value()},
            acss_debit_payments => #{requested => boolean(), _ := json:value()},
            _ := json:value()},
      business_type => company | government_entity | individual | non_profit,
      business_profile =>
          #{url => binary(),
            support_url => binary() | '',
            support_phone => binary(),
            support_email => binary(),
            support_address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            product_description => binary(),
            name => binary(),
            mcc => binary(),
            _ := json:value()},
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_type => checking | futsu | savings | toza,
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary(),
      account_token => binary()}.
-type post_accounts_response() :: stripe_model:error() | stripe_model:account().
-type get_accounts_request() ::
    #{query => get_accounts_request_query(),
      header => get_accounts_request_header(),
      cookie => get_accounts_request_cookie(),
      body => {binary(), get_accounts_request_body()}}.
-type get_accounts_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_accounts_request_header() :: map().
-type get_accounts_request_cookie() :: map().
-type get_accounts_request_body() :: #{}.
-type get_accounts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:account()],
      _ := json:value()}.
-type post_identity_verification_sessions_session_cancel_request() ::
    #{session := binary(),
      query => post_identity_verification_sessions_session_cancel_request_query(),
      header => post_identity_verification_sessions_session_cancel_request_header(),
      cookie => post_identity_verification_sessions_session_cancel_request_cookie(),
      body => {binary(), post_identity_verification_sessions_session_cancel_request_body()}}.
-type post_identity_verification_sessions_session_cancel_request_query() :: map().
-type post_identity_verification_sessions_session_cancel_request_header() :: map().
-type post_identity_verification_sessions_session_cancel_request_cookie() :: map().
-type post_identity_verification_sessions_session_cancel_request_body() ::
    #{expand => [binary()]}.
-type post_identity_verification_sessions_session_cancel_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type delete_account_persons_person_request() ::
    #{person := binary(),
      query => delete_account_persons_person_request_query(),
      header => delete_account_persons_person_request_header(),
      cookie => delete_account_persons_person_request_cookie(),
      body => {binary(), delete_account_persons_person_request_body()}}.
-type delete_account_persons_person_request_query() :: map().
-type delete_account_persons_person_request_header() :: map().
-type delete_account_persons_person_request_cookie() :: map().
-type delete_account_persons_person_request_body() :: #{}.
-type delete_account_persons_person_response() ::
    stripe_model:error() | stripe_model:deleted_person().
-type post_account_persons_person_request() ::
    #{person := binary(),
      query => post_account_persons_person_request_query(),
      header => post_account_persons_person_request_header(),
      cookie => post_account_persons_person_request_cookie(),
      body => {binary(), post_account_persons_person_request_body()}}.
-type post_account_persons_person_request_query() :: map().
-type post_account_persons_person_request_header() :: map().
-type post_account_persons_person_request_cookie() :: map().
-type post_account_persons_person_request_body() ::
    #{verification =>
          #{document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            additional_document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            _ := json:value()},
      ssn_last_4 => binary(),
      relationship =>
          #{title => binary(),
            representative => boolean(),
            percent_ownership => number() | '',
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      political_exposure => binary(),
      phone => binary(),
      person_token => binary(),
      nationality => binary(),
      metadata => json:value() | '',
      maiden_name => binary(),
      last_name_kanji => binary(),
      last_name_kana => binary(),
      last_name => binary(),
      id_number => binary(),
      gender => binary(),
      full_name_aliases => [binary()] | '',
      first_name_kanji => binary(),
      first_name_kana => binary(),
      first_name => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{visa => #{files => [binary()], _ := json:value()},
            passport => #{files => [binary()], _ := json:value()},
            company_authorization => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      dob =>
          #{year := integer(),
            month := integer(),
            day := integer(),
            _ := json:value()} |
          '',
      address_kanji =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address_kana =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      account => binary()}.
-type post_account_persons_person_response() ::
    stripe_model:error() | stripe_model:person().
-type get_account_persons_person_request() ::
    #{person := binary(),
      query => get_account_persons_person_request_query(),
      header => get_account_persons_person_request_header(),
      cookie => get_account_persons_person_request_cookie(),
      body => {binary(), get_account_persons_person_request_body()}}.
-type get_account_persons_person_request_query() :: #{expand => [binary()]}.
-type get_account_persons_person_request_header() :: map().
-type get_account_persons_person_request_cookie() :: map().
-type get_account_persons_person_request_body() :: #{}.
-type get_account_persons_person_response() ::
    stripe_model:error() | stripe_model:person().
-type post_issuing_authorizations_authorization_request() ::
    #{authorization := binary(),
      query => post_issuing_authorizations_authorization_request_query(),
      header => post_issuing_authorizations_authorization_request_header(),
      cookie => post_issuing_authorizations_authorization_request_cookie(),
      body => {binary(), post_issuing_authorizations_authorization_request_body()}}.
-type post_issuing_authorizations_authorization_request_query() :: map().
-type post_issuing_authorizations_authorization_request_header() :: map().
-type post_issuing_authorizations_authorization_request_cookie() :: map().
-type post_issuing_authorizations_authorization_request_body() ::
    #{metadata => json:value() | '', expand => [binary()]}.
-type post_issuing_authorizations_authorization_response() ::
    stripe_model:error() | stripe_model:issuing_authorization().
-type get_issuing_authorizations_authorization_request() ::
    #{authorization := binary(),
      query => get_issuing_authorizations_authorization_request_query(),
      header => get_issuing_authorizations_authorization_request_header(),
      cookie => get_issuing_authorizations_authorization_request_cookie(),
      body => {binary(), get_issuing_authorizations_authorization_request_body()}}.
-type get_issuing_authorizations_authorization_request_query() :: #{expand => [binary()]}.
-type get_issuing_authorizations_authorization_request_header() :: map().
-type get_issuing_authorizations_authorization_request_cookie() :: map().
-type get_issuing_authorizations_authorization_request_body() :: #{}.
-type get_issuing_authorizations_authorization_response() ::
    stripe_model:error() | stripe_model:issuing_authorization().
-type get_files_file_request() ::
    #{file := binary(),
      query => get_files_file_request_query(),
      header => get_files_file_request_header(),
      cookie => get_files_file_request_cookie(),
      body => {binary(), get_files_file_request_body()}}.
-type get_files_file_request_query() :: #{expand => [binary()]}.
-type get_files_file_request_header() :: map().
-type get_files_file_request_cookie() :: map().
-type get_files_file_request_body() :: #{}.
-type get_files_file_response() :: stripe_model:error() | stripe_model:file().
-type post_issuing_cards_card_request() ::
    #{card := binary(),
      query => post_issuing_cards_card_request_query(),
      header => post_issuing_cards_card_request_header(),
      cookie => post_issuing_cards_card_request_cookie(),
      body => {binary(), post_issuing_cards_card_request_body()}}.
-type post_issuing_cards_card_request_query() :: map().
-type post_issuing_cards_card_request_header() :: map().
-type post_issuing_cards_card_request_cookie() :: map().
-type post_issuing_cards_card_request_body() ::
    #{status => active | canceled | inactive,
      spending_controls =>
          #{spending_limits =>
                [#{interval := all_time | daily | monthly | per_authorization | weekly | yearly,
                   categories =>
                       [ac_refrigeration_repair | accounting_bookkeeping_services |
                        advertising_services | agricultural_cooperative | airlines_air_carriers |
                        airports_flying_fields | ambulance_services | amusement_parks_carnivals |
                        antique_reproductions | antique_shops | aquariums |
                        architectural_surveying_services | art_dealers_and_galleries |
                        artists_supply_and_craft_shops | auto_and_home_supply_stores |
                        auto_body_repair_shops | auto_paint_shops | auto_service_shops |
                        automated_cash_disburse | automated_fuel_dispensers |
                        automobile_associations | automotive_parts_and_accessories_stores |
                        automotive_tire_stores | bail_and_bond_payments | bakeries |
                        bands_orchestras | barber_and_beauty_shops | betting_casino_gambling |
                        bicycle_shops | billiard_pool_establishments | boat_dealers |
                        boat_rentals_and_leases | book_stores | books_periodicals_and_newspapers |
                        bowling_alleys | bus_lines | business_secretarial_schools |
                        buying_shopping_services |
                        cable_satellite_and_other_pay_television_and_radio |
                        camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                        car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                        car_rental_agencies | car_washes | carpentry_services |
                        carpet_upholstery_cleaning | caterers |
                        charitable_and_social_service_organizations_fundraising |
                        chemicals_and_allied_products | child_care_services |
                        childrens_and_infants_wear_stores | chiropodists_podiatrists |
                        chiropractors | cigar_stores_and_stands |
                        civic_social_fraternal_associations | cleaning_and_maintenance |
                        clothing_rental | colleges_universities | commercial_equipment |
                        commercial_footwear | commercial_photography_art_and_graphics |
                        commuter_transport_and_ferries | computer_network_services |
                        computer_programming | computer_repair | computer_software_stores |
                        computers_peripherals_and_software | concrete_work_services |
                        construction_materials | consulting_public_relations |
                        correspondence_schools | cosmetic_stores | counseling_services |
                        country_clubs | courier_services | court_costs | credit_reporting_agencies |
                        cruise_lines | dairy_products_stores | dance_hall_studios_schools |
                        dating_escort_services | dentists_orthodontists | department_stores |
                        detective_agencies | digital_goods_applications | digital_goods_games |
                        digital_goods_large_volume | digital_goods_media |
                        direct_marketing_catalog_merchant |
                        direct_marketing_combination_catalog_and_retail_merchant |
                        direct_marketing_inbound_telemarketing |
                        direct_marketing_insurance_services | direct_marketing_other |
                        direct_marketing_outbound_telemarketing | direct_marketing_subscription |
                        direct_marketing_travel | discount_stores | doctors | door_to_door_sales |
                        drapery_window_covering_and_upholstery_stores | drinking_places |
                        drug_stores_and_pharmacies |
                        drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners |
                        durable_goods | duty_free_stores | eating_places_restaurants |
                        educational_services | electric_razor_stores |
                        electrical_parts_and_equipment | electrical_services |
                        electronics_repair_shops | electronics_stores |
                        elementary_secondary_schools | employment_temp_agencies | equipment_rental |
                        exterminating_services | family_clothing_stores | fast_food_restaurants |
                        financial_institutions | fines_government_administrative_entities |
                        fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                        florists | florists_supplies_nursery_stock_and_flowers |
                        freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                        funeral_services_crematories |
                        furniture_home_furnishings_and_equipment_stores_except_appliances |
                        furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                        gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                        glassware_crystal_stores | golf_courses_public | government_services |
                        grocery_stores_supermarkets | hardware_equipment_and_supplies |
                        hardware_stores | health_and_beauty_spas | hearing_aids_sales_and_supplies |
                        heating_plumbing_a_c | hobby_toy_and_game_shops |
                        home_supply_warehouse_stores | hospitals | hotels_motels_and_resorts |
                        household_appliance_stores | industrial_supplies |
                        information_retrieval_services | insurance_default |
                        insurance_underwriting_premiums | intra_company_purchases |
                        jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                        laundries | laundry_cleaning_services | legal_services_attorneys |
                        luggage_and_leather_goods_stores | lumber_building_materials_stores |
                        manual_cash_disburse | marinas_service_and_supplies |
                        masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                        medical_dental_ophthalmic_and_hospital_equipment_and_supplies |
                        medical_services | membership_organizations |
                        mens_and_boys_clothing_and_accessories_stores |
                        mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                        miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                        miscellaneous_business_services | miscellaneous_food_stores |
                        miscellaneous_general_merchandise | miscellaneous_general_services |
                        miscellaneous_home_furnishing_specialty_stores |
                        miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                        miscellaneous_repair_shops | miscellaneous_specialty_retail |
                        mobile_home_dealers | motion_picture_theaters |
                        motor_freight_carriers_and_trucking | motor_homes_dealers |
                        motor_vehicle_supplies_and_new_parts | motorcycle_shops_and_dealers |
                        motorcycle_shops_dealers |
                        music_stores_musical_instruments_pianos_and_sheet_music |
                        news_dealers_and_newsstands | non_fi_money_orders |
                        non_fi_stored_value_card_purchase_load | nondurable_goods |
                        nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                        office_and_commercial_furniture | opticians_eyeglasses |
                        optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices |
                        osteopaths | package_stores_beer_wine_and_liquor |
                        paints_varnishes_and_supplies | parking_lots_garages | passenger_railways |
                        pawn_shops | pet_shops_pet_food_and_supplies |
                        petroleum_and_petroleum_products | photo_developing |
                        photographic_photocopy_microfilm_equipment_and_supplies |
                        photographic_studios | picture_video_production |
                        piece_goods_notions_and_other_dry_goods |
                        plumbing_heating_equipment_and_supplies | political_organizations |
                        postal_services_government_only |
                        precious_stones_and_metals_watches_and_jewelry | professional_services |
                        public_warehousing_and_storage | quick_copy_repro_and_blueprint |
                        railroads | real_estate_agents_and_managers_rentals | record_stores |
                        recreational_vehicle_rentals | religious_goods_stores |
                        religious_organizations | roofing_siding_sheet_metal |
                        secretarial_support_services | security_brokers_dealers | service_stations |
                        sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                        shoe_stores | small_appliance_repair | snowmobile_dealers |
                        special_trade_services | specialty_cleaning | sporting_goods_stores |
                        sporting_recreation_camps | sports_and_riding_apparel_stores |
                        sports_clubs_fields | stamp_and_coin_stores |
                        stationary_office_supplies_printing_and_writing_paper |
                        stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                        t_ui_travel_germany | tailors_alterations |
                        tax_payments_government_agencies | tax_preparation_services |
                        taxicabs_limousines | telecommunication_equipment_and_telephone_sales |
                        telecommunication_services | telegraph_services | tent_and_awning_shops |
                        testing_laboratories | theatrical_ticket_agencies | timeshares |
                        tire_retreading_and_repair | tolls_bridge_fees |
                        tourist_attractions_and_exhibits | towing_services |
                        trailer_parks_campgrounds | transportation_services |
                        travel_agencies_tour_operators | truck_stop_iteration |
                        truck_utility_trailer_rentals |
                        typesetting_plate_making_and_related_services | typewriter_stores |
                        u_s_federal_government_agencies_or_departments |
                        uniforms_commercial_clothing | used_merchandise_and_secondhand_stores |
                        utilities | variety_stores | veterinary_services |
                        video_amusement_game_supplies | video_game_arcades |
                        video_tape_rental_stores | vocational_trade_schools | watch_jewelry_repair |
                        welding_repair | wholesale_clubs | wig_and_toupee_stores |
                        wires_money_orders | womens_accessory_and_specialty_shops |
                        womens_ready_to_wear_stores | wrecking_and_salvage_yards],
                   amount := integer(),
                   _ := json:value()}],
            blocked_categories =>
                [ac_refrigeration_repair | accounting_bookkeeping_services | advertising_services |
                 agricultural_cooperative | airlines_air_carriers | airports_flying_fields |
                 ambulance_services | amusement_parks_carnivals | antique_reproductions |
                 antique_shops | aquariums | architectural_surveying_services |
                 art_dealers_and_galleries | artists_supply_and_craft_shops |
                 auto_and_home_supply_stores | auto_body_repair_shops | auto_paint_shops |
                 auto_service_shops | automated_cash_disburse | automated_fuel_dispensers |
                 automobile_associations | automotive_parts_and_accessories_stores |
                 automotive_tire_stores | bail_and_bond_payments | bakeries | bands_orchestras |
                 barber_and_beauty_shops | betting_casino_gambling | bicycle_shops |
                 billiard_pool_establishments | boat_dealers | boat_rentals_and_leases |
                 book_stores | books_periodicals_and_newspapers | bowling_alleys | bus_lines |
                 business_secretarial_schools | buying_shopping_services |
                 cable_satellite_and_other_pay_television_and_radio |
                 camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                 car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                 car_rental_agencies | car_washes | carpentry_services |
                 carpet_upholstery_cleaning | caterers |
                 charitable_and_social_service_organizations_fundraising |
                 chemicals_and_allied_products | child_care_services |
                 childrens_and_infants_wear_stores | chiropodists_podiatrists | chiropractors |
                 cigar_stores_and_stands | civic_social_fraternal_associations |
                 cleaning_and_maintenance | clothing_rental | colleges_universities |
                 commercial_equipment | commercial_footwear |
                 commercial_photography_art_and_graphics | commuter_transport_and_ferries |
                 computer_network_services | computer_programming | computer_repair |
                 computer_software_stores | computers_peripherals_and_software |
                 concrete_work_services | construction_materials | consulting_public_relations |
                 correspondence_schools | cosmetic_stores | counseling_services | country_clubs |
                 courier_services | court_costs | credit_reporting_agencies | cruise_lines |
                 dairy_products_stores | dance_hall_studios_schools | dating_escort_services |
                 dentists_orthodontists | department_stores | detective_agencies |
                 digital_goods_applications | digital_goods_games | digital_goods_large_volume |
                 digital_goods_media | direct_marketing_catalog_merchant |
                 direct_marketing_combination_catalog_and_retail_merchant |
                 direct_marketing_inbound_telemarketing | direct_marketing_insurance_services |
                 direct_marketing_other | direct_marketing_outbound_telemarketing |
                 direct_marketing_subscription | direct_marketing_travel | discount_stores |
                 doctors | door_to_door_sales | drapery_window_covering_and_upholstery_stores |
                 drinking_places | drug_stores_and_pharmacies |
                 drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners | durable_goods |
                 duty_free_stores | eating_places_restaurants | educational_services |
                 electric_razor_stores | electrical_parts_and_equipment | electrical_services |
                 electronics_repair_shops | electronics_stores | elementary_secondary_schools |
                 employment_temp_agencies | equipment_rental | exterminating_services |
                 family_clothing_stores | fast_food_restaurants | financial_institutions |
                 fines_government_administrative_entities |
                 fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                 florists | florists_supplies_nursery_stock_and_flowers |
                 freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                 funeral_services_crematories |
                 furniture_home_furnishings_and_equipment_stores_except_appliances |
                 furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                 gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                 glassware_crystal_stores | golf_courses_public | government_services |
                 grocery_stores_supermarkets | hardware_equipment_and_supplies | hardware_stores |
                 health_and_beauty_spas | hearing_aids_sales_and_supplies | heating_plumbing_a_c |
                 hobby_toy_and_game_shops | home_supply_warehouse_stores | hospitals |
                 hotels_motels_and_resorts | household_appliance_stores | industrial_supplies |
                 information_retrieval_services | insurance_default |
                 insurance_underwriting_premiums | intra_company_purchases |
                 jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                 laundries | laundry_cleaning_services | legal_services_attorneys |
                 luggage_and_leather_goods_stores | lumber_building_materials_stores |
                 manual_cash_disburse | marinas_service_and_supplies |
                 masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                 medical_dental_ophthalmic_and_hospital_equipment_and_supplies | medical_services |
                 membership_organizations | mens_and_boys_clothing_and_accessories_stores |
                 mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                 miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                 miscellaneous_business_services | miscellaneous_food_stores |
                 miscellaneous_general_merchandise | miscellaneous_general_services |
                 miscellaneous_home_furnishing_specialty_stores |
                 miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                 miscellaneous_repair_shops | miscellaneous_specialty_retail | mobile_home_dealers |
                 motion_picture_theaters | motor_freight_carriers_and_trucking |
                 motor_homes_dealers | motor_vehicle_supplies_and_new_parts |
                 motorcycle_shops_and_dealers | motorcycle_shops_dealers |
                 music_stores_musical_instruments_pianos_and_sheet_music |
                 news_dealers_and_newsstands | non_fi_money_orders |
                 non_fi_stored_value_card_purchase_load | nondurable_goods |
                 nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                 office_and_commercial_furniture | opticians_eyeglasses |
                 optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices | osteopaths |
                 package_stores_beer_wine_and_liquor | paints_varnishes_and_supplies |
                 parking_lots_garages | passenger_railways | pawn_shops |
                 pet_shops_pet_food_and_supplies | petroleum_and_petroleum_products |
                 photo_developing | photographic_photocopy_microfilm_equipment_and_supplies |
                 photographic_studios | picture_video_production |
                 piece_goods_notions_and_other_dry_goods | plumbing_heating_equipment_and_supplies |
                 political_organizations | postal_services_government_only |
                 precious_stones_and_metals_watches_and_jewelry | professional_services |
                 public_warehousing_and_storage | quick_copy_repro_and_blueprint | railroads |
                 real_estate_agents_and_managers_rentals | record_stores |
                 recreational_vehicle_rentals | religious_goods_stores | religious_organizations |
                 roofing_siding_sheet_metal | secretarial_support_services |
                 security_brokers_dealers | service_stations |
                 sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                 shoe_stores | small_appliance_repair | snowmobile_dealers |
                 special_trade_services | specialty_cleaning | sporting_goods_stores |
                 sporting_recreation_camps | sports_and_riding_apparel_stores |
                 sports_clubs_fields | stamp_and_coin_stores |
                 stationary_office_supplies_printing_and_writing_paper |
                 stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                 t_ui_travel_germany | tailors_alterations | tax_payments_government_agencies |
                 tax_preparation_services | taxicabs_limousines |
                 telecommunication_equipment_and_telephone_sales | telecommunication_services |
                 telegraph_services | tent_and_awning_shops | testing_laboratories |
                 theatrical_ticket_agencies | timeshares | tire_retreading_and_repair |
                 tolls_bridge_fees | tourist_attractions_and_exhibits | towing_services |
                 trailer_parks_campgrounds | transportation_services |
                 travel_agencies_tour_operators | truck_stop_iteration |
                 truck_utility_trailer_rentals | typesetting_plate_making_and_related_services |
                 typewriter_stores | u_s_federal_government_agencies_or_departments |
                 uniforms_commercial_clothing | used_merchandise_and_secondhand_stores | utilities |
                 variety_stores | veterinary_services | video_amusement_game_supplies |
                 video_game_arcades | video_tape_rental_stores | vocational_trade_schools |
                 watch_jewelry_repair | welding_repair | wholesale_clubs | wig_and_toupee_stores |
                 wires_money_orders | womens_accessory_and_specialty_shops |
                 womens_ready_to_wear_stores | wrecking_and_salvage_yards],
            allowed_categories =>
                [ac_refrigeration_repair | accounting_bookkeeping_services | advertising_services |
                 agricultural_cooperative | airlines_air_carriers | airports_flying_fields |
                 ambulance_services | amusement_parks_carnivals | antique_reproductions |
                 antique_shops | aquariums | architectural_surveying_services |
                 art_dealers_and_galleries | artists_supply_and_craft_shops |
                 auto_and_home_supply_stores | auto_body_repair_shops | auto_paint_shops |
                 auto_service_shops | automated_cash_disburse | automated_fuel_dispensers |
                 automobile_associations | automotive_parts_and_accessories_stores |
                 automotive_tire_stores | bail_and_bond_payments | bakeries | bands_orchestras |
                 barber_and_beauty_shops | betting_casino_gambling | bicycle_shops |
                 billiard_pool_establishments | boat_dealers | boat_rentals_and_leases |
                 book_stores | books_periodicals_and_newspapers | bowling_alleys | bus_lines |
                 business_secretarial_schools | buying_shopping_services |
                 cable_satellite_and_other_pay_television_and_radio |
                 camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                 car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                 car_rental_agencies | car_washes | carpentry_services |
                 carpet_upholstery_cleaning | caterers |
                 charitable_and_social_service_organizations_fundraising |
                 chemicals_and_allied_products | child_care_services |
                 childrens_and_infants_wear_stores | chiropodists_podiatrists | chiropractors |
                 cigar_stores_and_stands | civic_social_fraternal_associations |
                 cleaning_and_maintenance | clothing_rental | colleges_universities |
                 commercial_equipment | commercial_footwear |
                 commercial_photography_art_and_graphics | commuter_transport_and_ferries |
                 computer_network_services | computer_programming | computer_repair |
                 computer_software_stores | computers_peripherals_and_software |
                 concrete_work_services | construction_materials | consulting_public_relations |
                 correspondence_schools | cosmetic_stores | counseling_services | country_clubs |
                 courier_services | court_costs | credit_reporting_agencies | cruise_lines |
                 dairy_products_stores | dance_hall_studios_schools | dating_escort_services |
                 dentists_orthodontists | department_stores | detective_agencies |
                 digital_goods_applications | digital_goods_games | digital_goods_large_volume |
                 digital_goods_media | direct_marketing_catalog_merchant |
                 direct_marketing_combination_catalog_and_retail_merchant |
                 direct_marketing_inbound_telemarketing | direct_marketing_insurance_services |
                 direct_marketing_other | direct_marketing_outbound_telemarketing |
                 direct_marketing_subscription | direct_marketing_travel | discount_stores |
                 doctors | door_to_door_sales | drapery_window_covering_and_upholstery_stores |
                 drinking_places | drug_stores_and_pharmacies |
                 drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners | durable_goods |
                 duty_free_stores | eating_places_restaurants | educational_services |
                 electric_razor_stores | electrical_parts_and_equipment | electrical_services |
                 electronics_repair_shops | electronics_stores | elementary_secondary_schools |
                 employment_temp_agencies | equipment_rental | exterminating_services |
                 family_clothing_stores | fast_food_restaurants | financial_institutions |
                 fines_government_administrative_entities |
                 fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                 florists | florists_supplies_nursery_stock_and_flowers |
                 freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                 funeral_services_crematories |
                 furniture_home_furnishings_and_equipment_stores_except_appliances |
                 furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                 gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                 glassware_crystal_stores | golf_courses_public | government_services |
                 grocery_stores_supermarkets | hardware_equipment_and_supplies | hardware_stores |
                 health_and_beauty_spas | hearing_aids_sales_and_supplies | heating_plumbing_a_c |
                 hobby_toy_and_game_shops | home_supply_warehouse_stores | hospitals |
                 hotels_motels_and_resorts | household_appliance_stores | industrial_supplies |
                 information_retrieval_services | insurance_default |
                 insurance_underwriting_premiums | intra_company_purchases |
                 jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                 laundries | laundry_cleaning_services | legal_services_attorneys |
                 luggage_and_leather_goods_stores | lumber_building_materials_stores |
                 manual_cash_disburse | marinas_service_and_supplies |
                 masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                 medical_dental_ophthalmic_and_hospital_equipment_and_supplies | medical_services |
                 membership_organizations | mens_and_boys_clothing_and_accessories_stores |
                 mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                 miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                 miscellaneous_business_services | miscellaneous_food_stores |
                 miscellaneous_general_merchandise | miscellaneous_general_services |
                 miscellaneous_home_furnishing_specialty_stores |
                 miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                 miscellaneous_repair_shops | miscellaneous_specialty_retail | mobile_home_dealers |
                 motion_picture_theaters | motor_freight_carriers_and_trucking |
                 motor_homes_dealers | motor_vehicle_supplies_and_new_parts |
                 motorcycle_shops_and_dealers | motorcycle_shops_dealers |
                 music_stores_musical_instruments_pianos_and_sheet_music |
                 news_dealers_and_newsstands | non_fi_money_orders |
                 non_fi_stored_value_card_purchase_load | nondurable_goods |
                 nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                 office_and_commercial_furniture | opticians_eyeglasses |
                 optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices | osteopaths |
                 package_stores_beer_wine_and_liquor | paints_varnishes_and_supplies |
                 parking_lots_garages | passenger_railways | pawn_shops |
                 pet_shops_pet_food_and_supplies | petroleum_and_petroleum_products |
                 photo_developing | photographic_photocopy_microfilm_equipment_and_supplies |
                 photographic_studios | picture_video_production |
                 piece_goods_notions_and_other_dry_goods | plumbing_heating_equipment_and_supplies |
                 political_organizations | postal_services_government_only |
                 precious_stones_and_metals_watches_and_jewelry | professional_services |
                 public_warehousing_and_storage | quick_copy_repro_and_blueprint | railroads |
                 real_estate_agents_and_managers_rentals | record_stores |
                 recreational_vehicle_rentals | religious_goods_stores | religious_organizations |
                 roofing_siding_sheet_metal | secretarial_support_services |
                 security_brokers_dealers | service_stations |
                 sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                 shoe_stores | small_appliance_repair | snowmobile_dealers |
                 special_trade_services | specialty_cleaning | sporting_goods_stores |
                 sporting_recreation_camps | sports_and_riding_apparel_stores |
                 sports_clubs_fields | stamp_and_coin_stores |
                 stationary_office_supplies_printing_and_writing_paper |
                 stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                 t_ui_travel_germany | tailors_alterations | tax_payments_government_agencies |
                 tax_preparation_services | taxicabs_limousines |
                 telecommunication_equipment_and_telephone_sales | telecommunication_services |
                 telegraph_services | tent_and_awning_shops | testing_laboratories |
                 theatrical_ticket_agencies | timeshares | tire_retreading_and_repair |
                 tolls_bridge_fees | tourist_attractions_and_exhibits | towing_services |
                 trailer_parks_campgrounds | transportation_services |
                 travel_agencies_tour_operators | truck_stop_iteration |
                 truck_utility_trailer_rentals | typesetting_plate_making_and_related_services |
                 typewriter_stores | u_s_federal_government_agencies_or_departments |
                 uniforms_commercial_clothing | used_merchandise_and_secondhand_stores | utilities |
                 variety_stores | veterinary_services | video_amusement_game_supplies |
                 video_game_arcades | video_tape_rental_stores | vocational_trade_schools |
                 watch_jewelry_repair | welding_repair | wholesale_clubs | wig_and_toupee_stores |
                 wires_money_orders | womens_accessory_and_specialty_shops |
                 womens_ready_to_wear_stores | wrecking_and_salvage_yards],
            _ := json:value()},
      pin => #{encrypted_number => binary(), _ := json:value()},
      metadata => json:value() | '',
      expand => [binary()],
      cancellation_reason => lost | stolen}.
-type post_issuing_cards_card_response() ::
    stripe_model:error() | stripe_model:issuing_card().
-type get_issuing_cards_card_request() ::
    #{card := binary(),
      query => get_issuing_cards_card_request_query(),
      header => get_issuing_cards_card_request_header(),
      cookie => get_issuing_cards_card_request_cookie(),
      body => {binary(), get_issuing_cards_card_request_body()}}.
-type get_issuing_cards_card_request_query() :: #{expand => [binary()]}.
-type get_issuing_cards_card_request_header() :: map().
-type get_issuing_cards_card_request_cookie() :: map().
-type get_issuing_cards_card_request_body() :: #{}.
-type get_issuing_cards_card_response() ::
    stripe_model:error() | stripe_model:issuing_card().
-type post_sources_source_verify_request() ::
    #{source := binary(),
      query => post_sources_source_verify_request_query(),
      header => post_sources_source_verify_request_header(),
      cookie => post_sources_source_verify_request_cookie(),
      body := {binary(), post_sources_source_verify_request_body()}}.
-type post_sources_source_verify_request_query() :: map().
-type post_sources_source_verify_request_header() :: map().
-type post_sources_source_verify_request_cookie() :: map().
-type post_sources_source_verify_request_body() ::
    #{values := [binary()], expand => [binary()]}.
-type post_sources_source_verify_response() ::
    stripe_model:error() | stripe_model:source().
-type post_invoiceitems_request() ::
    #{query => post_invoiceitems_request_query(),
      header => post_invoiceitems_request_header(),
      cookie => post_invoiceitems_request_cookie(),
      body := {binary(), post_invoiceitems_request_body()}}.
-type post_invoiceitems_request_query() :: map().
-type post_invoiceitems_request_header() :: map().
-type post_invoiceitems_request_cookie() :: map().
-type post_invoiceitems_request_body() ::
    #{unit_amount_decimal => binary(),
      unit_amount => integer(),
      tax_rates => [binary()],
      subscription => binary(),
      quantity => integer(),
      price_data =>
          #{unit_amount_decimal => binary(),
            unit_amount => integer(),
            tax_behavior => exclusive | inclusive | unspecified,
            product := binary(),
            currency := binary(),
            _ := json:value()},
      price => binary(),
      period =>
          #{start := integer(),
            'end' := integer(),
            _ := json:value()},
      metadata => json:value() | '',
      invoice => binary(),
      expand => [binary()],
      discounts =>
          [#{discount => binary(),
             coupon => binary(),
             _ := json:value()}] |
          '',
      discountable => boolean(),
      description => binary(),
      customer := binary(),
      currency => binary(),
      amount => integer()}.
-type post_invoiceitems_response() :: stripe_model:error() | stripe_model:invoiceitem().
-type get_invoiceitems_request() ::
    #{query => get_invoiceitems_request_query(),
      header => get_invoiceitems_request_header(),
      cookie => get_invoiceitems_request_cookie(),
      body => {binary(), get_invoiceitems_request_body()}}.
-type get_invoiceitems_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      invoice => binary(),
      limit => integer(),
      pending => boolean(),
      starting_after => binary()}.
-type get_invoiceitems_request_header() :: map().
-type get_invoiceitems_request_cookie() :: map().
-type get_invoiceitems_request_body() :: #{}.
-type get_invoiceitems_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:invoiceitem()],
      _ := json:value()}.
-type delete_ephemeral_keys_key_request() ::
    #{key := binary(),
      query => delete_ephemeral_keys_key_request_query(),
      header => delete_ephemeral_keys_key_request_header(),
      cookie => delete_ephemeral_keys_key_request_cookie(),
      body => {binary(), delete_ephemeral_keys_key_request_body()}}.
-type delete_ephemeral_keys_key_request_query() :: map().
-type delete_ephemeral_keys_key_request_header() :: map().
-type delete_ephemeral_keys_key_request_cookie() :: map().
-type delete_ephemeral_keys_key_request_body() :: #{expand => [binary()]}.
-type delete_ephemeral_keys_key_response() ::
    stripe_model:error() | stripe_model:ephemeral_key().
-type get_exchange_rates_request() ::
    #{query => get_exchange_rates_request_query(),
      header => get_exchange_rates_request_header(),
      cookie => get_exchange_rates_request_cookie(),
      body => {binary(), get_exchange_rates_request_body()}}.
-type get_exchange_rates_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_exchange_rates_request_header() :: map().
-type get_exchange_rates_request_cookie() :: map().
-type get_exchange_rates_request_body() :: #{}.
-type get_exchange_rates_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:exchange_rate()],
      _ := json:value()}.
-type post_setup_intents_intent_request() ::
    #{intent := binary(),
      query => post_setup_intents_intent_request_query(),
      header => post_setup_intents_intent_request_header(),
      cookie => post_setup_intents_intent_request_cookie(),
      body => {binary(), post_setup_intents_intent_request_body()}}.
-type post_setup_intents_intent_request_query() :: map().
-type post_setup_intents_intent_request_header() :: map().
-type post_setup_intents_intent_request_cookie() :: map().
-type post_setup_intents_intent_request_body() ::
    #{payment_method_types => [binary()],
      payment_method_options =>
          #{sepa_debit => #{mandate_options => #{_ := json:value()}, _ := json:value()},
            card => #{request_three_d_secure => any | automatic, _ := json:value()},
            acss_debit =>
                #{verification_method => automatic | instant | microdeposits,
                  mandate_options =>
                      #{transaction_type => business | personal,
                        payment_schedule => combined | interval | sporadic,
                        interval_description => binary(),
                        default_for => [invoice | subscription],
                        custom_mandate_url => binary() | '',
                        _ := json:value()},
                  currency => cad | usd,
                  _ := json:value()},
            _ := json:value()},
      payment_method => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      description => binary(),
      customer => binary()}.
-type post_setup_intents_intent_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type get_setup_intents_intent_request() ::
    #{intent := binary(),
      query => get_setup_intents_intent_request_query(),
      header => get_setup_intents_intent_request_header(),
      cookie => get_setup_intents_intent_request_cookie(),
      body => {binary(), get_setup_intents_intent_request_body()}}.
-type get_setup_intents_intent_request_query() ::
    #{client_secret => binary(), expand => [binary()]}.
-type get_setup_intents_intent_request_header() :: map().
-type get_setup_intents_intent_request_cookie() :: map().
-type get_setup_intents_intent_request_body() :: #{}.
-type get_setup_intents_intent_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type post_files_request() ::
    #{query => post_files_request_query(),
      header => post_files_request_header(),
      cookie => post_files_request_cookie(),
      body := {binary(), post_files_request_body()}}.
-type post_files_request_query() :: map().
-type post_files_request_header() :: map().
-type post_files_request_cookie() :: map().
-type post_files_request_body() ::
    #{purpose :=
          account_requirement |
          additional_verification |
          business_icon |
          business_logo |
          customer_signature |
          dispute_evidence |
          identity_document |
          pci_document |
          tax_document_user_upload,
      file_link_data =>
          #{metadata => json:value() | '',
            expires_at => integer(),
            create := boolean(),
            _ := json:value()},
      file := binary(),
      expand => [binary()]}.
-type post_files_response() :: stripe_model:error() | stripe_model:file().
-type get_files_request() ::
    #{query => get_files_request_query(),
      header => get_files_request_header(),
      cookie => get_files_request_cookie(),
      body => {binary(), get_files_request_body()}}.
-type get_files_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      purpose =>
          account_requirement |
          additional_verification |
          business_icon |
          business_logo |
          customer_signature |
          dispute_evidence |
          document_provider_identity_document |
          finance_report_run |
          identity_document |
          identity_document_downloadable |
          pci_document |
          selfie |
          sigma_scheduled_query |
          tax_document_user_upload,
      starting_after => binary()}.
-type get_files_request_header() :: map().
-type get_files_request_cookie() :: map().
-type get_files_request_body() :: #{}.
-type get_files_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:file()],
      _ := json:value()}.
-type delete_customers_customer_bank_accounts_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => delete_customers_customer_bank_accounts_id_request_query(),
      header => delete_customers_customer_bank_accounts_id_request_header(),
      cookie => delete_customers_customer_bank_accounts_id_request_cookie(),
      body => {binary(), delete_customers_customer_bank_accounts_id_request_body()}}.
-type delete_customers_customer_bank_accounts_id_request_query() :: map().
-type delete_customers_customer_bank_accounts_id_request_header() :: map().
-type delete_customers_customer_bank_accounts_id_request_cookie() :: map().
-type delete_customers_customer_bank_accounts_id_request_body() ::
    #{expand => [binary()]}.
-type delete_customers_customer_bank_accounts_id_response() ::
    stripe_model:error() |
    stripe_model:payment_source() |
    stripe_model:deleted_payment_source().
-type post_customers_customer_bank_accounts_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_bank_accounts_id_request_query(),
      header => post_customers_customer_bank_accounts_id_request_header(),
      cookie => post_customers_customer_bank_accounts_id_request_cookie(),
      body => {binary(), post_customers_customer_bank_accounts_id_request_body()}}.
-type post_customers_customer_bank_accounts_id_request_query() :: map().
-type post_customers_customer_bank_accounts_id_request_header() :: map().
-type post_customers_customer_bank_accounts_id_request_cookie() :: map().
-type post_customers_customer_bank_accounts_id_request_body() ::
    #{owner =>
          #{phone => binary(),
            name => binary(),
            email => binary(),
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      name => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      exp_year => binary(),
      exp_month => binary(),
      address_zip => binary(),
      address_state => binary(),
      address_line2 => binary(),
      address_line1 => binary(),
      address_country => binary(),
      address_city => binary(),
      account_holder_type => company | individual,
      account_holder_name => binary()}.
-type post_customers_customer_bank_accounts_id_response() ::
    stripe_model:error() |
    stripe_model:card() |
    stripe_model:bank_account() |
    stripe_model:source().
-type get_customers_customer_bank_accounts_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => get_customers_customer_bank_accounts_id_request_query(),
      header => get_customers_customer_bank_accounts_id_request_header(),
      cookie => get_customers_customer_bank_accounts_id_request_cookie(),
      body => {binary(), get_customers_customer_bank_accounts_id_request_body()}}.
-type get_customers_customer_bank_accounts_id_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_bank_accounts_id_request_header() :: map().
-type get_customers_customer_bank_accounts_id_request_cookie() :: map().
-type get_customers_customer_bank_accounts_id_request_body() :: #{}.
-type get_customers_customer_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:bank_account().
-type get_issuer_fraud_records_issuer_fraud_record_request() ::
    #{issuer_fraud_record := binary(),
      query => get_issuer_fraud_records_issuer_fraud_record_request_query(),
      header => get_issuer_fraud_records_issuer_fraud_record_request_header(),
      cookie => get_issuer_fraud_records_issuer_fraud_record_request_cookie(),
      body => {binary(), get_issuer_fraud_records_issuer_fraud_record_request_body()}}.
-type get_issuer_fraud_records_issuer_fraud_record_request_query() ::
    #{expand => [binary()]}.
-type get_issuer_fraud_records_issuer_fraud_record_request_header() :: map().
-type get_issuer_fraud_records_issuer_fraud_record_request_cookie() :: map().
-type get_issuer_fraud_records_issuer_fraud_record_request_body() :: #{}.
-type get_issuer_fraud_records_issuer_fraud_record_response() ::
    stripe_model:error() | stripe_model:issuer_fraud_record().
-type delete_accounts_account_people_person_request() ::
    #{account := binary(),
      person := binary(),
      query => delete_accounts_account_people_person_request_query(),
      header => delete_accounts_account_people_person_request_header(),
      cookie => delete_accounts_account_people_person_request_cookie(),
      body => {binary(), delete_accounts_account_people_person_request_body()}}.
-type delete_accounts_account_people_person_request_query() :: map().
-type delete_accounts_account_people_person_request_header() :: map().
-type delete_accounts_account_people_person_request_cookie() :: map().
-type delete_accounts_account_people_person_request_body() :: #{}.
-type delete_accounts_account_people_person_response() ::
    stripe_model:error() | stripe_model:deleted_person().
-type post_accounts_account_people_person_request() ::
    #{account := binary(),
      person := binary(),
      query => post_accounts_account_people_person_request_query(),
      header => post_accounts_account_people_person_request_header(),
      cookie => post_accounts_account_people_person_request_cookie(),
      body => {binary(), post_accounts_account_people_person_request_body()}}.
-type post_accounts_account_people_person_request_query() :: map().
-type post_accounts_account_people_person_request_header() :: map().
-type post_accounts_account_people_person_request_cookie() :: map().
-type post_accounts_account_people_person_request_body() ::
    #{verification =>
          #{document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            additional_document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            _ := json:value()},
      ssn_last_4 => binary(),
      relationship =>
          #{title => binary(),
            representative => boolean(),
            percent_ownership => number() | '',
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      political_exposure => binary(),
      phone => binary(),
      person_token => binary(),
      nationality => binary(),
      metadata => json:value() | '',
      maiden_name => binary(),
      last_name_kanji => binary(),
      last_name_kana => binary(),
      last_name => binary(),
      id_number => binary(),
      gender => binary(),
      full_name_aliases => [binary()] | '',
      first_name_kanji => binary(),
      first_name_kana => binary(),
      first_name => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{visa => #{files => [binary()], _ := json:value()},
            passport => #{files => [binary()], _ := json:value()},
            company_authorization => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      dob =>
          #{year := integer(),
            month := integer(),
            day := integer(),
            _ := json:value()} |
          '',
      address_kanji =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address_kana =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()}}.
-type post_accounts_account_people_person_response() ::
    stripe_model:error() | stripe_model:person().
-type get_accounts_account_people_person_request() ::
    #{account := binary(),
      person := binary(),
      query => get_accounts_account_people_person_request_query(),
      header => get_accounts_account_people_person_request_header(),
      cookie => get_accounts_account_people_person_request_cookie(),
      body => {binary(), get_accounts_account_people_person_request_body()}}.
-type get_accounts_account_people_person_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_people_person_request_header() :: map().
-type get_accounts_account_people_person_request_cookie() :: map().
-type get_accounts_account_people_person_request_body() :: #{}.
-type get_accounts_account_people_person_response() ::
    stripe_model:error() | stripe_model:person().
-type post_payouts_request() ::
    #{query => post_payouts_request_query(),
      header => post_payouts_request_header(),
      cookie => post_payouts_request_cookie(),
      body := {binary(), post_payouts_request_body()}}.
-type post_payouts_request_query() :: map().
-type post_payouts_request_header() :: map().
-type post_payouts_request_cookie() :: map().
-type post_payouts_request_body() ::
    #{statement_descriptor => binary(),
      source_type => bank_account | card | fpx,
      method => instant | standard,
      metadata => json:value(),
      expand => [binary()],
      destination => binary(),
      description => binary(),
      currency := binary(),
      amount := integer()}.
-type post_payouts_response() :: stripe_model:error() | stripe_model:payout().
-type get_payouts_request() ::
    #{query => get_payouts_request_query(),
      header => get_payouts_request_header(),
      cookie => get_payouts_request_cookie(),
      body => {binary(), get_payouts_request_body()}}.
-type get_payouts_request_query() ::
    #{arrival_date =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      destination => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => binary()}.
-type get_payouts_request_header() :: map().
-type get_payouts_request_cookie() :: map().
-type get_payouts_request_body() :: #{}.
-type get_payouts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payout()],
      _ := json:value()}.
-type post_account_capabilities_capability_request() ::
    #{capability := binary(),
      query => post_account_capabilities_capability_request_query(),
      header => post_account_capabilities_capability_request_header(),
      cookie => post_account_capabilities_capability_request_cookie(),
      body => {binary(), post_account_capabilities_capability_request_body()}}.
-type post_account_capabilities_capability_request_query() :: map().
-type post_account_capabilities_capability_request_header() :: map().
-type post_account_capabilities_capability_request_cookie() :: map().
-type post_account_capabilities_capability_request_body() ::
    #{requested => boolean(), expand => [binary()]}.
-type post_account_capabilities_capability_response() ::
    stripe_model:error() | stripe_model:capability().
-type get_account_capabilities_capability_request() ::
    #{capability := binary(),
      query => get_account_capabilities_capability_request_query(),
      header => get_account_capabilities_capability_request_header(),
      cookie => get_account_capabilities_capability_request_cookie(),
      body => {binary(), get_account_capabilities_capability_request_body()}}.
-type get_account_capabilities_capability_request_query() :: #{expand => [binary()]}.
-type get_account_capabilities_capability_request_header() :: map().
-type get_account_capabilities_capability_request_cookie() :: map().
-type get_account_capabilities_capability_request_body() :: #{}.
-type get_account_capabilities_capability_response() ::
    stripe_model:error() | stripe_model:capability().
-type get_sources_source_mandate_notifications_mandate_notification_request() ::
    #{mandate_notification := binary(),
      source := binary(),
      query => get_sources_source_mandate_notifications_mandate_notification_request_query(),
      header => get_sources_source_mandate_notifications_mandate_notification_request_header(),
      cookie => get_sources_source_mandate_notifications_mandate_notification_request_cookie(),
      body =>
          {binary(), get_sources_source_mandate_notifications_mandate_notification_request_body()}}.
-type get_sources_source_mandate_notifications_mandate_notification_request_query() ::
    #{expand => [binary()]}.
-type get_sources_source_mandate_notifications_mandate_notification_request_header() ::
    map().
-type get_sources_source_mandate_notifications_mandate_notification_request_cookie() ::
    map().
-type get_sources_source_mandate_notifications_mandate_notification_request_body() :: #{}.
-type get_sources_source_mandate_notifications_mandate_notification_response() ::
    stripe_model:error() | stripe_model:source_mandate_notification().
-type post_application_fees_fee_refunds_id_request() ::
    #{fee := binary(),
      id := binary(),
      query => post_application_fees_fee_refunds_id_request_query(),
      header => post_application_fees_fee_refunds_id_request_header(),
      cookie => post_application_fees_fee_refunds_id_request_cookie(),
      body => {binary(), post_application_fees_fee_refunds_id_request_body()}}.
-type post_application_fees_fee_refunds_id_request_query() :: map().
-type post_application_fees_fee_refunds_id_request_header() :: map().
-type post_application_fees_fee_refunds_id_request_cookie() :: map().
-type post_application_fees_fee_refunds_id_request_body() ::
    #{metadata => json:value() | '', expand => [binary()]}.
-type post_application_fees_fee_refunds_id_response() ::
    stripe_model:error() | stripe_model:fee_refund().
-type get_application_fees_fee_refunds_id_request() ::
    #{fee := binary(),
      id := binary(),
      query => get_application_fees_fee_refunds_id_request_query(),
      header => get_application_fees_fee_refunds_id_request_header(),
      cookie => get_application_fees_fee_refunds_id_request_cookie(),
      body => {binary(), get_application_fees_fee_refunds_id_request_body()}}.
-type get_application_fees_fee_refunds_id_request_query() :: #{expand => [binary()]}.
-type get_application_fees_fee_refunds_id_request_header() :: map().
-type get_application_fees_fee_refunds_id_request_cookie() :: map().
-type get_application_fees_fee_refunds_id_request_body() :: #{}.
-type get_application_fees_fee_refunds_id_response() ::
    stripe_model:error() | stripe_model:fee_refund().
-type delete_customers_customer_discount_request() ::
    #{customer := binary(),
      query => delete_customers_customer_discount_request_query(),
      header => delete_customers_customer_discount_request_header(),
      cookie => delete_customers_customer_discount_request_cookie(),
      body => {binary(), delete_customers_customer_discount_request_body()}}.
-type delete_customers_customer_discount_request_query() :: map().
-type delete_customers_customer_discount_request_header() :: map().
-type delete_customers_customer_discount_request_cookie() :: map().
-type delete_customers_customer_discount_request_body() :: #{}.
-type delete_customers_customer_discount_response() ::
    stripe_model:error() | stripe_model:deleted_discount().
-type get_customers_customer_discount_request() ::
    #{customer := binary(),
      query => get_customers_customer_discount_request_query(),
      header => get_customers_customer_discount_request_header(),
      cookie => get_customers_customer_discount_request_cookie(),
      body => {binary(), get_customers_customer_discount_request_body()}}.
-type get_customers_customer_discount_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_discount_request_header() :: map().
-type get_customers_customer_discount_request_cookie() :: map().
-type get_customers_customer_discount_request_body() :: #{}.
-type get_customers_customer_discount_response() ::
    stripe_model:error() | stripe_model:discount().
-type post_coupons_request() ::
    #{query => post_coupons_request_query(),
      header => post_coupons_request_header(),
      cookie => post_coupons_request_cookie(),
      body => {binary(), post_coupons_request_body()}}.
-type post_coupons_request_query() :: map().
-type post_coupons_request_header() :: map().
-type post_coupons_request_cookie() :: map().
-type post_coupons_request_body() ::
    #{redeem_by => integer(),
      percent_off => number(),
      name => binary(),
      metadata => json:value() | '',
      max_redemptions => integer(),
      id => binary(),
      expand => [binary()],
      duration_in_months => integer(),
      duration => forever | once | repeating,
      currency => binary(),
      applies_to => #{products => [binary()], _ := json:value()},
      amount_off => integer()}.
-type post_coupons_response() :: stripe_model:error() | stripe_model:coupon().
-type get_coupons_request() ::
    #{query => get_coupons_request_query(),
      header => get_coupons_request_header(),
      cookie => get_coupons_request_cookie(),
      body => {binary(), get_coupons_request_body()}}.
-type get_coupons_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_coupons_request_header() :: map().
-type get_coupons_request_cookie() :: map().
-type get_coupons_request_body() :: #{}.
-type get_coupons_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:coupon()],
      _ := json:value()}.
-type post_charges_charge_dispute_close_request() ::
    #{charge := binary(),
      query => post_charges_charge_dispute_close_request_query(),
      header => post_charges_charge_dispute_close_request_header(),
      cookie => post_charges_charge_dispute_close_request_cookie(),
      body => {binary(), post_charges_charge_dispute_close_request_body()}}.
-type post_charges_charge_dispute_close_request_query() :: map().
-type post_charges_charge_dispute_close_request_header() :: map().
-type post_charges_charge_dispute_close_request_cookie() :: map().
-type post_charges_charge_dispute_close_request_body() :: #{expand => [binary()]}.
-type post_charges_charge_dispute_close_response() ::
    stripe_model:error() | stripe_model:dispute().
-type delete_plans_plan_request() ::
    #{plan := binary(),
      query => delete_plans_plan_request_query(),
      header => delete_plans_plan_request_header(),
      cookie => delete_plans_plan_request_cookie(),
      body => {binary(), delete_plans_plan_request_body()}}.
-type delete_plans_plan_request_query() :: map().
-type delete_plans_plan_request_header() :: map().
-type delete_plans_plan_request_cookie() :: map().
-type delete_plans_plan_request_body() :: #{}.
-type delete_plans_plan_response() :: stripe_model:error() | stripe_model:deleted_plan().
-type post_plans_plan_request() ::
    #{plan := binary(),
      query => post_plans_plan_request_query(),
      header => post_plans_plan_request_header(),
      cookie => post_plans_plan_request_cookie(),
      body => {binary(), post_plans_plan_request_body()}}.
-type post_plans_plan_request_query() :: map().
-type post_plans_plan_request_header() :: map().
-type post_plans_plan_request_cookie() :: map().
-type post_plans_plan_request_body() ::
    #{trial_period_days => integer(),
      product => binary(),
      nickname => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      active => boolean()}.
-type post_plans_plan_response() :: stripe_model:error() | stripe_model:plan().
-type get_plans_plan_request() ::
    #{plan := binary(),
      query => get_plans_plan_request_query(),
      header => get_plans_plan_request_header(),
      cookie => get_plans_plan_request_cookie(),
      body => {binary(), get_plans_plan_request_body()}}.
-type get_plans_plan_request_query() :: #{expand => [binary()]}.
-type get_plans_plan_request_header() :: map().
-type get_plans_plan_request_cookie() :: map().
-type get_plans_plan_request_body() :: #{}.
-type get_plans_plan_response() :: stripe_model:error() | stripe_model:plan().
-type post_customers_customer_bank_accounts_request() ::
    #{customer := binary(),
      query => post_customers_customer_bank_accounts_request_query(),
      header => post_customers_customer_bank_accounts_request_header(),
      cookie => post_customers_customer_bank_accounts_request_cookie(),
      body => {binary(), post_customers_customer_bank_accounts_request_body()}}.
-type post_customers_customer_bank_accounts_request_query() :: map().
-type post_customers_customer_bank_accounts_request_header() :: map().
-type post_customers_customer_bank_accounts_request_cookie() :: map().
-type post_customers_customer_bank_accounts_request_body() ::
    #{source => binary(),
      metadata => json:value(),
      expand => [binary()],
      card =>
          #{object => card,
            number := binary(),
            name => binary(),
            metadata => json:value(),
            exp_year := integer(),
            exp_month := integer(),
            cvc => binary(),
            address_zip => binary(),
            address_state => binary(),
            address_line2 => binary(),
            address_line1 => binary(),
            address_country => binary(),
            address_city => binary(),
            _ := json:value()} |
          binary(),
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary(),
      alipay_account => binary()}.
-type post_customers_customer_bank_accounts_response() ::
    stripe_model:error() | stripe_model:payment_source().
-type get_customers_customer_bank_accounts_request() ::
    #{customer := binary(),
      query => get_customers_customer_bank_accounts_request_query(),
      header => get_customers_customer_bank_accounts_request_header(),
      cookie => get_customers_customer_bank_accounts_request_cookie(),
      body => {binary(), get_customers_customer_bank_accounts_request_body()}}.
-type get_customers_customer_bank_accounts_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_bank_accounts_request_header() :: map().
-type get_customers_customer_bank_accounts_request_cookie() :: map().
-type get_customers_customer_bank_accounts_request_body() :: #{}.
-type get_customers_customer_bank_accounts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bank_account()],
      _ := json:value()}.
-type delete_terminal_readers_reader_request() ::
    #{reader := binary(),
      query => delete_terminal_readers_reader_request_query(),
      header => delete_terminal_readers_reader_request_header(),
      cookie => delete_terminal_readers_reader_request_cookie(),
      body => {binary(), delete_terminal_readers_reader_request_body()}}.
-type delete_terminal_readers_reader_request_query() :: map().
-type delete_terminal_readers_reader_request_header() :: map().
-type delete_terminal_readers_reader_request_cookie() :: map().
-type delete_terminal_readers_reader_request_body() :: #{}.
-type delete_terminal_readers_reader_response() ::
    stripe_model:error() | stripe_model:deleted_terminal_reader().
-type post_terminal_readers_reader_request() ::
    #{reader := binary(),
      query => post_terminal_readers_reader_request_query(),
      header => post_terminal_readers_reader_request_header(),
      cookie => post_terminal_readers_reader_request_cookie(),
      body => {binary(), post_terminal_readers_reader_request_body()}}.
-type post_terminal_readers_reader_request_query() :: map().
-type post_terminal_readers_reader_request_header() :: map().
-type post_terminal_readers_reader_request_cookie() :: map().
-type post_terminal_readers_reader_request_body() ::
    #{metadata => json:value() | '',
      label => binary(),
      expand => [binary()]}.
-type post_terminal_readers_reader_response() ::
    stripe_model:error() |
    stripe_model:terminal_reader() |
    stripe_model:deleted_terminal_reader().
-type get_terminal_readers_reader_request() ::
    #{reader := binary(),
      query => get_terminal_readers_reader_request_query(),
      header => get_terminal_readers_reader_request_header(),
      cookie => get_terminal_readers_reader_request_cookie(),
      body => {binary(), get_terminal_readers_reader_request_body()}}.
-type get_terminal_readers_reader_request_query() :: #{expand => [binary()]}.
-type get_terminal_readers_reader_request_header() :: map().
-type get_terminal_readers_reader_request_cookie() :: map().
-type get_terminal_readers_reader_request_body() :: #{}.
-type get_terminal_readers_reader_response() ::
    stripe_model:error() |
    stripe_model:terminal_reader() |
    stripe_model:deleted_terminal_reader().
-type delete_accounts_account_persons_person_request() ::
    #{account := binary(),
      person := binary(),
      query => delete_accounts_account_persons_person_request_query(),
      header => delete_accounts_account_persons_person_request_header(),
      cookie => delete_accounts_account_persons_person_request_cookie(),
      body => {binary(), delete_accounts_account_persons_person_request_body()}}.
-type delete_accounts_account_persons_person_request_query() :: map().
-type delete_accounts_account_persons_person_request_header() :: map().
-type delete_accounts_account_persons_person_request_cookie() :: map().
-type delete_accounts_account_persons_person_request_body() :: #{}.
-type delete_accounts_account_persons_person_response() ::
    stripe_model:error() | stripe_model:deleted_person().
-type post_accounts_account_persons_person_request() ::
    #{account := binary(),
      person := binary(),
      query => post_accounts_account_persons_person_request_query(),
      header => post_accounts_account_persons_person_request_header(),
      cookie => post_accounts_account_persons_person_request_cookie(),
      body => {binary(), post_accounts_account_persons_person_request_body()}}.
-type post_accounts_account_persons_person_request_query() :: map().
-type post_accounts_account_persons_person_request_header() :: map().
-type post_accounts_account_persons_person_request_cookie() :: map().
-type post_accounts_account_persons_person_request_body() ::
    #{verification =>
          #{document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            additional_document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            _ := json:value()},
      ssn_last_4 => binary(),
      relationship =>
          #{title => binary(),
            representative => boolean(),
            percent_ownership => number() | '',
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      political_exposure => binary(),
      phone => binary(),
      person_token => binary(),
      nationality => binary(),
      metadata => json:value() | '',
      maiden_name => binary(),
      last_name_kanji => binary(),
      last_name_kana => binary(),
      last_name => binary(),
      id_number => binary(),
      gender => binary(),
      full_name_aliases => [binary()] | '',
      first_name_kanji => binary(),
      first_name_kana => binary(),
      first_name => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{visa => #{files => [binary()], _ := json:value()},
            passport => #{files => [binary()], _ := json:value()},
            company_authorization => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      dob =>
          #{year := integer(),
            month := integer(),
            day := integer(),
            _ := json:value()} |
          '',
      address_kanji =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address_kana =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()}}.
-type post_accounts_account_persons_person_response() ::
    stripe_model:error() | stripe_model:person().
-type get_accounts_account_persons_person_request() ::
    #{account := binary(),
      person := binary(),
      query => get_accounts_account_persons_person_request_query(),
      header => get_accounts_account_persons_person_request_header(),
      cookie => get_accounts_account_persons_person_request_cookie(),
      body => {binary(), get_accounts_account_persons_person_request_body()}}.
-type get_accounts_account_persons_person_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_persons_person_request_header() :: map().
-type get_accounts_account_persons_person_request_cookie() :: map().
-type get_accounts_account_persons_person_request_body() :: #{}.
-type get_accounts_account_persons_person_response() ::
    stripe_model:error() | stripe_model:person().
-type post_credit_notes_id_void_request() ::
    #{id := binary(),
      query => post_credit_notes_id_void_request_query(),
      header => post_credit_notes_id_void_request_header(),
      cookie => post_credit_notes_id_void_request_cookie(),
      body => {binary(), post_credit_notes_id_void_request_body()}}.
-type post_credit_notes_id_void_request_query() :: map().
-type post_credit_notes_id_void_request_header() :: map().
-type post_credit_notes_id_void_request_cookie() :: map().
-type post_credit_notes_id_void_request_body() :: #{expand => [binary()]}.
-type post_credit_notes_id_void_response() ::
    stripe_model:error() | stripe_model:credit_note().
-type post_customers_customer_sources_request() ::
    #{customer := binary(),
      query => post_customers_customer_sources_request_query(),
      header => post_customers_customer_sources_request_header(),
      cookie => post_customers_customer_sources_request_cookie(),
      body => {binary(), post_customers_customer_sources_request_body()}}.
-type post_customers_customer_sources_request_query() :: map().
-type post_customers_customer_sources_request_header() :: map().
-type post_customers_customer_sources_request_cookie() :: map().
-type post_customers_customer_sources_request_body() ::
    #{source => binary(),
      metadata => json:value(),
      expand => [binary()],
      card =>
          #{object => card,
            number := binary(),
            name => binary(),
            metadata => json:value(),
            exp_year := integer(),
            exp_month := integer(),
            cvc => binary(),
            address_zip => binary(),
            address_state => binary(),
            address_line2 => binary(),
            address_line1 => binary(),
            address_country => binary(),
            address_city => binary(),
            _ := json:value()} |
          binary(),
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary(),
      alipay_account => binary()}.
-type post_customers_customer_sources_response() ::
    stripe_model:error() | stripe_model:payment_source().
-type get_customers_customer_sources_request() ::
    #{customer := binary(),
      query => get_customers_customer_sources_request_query(),
      header => get_customers_customer_sources_request_header(),
      cookie => get_customers_customer_sources_request_cookie(),
      body => {binary(), get_customers_customer_sources_request_body()}}.
-type get_customers_customer_sources_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      object => binary(),
      starting_after => binary()}.
-type get_customers_customer_sources_request_header() :: map().
-type get_customers_customer_sources_request_cookie() :: map().
-type get_customers_customer_sources_request_body() :: #{}.
-type get_customers_customer_sources_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data :=
          [stripe_model:alipay_account() |
           stripe_model:bank_account() |
           stripe_model:bitcoin_receiver() |
           stripe_model:card() |
           stripe_model:source()],
      _ := json:value()}.
-type post_account_links_request() ::
    #{query => post_account_links_request_query(),
      header => post_account_links_request_header(),
      cookie => post_account_links_request_cookie(),
      body := {binary(), post_account_links_request_body()}}.
-type post_account_links_request_query() :: map().
-type post_account_links_request_header() :: map().
-type post_account_links_request_cookie() :: map().
-type post_account_links_request_body() ::
    #{type := account_onboarding | account_update,
      return_url => binary(),
      refresh_url => binary(),
      expand => [binary()],
      collect => currently_due | eventually_due,
      account := binary()}.
-type post_account_links_response() :: stripe_model:error() | stripe_model:account_link().
-type post_payouts_payout_request() ::
    #{payout := binary(),
      query => post_payouts_payout_request_query(),
      header => post_payouts_payout_request_header(),
      cookie => post_payouts_payout_request_cookie(),
      body => {binary(), post_payouts_payout_request_body()}}.
-type post_payouts_payout_request_query() :: map().
-type post_payouts_payout_request_header() :: map().
-type post_payouts_payout_request_cookie() :: map().
-type post_payouts_payout_request_body() ::
    #{metadata => json:value() | '', expand => [binary()]}.
-type post_payouts_payout_response() :: stripe_model:error() | stripe_model:payout().
-type get_payouts_payout_request() ::
    #{payout := binary(),
      query => get_payouts_payout_request_query(),
      header => get_payouts_payout_request_header(),
      cookie => get_payouts_payout_request_cookie(),
      body => {binary(), get_payouts_payout_request_body()}}.
-type get_payouts_payout_request_query() :: #{expand => [binary()]}.
-type get_payouts_payout_request_header() :: map().
-type get_payouts_payout_request_cookie() :: map().
-type get_payouts_payout_request_body() :: #{}.
-type get_payouts_payout_response() :: stripe_model:error() | stripe_model:payout().
-type delete_subscription_items_item_request() ::
    #{item := binary(),
      query => delete_subscription_items_item_request_query(),
      header => delete_subscription_items_item_request_header(),
      cookie => delete_subscription_items_item_request_cookie(),
      body => {binary(), delete_subscription_items_item_request_body()}}.
-type delete_subscription_items_item_request_query() :: map().
-type delete_subscription_items_item_request_header() :: map().
-type delete_subscription_items_item_request_cookie() :: map().
-type delete_subscription_items_item_request_body() ::
    #{proration_date => integer(),
      proration_behavior => always_invoice | create_prorations | none,
      clear_usage => boolean()}.
-type delete_subscription_items_item_response() ::
    stripe_model:error() | stripe_model:deleted_subscription_item().
-type post_subscription_items_item_request() ::
    #{item := binary(),
      query => post_subscription_items_item_request_query(),
      header => post_subscription_items_item_request_header(),
      cookie => post_subscription_items_item_request_cookie(),
      body => {binary(), post_subscription_items_item_request_body()}}.
-type post_subscription_items_item_request_query() :: map().
-type post_subscription_items_item_request_header() :: map().
-type post_subscription_items_item_request_cookie() :: map().
-type post_subscription_items_item_request_body() ::
    #{tax_rates => [binary()] | '',
      quantity => integer(),
      proration_date => integer(),
      proration_behavior => always_invoice | create_prorations | none,
      price_data =>
          #{unit_amount_decimal => binary(),
            unit_amount => integer(),
            tax_behavior => exclusive | inclusive | unspecified,
            recurring :=
                #{interval_count => integer(),
                  interval := day | month | week | year,
                  _ := json:value()},
            product := binary(),
            currency := binary(),
            _ := json:value()},
      price => binary(),
      payment_behavior =>
          allow_incomplete | default_incomplete | error_if_incomplete | pending_if_incomplete,
      off_session => boolean(),
      metadata => json:value() | '',
      expand => [binary()],
      billing_thresholds => #{usage_gte := integer(), _ := json:value()} | ''}.
-type post_subscription_items_item_response() ::
    stripe_model:error() | stripe_model:subscription_item().
-type get_subscription_items_item_request() ::
    #{item := binary(),
      query => get_subscription_items_item_request_query(),
      header => get_subscription_items_item_request_header(),
      cookie => get_subscription_items_item_request_cookie(),
      body => {binary(), get_subscription_items_item_request_body()}}.
-type get_subscription_items_item_request_query() :: #{expand => [binary()]}.
-type get_subscription_items_item_request_header() :: map().
-type get_subscription_items_item_request_cookie() :: map().
-type get_subscription_items_item_request_body() :: #{}.
-type get_subscription_items_item_response() ::
    stripe_model:error() | stripe_model:subscription_item().
-type post_products_request() ::
    #{query => post_products_request_query(),
      header => post_products_request_header(),
      cookie => post_products_request_cookie(),
      body := {binary(), post_products_request_body()}}.
-type post_products_request_query() :: map().
-type post_products_request_header() :: map().
-type post_products_request_cookie() :: map().
-type post_products_request_body() ::
    #{url => binary(),
      unit_label => binary(),
      tax_code => binary(),
      statement_descriptor => binary(),
      shippable => boolean(),
      package_dimensions =>
          #{width := number(),
            weight := number(),
            length := number(),
            height := number(),
            _ := json:value()},
      name := binary(),
      metadata => json:value(),
      images => [binary()],
      id => binary(),
      expand => [binary()],
      description => binary(),
      active => boolean()}.
-type post_products_response() :: stripe_model:error() | stripe_model:product().
-type get_products_request() ::
    #{query => get_products_request_query(),
      header => get_products_request_header(),
      cookie => get_products_request_cookie(),
      body => {binary(), get_products_request_body()}}.
-type get_products_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      ids => [binary()],
      limit => integer(),
      shippable => boolean(),
      starting_after => binary(),
      url => binary()}.
-type get_products_request_header() :: map().
-type get_products_request_cookie() :: map().
-type get_products_request_body() :: #{}.
-type get_products_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:product()],
      _ := json:value()}.
-type get_reporting_report_types_report_type_request() ::
    #{report_type := binary(),
      query => get_reporting_report_types_report_type_request_query(),
      header => get_reporting_report_types_report_type_request_header(),
      cookie => get_reporting_report_types_report_type_request_cookie(),
      body => {binary(), get_reporting_report_types_report_type_request_body()}}.
-type get_reporting_report_types_report_type_request_query() :: #{expand => [binary()]}.
-type get_reporting_report_types_report_type_request_header() :: map().
-type get_reporting_report_types_report_type_request_cookie() :: map().
-type get_reporting_report_types_report_type_request_body() :: #{}.
-type get_reporting_report_types_report_type_response() ::
    stripe_model:error() | stripe_model:reporting_report_type().
-type post_quotes_quote_accept_request() ::
    #{quote := binary(),
      query => post_quotes_quote_accept_request_query(),
      header => post_quotes_quote_accept_request_header(),
      cookie => post_quotes_quote_accept_request_cookie(),
      body => {binary(), post_quotes_quote_accept_request_body()}}.
-type post_quotes_quote_accept_request_query() :: map().
-type post_quotes_quote_accept_request_header() :: map().
-type post_quotes_quote_accept_request_cookie() :: map().
-type post_quotes_quote_accept_request_body() :: #{expand => [binary()]}.
-type post_quotes_quote_accept_response() :: stripe_model:error() | stripe_model:quote().
-type get_mandates_mandate_request() ::
    #{mandate := binary(),
      query => get_mandates_mandate_request_query(),
      header => get_mandates_mandate_request_header(),
      cookie => get_mandates_mandate_request_cookie(),
      body => {binary(), get_mandates_mandate_request_body()}}.
-type get_mandates_mandate_request_query() :: #{expand => [binary()]}.
-type get_mandates_mandate_request_header() :: map().
-type get_mandates_mandate_request_cookie() :: map().
-type get_mandates_mandate_request_body() :: #{}.
-type get_mandates_mandate_response() :: stripe_model:error() | stripe_model:mandate().
-type post_customers_customer_subscriptions_request() ::
    #{customer := binary(),
      query => post_customers_customer_subscriptions_request_query(),
      header => post_customers_customer_subscriptions_request_header(),
      cookie => post_customers_customer_subscriptions_request_cookie(),
      body => {binary(), post_customers_customer_subscriptions_request_body()}}.
-type post_customers_customer_subscriptions_request_query() :: map().
-type post_customers_customer_subscriptions_request_header() :: map().
-type post_customers_customer_subscriptions_request_cookie() :: map().
-type post_customers_customer_subscriptions_request_body() ::
    #{trial_period_days => integer(),
      trial_from_plan => boolean(),
      trial_end => now | integer(),
      transfer_data =>
          #{destination := binary(),
            amount_percent => number(),
            _ := json:value()},
      proration_behavior => always_invoice | create_prorations | none,
      promotion_code => binary(),
      pending_invoice_item_interval =>
          #{interval_count => integer(),
            interval := day | month | week | year,
            _ := json:value()} |
          '',
      payment_settings =>
          #{payment_method_types =>
                [ach_credit_transfer |
                 ach_debit |
                 acss_debit |
                 au_becs_debit |
                 bacs_debit |
                 bancontact |
                 boleto |
                 card |
                 fpx |
                 giropay |
                 grabpay |
                 ideal |
                 sepa_debit |
                 sofort |
                 wechat_pay] |
                '',
            payment_method_options =>
                #{card =>
                      #{request_three_d_secure => any | automatic,
                        mandate_options =>
                            #{description => binary(),
                              amount_type => fixed | maximum,
                              amount => integer(),
                              _ := json:value()},
                        _ := json:value()} |
                      '',
                  bancontact => #{preferred_language => de | en | fr | nl, _ := json:value()} | '',
                  acss_debit =>
                      #{verification_method => automatic | instant | microdeposits,
                        mandate_options =>
                            #{transaction_type => business | personal, _ := json:value()},
                        _ := json:value()} |
                      '',
                  _ := json:value()},
            _ := json:value()},
      payment_behavior =>
          allow_incomplete | default_incomplete | error_if_incomplete | pending_if_incomplete,
      off_session => boolean(),
      metadata => json:value() | '',
      items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring :=
                       #{interval_count => integer(),
                         interval := day | month | week | year,
                         _ := json:value()},
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             metadata => json:value(),
             billing_thresholds => #{usage_gte := integer(), _ := json:value()} | '',
             _ := json:value()}],
      expand => [binary()],
      default_tax_rates => [binary()] | '',
      default_source => binary(),
      default_payment_method => binary(),
      days_until_due => integer(),
      coupon => binary(),
      collection_method => charge_automatically | send_invoice,
      cancel_at_period_end => boolean(),
      cancel_at => integer(),
      billing_thresholds =>
          #{reset_billing_cycle_anchor => boolean(),
            amount_gte => integer(),
            _ := json:value()} |
          '',
      billing_cycle_anchor => integer(),
      backdate_start_date => integer(),
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      application_fee_percent => number(),
      add_invoice_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             _ := json:value()}]}.
-type post_customers_customer_subscriptions_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_customers_customer_subscriptions_request() ::
    #{customer := binary(),
      query => get_customers_customer_subscriptions_request_query(),
      header => get_customers_customer_subscriptions_request_header(),
      cookie => get_customers_customer_subscriptions_request_cookie(),
      body => {binary(), get_customers_customer_subscriptions_request_body()}}.
-type get_customers_customer_subscriptions_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_subscriptions_request_header() :: map().
-type get_customers_customer_subscriptions_request_cookie() :: map().
-type get_customers_customer_subscriptions_request_body() :: #{}.
-type get_customers_customer_subscriptions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:subscription()],
      _ := json:value()}.
-type get_order_returns_id_request() ::
    #{id := binary(),
      query => get_order_returns_id_request_query(),
      header => get_order_returns_id_request_header(),
      cookie => get_order_returns_id_request_cookie(),
      body => {binary(), get_order_returns_id_request_body()}}.
-type get_order_returns_id_request_query() :: #{expand => [binary()]}.
-type get_order_returns_id_request_header() :: map().
-type get_order_returns_id_request_cookie() :: map().
-type get_order_returns_id_request_body() :: #{}.
-type get_order_returns_id_response() ::
    stripe_model:error() | stripe_model:order_return().
-type post_transfers_id_reversals_request() ::
    #{id := binary(),
      query => post_transfers_id_reversals_request_query(),
      header => post_transfers_id_reversals_request_header(),
      cookie => post_transfers_id_reversals_request_cookie(),
      body => {binary(), post_transfers_id_reversals_request_body()}}.
-type post_transfers_id_reversals_request_query() :: map().
-type post_transfers_id_reversals_request_header() :: map().
-type post_transfers_id_reversals_request_cookie() :: map().
-type post_transfers_id_reversals_request_body() ::
    #{refund_application_fee => boolean(),
      metadata => json:value() | '',
      expand => [binary()],
      description => binary(),
      amount => integer()}.
-type post_transfers_id_reversals_response() ::
    stripe_model:error() | stripe_model:transfer_reversal().
-type get_transfers_id_reversals_request() ::
    #{id := binary(),
      query => get_transfers_id_reversals_request_query(),
      header => get_transfers_id_reversals_request_header(),
      cookie => get_transfers_id_reversals_request_cookie(),
      body => {binary(), get_transfers_id_reversals_request_body()}}.
-type get_transfers_id_reversals_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_transfers_id_reversals_request_header() :: map().
-type get_transfers_id_reversals_request_cookie() :: map().
-type get_transfers_id_reversals_request_body() :: #{}.
-type get_transfers_id_reversals_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:transfer_reversal()],
      _ := json:value()}.
-type get_reviews_review_request() ::
    #{review := binary(),
      query => get_reviews_review_request_query(),
      header => get_reviews_review_request_header(),
      cookie => get_reviews_review_request_cookie(),
      body => {binary(), get_reviews_review_request_body()}}.
-type get_reviews_review_request_query() :: #{expand => [binary()]}.
-type get_reviews_review_request_header() :: map().
-type get_reviews_review_request_cookie() :: map().
-type get_reviews_review_request_body() :: #{}.
-type get_reviews_review_response() :: stripe_model:error() | stripe_model:review().
-type delete_accounts_account_bank_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => delete_accounts_account_bank_accounts_id_request_query(),
      header => delete_accounts_account_bank_accounts_id_request_header(),
      cookie => delete_accounts_account_bank_accounts_id_request_cookie(),
      body => {binary(), delete_accounts_account_bank_accounts_id_request_body()}}.
-type delete_accounts_account_bank_accounts_id_request_query() :: map().
-type delete_accounts_account_bank_accounts_id_request_header() :: map().
-type delete_accounts_account_bank_accounts_id_request_cookie() :: map().
-type delete_accounts_account_bank_accounts_id_request_body() :: #{}.
-type delete_accounts_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:deleted_external_account().
-type post_accounts_account_bank_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => post_accounts_account_bank_accounts_id_request_query(),
      header => post_accounts_account_bank_accounts_id_request_header(),
      cookie => post_accounts_account_bank_accounts_id_request_cookie(),
      body => {binary(), post_accounts_account_bank_accounts_id_request_body()}}.
-type post_accounts_account_bank_accounts_id_request_query() :: map().
-type post_accounts_account_bank_accounts_id_request_header() :: map().
-type post_accounts_account_bank_accounts_id_request_cookie() :: map().
-type post_accounts_account_bank_accounts_id_request_body() ::
    #{name => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      exp_year => binary(),
      exp_month => binary(),
      default_for_currency => boolean(),
      address_zip => binary(),
      address_state => binary(),
      address_line2 => binary(),
      address_line1 => binary(),
      address_country => binary(),
      address_city => binary(),
      account_type => checking | futsu | savings | toza,
      account_holder_type => '' | company | individual,
      account_holder_name => binary()}.
-type post_accounts_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_accounts_account_bank_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => get_accounts_account_bank_accounts_id_request_query(),
      header => get_accounts_account_bank_accounts_id_request_header(),
      cookie => get_accounts_account_bank_accounts_id_request_cookie(),
      body => {binary(), get_accounts_account_bank_accounts_id_request_body()}}.
-type get_accounts_account_bank_accounts_id_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_bank_accounts_id_request_header() :: map().
-type get_accounts_account_bank_accounts_id_request_cookie() :: map().
-type get_accounts_account_bank_accounts_id_request_body() :: #{}.
-type get_accounts_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type post_issuing_settlements_settlement_request() ::
    #{settlement := binary(),
      query => post_issuing_settlements_settlement_request_query(),
      header => post_issuing_settlements_settlement_request_header(),
      cookie => post_issuing_settlements_settlement_request_cookie(),
      body => {binary(), post_issuing_settlements_settlement_request_body()}}.
-type post_issuing_settlements_settlement_request_query() :: map().
-type post_issuing_settlements_settlement_request_header() :: map().
-type post_issuing_settlements_settlement_request_cookie() :: map().
-type post_issuing_settlements_settlement_request_body() ::
    #{metadata => json:value(), expand => [binary()]}.
-type post_issuing_settlements_settlement_response() ::
    stripe_model:error() | stripe_model:issuing_settlement().
-type get_issuing_settlements_settlement_request() ::
    #{settlement := binary(),
      query => get_issuing_settlements_settlement_request_query(),
      header => get_issuing_settlements_settlement_request_header(),
      cookie => get_issuing_settlements_settlement_request_cookie(),
      body => {binary(), get_issuing_settlements_settlement_request_body()}}.
-type get_issuing_settlements_settlement_request_query() :: #{expand => [binary()]}.
-type get_issuing_settlements_settlement_request_header() :: map().
-type get_issuing_settlements_settlement_request_cookie() :: map().
-type get_issuing_settlements_settlement_request_body() :: #{}.
-type get_issuing_settlements_settlement_response() ::
    stripe_model:error() | stripe_model:issuing_settlement().
-type post_promotion_codes_promotion_code_request() ::
    #{promotion_code := binary(),
      query => post_promotion_codes_promotion_code_request_query(),
      header => post_promotion_codes_promotion_code_request_header(),
      cookie => post_promotion_codes_promotion_code_request_cookie(),
      body => {binary(), post_promotion_codes_promotion_code_request_body()}}.
-type post_promotion_codes_promotion_code_request_query() :: map().
-type post_promotion_codes_promotion_code_request_header() :: map().
-type post_promotion_codes_promotion_code_request_cookie() :: map().
-type post_promotion_codes_promotion_code_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      active => boolean()}.
-type post_promotion_codes_promotion_code_response() ::
    stripe_model:error() | stripe_model:promotion_code().
-type get_promotion_codes_promotion_code_request() ::
    #{promotion_code := binary(),
      query => get_promotion_codes_promotion_code_request_query(),
      header => get_promotion_codes_promotion_code_request_header(),
      cookie => get_promotion_codes_promotion_code_request_cookie(),
      body => {binary(), get_promotion_codes_promotion_code_request_body()}}.
-type get_promotion_codes_promotion_code_request_query() :: #{expand => [binary()]}.
-type get_promotion_codes_promotion_code_request_header() :: map().
-type get_promotion_codes_promotion_code_request_cookie() :: map().
-type get_promotion_codes_promotion_code_request_body() :: #{}.
-type get_promotion_codes_promotion_code_response() ::
    stripe_model:error() | stripe_model:promotion_code().
-type post_subscription_schedules_schedule_cancel_request() ::
    #{schedule := binary(),
      query => post_subscription_schedules_schedule_cancel_request_query(),
      header => post_subscription_schedules_schedule_cancel_request_header(),
      cookie => post_subscription_schedules_schedule_cancel_request_cookie(),
      body => {binary(), post_subscription_schedules_schedule_cancel_request_body()}}.
-type post_subscription_schedules_schedule_cancel_request_query() :: map().
-type post_subscription_schedules_schedule_cancel_request_header() :: map().
-type post_subscription_schedules_schedule_cancel_request_cookie() :: map().
-type post_subscription_schedules_schedule_cancel_request_body() ::
    #{prorate => boolean(),
      invoice_now => boolean(),
      expand => [binary()]}.
-type post_subscription_schedules_schedule_cancel_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type post_identity_verification_sessions_request() ::
    #{query => post_identity_verification_sessions_request_query(),
      header => post_identity_verification_sessions_request_header(),
      cookie => post_identity_verification_sessions_request_cookie(),
      body := {binary(), post_identity_verification_sessions_request_body()}}.
-type post_identity_verification_sessions_request_query() :: map().
-type post_identity_verification_sessions_request_header() :: map().
-type post_identity_verification_sessions_request_cookie() :: map().
-type post_identity_verification_sessions_request_body() ::
    #{type := document | id_number,
      return_url => binary(),
      options =>
          #{document =>
                #{require_matching_selfie => boolean(),
                  require_live_capture => boolean(),
                  require_id_number => boolean(),
                  allowed_types => [driving_license | id_card | passport],
                  _ := json:value()} |
                '',
            _ := json:value()},
      metadata => json:value(),
      expand => [binary()]}.
-type post_identity_verification_sessions_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type get_identity_verification_sessions_request() ::
    #{query => get_identity_verification_sessions_request_query(),
      header => get_identity_verification_sessions_request_header(),
      cookie => get_identity_verification_sessions_request_cookie(),
      body => {binary(), get_identity_verification_sessions_request_body()}}.
-type get_identity_verification_sessions_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => canceled | processing | requires_input | verified}.
-type get_identity_verification_sessions_request_header() :: map().
-type get_identity_verification_sessions_request_cookie() :: map().
-type get_identity_verification_sessions_request_body() :: #{}.
-type get_identity_verification_sessions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:identity_verification_session()],
      _ := json:value()}.
-type post_radar_value_list_items_request() ::
    #{query => post_radar_value_list_items_request_query(),
      header => post_radar_value_list_items_request_header(),
      cookie => post_radar_value_list_items_request_cookie(),
      body := {binary(), post_radar_value_list_items_request_body()}}.
-type post_radar_value_list_items_request_query() :: map().
-type post_radar_value_list_items_request_header() :: map().
-type post_radar_value_list_items_request_cookie() :: map().
-type post_radar_value_list_items_request_body() ::
    #{value_list := binary(),
      value := binary(),
      expand => [binary()]}.
-type post_radar_value_list_items_response() ::
    stripe_model:error() | stripe_model:radar_value_list_item().
-type get_radar_value_list_items_request() ::
    #{query => get_radar_value_list_items_request_query(),
      header => get_radar_value_list_items_request_header(),
      cookie => get_radar_value_list_items_request_cookie(),
      body => {binary(), get_radar_value_list_items_request_body()}}.
-type get_radar_value_list_items_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      value => binary(),
      value_list := binary()}.
-type get_radar_value_list_items_request_header() :: map().
-type get_radar_value_list_items_request_cookie() :: map().
-type get_radar_value_list_items_request_body() :: #{}.
-type get_radar_value_list_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:radar_value_list_item()],
      _ := json:value()}.
-type get_events_id_request() ::
    #{id := binary(),
      query => get_events_id_request_query(),
      header => get_events_id_request_header(),
      cookie => get_events_id_request_cookie(),
      body => {binary(), get_events_id_request_body()}}.
-type get_events_id_request_query() :: #{expand => [binary()]}.
-type get_events_id_request_header() :: map().
-type get_events_id_request_cookie() :: map().
-type get_events_id_request_body() :: #{}.
-type get_events_id_response() :: stripe_model:error() | stripe_model:event().
-type get_country_specs_request() ::
    #{query => get_country_specs_request_query(),
      header => get_country_specs_request_header(),
      cookie => get_country_specs_request_cookie(),
      body => {binary(), get_country_specs_request_body()}}.
-type get_country_specs_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_country_specs_request_header() :: map().
-type get_country_specs_request_cookie() :: map().
-type get_country_specs_request_body() :: #{}.
-type get_country_specs_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:country_spec()],
      _ := json:value()}.
-type post_payment_intents_intent_verify_microdeposits_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_verify_microdeposits_request_query(),
      header => post_payment_intents_intent_verify_microdeposits_request_header(),
      cookie => post_payment_intents_intent_verify_microdeposits_request_cookie(),
      body => {binary(), post_payment_intents_intent_verify_microdeposits_request_body()}}.
-type post_payment_intents_intent_verify_microdeposits_request_query() :: map().
-type post_payment_intents_intent_verify_microdeposits_request_header() :: map().
-type post_payment_intents_intent_verify_microdeposits_request_cookie() :: map().
-type post_payment_intents_intent_verify_microdeposits_request_body() ::
    #{expand => [binary()],
      client_secret => binary(),
      amounts => [integer()]}.
-type post_payment_intents_intent_verify_microdeposits_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type post_subscription_items_subscription_item_usage_records_request() ::
    #{subscription_item := binary(),
      query => post_subscription_items_subscription_item_usage_records_request_query(),
      header => post_subscription_items_subscription_item_usage_records_request_header(),
      cookie => post_subscription_items_subscription_item_usage_records_request_cookie(),
      body :=
          {binary(), post_subscription_items_subscription_item_usage_records_request_body()}}.
-type post_subscription_items_subscription_item_usage_records_request_query() :: map().
-type post_subscription_items_subscription_item_usage_records_request_header() :: map().
-type post_subscription_items_subscription_item_usage_records_request_cookie() :: map().
-type post_subscription_items_subscription_item_usage_records_request_body() ::
    #{timestamp => now | integer(),
      quantity := integer(),
      expand => [binary()],
      action => increment | set}.
-type post_subscription_items_subscription_item_usage_records_response() ::
    stripe_model:error() | stripe_model:usage_record().
-type get_balance_history_request() ::
    #{query => get_balance_history_request_query(),
      header => get_balance_history_request_header(),
      cookie => get_balance_history_request_cookie(),
      body => {binary(), get_balance_history_request_body()}}.
-type get_balance_history_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      currency => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payout => binary(),
      source => binary(),
      starting_after => binary(),
      type => binary()}.
-type get_balance_history_request_header() :: map().
-type get_balance_history_request_cookie() :: map().
-type get_balance_history_request_body() :: #{}.
-type get_balance_history_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:balance_transaction()],
      _ := json:value()}.
-type get_order_returns_request() ::
    #{query => get_order_returns_request_query(),
      header => get_order_returns_request_header(),
      cookie => get_order_returns_request_cookie(),
      body => {binary(), get_order_returns_request_body()}}.
-type get_order_returns_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      order => binary(),
      starting_after => binary()}.
-type get_order_returns_request_header() :: map().
-type get_order_returns_request_cookie() :: map().
-type get_order_returns_request_body() :: #{}.
-type get_order_returns_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:order_return()],
      _ := json:value()}.
-type delete_account_external_accounts_id_request() ::
    #{id := binary(),
      query => delete_account_external_accounts_id_request_query(),
      header => delete_account_external_accounts_id_request_header(),
      cookie => delete_account_external_accounts_id_request_cookie(),
      body => {binary(), delete_account_external_accounts_id_request_body()}}.
-type delete_account_external_accounts_id_request_query() :: map().
-type delete_account_external_accounts_id_request_header() :: map().
-type delete_account_external_accounts_id_request_cookie() :: map().
-type delete_account_external_accounts_id_request_body() :: #{}.
-type delete_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:deleted_external_account().
-type post_account_external_accounts_id_request() ::
    #{id := binary(),
      query => post_account_external_accounts_id_request_query(),
      header => post_account_external_accounts_id_request_header(),
      cookie => post_account_external_accounts_id_request_cookie(),
      body => {binary(), post_account_external_accounts_id_request_body()}}.
-type post_account_external_accounts_id_request_query() :: map().
-type post_account_external_accounts_id_request_header() :: map().
-type post_account_external_accounts_id_request_cookie() :: map().
-type post_account_external_accounts_id_request_body() ::
    #{name => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      exp_year => binary(),
      exp_month => binary(),
      default_for_currency => boolean(),
      address_zip => binary(),
      address_state => binary(),
      address_line2 => binary(),
      address_line1 => binary(),
      address_country => binary(),
      address_city => binary(),
      account_type => checking | futsu | savings | toza,
      account_holder_type => '' | company | individual,
      account_holder_name => binary()}.
-type post_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_account_external_accounts_id_request() ::
    #{id := binary(),
      query => get_account_external_accounts_id_request_query(),
      header => get_account_external_accounts_id_request_header(),
      cookie => get_account_external_accounts_id_request_cookie(),
      body => {binary(), get_account_external_accounts_id_request_body()}}.
-type get_account_external_accounts_id_request_query() :: #{expand => [binary()]}.
-type get_account_external_accounts_id_request_header() :: map().
-type get_account_external_accounts_id_request_cookie() :: map().
-type get_account_external_accounts_id_request_body() :: #{}.
-type get_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type post_apple_pay_domains_request() ::
    #{query => post_apple_pay_domains_request_query(),
      header => post_apple_pay_domains_request_header(),
      cookie => post_apple_pay_domains_request_cookie(),
      body := {binary(), post_apple_pay_domains_request_body()}}.
-type post_apple_pay_domains_request_query() :: map().
-type post_apple_pay_domains_request_header() :: map().
-type post_apple_pay_domains_request_cookie() :: map().
-type post_apple_pay_domains_request_body() ::
    #{expand => [binary()], domain_name := binary()}.
-type post_apple_pay_domains_response() ::
    stripe_model:error() | stripe_model:apple_pay_domain().
-type get_apple_pay_domains_request() ::
    #{query => get_apple_pay_domains_request_query(),
      header => get_apple_pay_domains_request_header(),
      cookie => get_apple_pay_domains_request_cookie(),
      body => {binary(), get_apple_pay_domains_request_body()}}.
-type get_apple_pay_domains_request_query() ::
    #{domain_name => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_apple_pay_domains_request_header() :: map().
-type get_apple_pay_domains_request_cookie() :: map().
-type get_apple_pay_domains_request_body() :: #{}.
-type get_apple_pay_domains_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:apple_pay_domain()],
      _ := json:value()}.
-type post_credit_notes_request() ::
    #{query => post_credit_notes_request_query(),
      header => post_credit_notes_request_header(),
      cookie => post_credit_notes_request_cookie(),
      body := {binary(), post_credit_notes_request_body()}}.
-type post_credit_notes_request_query() :: map().
-type post_credit_notes_request_header() :: map().
-type post_credit_notes_request_cookie() :: map().
-type post_credit_notes_request_body() ::
    #{refund_amount => integer(),
      refund => binary(),
      reason => duplicate | fraudulent | order_change | product_unsatisfactory,
      out_of_band_amount => integer(),
      metadata => json:value(),
      memo => binary(),
      lines =>
          [#{unit_amount_decimal => binary(),
             unit_amount => integer(),
             type := custom_line_item | invoice_line_item,
             tax_rates => [binary()] | '',
             quantity => integer(),
             invoice_line_item => binary(),
             description => binary(),
             amount => integer(),
             _ := json:value()}],
      invoice := binary(),
      expand => [binary()],
      credit_amount => integer(),
      amount => integer()}.
-type post_credit_notes_response() :: stripe_model:error() | stripe_model:credit_note().
-type get_credit_notes_request() ::
    #{query => get_credit_notes_request_query(),
      header => get_credit_notes_request_header(),
      cookie => get_credit_notes_request_cookie(),
      body => {binary(), get_credit_notes_request_body()}}.
-type get_credit_notes_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      invoice => binary(),
      limit => integer(),
      starting_after => binary()}.
-type get_credit_notes_request_header() :: map().
-type get_credit_notes_request_cookie() :: map().
-type get_credit_notes_request_body() :: #{}.
-type get_credit_notes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:credit_note()],
      _ := json:value()}.
-type get_sigma_scheduled_query_runs_scheduled_query_run_request() ::
    #{scheduled_query_run := binary(),
      query => get_sigma_scheduled_query_runs_scheduled_query_run_request_query(),
      header => get_sigma_scheduled_query_runs_scheduled_query_run_request_header(),
      cookie => get_sigma_scheduled_query_runs_scheduled_query_run_request_cookie(),
      body => {binary(), get_sigma_scheduled_query_runs_scheduled_query_run_request_body()}}.
-type get_sigma_scheduled_query_runs_scheduled_query_run_request_query() ::
    #{expand => [binary()]}.
-type get_sigma_scheduled_query_runs_scheduled_query_run_request_header() :: map().
-type get_sigma_scheduled_query_runs_scheduled_query_run_request_cookie() :: map().
-type get_sigma_scheduled_query_runs_scheduled_query_run_request_body() :: #{}.
-type get_sigma_scheduled_query_runs_scheduled_query_run_response() ::
    stripe_model:error() | stripe_model:scheduled_query_run().
-type delete_coupons_coupon_request() ::
    #{coupon := binary(),
      query => delete_coupons_coupon_request_query(),
      header => delete_coupons_coupon_request_header(),
      cookie => delete_coupons_coupon_request_cookie(),
      body => {binary(), delete_coupons_coupon_request_body()}}.
-type delete_coupons_coupon_request_query() :: map().
-type delete_coupons_coupon_request_header() :: map().
-type delete_coupons_coupon_request_cookie() :: map().
-type delete_coupons_coupon_request_body() :: #{}.
-type delete_coupons_coupon_response() ::
    stripe_model:error() | stripe_model:deleted_coupon().
-type post_coupons_coupon_request() ::
    #{coupon := binary(),
      query => post_coupons_coupon_request_query(),
      header => post_coupons_coupon_request_header(),
      cookie => post_coupons_coupon_request_cookie(),
      body => {binary(), post_coupons_coupon_request_body()}}.
-type post_coupons_coupon_request_query() :: map().
-type post_coupons_coupon_request_header() :: map().
-type post_coupons_coupon_request_cookie() :: map().
-type post_coupons_coupon_request_body() ::
    #{name => binary(),
      metadata => json:value() | '',
      expand => [binary()]}.
-type post_coupons_coupon_response() :: stripe_model:error() | stripe_model:coupon().
-type get_coupons_coupon_request() ::
    #{coupon := binary(),
      query => get_coupons_coupon_request_query(),
      header => get_coupons_coupon_request_header(),
      cookie => get_coupons_coupon_request_cookie(),
      body => {binary(), get_coupons_coupon_request_body()}}.
-type get_coupons_coupon_request_query() :: #{expand => [binary()]}.
-type get_coupons_coupon_request_header() :: map().
-type get_coupons_coupon_request_cookie() :: map().
-type get_coupons_coupon_request_body() :: #{}.
-type get_coupons_coupon_response() :: stripe_model:error() | stripe_model:coupon().
-type delete_customers_customer_tax_ids_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => delete_customers_customer_tax_ids_id_request_query(),
      header => delete_customers_customer_tax_ids_id_request_header(),
      cookie => delete_customers_customer_tax_ids_id_request_cookie(),
      body => {binary(), delete_customers_customer_tax_ids_id_request_body()}}.
-type delete_customers_customer_tax_ids_id_request_query() :: map().
-type delete_customers_customer_tax_ids_id_request_header() :: map().
-type delete_customers_customer_tax_ids_id_request_cookie() :: map().
-type delete_customers_customer_tax_ids_id_request_body() :: #{}.
-type delete_customers_customer_tax_ids_id_response() ::
    stripe_model:error() | stripe_model:deleted_tax_id().
-type get_customers_customer_tax_ids_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => get_customers_customer_tax_ids_id_request_query(),
      header => get_customers_customer_tax_ids_id_request_header(),
      cookie => get_customers_customer_tax_ids_id_request_cookie(),
      body => {binary(), get_customers_customer_tax_ids_id_request_body()}}.
-type get_customers_customer_tax_ids_id_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_tax_ids_id_request_header() :: map().
-type get_customers_customer_tax_ids_id_request_cookie() :: map().
-type get_customers_customer_tax_ids_id_request_body() :: #{}.
-type get_customers_customer_tax_ids_id_response() ::
    stripe_model:error() | stripe_model:tax_id().
-type get_radar_early_fraud_warnings_early_fraud_warning_request() ::
    #{early_fraud_warning := binary(),
      query => get_radar_early_fraud_warnings_early_fraud_warning_request_query(),
      header => get_radar_early_fraud_warnings_early_fraud_warning_request_header(),
      cookie => get_radar_early_fraud_warnings_early_fraud_warning_request_cookie(),
      body => {binary(), get_radar_early_fraud_warnings_early_fraud_warning_request_body()}}.
-type get_radar_early_fraud_warnings_early_fraud_warning_request_query() ::
    #{expand => [binary()]}.
-type get_radar_early_fraud_warnings_early_fraud_warning_request_header() :: map().
-type get_radar_early_fraud_warnings_early_fraud_warning_request_cookie() :: map().
-type get_radar_early_fraud_warnings_early_fraud_warning_request_body() :: #{}.
-type get_radar_early_fraud_warnings_early_fraud_warning_response() ::
    stripe_model:error() | stripe_model:radar_early_fraud_warning().
-type get_issuing_settlements_request() ::
    #{query => get_issuing_settlements_request_query(),
      header => get_issuing_settlements_request_header(),
      cookie => get_issuing_settlements_request_cookie(),
      body => {binary(), get_issuing_settlements_request_body()}}.
-type get_issuing_settlements_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_issuing_settlements_request_header() :: map().
-type get_issuing_settlements_request_cookie() :: map().
-type get_issuing_settlements_request_body() :: #{}.
-type get_issuing_settlements_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_settlement()],
      _ := json:value()}.
-type post_file_links_request() ::
    #{query => post_file_links_request_query(),
      header => post_file_links_request_header(),
      cookie => post_file_links_request_cookie(),
      body := {binary(), post_file_links_request_body()}}.
-type post_file_links_request_query() :: map().
-type post_file_links_request_header() :: map().
-type post_file_links_request_cookie() :: map().
-type post_file_links_request_body() ::
    #{metadata => json:value() | '',
      file := binary(),
      expires_at => integer(),
      expand => [binary()]}.
-type post_file_links_response() :: stripe_model:error() | stripe_model:file_link().
-type get_file_links_request() ::
    #{query => get_file_links_request_query(),
      header => get_file_links_request_header(),
      cookie => get_file_links_request_cookie(),
      body => {binary(), get_file_links_request_body()}}.
-type get_file_links_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      expired => boolean(),
      file => binary(),
      limit => integer(),
      starting_after => binary()}.
-type get_file_links_request_header() :: map().
-type get_file_links_request_cookie() :: map().
-type get_file_links_request_body() :: #{}.
-type get_file_links_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:file_link()],
      _ := json:value()}.
-type get_identity_verification_reports_report_request() ::
    #{report := binary(),
      query => get_identity_verification_reports_report_request_query(),
      header => get_identity_verification_reports_report_request_header(),
      cookie => get_identity_verification_reports_report_request_cookie(),
      body => {binary(), get_identity_verification_reports_report_request_body()}}.
-type get_identity_verification_reports_report_request_query() :: #{expand => [binary()]}.
-type get_identity_verification_reports_report_request_header() :: map().
-type get_identity_verification_reports_report_request_cookie() :: map().
-type get_identity_verification_reports_report_request_body() :: #{}.
-type get_identity_verification_reports_report_response() ::
    stripe_model:error() | stripe_model:identity_verification_report().
-type post_transfers_request() ::
    #{query => post_transfers_request_query(),
      header => post_transfers_request_header(),
      cookie => post_transfers_request_cookie(),
      body := {binary(), post_transfers_request_body()}}.
-type post_transfers_request_query() :: map().
-type post_transfers_request_header() :: map().
-type post_transfers_request_cookie() :: map().
-type post_transfers_request_body() ::
    #{transfer_group => binary(),
      source_type => bank_account | card | fpx,
      source_transaction => binary(),
      metadata => json:value(),
      expand => [binary()],
      destination := binary(),
      description => binary(),
      currency := binary(),
      amount => integer()}.
-type post_transfers_response() :: stripe_model:error() | stripe_model:transfer().
-type get_transfers_request() ::
    #{query => get_transfers_request_query(),
      header => get_transfers_request_header(),
      cookie => get_transfers_request_cookie(),
      body => {binary(), get_transfers_request_body()}}.
-type get_transfers_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      destination => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      transfer_group => binary()}.
-type get_transfers_request_header() :: map().
-type get_transfers_request_cookie() :: map().
-type get_transfers_request_body() :: #{}.
-type get_transfers_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:transfer()],
      _ := json:value()}.
-type delete_subscriptions_subscription_exposed_id_discount_request() ::
    #{subscription_exposed_id := binary(),
      query => delete_subscriptions_subscription_exposed_id_discount_request_query(),
      header => delete_subscriptions_subscription_exposed_id_discount_request_header(),
      cookie => delete_subscriptions_subscription_exposed_id_discount_request_cookie(),
      body => {binary(), delete_subscriptions_subscription_exposed_id_discount_request_body()}}.
-type delete_subscriptions_subscription_exposed_id_discount_request_query() :: map().
-type delete_subscriptions_subscription_exposed_id_discount_request_header() :: map().
-type delete_subscriptions_subscription_exposed_id_discount_request_cookie() :: map().
-type delete_subscriptions_subscription_exposed_id_discount_request_body() :: #{}.
-type delete_subscriptions_subscription_exposed_id_discount_response() ::
    stripe_model:error() | stripe_model:deleted_discount().
-type post_application_fees_id_refunds_request() ::
    #{id := binary(),
      query => post_application_fees_id_refunds_request_query(),
      header => post_application_fees_id_refunds_request_header(),
      cookie => post_application_fees_id_refunds_request_cookie(),
      body => {binary(), post_application_fees_id_refunds_request_body()}}.
-type post_application_fees_id_refunds_request_query() :: map().
-type post_application_fees_id_refunds_request_header() :: map().
-type post_application_fees_id_refunds_request_cookie() :: map().
-type post_application_fees_id_refunds_request_body() ::
    #{metadata => json:value(),
      expand => [binary()],
      amount => integer()}.
-type post_application_fees_id_refunds_response() ::
    stripe_model:error() | stripe_model:fee_refund().
-type get_application_fees_id_refunds_request() ::
    #{id := binary(),
      query => get_application_fees_id_refunds_request_query(),
      header => get_application_fees_id_refunds_request_header(),
      cookie => get_application_fees_id_refunds_request_cookie(),
      body => {binary(), get_application_fees_id_refunds_request_body()}}.
-type get_application_fees_id_refunds_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_application_fees_id_refunds_request_header() :: map().
-type get_application_fees_id_refunds_request_cookie() :: map().
-type get_application_fees_id_refunds_request_body() :: #{}.
-type get_application_fees_id_refunds_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:fee_refund()],
      _ := json:value()}.
-type post_accounts_account_bank_accounts_request() ::
    #{account := binary(),
      query => post_accounts_account_bank_accounts_request_query(),
      header => post_accounts_account_bank_accounts_request_header(),
      cookie => post_accounts_account_bank_accounts_request_cookie(),
      body => {binary(), post_accounts_account_bank_accounts_request_body()}}.
-type post_accounts_account_bank_accounts_request_query() :: map().
-type post_accounts_account_bank_accounts_request_header() :: map().
-type post_accounts_account_bank_accounts_request_cookie() :: map().
-type post_accounts_account_bank_accounts_request_body() ::
    #{metadata => json:value(),
      external_account => binary(),
      expand => [binary()],
      default_for_currency => boolean(),
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_type => checking | futsu | savings | toza,
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary()}.
-type post_accounts_account_bank_accounts_response() ::
    stripe_model:error() | stripe_model:external_account().
-type delete_accounts_account_request() ::
    #{account := binary(),
      query => delete_accounts_account_request_query(),
      header => delete_accounts_account_request_header(),
      cookie => delete_accounts_account_request_cookie(),
      body => {binary(), delete_accounts_account_request_body()}}.
-type delete_accounts_account_request_query() :: map().
-type delete_accounts_account_request_header() :: map().
-type delete_accounts_account_request_cookie() :: map().
-type delete_accounts_account_request_body() :: #{}.
-type delete_accounts_account_response() ::
    stripe_model:error() | stripe_model:deleted_account().
-type post_accounts_account_request() ::
    #{account := binary(),
      query => post_accounts_account_request_query(),
      header => post_accounts_account_request_header(),
      cookie => post_accounts_account_request_cookie(),
      body => {binary(), post_accounts_account_request_body()}}.
-type post_accounts_account_request_query() :: map().
-type post_accounts_account_request_header() :: map().
-type post_accounts_account_request_cookie() :: map().
-type post_accounts_account_request_body() ::
    #{tos_acceptance =>
          #{user_agent => binary(),
            service_agreement => binary(),
            ip => binary(),
            date => integer(),
            _ := json:value()},
      settings =>
          #{payouts =>
                #{statement_descriptor => binary(),
                  schedule =>
                      #{weekly_anchor =>
                            friday | monday | saturday | sunday | thursday | tuesday | wednesday,
                        monthly_anchor => integer(),
                        interval => daily | manual | monthly | weekly,
                        delay_days => minimum | integer(),
                        _ := json:value()},
                  debit_negative_balances => boolean(),
                  _ := json:value()},
            payments =>
                #{statement_descriptor_kanji => binary(),
                  statement_descriptor_kana => binary(),
                  statement_descriptor => binary(),
                  _ := json:value()},
            card_payments =>
                #{statement_descriptor_prefix => binary(),
                  decline_on =>
                      #{cvc_failure => boolean(),
                        avs_failure => boolean(),
                        _ := json:value()},
                  _ := json:value()},
            card_issuing =>
                #{tos_acceptance =>
                      #{user_agent => binary(),
                        ip => binary(),
                        date => integer(),
                        _ := json:value()},
                  _ := json:value()},
            branding =>
                #{secondary_color => binary(),
                  primary_color => binary(),
                  logo => binary(),
                  icon => binary(),
                  _ := json:value()},
            _ := json:value()},
      metadata => json:value() | '',
      individual =>
          #{verification =>
                #{document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  additional_document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  _ := json:value()},
            ssn_last_4 => binary(),
            political_exposure => existing | none,
            phone => binary(),
            metadata => json:value() | '',
            maiden_name => binary(),
            last_name_kanji => binary(),
            last_name_kana => binary(),
            last_name => binary(),
            id_number => binary(),
            gender => binary(),
            full_name_aliases => [binary()] | '',
            first_name_kanji => binary(),
            first_name_kana => binary(),
            first_name => binary(),
            email => binary(),
            dob =>
                #{year := integer(),
                  month := integer(),
                  day := integer(),
                  _ := json:value()} |
                '',
            address_kanji =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address_kana =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      external_account => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{proof_of_registration => #{files => [binary()], _ := json:value()},
            company_tax_id_verification => #{files => [binary()], _ := json:value()},
            company_registration_verification => #{files => [binary()], _ := json:value()},
            company_ministerial_decree => #{files => [binary()], _ := json:value()},
            company_memorandum_of_association => #{files => [binary()], _ := json:value()},
            company_license => #{files => [binary()], _ := json:value()},
            bank_account_ownership_verification => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      default_currency => binary(),
      company =>
          #{verification =>
                #{document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  _ := json:value()},
            vat_id => binary(),
            tax_id_registrar => binary(),
            tax_id => binary(),
            structure =>
                '' |
                free_zone_establishment |
                free_zone_llc |
                government_instrumentality |
                governmental_unit |
                incorporated_non_profit |
                limited_liability_partnership |
                llc |
                multi_member_llc |
                private_company |
                private_corporation |
                private_partnership |
                public_company |
                public_corporation |
                public_partnership |
                single_member_llc |
                sole_establishment |
                sole_proprietorship |
                tax_exempt_government_instrumentality |
                unincorporated_association |
                unincorporated_non_profit,
            registration_number => binary(),
            phone => binary(),
            ownership_declaration =>
                #{user_agent => binary(),
                  ip => binary(),
                  date => integer(),
                  _ := json:value()},
            owners_provided => boolean(),
            name_kanji => binary(),
            name_kana => binary(),
            name => binary(),
            executives_provided => boolean(),
            directors_provided => boolean(),
            address_kanji =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address_kana =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      capabilities =>
          #{transfers => #{requested => boolean(), _ := json:value()},
            tax_reporting_us_1099_misc => #{requested => boolean(), _ := json:value()},
            tax_reporting_us_1099_k => #{requested => boolean(), _ := json:value()},
            sofort_payments => #{requested => boolean(), _ := json:value()},
            sepa_debit_payments => #{requested => boolean(), _ := json:value()},
            p24_payments => #{requested => boolean(), _ := json:value()},
            oxxo_payments => #{requested => boolean(), _ := json:value()},
            legacy_payments => #{requested => boolean(), _ := json:value()},
            klarna_payments => #{requested => boolean(), _ := json:value()},
            jcb_payments => #{requested => boolean(), _ := json:value()},
            ideal_payments => #{requested => boolean(), _ := json:value()},
            grabpay_payments => #{requested => boolean(), _ := json:value()},
            giropay_payments => #{requested => boolean(), _ := json:value()},
            fpx_payments => #{requested => boolean(), _ := json:value()},
            eps_payments => #{requested => boolean(), _ := json:value()},
            cartes_bancaires_payments => #{requested => boolean(), _ := json:value()},
            card_payments => #{requested => boolean(), _ := json:value()},
            card_issuing => #{requested => boolean(), _ := json:value()},
            boleto_payments => #{requested => boolean(), _ := json:value()},
            bancontact_payments => #{requested => boolean(), _ := json:value()},
            bacs_debit_payments => #{requested => boolean(), _ := json:value()},
            au_becs_debit_payments => #{requested => boolean(), _ := json:value()},
            afterpay_clearpay_payments => #{requested => boolean(), _ := json:value()},
            acss_debit_payments => #{requested => boolean(), _ := json:value()},
            _ := json:value()},
      business_type => company | government_entity | individual | non_profit,
      business_profile =>
          #{url => binary(),
            support_url => binary() | '',
            support_phone => binary(),
            support_email => binary(),
            support_address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            product_description => binary(),
            name => binary(),
            mcc => binary(),
            _ := json:value()},
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_type => checking | futsu | savings | toza,
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary(),
      account_token => binary()}.
-type post_accounts_account_response() :: stripe_model:error() | stripe_model:account().
-type get_accounts_account_request() ::
    #{account := binary(),
      query => get_accounts_account_request_query(),
      header => get_accounts_account_request_header(),
      cookie => get_accounts_account_request_cookie(),
      body => {binary(), get_accounts_account_request_body()}}.
-type get_accounts_account_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_request_header() :: map().
-type get_accounts_account_request_cookie() :: map().
-type get_accounts_account_request_body() :: #{}.
-type get_accounts_account_response() :: stripe_model:error() | stripe_model:account().
-type post_subscription_schedules_schedule_request() ::
    #{schedule := binary(),
      query => post_subscription_schedules_schedule_request_query(),
      header => post_subscription_schedules_schedule_request_header(),
      cookie => post_subscription_schedules_schedule_request_cookie(),
      body => {binary(), post_subscription_schedules_schedule_request_body()}}.
-type post_subscription_schedules_schedule_request_query() :: map().
-type post_subscription_schedules_schedule_request_header() :: map().
-type post_subscription_schedules_schedule_request_cookie() :: map().
-type post_subscription_schedules_schedule_request_body() ::
    #{proration_behavior => always_invoice | create_prorations | none,
      phases =>
          [#{trial_end => integer() | now,
             trial => boolean(),
             transfer_data =>
                 #{destination := binary(),
                   amount_percent => number(),
                   _ := json:value()},
             start_date => integer() | now,
             proration_behavior => always_invoice | create_prorations | none,
             iterations => integer(),
             items :=
                 [#{tax_rates => [binary()] | '',
                    quantity => integer(),
                    price_data =>
                        #{unit_amount_decimal => binary(),
                          unit_amount => integer(),
                          tax_behavior => exclusive | inclusive | unspecified,
                          recurring :=
                              #{interval_count => integer(),
                                interval := day | month | week | year,
                                _ := json:value()},
                          product := binary(),
                          currency := binary(),
                          _ := json:value()},
                    price => binary(),
                    billing_thresholds => #{usage_gte := integer(), _ := json:value()} | '',
                    _ := json:value()}],
             invoice_settings => #{days_until_due => integer(), _ := json:value()},
             end_date => integer() | now,
             default_tax_rates => [binary()] | '',
             default_payment_method => binary(),
             coupon => binary(),
             collection_method => charge_automatically | send_invoice,
             billing_thresholds =>
                 #{reset_billing_cycle_anchor => boolean(),
                   amount_gte => integer(),
                   _ := json:value()} |
                 '',
             billing_cycle_anchor => automatic | phase_start,
             automatic_tax => #{enabled := boolean(), _ := json:value()},
             application_fee_percent => number(),
             add_invoice_items =>
                 [#{tax_rates => [binary()] | '',
                    quantity => integer(),
                    price_data =>
                        #{unit_amount_decimal => binary(),
                          unit_amount => integer(),
                          tax_behavior => exclusive | inclusive | unspecified,
                          product := binary(),
                          currency := binary(),
                          _ := json:value()},
                    price => binary(),
                    _ := json:value()}],
             _ := json:value()}],
      metadata => json:value() | '',
      expand => [binary()],
      end_behavior => cancel | none | release | renew,
      default_settings =>
          #{transfer_data =>
                #{destination := binary(),
                  amount_percent => number(),
                  _ := json:value()} |
                '',
            invoice_settings => #{days_until_due => integer(), _ := json:value()},
            default_payment_method => binary(),
            collection_method => charge_automatically | send_invoice,
            billing_thresholds =>
                #{reset_billing_cycle_anchor => boolean(),
                  amount_gte => integer(),
                  _ := json:value()} |
                '',
            billing_cycle_anchor => automatic | phase_start,
            automatic_tax => #{enabled := boolean(), _ := json:value()},
            application_fee_percent => number(),
            _ := json:value()}}.
-type post_subscription_schedules_schedule_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type get_subscription_schedules_schedule_request() ::
    #{schedule := binary(),
      query => get_subscription_schedules_schedule_request_query(),
      header => get_subscription_schedules_schedule_request_header(),
      cookie => get_subscription_schedules_schedule_request_cookie(),
      body => {binary(), get_subscription_schedules_schedule_request_body()}}.
-type get_subscription_schedules_schedule_request_query() :: #{expand => [binary()]}.
-type get_subscription_schedules_schedule_request_header() :: map().
-type get_subscription_schedules_schedule_request_cookie() :: map().
-type get_subscription_schedules_schedule_request_body() :: #{}.
-type get_subscription_schedules_schedule_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type post_invoices_invoice_pay_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_pay_request_query(),
      header => post_invoices_invoice_pay_request_header(),
      cookie => post_invoices_invoice_pay_request_cookie(),
      body => {binary(), post_invoices_invoice_pay_request_body()}}.
-type post_invoices_invoice_pay_request_query() :: map().
-type post_invoices_invoice_pay_request_header() :: map().
-type post_invoices_invoice_pay_request_cookie() :: map().
-type post_invoices_invoice_pay_request_body() ::
    #{source => binary(),
      payment_method => binary(),
      paid_out_of_band => boolean(),
      off_session => boolean(),
      forgive => boolean(),
      expand => [binary()]}.
-type post_invoices_invoice_pay_response() ::
    stripe_model:error() | stripe_model:invoice().
-type post_transfers_transfer_reversals_id_request() ::
    #{id := binary(),
      transfer := binary(),
      query => post_transfers_transfer_reversals_id_request_query(),
      header => post_transfers_transfer_reversals_id_request_header(),
      cookie => post_transfers_transfer_reversals_id_request_cookie(),
      body => {binary(), post_transfers_transfer_reversals_id_request_body()}}.
-type post_transfers_transfer_reversals_id_request_query() :: map().
-type post_transfers_transfer_reversals_id_request_header() :: map().
-type post_transfers_transfer_reversals_id_request_cookie() :: map().
-type post_transfers_transfer_reversals_id_request_body() ::
    #{metadata => json:value() | '', expand => [binary()]}.
-type post_transfers_transfer_reversals_id_response() ::
    stripe_model:error() | stripe_model:transfer_reversal().
-type get_transfers_transfer_reversals_id_request() ::
    #{id := binary(),
      transfer := binary(),
      query => get_transfers_transfer_reversals_id_request_query(),
      header => get_transfers_transfer_reversals_id_request_header(),
      cookie => get_transfers_transfer_reversals_id_request_cookie(),
      body => {binary(), get_transfers_transfer_reversals_id_request_body()}}.
-type get_transfers_transfer_reversals_id_request_query() :: #{expand => [binary()]}.
-type get_transfers_transfer_reversals_id_request_header() :: map().
-type get_transfers_transfer_reversals_id_request_cookie() :: map().
-type get_transfers_transfer_reversals_id_request_body() :: #{}.
-type get_transfers_transfer_reversals_id_response() ::
    stripe_model:error() | stripe_model:transfer_reversal().
-type post_topups_topup_request() ::
    #{topup := binary(),
      query => post_topups_topup_request_query(),
      header => post_topups_topup_request_header(),
      cookie => post_topups_topup_request_cookie(),
      body => {binary(), post_topups_topup_request_body()}}.
-type post_topups_topup_request_query() :: map().
-type post_topups_topup_request_header() :: map().
-type post_topups_topup_request_cookie() :: map().
-type post_topups_topup_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      description => binary()}.
-type post_topups_topup_response() :: stripe_model:error() | stripe_model:topup().
-type get_topups_topup_request() ::
    #{topup := binary(),
      query => get_topups_topup_request_query(),
      header => get_topups_topup_request_header(),
      cookie => get_topups_topup_request_cookie(),
      body => {binary(), get_topups_topup_request_body()}}.
-type get_topups_topup_request_query() :: #{expand => [binary()]}.
-type get_topups_topup_request_header() :: map().
-type get_topups_topup_request_cookie() :: map().
-type get_topups_topup_request_body() :: #{}.
-type get_topups_topup_response() :: stripe_model:error() | stripe_model:topup().
-type delete_recipients_id_request() ::
    #{id := binary(),
      query => delete_recipients_id_request_query(),
      header => delete_recipients_id_request_header(),
      cookie => delete_recipients_id_request_cookie(),
      body => {binary(), delete_recipients_id_request_body()}}.
-type delete_recipients_id_request_query() :: map().
-type delete_recipients_id_request_header() :: map().
-type delete_recipients_id_request_cookie() :: map().
-type delete_recipients_id_request_body() :: #{}.
-type delete_recipients_id_response() ::
    stripe_model:error() | stripe_model:deleted_recipient().
-type post_recipients_id_request() ::
    #{id := binary(),
      query => post_recipients_id_request_query(),
      header => post_recipients_id_request_header(),
      cookie => post_recipients_id_request_cookie(),
      body => {binary(), post_recipients_id_request_body()}}.
-type post_recipients_id_request_query() :: map().
-type post_recipients_id_request_header() :: map().
-type post_recipients_id_request_cookie() :: map().
-type post_recipients_id_request_body() ::
    #{tax_id => binary(),
      name => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      email => binary(),
      description => binary(),
      default_card => binary(),
      card => binary(),
      bank_account => binary()}.
-type post_recipients_id_response() :: stripe_model:error() | stripe_model:recipient().
-type get_recipients_id_request() ::
    #{id := binary(),
      query => get_recipients_id_request_query(),
      header => get_recipients_id_request_header(),
      cookie => get_recipients_id_request_cookie(),
      body => {binary(), get_recipients_id_request_body()}}.
-type get_recipients_id_request_query() :: #{expand => [binary()]}.
-type get_recipients_id_request_header() :: map().
-type get_recipients_id_request_cookie() :: map().
-type get_recipients_id_request_body() :: #{}.
-type get_recipients_id_response() ::
    stripe_model:error() | stripe_model:recipient() | stripe_model:deleted_recipient().
-type get_invoices_invoice_lines_request() ::
    #{invoice := binary(),
      query => get_invoices_invoice_lines_request_query(),
      header => get_invoices_invoice_lines_request_header(),
      cookie => get_invoices_invoice_lines_request_cookie(),
      body => {binary(), get_invoices_invoice_lines_request_body()}}.
-type get_invoices_invoice_lines_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_invoices_invoice_lines_request_header() :: map().
-type get_invoices_invoice_lines_request_cookie() :: map().
-type get_invoices_invoice_lines_request_body() :: #{}.
-type get_invoices_invoice_lines_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:line_item()],
      _ := json:value()}.
-type delete_accounts_account_external_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => delete_accounts_account_external_accounts_id_request_query(),
      header => delete_accounts_account_external_accounts_id_request_header(),
      cookie => delete_accounts_account_external_accounts_id_request_cookie(),
      body => {binary(), delete_accounts_account_external_accounts_id_request_body()}}.
-type delete_accounts_account_external_accounts_id_request_query() :: map().
-type delete_accounts_account_external_accounts_id_request_header() :: map().
-type delete_accounts_account_external_accounts_id_request_cookie() :: map().
-type delete_accounts_account_external_accounts_id_request_body() :: #{}.
-type delete_accounts_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:deleted_external_account().
-type post_accounts_account_external_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => post_accounts_account_external_accounts_id_request_query(),
      header => post_accounts_account_external_accounts_id_request_header(),
      cookie => post_accounts_account_external_accounts_id_request_cookie(),
      body => {binary(), post_accounts_account_external_accounts_id_request_body()}}.
-type post_accounts_account_external_accounts_id_request_query() :: map().
-type post_accounts_account_external_accounts_id_request_header() :: map().
-type post_accounts_account_external_accounts_id_request_cookie() :: map().
-type post_accounts_account_external_accounts_id_request_body() ::
    #{name => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      exp_year => binary(),
      exp_month => binary(),
      default_for_currency => boolean(),
      address_zip => binary(),
      address_state => binary(),
      address_line2 => binary(),
      address_line1 => binary(),
      address_country => binary(),
      address_city => binary(),
      account_type => checking | futsu | savings | toza,
      account_holder_type => '' | company | individual,
      account_holder_name => binary()}.
-type post_accounts_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_accounts_account_external_accounts_id_request() ::
    #{account := binary(),
      id := binary(),
      query => get_accounts_account_external_accounts_id_request_query(),
      header => get_accounts_account_external_accounts_id_request_header(),
      cookie => get_accounts_account_external_accounts_id_request_cookie(),
      body => {binary(), get_accounts_account_external_accounts_id_request_body()}}.
-type get_accounts_account_external_accounts_id_request_query() ::
    #{expand => [binary()]}.
-type get_accounts_account_external_accounts_id_request_header() :: map().
-type get_accounts_account_external_accounts_id_request_cookie() :: map().
-type get_accounts_account_external_accounts_id_request_body() :: #{}.
-type get_accounts_account_external_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type post_topups_request() ::
    #{query => post_topups_request_query(),
      header => post_topups_request_header(),
      cookie => post_topups_request_cookie(),
      body := {binary(), post_topups_request_body()}}.
-type post_topups_request_query() :: map().
-type post_topups_request_header() :: map().
-type post_topups_request_cookie() :: map().
-type post_topups_request_body() ::
    #{transfer_group => binary(),
      statement_descriptor => binary(),
      source => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      description => binary(),
      currency := binary(),
      amount := integer()}.
-type post_topups_response() :: stripe_model:error() | stripe_model:topup().
-type get_topups_request() ::
    #{query => get_topups_request_query(),
      header => get_topups_request_header(),
      cookie => get_topups_request_cookie(),
      body => {binary(), get_topups_request_body()}}.
-type get_topups_request_query() ::
    #{amount =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => canceled | failed | pending | succeeded}.
-type get_topups_request_header() :: map().
-type get_topups_request_cookie() :: map().
-type get_topups_request_body() :: #{}.
-type get_topups_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:topup()],
      _ := json:value()}.
-type post_orders_id_returns_request() ::
    #{id := binary(),
      query => post_orders_id_returns_request_query(),
      header => post_orders_id_returns_request_header(),
      cookie => post_orders_id_returns_request_cookie(),
      body => {binary(), post_orders_id_returns_request_body()}}.
-type post_orders_id_returns_request_query() :: map().
-type post_orders_id_returns_request_header() :: map().
-type post_orders_id_returns_request_cookie() :: map().
-type post_orders_id_returns_request_body() ::
    #{items =>
          [#{type => discount | shipping | sku | tax,
             quantity => integer(),
             parent => binary(),
             description => binary(),
             amount => integer(),
             _ := json:value()}] |
          '',
      expand => [binary()]}.
-type post_orders_id_returns_response() ::
    stripe_model:error() | stripe_model:order_return().
-type post_orders_id_request() ::
    #{id := binary(),
      query => post_orders_id_request_query(),
      header => post_orders_id_request_header(),
      cookie => post_orders_id_request_cookie(),
      body => {binary(), post_orders_id_request_body()}}.
-type post_orders_id_request_query() :: map().
-type post_orders_id_request_header() :: map().
-type post_orders_id_request_cookie() :: map().
-type post_orders_id_request_body() ::
    #{status => canceled | created | fulfilled | paid | returned,
      shipping =>
          #{tracking_number := binary(),
            carrier := binary(),
            _ := json:value()},
      selected_shipping_method => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      coupon => binary()}.
-type post_orders_id_response() :: stripe_model:error() | stripe_model:order().
-type get_orders_id_request() ::
    #{id := binary(),
      query => get_orders_id_request_query(),
      header => get_orders_id_request_header(),
      cookie => get_orders_id_request_cookie(),
      body => {binary(), get_orders_id_request_body()}}.
-type get_orders_id_request_query() :: #{expand => [binary()]}.
-type get_orders_id_request_header() :: map().
-type get_orders_id_request_cookie() :: map().
-type get_orders_id_request_body() :: #{}.
-type get_orders_id_response() :: stripe_model:error() | stripe_model:order().
-type delete_apple_pay_domains_domain_request() ::
    #{domain := binary(),
      query => delete_apple_pay_domains_domain_request_query(),
      header => delete_apple_pay_domains_domain_request_header(),
      cookie => delete_apple_pay_domains_domain_request_cookie(),
      body => {binary(), delete_apple_pay_domains_domain_request_body()}}.
-type delete_apple_pay_domains_domain_request_query() :: map().
-type delete_apple_pay_domains_domain_request_header() :: map().
-type delete_apple_pay_domains_domain_request_cookie() :: map().
-type delete_apple_pay_domains_domain_request_body() :: #{}.
-type delete_apple_pay_domains_domain_response() ::
    stripe_model:error() | stripe_model:deleted_apple_pay_domain().
-type get_apple_pay_domains_domain_request() ::
    #{domain := binary(),
      query => get_apple_pay_domains_domain_request_query(),
      header => get_apple_pay_domains_domain_request_header(),
      cookie => get_apple_pay_domains_domain_request_cookie(),
      body => {binary(), get_apple_pay_domains_domain_request_body()}}.
-type get_apple_pay_domains_domain_request_query() :: #{expand => [binary()]}.
-type get_apple_pay_domains_domain_request_header() :: map().
-type get_apple_pay_domains_domain_request_cookie() :: map().
-type get_apple_pay_domains_domain_request_body() :: #{}.
-type get_apple_pay_domains_domain_response() ::
    stripe_model:error() | stripe_model:apple_pay_domain().
-type get_issuing_transactions_request() ::
    #{query => get_issuing_transactions_request_query(),
      header => get_issuing_transactions_request_header(),
      cookie => get_issuing_transactions_request_cookie(),
      body => {binary(), get_issuing_transactions_request_body()}}.
-type get_issuing_transactions_request_query() ::
    #{card => binary(),
      cardholder => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type => capture | refund}.
-type get_issuing_transactions_request_header() :: map().
-type get_issuing_transactions_request_cookie() :: map().
-type get_issuing_transactions_request_body() :: #{}.
-type get_issuing_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_transaction()],
      _ := json:value()}.
-type post_charges_charge_refund_request() ::
    #{charge := binary(),
      query => post_charges_charge_refund_request_query(),
      header => post_charges_charge_refund_request_header(),
      cookie => post_charges_charge_refund_request_cookie(),
      body => {binary(), post_charges_charge_refund_request_body()}}.
-type post_charges_charge_refund_request_query() :: map().
-type post_charges_charge_refund_request_header() :: map().
-type post_charges_charge_refund_request_cookie() :: map().
-type post_charges_charge_refund_request_body() ::
    #{reverse_transfer => boolean(),
      refund_application_fee => boolean(),
      reason => duplicate | fraudulent | requested_by_customer,
      payment_intent => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      amount => integer()}.
-type post_charges_charge_refund_response() ::
    stripe_model:error() | stripe_model:charge().
-type post_payment_methods_payment_method_attach_request() ::
    #{payment_method := binary(),
      query => post_payment_methods_payment_method_attach_request_query(),
      header => post_payment_methods_payment_method_attach_request_header(),
      cookie => post_payment_methods_payment_method_attach_request_cookie(),
      body := {binary(), post_payment_methods_payment_method_attach_request_body()}}.
-type post_payment_methods_payment_method_attach_request_query() :: map().
-type post_payment_methods_payment_method_attach_request_header() :: map().
-type post_payment_methods_payment_method_attach_request_cookie() :: map().
-type post_payment_methods_payment_method_attach_request_body() ::
    #{expand => [binary()], customer := binary()}.
-type post_payment_methods_payment_method_attach_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type post_payment_intents_intent_cancel_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_cancel_request_query(),
      header => post_payment_intents_intent_cancel_request_header(),
      cookie => post_payment_intents_intent_cancel_request_cookie(),
      body => {binary(), post_payment_intents_intent_cancel_request_body()}}.
-type post_payment_intents_intent_cancel_request_query() :: map().
-type post_payment_intents_intent_cancel_request_header() :: map().
-type post_payment_intents_intent_cancel_request_cookie() :: map().
-type post_payment_intents_intent_cancel_request_body() ::
    #{expand => [binary()],
      cancellation_reason => abandoned | duplicate | fraudulent | requested_by_customer}.
-type post_payment_intents_intent_cancel_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type get_accounts_account_capabilities_request() ::
    #{account := binary(),
      query => get_accounts_account_capabilities_request_query(),
      header => get_accounts_account_capabilities_request_header(),
      cookie => get_accounts_account_capabilities_request_cookie(),
      body => {binary(), get_accounts_account_capabilities_request_body()}}.
-type get_accounts_account_capabilities_request_query() :: #{expand => [binary()]}.
-type get_accounts_account_capabilities_request_header() :: map().
-type get_accounts_account_capabilities_request_cookie() :: map().
-type get_accounts_account_capabilities_request_body() :: #{}.
-type get_accounts_account_capabilities_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:capability()],
      _ := json:value()}.
-type get_credit_notes_preview_lines_request() ::
    #{query => get_credit_notes_preview_lines_request_query(),
      header => get_credit_notes_preview_lines_request_header(),
      cookie => get_credit_notes_preview_lines_request_cookie(),
      body => {binary(), get_credit_notes_preview_lines_request_body()}}.
-type get_credit_notes_preview_lines_request_query() ::
    #{amount => integer(),
      credit_amount => integer(),
      ending_before => binary(),
      expand => [binary()],
      invoice := binary(),
      limit => integer(),
      lines =>
          [#{unit_amount_decimal => binary(),
             unit_amount => integer(),
             type := custom_line_item | invoice_line_item,
             tax_rates => [binary()] | '',
             quantity => integer(),
             invoice_line_item => binary(),
             description => binary(),
             amount => integer(),
             _ := json:value()}],
      memo => binary(),
      metadata => json:value(),
      out_of_band_amount => integer(),
      reason => duplicate | fraudulent | order_change | product_unsatisfactory,
      refund => binary(),
      refund_amount => integer(),
      starting_after => binary()}.
-type get_credit_notes_preview_lines_request_header() :: map().
-type get_credit_notes_preview_lines_request_cookie() :: map().
-type get_credit_notes_preview_lines_request_body() :: #{}.
-type get_credit_notes_preview_lines_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:credit_note_line_item()],
      _ := json:value()}.
-type post_subscriptions_request() ::
    #{query => post_subscriptions_request_query(),
      header => post_subscriptions_request_header(),
      cookie => post_subscriptions_request_cookie(),
      body := {binary(), post_subscriptions_request_body()}}.
-type post_subscriptions_request_query() :: map().
-type post_subscriptions_request_header() :: map().
-type post_subscriptions_request_cookie() :: map().
-type post_subscriptions_request_body() ::
    #{trial_period_days => integer(),
      trial_from_plan => boolean(),
      trial_end => now | integer(),
      transfer_data =>
          #{destination := binary(),
            amount_percent => number(),
            _ := json:value()},
      proration_behavior => always_invoice | create_prorations | none,
      promotion_code => binary(),
      pending_invoice_item_interval =>
          #{interval_count => integer(),
            interval := day | month | week | year,
            _ := json:value()} |
          '',
      payment_settings =>
          #{payment_method_types =>
                [ach_credit_transfer |
                 ach_debit |
                 acss_debit |
                 au_becs_debit |
                 bacs_debit |
                 bancontact |
                 boleto |
                 card |
                 fpx |
                 giropay |
                 grabpay |
                 ideal |
                 sepa_debit |
                 sofort |
                 wechat_pay] |
                '',
            payment_method_options =>
                #{card =>
                      #{request_three_d_secure => any | automatic,
                        mandate_options =>
                            #{description => binary(),
                              amount_type => fixed | maximum,
                              amount => integer(),
                              _ := json:value()},
                        _ := json:value()} |
                      '',
                  bancontact => #{preferred_language => de | en | fr | nl, _ := json:value()} | '',
                  acss_debit =>
                      #{verification_method => automatic | instant | microdeposits,
                        mandate_options =>
                            #{transaction_type => business | personal, _ := json:value()},
                        _ := json:value()} |
                      '',
                  _ := json:value()},
            _ := json:value()},
      payment_behavior =>
          allow_incomplete | default_incomplete | error_if_incomplete | pending_if_incomplete,
      off_session => boolean(),
      metadata => json:value() | '',
      items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring :=
                       #{interval_count => integer(),
                         interval := day | month | week | year,
                         _ := json:value()},
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             metadata => json:value(),
             billing_thresholds => #{usage_gte := integer(), _ := json:value()} | '',
             _ := json:value()}],
      expand => [binary()],
      default_tax_rates => [binary()] | '',
      default_source => binary(),
      default_payment_method => binary(),
      days_until_due => integer(),
      customer := binary(),
      coupon => binary(),
      collection_method => charge_automatically | send_invoice,
      cancel_at_period_end => boolean(),
      cancel_at => integer(),
      billing_thresholds =>
          #{reset_billing_cycle_anchor => boolean(),
            amount_gte => integer(),
            _ := json:value()} |
          '',
      billing_cycle_anchor => integer(),
      backdate_start_date => integer(),
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      application_fee_percent => number(),
      add_invoice_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             _ := json:value()}]}.
-type post_subscriptions_response() :: stripe_model:error() | stripe_model:subscription().
-type get_subscriptions_request() ::
    #{query => get_subscriptions_request_query(),
      header => get_subscriptions_request_header(),
      cookie => get_subscriptions_request_cookie(),
      body => {binary(), get_subscriptions_request_body()}}.
-type get_subscriptions_request_query() ::
    #{collection_method => charge_automatically | send_invoice,
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      current_period_end =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      current_period_start =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      price => binary(),
      starting_after => binary(),
      status =>
          active |
          all |
          canceled |
          ended |
          incomplete |
          incomplete_expired |
          past_due |
          trialing |
          unpaid}.
-type get_subscriptions_request_header() :: map().
-type get_subscriptions_request_cookie() :: map().
-type get_subscriptions_request_body() :: #{}.
-type get_subscriptions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:subscription()],
      _ := json:value()}.
-type get_setup_attempts_request() ::
    #{query => get_setup_attempts_request_query(),
      header => get_setup_attempts_request_header(),
      cookie => get_setup_attempts_request_cookie(),
      body => {binary(), get_setup_attempts_request_body()}}.
-type get_setup_attempts_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      setup_intent := binary(),
      starting_after => binary()}.
-type get_setup_attempts_request_header() :: map().
-type get_setup_attempts_request_cookie() :: map().
-type get_setup_attempts_request_body() :: #{}.
-type get_setup_attempts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:setup_attempt()],
      _ := json:value()}.
-type delete_customers_customer_subscriptions_subscription_exposed_id_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query => delete_customers_customer_subscriptions_subscription_exposed_id_request_query(),
      header =>
          delete_customers_customer_subscriptions_subscription_exposed_id_request_header(),
      cookie =>
          delete_customers_customer_subscriptions_subscription_exposed_id_request_cookie(),
      body =>
          {binary(),
           delete_customers_customer_subscriptions_subscription_exposed_id_request_body()}}.
-type delete_customers_customer_subscriptions_subscription_exposed_id_request_query() ::
    map().
-type delete_customers_customer_subscriptions_subscription_exposed_id_request_header() ::
    map().
-type delete_customers_customer_subscriptions_subscription_exposed_id_request_cookie() ::
    map().
-type delete_customers_customer_subscriptions_subscription_exposed_id_request_body() ::
    #{prorate => boolean(),
      invoice_now => boolean(),
      expand => [binary()]}.
-type delete_customers_customer_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type post_customers_customer_subscriptions_subscription_exposed_id_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query => post_customers_customer_subscriptions_subscription_exposed_id_request_query(),
      header => post_customers_customer_subscriptions_subscription_exposed_id_request_header(),
      cookie => post_customers_customer_subscriptions_subscription_exposed_id_request_cookie(),
      body =>
          {binary(), post_customers_customer_subscriptions_subscription_exposed_id_request_body()}}.
-type post_customers_customer_subscriptions_subscription_exposed_id_request_query() ::
    map().
-type post_customers_customer_subscriptions_subscription_exposed_id_request_header() ::
    map().
-type post_customers_customer_subscriptions_subscription_exposed_id_request_cookie() ::
    map().
-type post_customers_customer_subscriptions_subscription_exposed_id_request_body() ::
    #{trial_from_plan => boolean(),
      trial_end => now | integer(),
      transfer_data =>
          #{destination := binary(),
            amount_percent => number(),
            _ := json:value()} |
          '',
      proration_date => integer(),
      proration_behavior => always_invoice | create_prorations | none,
      promotion_code => binary(),
      pending_invoice_item_interval =>
          #{interval_count => integer(),
            interval := day | month | week | year,
            _ := json:value()} |
          '',
      payment_settings =>
          #{payment_method_types =>
                [ach_credit_transfer |
                 ach_debit |
                 acss_debit |
                 au_becs_debit |
                 bacs_debit |
                 bancontact |
                 boleto |
                 card |
                 fpx |
                 giropay |
                 grabpay |
                 ideal |
                 sepa_debit |
                 sofort |
                 wechat_pay] |
                '',
            payment_method_options =>
                #{card =>
                      #{request_three_d_secure => any | automatic,
                        mandate_options =>
                            #{description => binary(),
                              amount_type => fixed | maximum,
                              amount => integer(),
                              _ := json:value()},
                        _ := json:value()} |
                      '',
                  bancontact => #{preferred_language => de | en | fr | nl, _ := json:value()} | '',
                  acss_debit =>
                      #{verification_method => automatic | instant | microdeposits,
                        mandate_options =>
                            #{transaction_type => business | personal, _ := json:value()},
                        _ := json:value()} |
                      '',
                  _ := json:value()},
            _ := json:value()},
      payment_behavior =>
          allow_incomplete | default_incomplete | error_if_incomplete | pending_if_incomplete,
      pause_collection =>
          #{resumes_at => integer(),
            behavior := keep_as_draft | mark_uncollectible | void,
            _ := json:value()} |
          '',
      off_session => boolean(),
      metadata => json:value() | '',
      items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring :=
                       #{interval_count => integer(),
                         interval := day | month | week | year,
                         _ := json:value()},
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             metadata => json:value() | '',
             id => binary(),
             deleted => boolean(),
             clear_usage => boolean(),
             billing_thresholds => #{usage_gte := integer(), _ := json:value()} | '',
             _ := json:value()}],
      expand => [binary()],
      default_tax_rates => [binary()] | '',
      default_source => binary(),
      default_payment_method => binary(),
      days_until_due => integer(),
      coupon => binary(),
      collection_method => charge_automatically | send_invoice,
      cancel_at_period_end => boolean(),
      cancel_at => integer() | '',
      billing_thresholds =>
          #{reset_billing_cycle_anchor => boolean(),
            amount_gte => integer(),
            _ := json:value()} |
          '',
      billing_cycle_anchor => now | unchanged,
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      application_fee_percent => number(),
      add_invoice_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             _ := json:value()}]}.
-type post_customers_customer_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_customers_customer_subscriptions_subscription_exposed_id_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query => get_customers_customer_subscriptions_subscription_exposed_id_request_query(),
      header => get_customers_customer_subscriptions_subscription_exposed_id_request_header(),
      cookie => get_customers_customer_subscriptions_subscription_exposed_id_request_cookie(),
      body =>
          {binary(), get_customers_customer_subscriptions_subscription_exposed_id_request_body()}}.
-type get_customers_customer_subscriptions_subscription_exposed_id_request_query() ::
    #{expand => [binary()]}.
-type get_customers_customer_subscriptions_subscription_exposed_id_request_header() ::
    map().
-type get_customers_customer_subscriptions_subscription_exposed_id_request_cookie() ::
    map().
-type get_customers_customer_subscriptions_subscription_exposed_id_request_body() :: #{}.
-type get_customers_customer_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_bitcoin_receivers_id_request() ::
    #{id := binary(),
      query => get_bitcoin_receivers_id_request_query(),
      header => get_bitcoin_receivers_id_request_header(),
      cookie => get_bitcoin_receivers_id_request_cookie(),
      body => {binary(), get_bitcoin_receivers_id_request_body()}}.
-type get_bitcoin_receivers_id_request_query() :: #{expand => [binary()]}.
-type get_bitcoin_receivers_id_request_header() :: map().
-type get_bitcoin_receivers_id_request_cookie() :: map().
-type get_bitcoin_receivers_id_request_body() :: #{}.
-type get_bitcoin_receivers_id_response() ::
    stripe_model:error() | stripe_model:bitcoin_receiver().
-type post_orders_request() ::
    #{query => post_orders_request_query(),
      header => post_orders_request_header(),
      cookie => post_orders_request_cookie(),
      body := {binary(), post_orders_request_body()}}.
-type post_orders_request_query() :: map().
-type post_orders_request_header() :: map().
-type post_orders_request_cookie() :: map().
-type post_orders_request_body() ::
    #{shipping =>
          #{phone => binary(),
            name := binary(),
            address :=
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      metadata => json:value(),
      items =>
          [#{type => discount | shipping | sku | tax,
             quantity => integer(),
             parent => binary(),
             description => binary(),
             currency => binary(),
             amount => integer(),
             _ := json:value()}],
      expand => [binary()],
      email => binary(),
      customer => binary(),
      currency := binary(),
      coupon => binary()}.
-type post_orders_response() :: stripe_model:error() | stripe_model:order().
-type get_orders_request() ::
    #{query => get_orders_request_query(),
      header => get_orders_request_header(),
      cookie => get_orders_request_cookie(),
      body => {binary(), get_orders_request_body()}}.
-type get_orders_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      ids => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => binary(),
      status_transitions =>
          #{returned =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer(),
                  _ := json:value()} |
                integer(),
            paid =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer(),
                  _ := json:value()} |
                integer(),
            fulfilled =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer(),
                  _ := json:value()} |
                integer(),
            canceled =>
                #{lte => integer(),
                  lt => integer(),
                  gte => integer(),
                  gt => integer(),
                  _ := json:value()} |
                integer(),
            _ := json:value()},
      upstream_ids => [binary()]}.
-type get_orders_request_header() :: map().
-type get_orders_request_cookie() :: map().
-type get_orders_request_body() :: #{}.
-type get_orders_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:order()],
      _ := json:value()}.
-type post_ephemeral_keys_request() ::
    #{query => post_ephemeral_keys_request_query(),
      header => post_ephemeral_keys_request_header(),
      cookie => post_ephemeral_keys_request_cookie(),
      body => {binary(), post_ephemeral_keys_request_body()}}.
-type post_ephemeral_keys_request_query() :: map().
-type post_ephemeral_keys_request_header() :: map().
-type post_ephemeral_keys_request_cookie() :: map().
-type post_ephemeral_keys_request_body() ::
    #{issuing_card => binary(),
      expand => [binary()],
      customer => binary()}.
-type post_ephemeral_keys_response() ::
    stripe_model:error() | stripe_model:ephemeral_key().
-type delete_webhook_endpoints_webhook_endpoint_request() ::
    #{webhook_endpoint := binary(),
      query => delete_webhook_endpoints_webhook_endpoint_request_query(),
      header => delete_webhook_endpoints_webhook_endpoint_request_header(),
      cookie => delete_webhook_endpoints_webhook_endpoint_request_cookie(),
      body => {binary(), delete_webhook_endpoints_webhook_endpoint_request_body()}}.
-type delete_webhook_endpoints_webhook_endpoint_request_query() :: map().
-type delete_webhook_endpoints_webhook_endpoint_request_header() :: map().
-type delete_webhook_endpoints_webhook_endpoint_request_cookie() :: map().
-type delete_webhook_endpoints_webhook_endpoint_request_body() :: #{}.
-type delete_webhook_endpoints_webhook_endpoint_response() ::
    stripe_model:error() | stripe_model:deleted_webhook_endpoint().
-type post_webhook_endpoints_webhook_endpoint_request() ::
    #{webhook_endpoint := binary(),
      query => post_webhook_endpoints_webhook_endpoint_request_query(),
      header => post_webhook_endpoints_webhook_endpoint_request_header(),
      cookie => post_webhook_endpoints_webhook_endpoint_request_cookie(),
      body => {binary(), post_webhook_endpoints_webhook_endpoint_request_body()}}.
-type post_webhook_endpoints_webhook_endpoint_request_query() :: map().
-type post_webhook_endpoints_webhook_endpoint_request_header() :: map().
-type post_webhook_endpoints_webhook_endpoint_request_cookie() :: map().
-type post_webhook_endpoints_webhook_endpoint_request_body() ::
    #{url => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      enabled_events =>
          ['*' | 'account.application.authorized' | 'account.application.deauthorized' |
           'account.external_account.created' | 'account.external_account.deleted' |
           'account.external_account.updated' | 'account.updated' | 'application_fee.created' |
           'application_fee.refund.updated' | 'application_fee.refunded' | 'balance.available' |
           'billing_portal.configuration.created' | 'billing_portal.configuration.updated' |
           'capability.updated' | 'charge.captured' | 'charge.dispute.closed' |
           'charge.dispute.created' | 'charge.dispute.funds_reinstated' |
           'charge.dispute.funds_withdrawn' | 'charge.dispute.updated' | 'charge.expired' |
           'charge.failed' | 'charge.pending' | 'charge.refund.updated' | 'charge.refunded' |
           'charge.succeeded' | 'charge.updated' | 'checkout.session.async_payment_failed' |
           'checkout.session.async_payment_succeeded' | 'checkout.session.completed' |
           'checkout.session.expired' | 'coupon.created' | 'coupon.deleted' | 'coupon.updated' |
           'credit_note.created' | 'credit_note.updated' | 'credit_note.voided' |
           'customer.created' | 'customer.deleted' | 'customer.discount.created' |
           'customer.discount.deleted' | 'customer.discount.updated' | 'customer.source.created' |
           'customer.source.deleted' | 'customer.source.expiring' | 'customer.source.updated' |
           'customer.subscription.created' | 'customer.subscription.deleted' |
           'customer.subscription.pending_update_applied' |
           'customer.subscription.pending_update_expired' | 'customer.subscription.trial_will_end' |
           'customer.subscription.updated' | 'customer.tax_id.created' | 'customer.tax_id.deleted' |
           'customer.tax_id.updated' | 'customer.updated' | 'file.created' |
           'identity.verification_session.canceled' | 'identity.verification_session.created' |
           'identity.verification_session.processing' | 'identity.verification_session.redacted' |
           'identity.verification_session.requires_input' |
           'identity.verification_session.verified' | 'invoice.created' | 'invoice.deleted' |
           'invoice.finalization_failed' | 'invoice.finalized' | 'invoice.marked_uncollectible' |
           'invoice.paid' | 'invoice.payment_action_required' | 'invoice.payment_failed' |
           'invoice.payment_succeeded' | 'invoice.sent' | 'invoice.upcoming' | 'invoice.updated' |
           'invoice.voided' | 'invoiceitem.created' | 'invoiceitem.deleted' |
           'invoiceitem.updated' | 'issuing_authorization.created' |
           'issuing_authorization.request' | 'issuing_authorization.updated' |
           'issuing_card.created' | 'issuing_card.updated' | 'issuing_cardholder.created' |
           'issuing_cardholder.updated' | 'issuing_dispute.closed' | 'issuing_dispute.created' |
           'issuing_dispute.funds_reinstated' | 'issuing_dispute.submitted' |
           'issuing_dispute.updated' | 'issuing_transaction.created' |
           'issuing_transaction.updated' | 'mandate.updated' | 'order.created' |
           'order.payment_failed' | 'order.payment_succeeded' | 'order.updated' |
           'order_return.created' | 'payment_intent.amount_capturable_updated' |
           'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' |
           'payment_intent.processing' | 'payment_intent.requires_action' |
           'payment_intent.succeeded' | 'payment_link.created' | 'payment_link.updated' |
           'payment_method.attached' | 'payment_method.automatically_updated' |
           'payment_method.detached' | 'payment_method.updated' | 'payout.canceled' |
           'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' |
           'person.created' | 'person.deleted' | 'person.updated' | 'plan.created' |
           'plan.deleted' | 'plan.updated' | 'price.created' | 'price.deleted' | 'price.updated' |
           'product.created' | 'product.deleted' | 'product.updated' | 'promotion_code.created' |
           'promotion_code.updated' | 'quote.accepted' | 'quote.canceled' | 'quote.created' |
           'quote.finalized' | 'radar.early_fraud_warning.created' |
           'radar.early_fraud_warning.updated' | 'recipient.created' | 'recipient.deleted' |
           'recipient.updated' | 'reporting.report_run.failed' | 'reporting.report_run.succeeded' |
           'reporting.report_type.updated' | 'review.closed' | 'review.opened' |
           'setup_intent.canceled' | 'setup_intent.created' | 'setup_intent.requires_action' |
           'setup_intent.setup_failed' | 'setup_intent.succeeded' |
           'sigma.scheduled_query_run.created' | 'sku.created' | 'sku.deleted' | 'sku.updated' |
           'source.canceled' | 'source.chargeable' | 'source.failed' |
           'source.mandate_notification' | 'source.refund_attributes_required' |
           'source.transaction.created' | 'source.transaction.updated' |
           'subscription_schedule.aborted' | 'subscription_schedule.canceled' |
           'subscription_schedule.completed' | 'subscription_schedule.created' |
           'subscription_schedule.expiring' | 'subscription_schedule.released' |
           'subscription_schedule.updated' | 'tax_rate.created' | 'tax_rate.updated' |
           'topup.canceled' | 'topup.created' | 'topup.failed' | 'topup.reversed' |
           'topup.succeeded' | 'transfer.created' | 'transfer.failed' | 'transfer.paid' |
           'transfer.reversed' | 'transfer.updated'],
      disabled => boolean(),
      description => binary()}.
-type post_webhook_endpoints_webhook_endpoint_response() ::
    stripe_model:error() | stripe_model:webhook_endpoint().
-type get_webhook_endpoints_webhook_endpoint_request() ::
    #{webhook_endpoint := binary(),
      query => get_webhook_endpoints_webhook_endpoint_request_query(),
      header => get_webhook_endpoints_webhook_endpoint_request_header(),
      cookie => get_webhook_endpoints_webhook_endpoint_request_cookie(),
      body => {binary(), get_webhook_endpoints_webhook_endpoint_request_body()}}.
-type get_webhook_endpoints_webhook_endpoint_request_query() :: #{expand => [binary()]}.
-type get_webhook_endpoints_webhook_endpoint_request_header() :: map().
-type get_webhook_endpoints_webhook_endpoint_request_cookie() :: map().
-type get_webhook_endpoints_webhook_endpoint_request_body() :: #{}.
-type get_webhook_endpoints_webhook_endpoint_response() ::
    stripe_model:error() | stripe_model:webhook_endpoint().
-type post_account_persons_request() ::
    #{query => post_account_persons_request_query(),
      header => post_account_persons_request_header(),
      cookie => post_account_persons_request_cookie(),
      body => {binary(), post_account_persons_request_body()}}.
-type post_account_persons_request_query() :: map().
-type post_account_persons_request_header() :: map().
-type post_account_persons_request_cookie() :: map().
-type post_account_persons_request_body() ::
    #{verification =>
          #{document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            additional_document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            _ := json:value()},
      ssn_last_4 => binary(),
      relationship =>
          #{title => binary(),
            representative => boolean(),
            percent_ownership => number() | '',
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      political_exposure => binary(),
      phone => binary(),
      person_token => binary(),
      nationality => binary(),
      metadata => json:value() | '',
      maiden_name => binary(),
      last_name_kanji => binary(),
      last_name_kana => binary(),
      last_name => binary(),
      id_number => binary(),
      gender => binary(),
      full_name_aliases => [binary()] | '',
      first_name_kanji => binary(),
      first_name_kana => binary(),
      first_name => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{visa => #{files => [binary()], _ := json:value()},
            passport => #{files => [binary()], _ := json:value()},
            company_authorization => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      dob =>
          #{year := integer(),
            month := integer(),
            day := integer(),
            _ := json:value()} |
          '',
      address_kanji =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address_kana =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      account => binary()}.
-type post_account_persons_response() :: stripe_model:error() | stripe_model:person().
-type get_account_persons_request() ::
    #{query => get_account_persons_request_query(),
      header => get_account_persons_request_header(),
      cookie => get_account_persons_request_cookie(),
      body => {binary(), get_account_persons_request_body()}}.
-type get_account_persons_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      relationship =>
          #{representative => boolean(),
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      starting_after => binary()}.
-type get_account_persons_request_header() :: map().
-type get_account_persons_request_cookie() :: map().
-type get_account_persons_request_body() :: #{}.
-type get_account_persons_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:person()],
      _ := json:value()}.
-type get_account_capabilities_request() ::
    #{query => get_account_capabilities_request_query(),
      header => get_account_capabilities_request_header(),
      cookie => get_account_capabilities_request_cookie(),
      body => {binary(), get_account_capabilities_request_body()}}.
-type get_account_capabilities_request_query() :: #{expand => [binary()]}.
-type get_account_capabilities_request_header() :: map().
-type get_account_capabilities_request_cookie() :: map().
-type get_account_capabilities_request_body() :: #{}.
-type get_account_capabilities_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:capability()],
      _ := json:value()}.
-type post_checkout_sessions_session_expire_request() ::
    #{session := binary(),
      query => post_checkout_sessions_session_expire_request_query(),
      header => post_checkout_sessions_session_expire_request_header(),
      cookie => post_checkout_sessions_session_expire_request_cookie(),
      body => {binary(), post_checkout_sessions_session_expire_request_body()}}.
-type post_checkout_sessions_session_expire_request_query() :: map().
-type post_checkout_sessions_session_expire_request_header() :: map().
-type post_checkout_sessions_session_expire_request_cookie() :: map().
-type post_checkout_sessions_session_expire_request_body() :: #{expand => [binary()]}.
-type post_checkout_sessions_session_expire_response() ::
    stripe_model:error() | stripe_model:checkout_session().
-type get_bitcoin_receivers_receiver_transactions_request() ::
    #{receiver := binary(),
      query => get_bitcoin_receivers_receiver_transactions_request_query(),
      header => get_bitcoin_receivers_receiver_transactions_request_header(),
      cookie => get_bitcoin_receivers_receiver_transactions_request_cookie(),
      body => {binary(), get_bitcoin_receivers_receiver_transactions_request_body()}}.
-type get_bitcoin_receivers_receiver_transactions_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_bitcoin_receivers_receiver_transactions_request_header() :: map().
-type get_bitcoin_receivers_receiver_transactions_request_cookie() :: map().
-type get_bitcoin_receivers_receiver_transactions_request_body() :: #{}.
-type get_bitcoin_receivers_receiver_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bitcoin_transaction()],
      _ := json:value()}.
-type post_quotes_quote_request() ::
    #{quote := binary(),
      query => post_quotes_quote_request_query(),
      header => post_quotes_quote_request_header(),
      cookie => post_quotes_quote_request_cookie(),
      body => {binary(), post_quotes_quote_request_body()}}.
-type post_quotes_quote_request_query() :: map().
-type post_quotes_quote_request_header() :: map().
-type post_quotes_quote_request_cookie() :: map().
-type post_quotes_quote_request_body() ::
    #{transfer_data =>
          #{destination := binary(),
            amount_percent => number(),
            amount => integer(),
            _ := json:value()} |
          '',
      subscription_data =>
          #{trial_period_days => integer() | '',
            effective_date => current_period_end | integer() | '',
            _ := json:value()},
      on_behalf_of => binary() | '',
      metadata => json:value(),
      line_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring =>
                       #{interval_count => integer(),
                         interval := day | month | week | year,
                         _ := json:value()},
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             id => binary(),
             _ := json:value()}],
      invoice_settings => #{days_until_due => integer(), _ := json:value()},
      header => binary(),
      footer => binary(),
      expires_at => integer(),
      expand => [binary()],
      discounts =>
          [#{discount => binary(),
             coupon => binary(),
             _ := json:value()}] |
          '',
      description => binary(),
      default_tax_rates => [binary()] | '',
      customer => binary(),
      collection_method => charge_automatically | send_invoice,
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      application_fee_percent => number() | '',
      application_fee_amount => integer() | ''}.
-type post_quotes_quote_response() :: stripe_model:error() | stripe_model:quote().
-type get_quotes_quote_request() ::
    #{quote := binary(),
      query => get_quotes_quote_request_query(),
      header => get_quotes_quote_request_header(),
      cookie => get_quotes_quote_request_cookie(),
      body => {binary(), get_quotes_quote_request_body()}}.
-type get_quotes_quote_request_query() :: #{expand => [binary()]}.
-type get_quotes_quote_request_header() :: map().
-type get_quotes_quote_request_cookie() :: map().
-type get_quotes_quote_request_body() :: #{}.
-type get_quotes_quote_response() :: stripe_model:error() | stripe_model:quote().
-type post_account_people_request() ::
    #{query => post_account_people_request_query(),
      header => post_account_people_request_header(),
      cookie => post_account_people_request_cookie(),
      body => {binary(), post_account_people_request_body()}}.
-type post_account_people_request_query() :: map().
-type post_account_people_request_header() :: map().
-type post_account_people_request_cookie() :: map().
-type post_account_people_request_body() ::
    #{verification =>
          #{document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            additional_document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            _ := json:value()},
      ssn_last_4 => binary(),
      relationship =>
          #{title => binary(),
            representative => boolean(),
            percent_ownership => number() | '',
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      political_exposure => binary(),
      phone => binary(),
      person_token => binary(),
      nationality => binary(),
      metadata => json:value() | '',
      maiden_name => binary(),
      last_name_kanji => binary(),
      last_name_kana => binary(),
      last_name => binary(),
      id_number => binary(),
      gender => binary(),
      full_name_aliases => [binary()] | '',
      first_name_kanji => binary(),
      first_name_kana => binary(),
      first_name => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{visa => #{files => [binary()], _ := json:value()},
            passport => #{files => [binary()], _ := json:value()},
            company_authorization => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      dob =>
          #{year := integer(),
            month := integer(),
            day := integer(),
            _ := json:value()} |
          '',
      address_kanji =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address_kana =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      account => binary()}.
-type post_account_people_response() :: stripe_model:error() | stripe_model:person().
-type get_account_people_request() ::
    #{query => get_account_people_request_query(),
      header => get_account_people_request_header(),
      cookie => get_account_people_request_cookie(),
      body => {binary(), get_account_people_request_body()}}.
-type get_account_people_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      relationship =>
          #{representative => boolean(),
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      starting_after => binary()}.
-type get_account_people_request_header() :: map().
-type get_account_people_request_cookie() :: map().
-type get_account_people_request_body() :: #{}.
-type get_account_people_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:person()],
      _ := json:value()}.
-type post_setup_intents_intent_confirm_request() ::
    #{intent := binary(),
      query => post_setup_intents_intent_confirm_request_query(),
      header => post_setup_intents_intent_confirm_request_header(),
      cookie => post_setup_intents_intent_confirm_request_cookie(),
      body => {binary(), post_setup_intents_intent_confirm_request_body()}}.
-type post_setup_intents_intent_confirm_request_query() :: map().
-type post_setup_intents_intent_confirm_request_header() :: map().
-type post_setup_intents_intent_confirm_request_cookie() :: map().
-type post_setup_intents_intent_confirm_request_body() ::
    #{return_url => binary(),
      payment_method_options =>
          #{sepa_debit => #{mandate_options => #{_ := json:value()}, _ := json:value()},
            card => #{request_three_d_secure => any | automatic, _ := json:value()},
            acss_debit =>
                #{verification_method => automatic | instant | microdeposits,
                  mandate_options =>
                      #{transaction_type => business | personal,
                        payment_schedule => combined | interval | sporadic,
                        interval_description => binary(),
                        default_for => [invoice | subscription],
                        custom_mandate_url => binary() | '',
                        _ := json:value()},
                  currency => cad | usd,
                  _ := json:value()},
            _ := json:value()},
      payment_method => binary(),
      mandate_data =>
          #{customer_acceptance :=
                #{type := offline | online,
                  online =>
                      #{user_agent := binary(),
                        ip_address := binary(),
                        _ := json:value()},
                  offline => #{_ := json:value()},
                  accepted_at => integer(),
                  _ := json:value()},
            _ := json:value()} |
          #{customer_acceptance :=
                #{type := online,
                  online :=
                      #{user_agent => binary(),
                        ip_address => binary(),
                        _ := json:value()},
                  _ := json:value()},
            _ := json:value()},
      expand => [binary()],
      client_secret => binary()}.
-type post_setup_intents_intent_confirm_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type post_customers_customer_cards_request() ::
    #{customer := binary(),
      query => post_customers_customer_cards_request_query(),
      header => post_customers_customer_cards_request_header(),
      cookie => post_customers_customer_cards_request_cookie(),
      body => {binary(), post_customers_customer_cards_request_body()}}.
-type post_customers_customer_cards_request_query() :: map().
-type post_customers_customer_cards_request_header() :: map().
-type post_customers_customer_cards_request_cookie() :: map().
-type post_customers_customer_cards_request_body() ::
    #{source => binary(),
      metadata => json:value(),
      expand => [binary()],
      card =>
          #{object => card,
            number := binary(),
            name => binary(),
            metadata => json:value(),
            exp_year := integer(),
            exp_month := integer(),
            cvc => binary(),
            address_zip => binary(),
            address_state => binary(),
            address_line2 => binary(),
            address_line1 => binary(),
            address_country => binary(),
            address_city => binary(),
            _ := json:value()} |
          binary(),
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary(),
      alipay_account => binary()}.
-type post_customers_customer_cards_response() ::
    stripe_model:error() | stripe_model:payment_source().
-type get_customers_customer_cards_request() ::
    #{customer := binary(),
      query => get_customers_customer_cards_request_query(),
      header => get_customers_customer_cards_request_header(),
      cookie => get_customers_customer_cards_request_cookie(),
      body => {binary(), get_customers_customer_cards_request_body()}}.
-type get_customers_customer_cards_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_cards_request_header() :: map().
-type get_customers_customer_cards_request_cookie() :: map().
-type get_customers_customer_cards_request_body() :: #{}.
-type get_customers_customer_cards_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:card()],
      _ := json:value()}.
-type get_identity_verification_reports_request() ::
    #{query => get_identity_verification_reports_request_query(),
      header => get_identity_verification_reports_request_header(),
      cookie => get_identity_verification_reports_request_cookie(),
      body => {binary(), get_identity_verification_reports_request_body()}}.
-type get_identity_verification_reports_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type => document | id_number,
      verification_session => binary()}.
-type get_identity_verification_reports_request_header() :: map().
-type get_identity_verification_reports_request_cookie() :: map().
-type get_identity_verification_reports_request_body() :: #{}.
-type get_identity_verification_reports_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:identity_verification_report()],
      _ := json:value()}.
-type post_accounts_account_persons_request() ::
    #{account := binary(),
      query => post_accounts_account_persons_request_query(),
      header => post_accounts_account_persons_request_header(),
      cookie => post_accounts_account_persons_request_cookie(),
      body => {binary(), post_accounts_account_persons_request_body()}}.
-type post_accounts_account_persons_request_query() :: map().
-type post_accounts_account_persons_request_header() :: map().
-type post_accounts_account_persons_request_cookie() :: map().
-type post_accounts_account_persons_request_body() ::
    #{verification =>
          #{document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            additional_document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            _ := json:value()},
      ssn_last_4 => binary(),
      relationship =>
          #{title => binary(),
            representative => boolean(),
            percent_ownership => number() | '',
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      political_exposure => binary(),
      phone => binary(),
      person_token => binary(),
      nationality => binary(),
      metadata => json:value() | '',
      maiden_name => binary(),
      last_name_kanji => binary(),
      last_name_kana => binary(),
      last_name => binary(),
      id_number => binary(),
      gender => binary(),
      full_name_aliases => [binary()] | '',
      first_name_kanji => binary(),
      first_name_kana => binary(),
      first_name => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{visa => #{files => [binary()], _ := json:value()},
            passport => #{files => [binary()], _ := json:value()},
            company_authorization => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      dob =>
          #{year := integer(),
            month := integer(),
            day := integer(),
            _ := json:value()} |
          '',
      address_kanji =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address_kana =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()}}.
-type post_accounts_account_persons_response() ::
    stripe_model:error() | stripe_model:person().
-type get_accounts_account_persons_request() ::
    #{account := binary(),
      query => get_accounts_account_persons_request_query(),
      header => get_accounts_account_persons_request_header(),
      cookie => get_accounts_account_persons_request_cookie(),
      body => {binary(), get_accounts_account_persons_request_body()}}.
-type get_accounts_account_persons_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      relationship =>
          #{representative => boolean(),
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      starting_after => binary()}.
-type get_accounts_account_persons_request_header() :: map().
-type get_accounts_account_persons_request_cookie() :: map().
-type get_accounts_account_persons_request_body() :: #{}.
-type get_accounts_account_persons_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:person()],
      _ := json:value()}.
-type post_application_fees_id_refund_request() ::
    #{id := binary(),
      query => post_application_fees_id_refund_request_query(),
      header => post_application_fees_id_refund_request_header(),
      cookie => post_application_fees_id_refund_request_cookie(),
      body => {binary(), post_application_fees_id_refund_request_body()}}.
-type post_application_fees_id_refund_request_query() :: map().
-type post_application_fees_id_refund_request_header() :: map().
-type post_application_fees_id_refund_request_cookie() :: map().
-type post_application_fees_id_refund_request_body() ::
    #{expand => [binary()],
      directive => binary(),
      amount => integer()}.
-type post_application_fees_id_refund_response() ::
    stripe_model:error() | stripe_model:application_fee().
-type post_payment_intents_request() ::
    #{query => post_payment_intents_request_query(),
      header => post_payment_intents_request_header(),
      cookie => post_payment_intents_request_cookie(),
      body := {binary(), post_payment_intents_request_body()}}.
-type post_payment_intents_request_query() :: map().
-type post_payment_intents_request_header() :: map().
-type post_payment_intents_request_cookie() :: map().
-type post_payment_intents_request_body() ::
    #{use_stripe_sdk => boolean(),
      transfer_group => binary(),
      transfer_data =>
          #{destination := binary(),
            amount => integer(),
            _ := json:value()},
      statement_descriptor_suffix => binary(),
      statement_descriptor => binary(),
      shipping =>
          #{tracking_number => binary(),
            phone => binary(),
            name := binary(),
            carrier => binary(),
            address :=
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      setup_future_usage => off_session | on_session,
      return_url => binary(),
      receipt_email => binary(),
      payment_method_types => [binary()],
      payment_method_options =>
          #{wechat_pay =>
                #{setup_future_usage => none,
                  client := android | ios | web,
                  app_id => binary(),
                  _ := json:value()} |
                '',
            sofort =>
                #{setup_future_usage => '' | none | off_session,
                  preferred_language => '' | de | en | es | fr | it | nl | pl,
                  _ := json:value()} |
                '',
            sepa_debit =>
                #{setup_future_usage => '' | none | off_session | on_session,
                  mandate_options => #{_ := json:value()},
                  _ := json:value()} |
                '',
            p24 =>
                #{tos_shown_and_accepted => boolean(),
                  setup_future_usage => none,
                  _ := json:value()} |
                '',
            oxxo =>
                #{setup_future_usage => none,
                  expires_after_days => integer(),
                  _ := json:value()} |
                '',
            klarna =>
                #{setup_future_usage => none,
                  preferred_locale =>
                      'da-DK' | 'de-AT' | 'de-DE' | 'en-AT' | 'en-BE' | 'en-DE' | 'en-DK' |
                      'en-ES' | 'en-FI' | 'en-FR' | 'en-GB' | 'en-IE' | 'en-IT' | 'en-NL' |
                      'en-NO' | 'en-SE' | 'en-US' | 'es-ES' | 'es-US' | 'fi-FI' | 'fr-BE' |
                      'fr-FR' | 'it-IT' | 'nb-NO' | 'nl-BE' | 'nl-NL' | 'sv-FI' | 'sv-SE',
                  _ := json:value()} |
                '',
            interac_present => #{_ := json:value()} | '',
            ideal => #{setup_future_usage => '' | none | off_session, _ := json:value()} | '',
            grabpay => #{setup_future_usage => none, _ := json:value()} | '',
            giropay => #{setup_future_usage => none, _ := json:value()} | '',
            fpx => #{setup_future_usage => none, _ := json:value()} | '',
            eps => #{setup_future_usage => none, _ := json:value()} | '',
            card_present => #{_ := json:value()} | '',
            card =>
                #{setup_future_usage => '' | none | off_session | on_session,
                  request_three_d_secure => any | automatic,
                  network =>
                      amex |
                      cartes_bancaires |
                      diners |
                      discover |
                      interac |
                      jcb |
                      mastercard |
                      unionpay |
                      unknown |
                      visa,
                  installments =>
                      #{plan =>
                            #{type := fixed_count,
                              interval := month,
                              count := integer(),
                              _ := json:value()} |
                            '',
                        enabled => boolean(),
                        _ := json:value()},
                  cvc_token => binary(),
                  _ := json:value()} |
                '',
            boleto =>
                #{setup_future_usage => '' | none | off_session | on_session,
                  expires_after_days => integer(),
                  _ := json:value()} |
                '',
            bancontact =>
                #{setup_future_usage => '' | none | off_session,
                  preferred_language => de | en | fr | nl,
                  _ := json:value()} |
                '',
            bacs_debit =>
                #{setup_future_usage => '' | none | off_session | on_session, _ := json:value()} |
                '',
            au_becs_debit =>
                #{setup_future_usage => '' | none | off_session | on_session, _ := json:value()} |
                '',
            alipay => #{setup_future_usage => '' | none | off_session, _ := json:value()} | '',
            afterpay_clearpay =>
                #{setup_future_usage => none,
                  reference => binary(),
                  _ := json:value()} |
                '',
            acss_debit =>
                #{verification_method => automatic | instant | microdeposits,
                  setup_future_usage => '' | none | off_session | on_session,
                  mandate_options =>
                      #{transaction_type => business | personal,
                        payment_schedule => combined | interval | sporadic,
                        interval_description => binary(),
                        custom_mandate_url => binary() | '',
                        _ := json:value()},
                  _ := json:value()} |
                '',
            _ := json:value()},
      payment_method_data =>
          #{wechat_pay => #{_ := json:value()},
            type :=
                acss_debit |
                afterpay_clearpay |
                alipay |
                au_becs_debit |
                bacs_debit |
                bancontact |
                boleto |
                eps |
                fpx |
                giropay |
                grabpay |
                ideal |
                klarna |
                oxxo |
                p24 |
                sepa_debit |
                sofort |
                wechat_pay,
            sofort => #{country := 'AT' | 'BE' | 'DE' | 'ES' | 'IT' | 'NL', _ := json:value()},
            sepa_debit => #{iban := binary(), _ := json:value()},
            p24 =>
                #{bank =>
                      alior_bank |
                      bank_millennium |
                      bank_nowy_bfg_sa |
                      bank_pekao_sa |
                      banki_spbdzielcze |
                      blik |
                      bnp_paribas |
                      boz |
                      citi_handlowy |
                      credit_agricole |
                      envelobank |
                      etransfer_pocztowy24 |
                      getin_bank |
                      ideabank |
                      ing |
                      inteligo |
                      mbank_mtransfer |
                      nest_przelew |
                      noble_pay |
                      pbac_z_ipko |
                      plus_bank |
                      santander_przelew24 |
                      tmobile_usbugi_bankowe |
                      toyota_bank |
                      volkswagen_bank,
                  _ := json:value()},
            oxxo => #{_ := json:value()},
            metadata => json:value(),
            klarna =>
                #{dob =>
                      #{year := integer(),
                        month := integer(),
                        day := integer(),
                        _ := json:value()},
                  _ := json:value()},
            interac_present => #{_ := json:value()},
            ideal =>
                #{bank =>
                      abn_amro |
                      asn_bank |
                      bunq |
                      handelsbanken |
                      ing |
                      knab |
                      moneyou |
                      rabobank |
                      regiobank |
                      revolut |
                      sns_bank |
                      triodos_bank |
                      van_lanschot,
                  _ := json:value()},
            grabpay => #{_ := json:value()},
            giropay => #{_ := json:value()},
            fpx =>
                #{bank :=
                      affin_bank |
                      agrobank |
                      alliance_bank |
                      ambank |
                      bank_islam |
                      bank_muamalat |
                      bank_rakyat |
                      bsn |
                      cimb |
                      deutsche_bank |
                      hong_leong_bank |
                      hsbc |
                      kfh |
                      maybank2e |
                      maybank2u |
                      ocbc |
                      pb_enterprise |
                      public_bank |
                      rhb |
                      standard_chartered |
                      uob,
                  _ := json:value()},
            eps =>
                #{bank =>
                      arzte_und_apotheker_bank | austrian_anadi_bank_ag | bank_austria |
                      bankhaus_carl_spangler | bankhaus_schelhammer_und_schattera_ag |
                      bawag_psk_ag | bks_bank_ag | brull_kallmus_bank_ag | btv_vier_lander_bank |
                      capital_bank_grawe_gruppe_ag | dolomitenbank | easybank_ag |
                      erste_bank_und_sparkassen | hypo_alpeadriabank_international_ag |
                      hypo_bank_burgenland_aktiengesellschaft |
                      hypo_noe_lb_fur_niederosterreich_u_wien |
                      hypo_oberosterreich_salzburg_steiermark | hypo_tirol_bank_ag |
                      hypo_vorarlberg_bank_ag | marchfelder_bank | oberbank_ag |
                      raiffeisen_bankengruppe_osterreich | schoellerbank_ag | sparda_bank_wien |
                      volksbank_gruppe | volkskreditbank_ag | vr_bank_braunau,
                  _ := json:value()},
            boleto => #{tax_id := binary(), _ := json:value()},
            billing_details =>
                #{phone => binary(),
                  name => binary(),
                  email => binary() | '',
                  address =>
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()} |
                      '',
                  _ := json:value()},
            bancontact => #{_ := json:value()},
            bacs_debit =>
                #{sort_code => binary(),
                  account_number => binary(),
                  _ := json:value()},
            au_becs_debit =>
                #{bsb_number := binary(),
                  account_number := binary(),
                  _ := json:value()},
            alipay => #{_ := json:value()},
            afterpay_clearpay => #{_ := json:value()},
            acss_debit =>
                #{transit_number := binary(),
                  institution_number := binary(),
                  account_number := binary(),
                  _ := json:value()},
            _ := json:value()},
      payment_method => binary(),
      on_behalf_of => binary(),
      off_session => boolean() | one_off | recurring,
      metadata => json:value(),
      mandate_data =>
          #{customer_acceptance :=
                #{type := offline | online,
                  online =>
                      #{user_agent := binary(),
                        ip_address := binary(),
                        _ := json:value()},
                  offline => #{_ := json:value()},
                  accepted_at => integer(),
                  _ := json:value()},
            _ := json:value()},
      mandate => binary(),
      expand => [binary()],
      error_on_requires_action => boolean(),
      description => binary(),
      customer => binary(),
      currency := binary(),
      confirmation_method => automatic | manual,
      confirm => boolean(),
      capture_method => automatic | manual,
      automatic_payment_methods => #{enabled := boolean(), _ := json:value()},
      application_fee_amount => integer(),
      amount := integer()}.
-type post_payment_intents_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type get_payment_intents_request() ::
    #{query => get_payment_intents_request_query(),
      header => get_payment_intents_request_header(),
      cookie => get_payment_intents_request_cookie(),
      body => {binary(), get_payment_intents_request_body()}}.
-type get_payment_intents_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_payment_intents_request_header() :: map().
-type get_payment_intents_request_cookie() :: map().
-type get_payment_intents_request_body() :: #{}.
-type get_payment_intents_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payment_intent()],
      _ := json:value()}.
-type post_skus_request() ::
    #{query => post_skus_request_query(),
      header => post_skus_request_header(),
      cookie => post_skus_request_cookie(),
      body := {binary(), post_skus_request_body()}}.
-type post_skus_request_query() :: map().
-type post_skus_request_header() :: map().
-type post_skus_request_cookie() :: map().
-type post_skus_request_body() ::
    #{product := binary(),
      price := integer(),
      package_dimensions =>
          #{width := number(),
            weight := number(),
            length := number(),
            height := number(),
            _ := json:value()},
      metadata => json:value(),
      inventory :=
          #{value => '' | in_stock | limited | out_of_stock,
            type := bucket | finite | infinite,
            quantity => integer(),
            _ := json:value()},
      image => binary(),
      id => binary(),
      expand => [binary()],
      currency := binary(),
      attributes => json:value(),
      active => boolean()}.
-type post_skus_response() :: stripe_model:error() | stripe_model:sku().
-type get_skus_request() ::
    #{query => get_skus_request_query(),
      header => get_skus_request_header(),
      cookie => get_skus_request_cookie(),
      body => {binary(), get_skus_request_body()}}.
-type get_skus_request_query() ::
    #{active => boolean(),
      attributes => json:value(),
      ending_before => binary(),
      expand => [binary()],
      ids => [binary()],
      in_stock => boolean(),
      limit => integer(),
      product => binary(),
      starting_after => binary()}.
-type get_skus_request_header() :: map().
-type get_skus_request_cookie() :: map().
-type get_skus_request_body() :: #{}.
-type get_skus_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:sku()],
      _ := json:value()}.
-type post_webhook_endpoints_request() ::
    #{query => post_webhook_endpoints_request_query(),
      header => post_webhook_endpoints_request_header(),
      cookie => post_webhook_endpoints_request_cookie(),
      body := {binary(), post_webhook_endpoints_request_body()}}.
-type post_webhook_endpoints_request_query() :: map().
-type post_webhook_endpoints_request_header() :: map().
-type post_webhook_endpoints_request_cookie() :: map().
-type post_webhook_endpoints_request_body() ::
    #{url := binary(),
      metadata => json:value() | '',
      expand => [binary()],
      enabled_events :=
          ['*' | 'account.application.authorized' | 'account.application.deauthorized' |
           'account.external_account.created' | 'account.external_account.deleted' |
           'account.external_account.updated' | 'account.updated' | 'application_fee.created' |
           'application_fee.refund.updated' | 'application_fee.refunded' | 'balance.available' |
           'billing_portal.configuration.created' | 'billing_portal.configuration.updated' |
           'capability.updated' | 'charge.captured' | 'charge.dispute.closed' |
           'charge.dispute.created' | 'charge.dispute.funds_reinstated' |
           'charge.dispute.funds_withdrawn' | 'charge.dispute.updated' | 'charge.expired' |
           'charge.failed' | 'charge.pending' | 'charge.refund.updated' | 'charge.refunded' |
           'charge.succeeded' | 'charge.updated' | 'checkout.session.async_payment_failed' |
           'checkout.session.async_payment_succeeded' | 'checkout.session.completed' |
           'checkout.session.expired' | 'coupon.created' | 'coupon.deleted' | 'coupon.updated' |
           'credit_note.created' | 'credit_note.updated' | 'credit_note.voided' |
           'customer.created' | 'customer.deleted' | 'customer.discount.created' |
           'customer.discount.deleted' | 'customer.discount.updated' | 'customer.source.created' |
           'customer.source.deleted' | 'customer.source.expiring' | 'customer.source.updated' |
           'customer.subscription.created' | 'customer.subscription.deleted' |
           'customer.subscription.pending_update_applied' |
           'customer.subscription.pending_update_expired' | 'customer.subscription.trial_will_end' |
           'customer.subscription.updated' | 'customer.tax_id.created' | 'customer.tax_id.deleted' |
           'customer.tax_id.updated' | 'customer.updated' | 'file.created' |
           'identity.verification_session.canceled' | 'identity.verification_session.created' |
           'identity.verification_session.processing' | 'identity.verification_session.redacted' |
           'identity.verification_session.requires_input' |
           'identity.verification_session.verified' | 'invoice.created' | 'invoice.deleted' |
           'invoice.finalization_failed' | 'invoice.finalized' | 'invoice.marked_uncollectible' |
           'invoice.paid' | 'invoice.payment_action_required' | 'invoice.payment_failed' |
           'invoice.payment_succeeded' | 'invoice.sent' | 'invoice.upcoming' | 'invoice.updated' |
           'invoice.voided' | 'invoiceitem.created' | 'invoiceitem.deleted' |
           'invoiceitem.updated' | 'issuing_authorization.created' |
           'issuing_authorization.request' | 'issuing_authorization.updated' |
           'issuing_card.created' | 'issuing_card.updated' | 'issuing_cardholder.created' |
           'issuing_cardholder.updated' | 'issuing_dispute.closed' | 'issuing_dispute.created' |
           'issuing_dispute.funds_reinstated' | 'issuing_dispute.submitted' |
           'issuing_dispute.updated' | 'issuing_transaction.created' |
           'issuing_transaction.updated' | 'mandate.updated' | 'order.created' |
           'order.payment_failed' | 'order.payment_succeeded' | 'order.updated' |
           'order_return.created' | 'payment_intent.amount_capturable_updated' |
           'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' |
           'payment_intent.processing' | 'payment_intent.requires_action' |
           'payment_intent.succeeded' | 'payment_link.created' | 'payment_link.updated' |
           'payment_method.attached' | 'payment_method.automatically_updated' |
           'payment_method.detached' | 'payment_method.updated' | 'payout.canceled' |
           'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' |
           'person.created' | 'person.deleted' | 'person.updated' | 'plan.created' |
           'plan.deleted' | 'plan.updated' | 'price.created' | 'price.deleted' | 'price.updated' |
           'product.created' | 'product.deleted' | 'product.updated' | 'promotion_code.created' |
           'promotion_code.updated' | 'quote.accepted' | 'quote.canceled' | 'quote.created' |
           'quote.finalized' | 'radar.early_fraud_warning.created' |
           'radar.early_fraud_warning.updated' | 'recipient.created' | 'recipient.deleted' |
           'recipient.updated' | 'reporting.report_run.failed' | 'reporting.report_run.succeeded' |
           'reporting.report_type.updated' | 'review.closed' | 'review.opened' |
           'setup_intent.canceled' | 'setup_intent.created' | 'setup_intent.requires_action' |
           'setup_intent.setup_failed' | 'setup_intent.succeeded' |
           'sigma.scheduled_query_run.created' | 'sku.created' | 'sku.deleted' | 'sku.updated' |
           'source.canceled' | 'source.chargeable' | 'source.failed' |
           'source.mandate_notification' | 'source.refund_attributes_required' |
           'source.transaction.created' | 'source.transaction.updated' |
           'subscription_schedule.aborted' | 'subscription_schedule.canceled' |
           'subscription_schedule.completed' | 'subscription_schedule.created' |
           'subscription_schedule.expiring' | 'subscription_schedule.released' |
           'subscription_schedule.updated' | 'tax_rate.created' | 'tax_rate.updated' |
           'topup.canceled' | 'topup.created' | 'topup.failed' | 'topup.reversed' |
           'topup.succeeded' | 'transfer.created' | 'transfer.failed' | 'transfer.paid' |
           'transfer.reversed' | 'transfer.updated'],
      description => binary(),
      connect => boolean(),
      api_version =>
          '2011-01-01' | '2011-06-21' | '2011-06-28' | '2011-08-01' | '2011-09-15' | '2011-11-17' |
          '2012-02-23' | '2012-03-25' | '2012-06-18' | '2012-06-28' | '2012-07-09' | '2012-09-24' |
          '2012-10-26' | '2012-11-07' | '2013-02-11' | '2013-02-13' | '2013-07-05' | '2013-08-12' |
          '2013-08-13' | '2013-10-29' | '2013-12-03' | '2014-01-31' | '2014-03-13' | '2014-03-28' |
          '2014-05-19' | '2014-06-13' | '2014-06-17' | '2014-07-22' | '2014-07-26' | '2014-08-04' |
          '2014-08-20' | '2014-09-08' | '2014-10-07' | '2014-11-05' | '2014-11-20' | '2014-12-08' |
          '2014-12-17' | '2014-12-22' | '2015-01-11' | '2015-01-26' | '2015-02-10' | '2015-02-16' |
          '2015-02-18' | '2015-03-24' | '2015-04-07' | '2015-06-15' | '2015-07-07' | '2015-07-13' |
          '2015-07-28' | '2015-08-07' | '2015-08-19' | '2015-09-03' | '2015-09-08' | '2015-09-23' |
          '2015-10-01' | '2015-10-12' | '2015-10-16' | '2016-02-03' | '2016-02-19' | '2016-02-22' |
          '2016-02-23' | '2016-02-29' | '2016-03-07' | '2016-06-15' | '2016-07-06' | '2016-10-19' |
          '2017-01-27' | '2017-02-14' | '2017-04-06' | '2017-05-25' | '2017-06-05' | '2017-08-15' |
          '2017-12-14' | '2018-01-23' | '2018-02-05' | '2018-02-06' | '2018-02-28' | '2018-05-21' |
          '2018-07-27' | '2018-08-23' | '2018-09-06' | '2018-09-24' | '2018-10-31' | '2018-11-08' |
          '2019-02-11' | '2019-02-19' | '2019-03-14' | '2019-05-16' | '2019-08-14' | '2019-09-09' |
          '2019-10-08' | '2019-10-17' | '2019-11-05' | '2019-12-03' | '2020-03-02' | '2020-08-27'}.
-type post_webhook_endpoints_response() ::
    stripe_model:error() | stripe_model:webhook_endpoint().
-type get_webhook_endpoints_request() ::
    #{query => get_webhook_endpoints_request_query(),
      header => get_webhook_endpoints_request_header(),
      cookie => get_webhook_endpoints_request_cookie(),
      body => {binary(), get_webhook_endpoints_request_body()}}.
-type get_webhook_endpoints_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_webhook_endpoints_request_header() :: map().
-type get_webhook_endpoints_request_cookie() :: map().
-type get_webhook_endpoints_request_body() :: #{}.
-type get_webhook_endpoints_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:webhook_endpoint()],
      _ := json:value()}.
-type get_balance_request() ::
    #{query => get_balance_request_query(),
      header => get_balance_request_header(),
      cookie => get_balance_request_cookie(),
      body => {binary(), get_balance_request_body()}}.
-type get_balance_request_query() :: #{expand => [binary()]}.
-type get_balance_request_header() :: map().
-type get_balance_request_cookie() :: map().
-type get_balance_request_body() :: #{}.
-type get_balance_response() :: stripe_model:error() | stripe_model:balance().
-type post_customers_customer_balance_transactions_transaction_request() ::
    #{customer := binary(),
      transaction := binary(),
      query => post_customers_customer_balance_transactions_transaction_request_query(),
      header => post_customers_customer_balance_transactions_transaction_request_header(),
      cookie => post_customers_customer_balance_transactions_transaction_request_cookie(),
      body =>
          {binary(), post_customers_customer_balance_transactions_transaction_request_body()}}.
-type post_customers_customer_balance_transactions_transaction_request_query() :: map().
-type post_customers_customer_balance_transactions_transaction_request_header() :: map().
-type post_customers_customer_balance_transactions_transaction_request_cookie() :: map().
-type post_customers_customer_balance_transactions_transaction_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      description => binary()}.
-type post_customers_customer_balance_transactions_transaction_response() ::
    stripe_model:error() | stripe_model:customer_balance_transaction().
-type get_customers_customer_balance_transactions_transaction_request() ::
    #{customer := binary(),
      transaction := binary(),
      query => get_customers_customer_balance_transactions_transaction_request_query(),
      header => get_customers_customer_balance_transactions_transaction_request_header(),
      cookie => get_customers_customer_balance_transactions_transaction_request_cookie(),
      body =>
          {binary(), get_customers_customer_balance_transactions_transaction_request_body()}}.
-type get_customers_customer_balance_transactions_transaction_request_query() ::
    #{expand => [binary()]}.
-type get_customers_customer_balance_transactions_transaction_request_header() :: map().
-type get_customers_customer_balance_transactions_transaction_request_cookie() :: map().
-type get_customers_customer_balance_transactions_transaction_request_body() :: #{}.
-type get_customers_customer_balance_transactions_transaction_response() ::
    stripe_model:error() | stripe_model:customer_balance_transaction().
-type post_payment_methods_payment_method_request() ::
    #{payment_method := binary(),
      query => post_payment_methods_payment_method_request_query(),
      header => post_payment_methods_payment_method_request_header(),
      cookie => post_payment_methods_payment_method_request_cookie(),
      body => {binary(), post_payment_methods_payment_method_request_body()}}.
-type post_payment_methods_payment_method_request_query() :: map().
-type post_payment_methods_payment_method_request_header() :: map().
-type post_payment_methods_payment_method_request_cookie() :: map().
-type post_payment_methods_payment_method_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      card =>
          #{exp_year => integer(),
            exp_month => integer(),
            _ := json:value()},
      billing_details =>
          #{phone => binary(),
            name => binary(),
            email => binary() | '',
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()} |
                '',
            _ := json:value()}}.
-type post_payment_methods_payment_method_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type get_payment_methods_payment_method_request() ::
    #{payment_method := binary(),
      query => get_payment_methods_payment_method_request_query(),
      header => get_payment_methods_payment_method_request_header(),
      cookie => get_payment_methods_payment_method_request_cookie(),
      body => {binary(), get_payment_methods_payment_method_request_body()}}.
-type get_payment_methods_payment_method_request_query() :: #{expand => [binary()]}.
-type get_payment_methods_payment_method_request_header() :: map().
-type get_payment_methods_payment_method_request_cookie() :: map().
-type get_payment_methods_payment_method_request_body() :: #{}.
-type get_payment_methods_payment_method_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type post_topups_topup_cancel_request() ::
    #{topup := binary(),
      query => post_topups_topup_cancel_request_query(),
      header => post_topups_topup_cancel_request_header(),
      cookie => post_topups_topup_cancel_request_cookie(),
      body => {binary(), post_topups_topup_cancel_request_body()}}.
-type post_topups_topup_cancel_request_query() :: map().
-type post_topups_topup_cancel_request_header() :: map().
-type post_topups_topup_cancel_request_cookie() :: map().
-type post_topups_topup_cancel_request_body() :: #{expand => [binary()]}.
-type post_topups_topup_cancel_response() :: stripe_model:error() | stripe_model:topup().
-type get_events_request() ::
    #{query => get_events_request_query(),
      header => get_events_request_header(),
      cookie => get_events_request_cookie(),
      body => {binary(), get_events_request_body()}}.
-type get_events_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      delivery_success => boolean(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type => binary(),
      types => [binary()]}.
-type get_events_request_header() :: map().
-type get_events_request_cookie() :: map().
-type get_events_request_body() :: #{}.
-type get_events_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:event()],
      _ := json:value()}.
-type post_charges_charge_refunds_refund_request() ::
    #{charge := binary(),
      refund := binary(),
      query => post_charges_charge_refunds_refund_request_query(),
      header => post_charges_charge_refunds_refund_request_header(),
      cookie => post_charges_charge_refunds_refund_request_cookie(),
      body => {binary(), post_charges_charge_refunds_refund_request_body()}}.
-type post_charges_charge_refunds_refund_request_query() :: map().
-type post_charges_charge_refunds_refund_request_header() :: map().
-type post_charges_charge_refunds_refund_request_cookie() :: map().
-type post_charges_charge_refunds_refund_request_body() ::
    #{metadata => json:value() | '', expand => [binary()]}.
-type post_charges_charge_refunds_refund_response() ::
    stripe_model:error() | stripe_model:refund().
-type get_charges_charge_refunds_refund_request() ::
    #{charge := binary(),
      refund := binary(),
      query => get_charges_charge_refunds_refund_request_query(),
      header => get_charges_charge_refunds_refund_request_header(),
      cookie => get_charges_charge_refunds_refund_request_cookie(),
      body => {binary(), get_charges_charge_refunds_refund_request_body()}}.
-type get_charges_charge_refunds_refund_request_query() :: #{expand => [binary()]}.
-type get_charges_charge_refunds_refund_request_header() :: map().
-type get_charges_charge_refunds_refund_request_cookie() :: map().
-type get_charges_charge_refunds_refund_request_body() :: #{}.
-type get_charges_charge_refunds_refund_response() ::
    stripe_model:error() | stripe_model:refund().
-type post_accounts_account_capabilities_capability_request() ::
    #{account := binary(),
      capability := binary(),
      query => post_accounts_account_capabilities_capability_request_query(),
      header => post_accounts_account_capabilities_capability_request_header(),
      cookie => post_accounts_account_capabilities_capability_request_cookie(),
      body => {binary(), post_accounts_account_capabilities_capability_request_body()}}.
-type post_accounts_account_capabilities_capability_request_query() :: map().
-type post_accounts_account_capabilities_capability_request_header() :: map().
-type post_accounts_account_capabilities_capability_request_cookie() :: map().
-type post_accounts_account_capabilities_capability_request_body() ::
    #{requested => boolean(), expand => [binary()]}.
-type post_accounts_account_capabilities_capability_response() ::
    stripe_model:error() | stripe_model:capability().
-type get_accounts_account_capabilities_capability_request() ::
    #{account := binary(),
      capability := binary(),
      query => get_accounts_account_capabilities_capability_request_query(),
      header => get_accounts_account_capabilities_capability_request_header(),
      cookie => get_accounts_account_capabilities_capability_request_cookie(),
      body => {binary(), get_accounts_account_capabilities_capability_request_body()}}.
-type get_accounts_account_capabilities_capability_request_query() ::
    #{expand => [binary()]}.
-type get_accounts_account_capabilities_capability_request_header() :: map().
-type get_accounts_account_capabilities_capability_request_cookie() :: map().
-type get_accounts_account_capabilities_capability_request_body() :: #{}.
-type get_accounts_account_capabilities_capability_response() ::
    stripe_model:error() | stripe_model:capability().
-type post_subscription_items_request() ::
    #{query => post_subscription_items_request_query(),
      header => post_subscription_items_request_header(),
      cookie => post_subscription_items_request_cookie(),
      body := {binary(), post_subscription_items_request_body()}}.
-type post_subscription_items_request_query() :: map().
-type post_subscription_items_request_header() :: map().
-type post_subscription_items_request_cookie() :: map().
-type post_subscription_items_request_body() ::
    #{tax_rates => [binary()] | '',
      subscription := binary(),
      quantity => integer(),
      proration_date => integer(),
      proration_behavior => always_invoice | create_prorations | none,
      price_data =>
          #{unit_amount_decimal => binary(),
            unit_amount => integer(),
            tax_behavior => exclusive | inclusive | unspecified,
            recurring :=
                #{interval_count => integer(),
                  interval := day | month | week | year,
                  _ := json:value()},
            product := binary(),
            currency := binary(),
            _ := json:value()},
      price => binary(),
      payment_behavior =>
          allow_incomplete | default_incomplete | error_if_incomplete | pending_if_incomplete,
      metadata => json:value(),
      expand => [binary()],
      billing_thresholds => #{usage_gte := integer(), _ := json:value()} | ''}.
-type post_subscription_items_response() ::
    stripe_model:error() | stripe_model:subscription_item().
-type get_subscription_items_request() ::
    #{query => get_subscription_items_request_query(),
      header => get_subscription_items_request_header(),
      cookie => get_subscription_items_request_cookie(),
      body => {binary(), get_subscription_items_request_body()}}.
-type get_subscription_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      subscription := binary()}.
-type get_subscription_items_request_header() :: map().
-type get_subscription_items_request_cookie() :: map().
-type get_subscription_items_request_body() :: #{}.
-type get_subscription_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:subscription_item()],
      _ := json:value()}.
-type get_quotes_quote_pdf_request() ::
    #{quote := binary(),
      query => get_quotes_quote_pdf_request_query(),
      header => get_quotes_quote_pdf_request_header(),
      cookie => get_quotes_quote_pdf_request_cookie(),
      body => {binary(), get_quotes_quote_pdf_request_body()}}.
-type get_quotes_quote_pdf_request_query() :: #{expand => [binary()]}.
-type get_quotes_quote_pdf_request_header() :: map().
-type get_quotes_quote_pdf_request_cookie() :: map().
-type get_quotes_quote_pdf_request_body() :: #{}.
-type get_quotes_quote_pdf_response() :: stripe_model:error() | binary().
-type delete_account_bank_accounts_id_request() ::
    #{id := binary(),
      query => delete_account_bank_accounts_id_request_query(),
      header => delete_account_bank_accounts_id_request_header(),
      cookie => delete_account_bank_accounts_id_request_cookie(),
      body => {binary(), delete_account_bank_accounts_id_request_body()}}.
-type delete_account_bank_accounts_id_request_query() :: map().
-type delete_account_bank_accounts_id_request_header() :: map().
-type delete_account_bank_accounts_id_request_cookie() :: map().
-type delete_account_bank_accounts_id_request_body() :: #{}.
-type delete_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:deleted_external_account().
-type post_account_bank_accounts_id_request() ::
    #{id := binary(),
      query => post_account_bank_accounts_id_request_query(),
      header => post_account_bank_accounts_id_request_header(),
      cookie => post_account_bank_accounts_id_request_cookie(),
      body => {binary(), post_account_bank_accounts_id_request_body()}}.
-type post_account_bank_accounts_id_request_query() :: map().
-type post_account_bank_accounts_id_request_header() :: map().
-type post_account_bank_accounts_id_request_cookie() :: map().
-type post_account_bank_accounts_id_request_body() ::
    #{name => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      exp_year => binary(),
      exp_month => binary(),
      default_for_currency => boolean(),
      address_zip => binary(),
      address_state => binary(),
      address_line2 => binary(),
      address_line1 => binary(),
      address_country => binary(),
      address_city => binary(),
      account_type => checking | futsu | savings | toza,
      account_holder_type => '' | company | individual,
      account_holder_name => binary()}.
-type post_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_account_bank_accounts_id_request() ::
    #{id := binary(),
      query => get_account_bank_accounts_id_request_query(),
      header => get_account_bank_accounts_id_request_header(),
      cookie => get_account_bank_accounts_id_request_cookie(),
      body => {binary(), get_account_bank_accounts_id_request_body()}}.
-type get_account_bank_accounts_id_request_query() :: #{expand => [binary()]}.
-type get_account_bank_accounts_id_request_header() :: map().
-type get_account_bank_accounts_id_request_cookie() :: map().
-type get_account_bank_accounts_id_request_body() :: #{}.
-type get_account_bank_accounts_id_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_payment_links_payment_link_line_items_request() ::
    #{payment_link := binary(),
      query => get_payment_links_payment_link_line_items_request_query(),
      header => get_payment_links_payment_link_line_items_request_header(),
      cookie => get_payment_links_payment_link_line_items_request_cookie(),
      body => {binary(), get_payment_links_payment_link_line_items_request_body()}}.
-type get_payment_links_payment_link_line_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_payment_links_payment_link_line_items_request_header() :: map().
-type get_payment_links_payment_link_line_items_request_cookie() :: map().
-type get_payment_links_payment_link_line_items_request_body() :: #{}.
-type get_payment_links_payment_link_line_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:item()],
      _ := json:value()}.
-type get_subscription_items_subscription_item_usage_record_summaries_request() ::
    #{subscription_item := binary(),
      query => get_subscription_items_subscription_item_usage_record_summaries_request_query(),
      header =>
          get_subscription_items_subscription_item_usage_record_summaries_request_header(),
      cookie =>
          get_subscription_items_subscription_item_usage_record_summaries_request_cookie(),
      body =>
          {binary(),
           get_subscription_items_subscription_item_usage_record_summaries_request_body()}}.
-type get_subscription_items_subscription_item_usage_record_summaries_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_subscription_items_subscription_item_usage_record_summaries_request_header() ::
    map().
-type get_subscription_items_subscription_item_usage_record_summaries_request_cookie() ::
    map().
-type get_subscription_items_subscription_item_usage_record_summaries_request_body() ::
    #{}.
-type get_subscription_items_subscription_item_usage_record_summaries_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:usage_record_summary()],
      _ := json:value()}.
-type post_payment_intents_intent_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_request_query(),
      header => post_payment_intents_intent_request_header(),
      cookie => post_payment_intents_intent_request_cookie(),
      body => {binary(), post_payment_intents_intent_request_body()}}.
-type post_payment_intents_intent_request_query() :: map().
-type post_payment_intents_intent_request_header() :: map().
-type post_payment_intents_intent_request_cookie() :: map().
-type post_payment_intents_intent_request_body() ::
    #{transfer_group => binary(),
      transfer_data => #{amount => integer(), _ := json:value()},
      statement_descriptor_suffix => binary(),
      statement_descriptor => binary(),
      shipping =>
          #{tracking_number => binary(),
            phone => binary(),
            name := binary(),
            carrier => binary(),
            address :=
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()} |
          '',
      setup_future_usage => '' | off_session | on_session,
      receipt_email => binary() | '',
      payment_method_types => [binary()],
      payment_method_options =>
          #{wechat_pay =>
                #{setup_future_usage => none,
                  client := android | ios | web,
                  app_id => binary(),
                  _ := json:value()} |
                '',
            sofort =>
                #{setup_future_usage => '' | none | off_session,
                  preferred_language => '' | de | en | es | fr | it | nl | pl,
                  _ := json:value()} |
                '',
            sepa_debit =>
                #{setup_future_usage => '' | none | off_session | on_session,
                  mandate_options => #{_ := json:value()},
                  _ := json:value()} |
                '',
            p24 =>
                #{tos_shown_and_accepted => boolean(),
                  setup_future_usage => none,
                  _ := json:value()} |
                '',
            oxxo =>
                #{setup_future_usage => none,
                  expires_after_days => integer(),
                  _ := json:value()} |
                '',
            klarna =>
                #{setup_future_usage => none,
                  preferred_locale =>
                      'da-DK' | 'de-AT' | 'de-DE' | 'en-AT' | 'en-BE' | 'en-DE' | 'en-DK' |
                      'en-ES' | 'en-FI' | 'en-FR' | 'en-GB' | 'en-IE' | 'en-IT' | 'en-NL' |
                      'en-NO' | 'en-SE' | 'en-US' | 'es-ES' | 'es-US' | 'fi-FI' | 'fr-BE' |
                      'fr-FR' | 'it-IT' | 'nb-NO' | 'nl-BE' | 'nl-NL' | 'sv-FI' | 'sv-SE',
                  _ := json:value()} |
                '',
            interac_present => #{_ := json:value()} | '',
            ideal => #{setup_future_usage => '' | none | off_session, _ := json:value()} | '',
            grabpay => #{setup_future_usage => none, _ := json:value()} | '',
            giropay => #{setup_future_usage => none, _ := json:value()} | '',
            fpx => #{setup_future_usage => none, _ := json:value()} | '',
            eps => #{setup_future_usage => none, _ := json:value()} | '',
            card_present => #{_ := json:value()} | '',
            card =>
                #{setup_future_usage => '' | none | off_session | on_session,
                  request_three_d_secure => any | automatic,
                  network =>
                      amex |
                      cartes_bancaires |
                      diners |
                      discover |
                      interac |
                      jcb |
                      mastercard |
                      unionpay |
                      unknown |
                      visa,
                  installments =>
                      #{plan =>
                            #{type := fixed_count,
                              interval := month,
                              count := integer(),
                              _ := json:value()} |
                            '',
                        enabled => boolean(),
                        _ := json:value()},
                  cvc_token => binary(),
                  _ := json:value()} |
                '',
            boleto =>
                #{setup_future_usage => '' | none | off_session | on_session,
                  expires_after_days => integer(),
                  _ := json:value()} |
                '',
            bancontact =>
                #{setup_future_usage => '' | none | off_session,
                  preferred_language => de | en | fr | nl,
                  _ := json:value()} |
                '',
            bacs_debit =>
                #{setup_future_usage => '' | none | off_session | on_session, _ := json:value()} |
                '',
            au_becs_debit =>
                #{setup_future_usage => '' | none | off_session | on_session, _ := json:value()} |
                '',
            alipay => #{setup_future_usage => '' | none | off_session, _ := json:value()} | '',
            afterpay_clearpay =>
                #{setup_future_usage => none,
                  reference => binary(),
                  _ := json:value()} |
                '',
            acss_debit =>
                #{verification_method => automatic | instant | microdeposits,
                  setup_future_usage => '' | none | off_session | on_session,
                  mandate_options =>
                      #{transaction_type => business | personal,
                        payment_schedule => combined | interval | sporadic,
                        interval_description => binary(),
                        custom_mandate_url => binary() | '',
                        _ := json:value()},
                  _ := json:value()} |
                '',
            _ := json:value()},
      payment_method_data =>
          #{wechat_pay => #{_ := json:value()},
            type :=
                acss_debit |
                afterpay_clearpay |
                alipay |
                au_becs_debit |
                bacs_debit |
                bancontact |
                boleto |
                eps |
                fpx |
                giropay |
                grabpay |
                ideal |
                klarna |
                oxxo |
                p24 |
                sepa_debit |
                sofort |
                wechat_pay,
            sofort => #{country := 'AT' | 'BE' | 'DE' | 'ES' | 'IT' | 'NL', _ := json:value()},
            sepa_debit => #{iban := binary(), _ := json:value()},
            p24 =>
                #{bank =>
                      alior_bank |
                      bank_millennium |
                      bank_nowy_bfg_sa |
                      bank_pekao_sa |
                      banki_spbdzielcze |
                      blik |
                      bnp_paribas |
                      boz |
                      citi_handlowy |
                      credit_agricole |
                      envelobank |
                      etransfer_pocztowy24 |
                      getin_bank |
                      ideabank |
                      ing |
                      inteligo |
                      mbank_mtransfer |
                      nest_przelew |
                      noble_pay |
                      pbac_z_ipko |
                      plus_bank |
                      santander_przelew24 |
                      tmobile_usbugi_bankowe |
                      toyota_bank |
                      volkswagen_bank,
                  _ := json:value()},
            oxxo => #{_ := json:value()},
            metadata => json:value(),
            klarna =>
                #{dob =>
                      #{year := integer(),
                        month := integer(),
                        day := integer(),
                        _ := json:value()},
                  _ := json:value()},
            interac_present => #{_ := json:value()},
            ideal =>
                #{bank =>
                      abn_amro |
                      asn_bank |
                      bunq |
                      handelsbanken |
                      ing |
                      knab |
                      moneyou |
                      rabobank |
                      regiobank |
                      revolut |
                      sns_bank |
                      triodos_bank |
                      van_lanschot,
                  _ := json:value()},
            grabpay => #{_ := json:value()},
            giropay => #{_ := json:value()},
            fpx =>
                #{bank :=
                      affin_bank |
                      agrobank |
                      alliance_bank |
                      ambank |
                      bank_islam |
                      bank_muamalat |
                      bank_rakyat |
                      bsn |
                      cimb |
                      deutsche_bank |
                      hong_leong_bank |
                      hsbc |
                      kfh |
                      maybank2e |
                      maybank2u |
                      ocbc |
                      pb_enterprise |
                      public_bank |
                      rhb |
                      standard_chartered |
                      uob,
                  _ := json:value()},
            eps =>
                #{bank =>
                      arzte_und_apotheker_bank | austrian_anadi_bank_ag | bank_austria |
                      bankhaus_carl_spangler | bankhaus_schelhammer_und_schattera_ag |
                      bawag_psk_ag | bks_bank_ag | brull_kallmus_bank_ag | btv_vier_lander_bank |
                      capital_bank_grawe_gruppe_ag | dolomitenbank | easybank_ag |
                      erste_bank_und_sparkassen | hypo_alpeadriabank_international_ag |
                      hypo_bank_burgenland_aktiengesellschaft |
                      hypo_noe_lb_fur_niederosterreich_u_wien |
                      hypo_oberosterreich_salzburg_steiermark | hypo_tirol_bank_ag |
                      hypo_vorarlberg_bank_ag | marchfelder_bank | oberbank_ag |
                      raiffeisen_bankengruppe_osterreich | schoellerbank_ag | sparda_bank_wien |
                      volksbank_gruppe | volkskreditbank_ag | vr_bank_braunau,
                  _ := json:value()},
            boleto => #{tax_id := binary(), _ := json:value()},
            billing_details =>
                #{phone => binary(),
                  name => binary(),
                  email => binary() | '',
                  address =>
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()} |
                      '',
                  _ := json:value()},
            bancontact => #{_ := json:value()},
            bacs_debit =>
                #{sort_code => binary(),
                  account_number => binary(),
                  _ := json:value()},
            au_becs_debit =>
                #{bsb_number := binary(),
                  account_number := binary(),
                  _ := json:value()},
            alipay => #{_ := json:value()},
            afterpay_clearpay => #{_ := json:value()},
            acss_debit =>
                #{transit_number := binary(),
                  institution_number := binary(),
                  account_number := binary(),
                  _ := json:value()},
            _ := json:value()},
      payment_method => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      description => binary(),
      customer => binary(),
      currency => binary(),
      application_fee_amount => integer() | '',
      amount => integer()}.
-type post_payment_intents_intent_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type get_payment_intents_intent_request() ::
    #{intent := binary(),
      query => get_payment_intents_intent_request_query(),
      header => get_payment_intents_intent_request_header(),
      cookie => get_payment_intents_intent_request_cookie(),
      body => {binary(), get_payment_intents_intent_request_body()}}.
-type get_payment_intents_intent_request_query() ::
    #{client_secret => binary(), expand => [binary()]}.
-type get_payment_intents_intent_request_header() :: map().
-type get_payment_intents_intent_request_cookie() :: map().
-type get_payment_intents_intent_request_body() :: #{}.
-type get_payment_intents_intent_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type post_charges_request() ::
    #{query => post_charges_request_query(),
      header => post_charges_request_header(),
      cookie => post_charges_request_cookie(),
      body => {binary(), post_charges_request_body()}}.
-type post_charges_request_query() :: map().
-type post_charges_request_header() :: map().
-type post_charges_request_cookie() :: map().
-type post_charges_request_body() ::
    #{transfer_group => binary(),
      transfer_data =>
          #{destination := binary(),
            amount => integer(),
            _ := json:value()},
      statement_descriptor_suffix => binary(),
      statement_descriptor => binary(),
      source => binary(),
      shipping =>
          #{tracking_number => binary(),
            phone => binary(),
            name := binary(),
            carrier => binary(),
            address :=
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      receipt_email => binary(),
      on_behalf_of => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      destination =>
          #{amount => integer(),
            account := binary(),
            _ := json:value()} |
          binary(),
      description => binary(),
      customer => binary(),
      currency => binary(),
      card =>
          #{object => card,
            number := binary(),
            name => binary(),
            metadata => json:value(),
            exp_year := integer(),
            exp_month := integer(),
            cvc => binary(),
            address_zip => binary(),
            address_state => binary(),
            address_line2 => binary(),
            address_line1 => binary(),
            address_country => binary(),
            address_city => binary(),
            _ := json:value()} |
          binary(),
      capture => boolean(),
      application_fee_amount => integer(),
      application_fee => integer(),
      amount => integer()}.
-type post_charges_response() :: stripe_model:error() | stripe_model:charge().
-type get_charges_request() ::
    #{query => get_charges_request_query(),
      header => get_charges_request_header(),
      cookie => get_charges_request_cookie(),
      body => {binary(), get_charges_request_body()}}.
-type get_charges_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary(),
      transfer_group => binary()}.
-type get_charges_request_header() :: map().
-type get_charges_request_cookie() :: map().
-type get_charges_request_body() :: #{}.
-type get_charges_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:charge()],
      _ := json:value()}.
-type post_accounts_account_external_accounts_request() ::
    #{account := binary(),
      query => post_accounts_account_external_accounts_request_query(),
      header => post_accounts_account_external_accounts_request_header(),
      cookie => post_accounts_account_external_accounts_request_cookie(),
      body => {binary(), post_accounts_account_external_accounts_request_body()}}.
-type post_accounts_account_external_accounts_request_query() :: map().
-type post_accounts_account_external_accounts_request_header() :: map().
-type post_accounts_account_external_accounts_request_cookie() :: map().
-type post_accounts_account_external_accounts_request_body() ::
    #{metadata => json:value(),
      external_account => binary(),
      expand => [binary()],
      default_for_currency => boolean(),
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_type => checking | futsu | savings | toza,
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary()}.
-type post_accounts_account_external_accounts_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_accounts_account_external_accounts_request() ::
    #{account := binary(),
      query => get_accounts_account_external_accounts_request_query(),
      header => get_accounts_account_external_accounts_request_header(),
      cookie => get_accounts_account_external_accounts_request_cookie(),
      body => {binary(), get_accounts_account_external_accounts_request_body()}}.
-type get_accounts_account_external_accounts_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_accounts_account_external_accounts_request_header() :: map().
-type get_accounts_account_external_accounts_request_cookie() :: map().
-type get_accounts_account_external_accounts_request_body() :: #{}.
-type get_accounts_account_external_accounts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bank_account() | stripe_model:card()],
      _ := json:value()}.
-type get_issuing_authorizations_request() ::
    #{query => get_issuing_authorizations_request_query(),
      header => get_issuing_authorizations_request_header(),
      cookie => get_issuing_authorizations_request_cookie(),
      body => {binary(), get_issuing_authorizations_request_body()}}.
-type get_issuing_authorizations_request_query() ::
    #{card => binary(),
      cardholder => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => closed | pending | reversed}.
-type get_issuing_authorizations_request_header() :: map().
-type get_issuing_authorizations_request_cookie() :: map().
-type get_issuing_authorizations_request_body() :: #{}.
-type get_issuing_authorizations_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_authorization()],
      _ := json:value()}.
-type delete_products_id_request() ::
    #{id := binary(),
      query => delete_products_id_request_query(),
      header => delete_products_id_request_header(),
      cookie => delete_products_id_request_cookie(),
      body => {binary(), delete_products_id_request_body()}}.
-type delete_products_id_request_query() :: map().
-type delete_products_id_request_header() :: map().
-type delete_products_id_request_cookie() :: map().
-type delete_products_id_request_body() :: #{}.
-type delete_products_id_response() ::
    stripe_model:error() | stripe_model:deleted_product().
-type post_products_id_request() ::
    #{id := binary(),
      query => post_products_id_request_query(),
      header => post_products_id_request_header(),
      cookie => post_products_id_request_cookie(),
      body => {binary(), post_products_id_request_body()}}.
-type post_products_id_request_query() :: map().
-type post_products_id_request_header() :: map().
-type post_products_id_request_cookie() :: map().
-type post_products_id_request_body() ::
    #{url => binary(),
      unit_label => binary(),
      tax_code => binary() | '',
      statement_descriptor => binary(),
      shippable => boolean(),
      package_dimensions =>
          #{width := number(),
            weight := number(),
            length := number(),
            height := number(),
            _ := json:value()} |
          '',
      name => binary(),
      metadata => json:value() | '',
      images => [binary()] | '',
      expand => [binary()],
      description => binary(),
      active => boolean()}.
-type post_products_id_response() :: stripe_model:error() | stripe_model:product().
-type get_products_id_request() ::
    #{id := binary(),
      query => get_products_id_request_query(),
      header => get_products_id_request_header(),
      cookie => get_products_id_request_cookie(),
      body => {binary(), get_products_id_request_body()}}.
-type get_products_id_request_query() :: #{expand => [binary()]}.
-type get_products_id_request_header() :: map().
-type get_products_id_request_cookie() :: map().
-type get_products_id_request_body() :: #{}.
-type get_products_id_response() :: stripe_model:error() | stripe_model:product().
-type post_setup_intents_intent_verify_microdeposits_request() ::
    #{intent := binary(),
      query => post_setup_intents_intent_verify_microdeposits_request_query(),
      header => post_setup_intents_intent_verify_microdeposits_request_header(),
      cookie => post_setup_intents_intent_verify_microdeposits_request_cookie(),
      body => {binary(), post_setup_intents_intent_verify_microdeposits_request_body()}}.
-type post_setup_intents_intent_verify_microdeposits_request_query() :: map().
-type post_setup_intents_intent_verify_microdeposits_request_header() :: map().
-type post_setup_intents_intent_verify_microdeposits_request_cookie() :: map().
-type post_setup_intents_intent_verify_microdeposits_request_body() ::
    #{expand => [binary()],
      client_secret => binary(),
      amounts => [integer()]}.
-type post_setup_intents_intent_verify_microdeposits_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type get_reporting_report_types_request() ::
    #{query => get_reporting_report_types_request_query(),
      header => get_reporting_report_types_request_header(),
      cookie => get_reporting_report_types_request_cookie(),
      body => {binary(), get_reporting_report_types_request_body()}}.
-type get_reporting_report_types_request_query() :: #{expand => [binary()]}.
-type get_reporting_report_types_request_header() :: map().
-type get_reporting_report_types_request_cookie() :: map().
-type get_reporting_report_types_request_body() :: #{}.
-type get_reporting_report_types_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:reporting_report_type()],
      _ := json:value()}.
-type post_account_external_accounts_request() ::
    #{query => post_account_external_accounts_request_query(),
      header => post_account_external_accounts_request_header(),
      cookie => post_account_external_accounts_request_cookie(),
      body => {binary(), post_account_external_accounts_request_body()}}.
-type post_account_external_accounts_request_query() :: map().
-type post_account_external_accounts_request_header() :: map().
-type post_account_external_accounts_request_cookie() :: map().
-type post_account_external_accounts_request_body() ::
    #{metadata => json:value(),
      external_account => binary(),
      expand => [binary()],
      default_for_currency => boolean(),
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_type => checking | futsu | savings | toza,
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary()}.
-type post_account_external_accounts_response() ::
    stripe_model:error() | stripe_model:external_account().
-type get_account_external_accounts_request() ::
    #{query => get_account_external_accounts_request_query(),
      header => get_account_external_accounts_request_header(),
      cookie => get_account_external_accounts_request_cookie(),
      body => {binary(), get_account_external_accounts_request_body()}}.
-type get_account_external_accounts_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_account_external_accounts_request_header() :: map().
-type get_account_external_accounts_request_cookie() :: map().
-type get_account_external_accounts_request_body() :: #{}.
-type get_account_external_accounts_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bank_account() | stripe_model:card()],
      _ := json:value()}.
-type post_radar_value_lists_request() ::
    #{query => post_radar_value_lists_request_query(),
      header => post_radar_value_lists_request_header(),
      cookie => post_radar_value_lists_request_cookie(),
      body := {binary(), post_radar_value_lists_request_body()}}.
-type post_radar_value_lists_request_query() :: map().
-type post_radar_value_lists_request_header() :: map().
-type post_radar_value_lists_request_cookie() :: map().
-type post_radar_value_lists_request_body() ::
    #{name := binary(),
      metadata => json:value(),
      item_type =>
          card_bin |
          card_fingerprint |
          case_sensitive_string |
          country |
          customer_id |
          email |
          ip_address |
          string,
      expand => [binary()],
      alias := binary()}.
-type post_radar_value_lists_response() ::
    stripe_model:error() | stripe_model:radar_value_list().
-type get_radar_value_lists_request() ::
    #{query => get_radar_value_lists_request_query(),
      header => get_radar_value_lists_request_header(),
      cookie => get_radar_value_lists_request_cookie(),
      body => {binary(), get_radar_value_lists_request_body()}}.
-type get_radar_value_lists_request_query() ::
    #{alias => binary(),
      contains => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_radar_value_lists_request_header() :: map().
-type get_radar_value_lists_request_cookie() :: map().
-type get_radar_value_lists_request_body() :: #{}.
-type get_radar_value_lists_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:radar_value_list()],
      _ := json:value()}.
-type post_shipping_rates_request() ::
    #{query => post_shipping_rates_request_query(),
      header => post_shipping_rates_request_header(),
      cookie => post_shipping_rates_request_cookie(),
      body := {binary(), post_shipping_rates_request_body()}}.
-type post_shipping_rates_request_query() :: map().
-type post_shipping_rates_request_header() :: map().
-type post_shipping_rates_request_cookie() :: map().
-type post_shipping_rates_request_body() ::
    #{type => fixed_amount,
      tax_code => binary(),
      tax_behavior => exclusive | inclusive | unspecified,
      metadata => json:value(),
      fixed_amount =>
          #{currency := binary(),
            amount := integer(),
            _ := json:value()},
      expand => [binary()],
      display_name := binary(),
      delivery_estimate =>
          #{minimum =>
                #{value := integer(),
                  unit := business_day | day | hour | month | week,
                  _ := json:value()},
            maximum =>
                #{value := integer(),
                  unit := business_day | day | hour | month | week,
                  _ := json:value()},
            _ := json:value()}}.
-type post_shipping_rates_response() ::
    stripe_model:error() | stripe_model:shipping_rate().
-type get_shipping_rates_request() ::
    #{query => get_shipping_rates_request_query(),
      header => get_shipping_rates_request_header(),
      cookie => get_shipping_rates_request_cookie(),
      body => {binary(), get_shipping_rates_request_body()}}.
-type get_shipping_rates_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      currency => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_shipping_rates_request_header() :: map().
-type get_shipping_rates_request_cookie() :: map().
-type get_shipping_rates_request_body() :: #{}.
-type get_shipping_rates_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:shipping_rate()],
      _ := json:value()}.
-type post_file_links_link_request() ::
    #{link := binary(),
      query => post_file_links_link_request_query(),
      header => post_file_links_link_request_header(),
      cookie => post_file_links_link_request_cookie(),
      body => {binary(), post_file_links_link_request_body()}}.
-type post_file_links_link_request_query() :: map().
-type post_file_links_link_request_header() :: map().
-type post_file_links_link_request_cookie() :: map().
-type post_file_links_link_request_body() ::
    #{metadata => json:value() | '',
      expires_at => now | integer() | '',
      expand => [binary()]}.
-type post_file_links_link_response() :: stripe_model:error() | stripe_model:file_link().
-type get_file_links_link_request() ::
    #{link := binary(),
      query => get_file_links_link_request_query(),
      header => get_file_links_link_request_header(),
      cookie => get_file_links_link_request_cookie(),
      body => {binary(), get_file_links_link_request_body()}}.
-type get_file_links_link_request_query() :: #{expand => [binary()]}.
-type get_file_links_link_request_header() :: map().
-type get_file_links_link_request_cookie() :: map().
-type get_file_links_link_request_body() :: #{}.
-type get_file_links_link_response() :: stripe_model:error() | stripe_model:file_link().
-type get3d_secure_three_d_secure_request() ::
    #{three_d_secure := binary(),
      query => get3d_secure_three_d_secure_request_query(),
      header => get3d_secure_three_d_secure_request_header(),
      cookie => get3d_secure_three_d_secure_request_cookie(),
      body => {binary(), get3d_secure_three_d_secure_request_body()}}.
-type get3d_secure_three_d_secure_request_query() :: #{expand => [binary()]}.
-type get3d_secure_three_d_secure_request_header() :: map().
-type get3d_secure_three_d_secure_request_cookie() :: map().
-type get3d_secure_three_d_secure_request_body() :: #{}.
-type get3d_secure_three_d_secure_response() ::
    stripe_model:error() | stripe_model:three_d_secure().
-type post_invoices_invoice_send_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_send_request_query(),
      header => post_invoices_invoice_send_request_header(),
      cookie => post_invoices_invoice_send_request_cookie(),
      body => {binary(), post_invoices_invoice_send_request_body()}}.
-type post_invoices_invoice_send_request_query() :: map().
-type post_invoices_invoice_send_request_header() :: map().
-type post_invoices_invoice_send_request_cookie() :: map().
-type post_invoices_invoice_send_request_body() :: #{expand => [binary()]}.
-type post_invoices_invoice_send_response() ::
    stripe_model:error() | stripe_model:invoice().
-type get_invoices_upcoming_request() ::
    #{query => get_invoices_upcoming_request_query(),
      header => get_invoices_upcoming_request_header(),
      cookie => get_invoices_upcoming_request_cookie(),
      body => {binary(), get_invoices_upcoming_request_body()}}.
-type get_invoices_upcoming_request_query() ::
    #{automatic_tax => #{enabled := boolean(), _ := json:value()},
      coupon => binary(),
      customer => binary(),
      customer_details =>
          #{tax_ids =>
                [#{value := binary(),
                   type :=
                       ae_trn | au_abn | au_arn | br_cnpj | br_cpf | ca_bn | ca_gst_hst |
                       ca_pst_bc | ca_pst_mb | ca_pst_sk | ca_qst | ch_vat | cl_tin | es_cif |
                       eu_vat | gb_vat | ge_vat | hk_br | id_npwp | il_vat | in_gst | is_vat |
                       jp_cn | jp_rn | kr_brn | li_uid | mx_rfc | my_frp | my_itn | my_sst |
                       no_vat | nz_gst | ru_inn | ru_kpp | sa_vat | sg_gst | sg_uen | th_vat |
                       tw_vat | ua_vat | us_ein | za_vat,
                   _ := json:value()}],
            tax_exempt => '' | exempt | none | reverse,
            tax => #{ip_address => binary() | '', _ := json:value()},
            shipping =>
                #{phone => binary(),
                  name := binary(),
                  address :=
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  _ := json:value()} |
                '',
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()} |
                '',
            _ := json:value()},
      discounts =>
          [#{discount => binary(),
             coupon => binary(),
             _ := json:value()}] |
          '',
      expand => [binary()],
      invoice_items =>
          [#{unit_amount_decimal => binary(),
             unit_amount => integer(),
             tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             period =>
                 #{start := integer(),
                   'end' := integer(),
                   _ := json:value()},
             metadata => json:value() | '',
             invoiceitem => binary(),
             discounts =>
                 [#{discount => binary(),
                    coupon => binary(),
                    _ := json:value()}] |
                 '',
             discountable => boolean(),
             description => binary(),
             currency => binary(),
             amount => integer(),
             _ := json:value()}],
      schedule => binary(),
      subscription => binary(),
      subscription_billing_cycle_anchor => now | unchanged | integer(),
      subscription_cancel_at => integer() | '',
      subscription_cancel_at_period_end => boolean(),
      subscription_cancel_now => boolean(),
      subscription_default_tax_rates => [binary()] | '',
      subscription_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring :=
                       #{interval_count => integer(),
                         interval := day | month | week | year,
                         _ := json:value()},
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             metadata => json:value() | '',
             id => binary(),
             deleted => boolean(),
             clear_usage => boolean(),
             billing_thresholds => #{usage_gte := integer(), _ := json:value()} | '',
             _ := json:value()}],
      subscription_proration_behavior => always_invoice | create_prorations | none,
      subscription_proration_date => integer(),
      subscription_start_date => integer(),
      subscription_trial_end => now | integer(),
      subscription_trial_from_plan => boolean()}.
-type get_invoices_upcoming_request_header() :: map().
-type get_invoices_upcoming_request_cookie() :: map().
-type get_invoices_upcoming_request_body() :: #{}.
-type get_invoices_upcoming_response() :: stripe_model:error() | stripe_model:invoice().
-type get_checkout_sessions_session_line_items_request() ::
    #{session := binary(),
      query => get_checkout_sessions_session_line_items_request_query(),
      header => get_checkout_sessions_session_line_items_request_header(),
      cookie => get_checkout_sessions_session_line_items_request_cookie(),
      body => {binary(), get_checkout_sessions_session_line_items_request_body()}}.
-type get_checkout_sessions_session_line_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_checkout_sessions_session_line_items_request_header() :: map().
-type get_checkout_sessions_session_line_items_request_cookie() :: map().
-type get_checkout_sessions_session_line_items_request_body() :: #{}.
-type get_checkout_sessions_session_line_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:item()],
      _ := json:value()}.
-type get_tax_codes_request() ::
    #{query => get_tax_codes_request_query(),
      header => get_tax_codes_request_header(),
      cookie => get_tax_codes_request_cookie(),
      body => {binary(), get_tax_codes_request_body()}}.
-type get_tax_codes_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_tax_codes_request_header() :: map().
-type get_tax_codes_request_cookie() :: map().
-type get_tax_codes_request_body() :: #{}.
-type get_tax_codes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:tax_code()],
      _ := json:value()}.
-type post_invoices_request() ::
    #{query => post_invoices_request_query(),
      header => post_invoices_request_header(),
      cookie => post_invoices_request_cookie(),
      body := {binary(), post_invoices_request_body()}}.
-type post_invoices_request_query() :: map().
-type post_invoices_request_header() :: map().
-type post_invoices_request_cookie() :: map().
-type post_invoices_request_body() ::
    #{transfer_data =>
          #{destination := binary(),
            amount => integer(),
            _ := json:value()},
      subscription => binary(),
      statement_descriptor => binary(),
      payment_settings =>
          #{payment_method_types =>
                [ach_credit_transfer |
                 ach_debit |
                 acss_debit |
                 au_becs_debit |
                 bacs_debit |
                 bancontact |
                 boleto |
                 card |
                 fpx |
                 giropay |
                 grabpay |
                 ideal |
                 sepa_debit |
                 sofort |
                 wechat_pay] |
                '',
            payment_method_options =>
                #{card => #{request_three_d_secure => any | automatic, _ := json:value()} | '',
                  bancontact => #{preferred_language => de | en | fr | nl, _ := json:value()} | '',
                  acss_debit =>
                      #{verification_method => automatic | instant | microdeposits,
                        mandate_options =>
                            #{transaction_type => business | personal, _ := json:value()},
                        _ := json:value()} |
                      '',
                  _ := json:value()},
            _ := json:value()},
      on_behalf_of => binary(),
      metadata => json:value() | '',
      footer => binary(),
      expand => [binary()],
      due_date => integer(),
      discounts =>
          [#{discount => binary(),
             coupon => binary(),
             _ := json:value()}] |
          '',
      description => binary(),
      default_tax_rates => [binary()],
      default_source => binary(),
      default_payment_method => binary(),
      days_until_due => integer(),
      customer := binary(),
      custom_fields =>
          [#{value := binary(),
             name := binary(),
             _ := json:value()}] |
          '',
      collection_method => charge_automatically | send_invoice,
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      auto_advance => boolean(),
      application_fee_amount => integer(),
      account_tax_ids => [binary()] | ''}.
-type post_invoices_response() :: stripe_model:error() | stripe_model:invoice().
-type get_invoices_request() ::
    #{query => get_invoices_request_query(),
      header => get_invoices_request_header(),
      cookie => get_invoices_request_cookie(),
      body => {binary(), get_invoices_request_body()}}.
-type get_invoices_request_query() ::
    #{collection_method => charge_automatically | send_invoice,
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      customer => binary(),
      due_date =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => draft | open | paid | uncollectible | void,
      subscription => binary()}.
-type get_invoices_request_header() :: map().
-type get_invoices_request_cookie() :: map().
-type get_invoices_request_body() :: #{}.
-type get_invoices_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:invoice()],
      _ := json:value()}.
-type post_charges_charge_request() ::
    #{charge := binary(),
      query => post_charges_charge_request_query(),
      header => post_charges_charge_request_header(),
      cookie => post_charges_charge_request_cookie(),
      body => {binary(), post_charges_charge_request_body()}}.
-type post_charges_charge_request_query() :: map().
-type post_charges_charge_request_header() :: map().
-type post_charges_charge_request_cookie() :: map().
-type post_charges_charge_request_body() ::
    #{transfer_group => binary(),
      shipping =>
          #{tracking_number => binary(),
            phone => binary(),
            name := binary(),
            carrier => binary(),
            address :=
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      receipt_email => binary(),
      metadata => json:value() | '',
      fraud_details => #{user_report := '' | fraudulent | safe, _ := json:value()},
      expand => [binary()],
      description => binary(),
      customer => binary()}.
-type post_charges_charge_response() :: stripe_model:error() | stripe_model:charge().
-type get_charges_charge_request() ::
    #{charge := binary(),
      query => get_charges_charge_request_query(),
      header => get_charges_charge_request_header(),
      cookie => get_charges_charge_request_cookie(),
      body => {binary(), get_charges_charge_request_body()}}.
-type get_charges_charge_request_query() :: #{expand => [binary()]}.
-type get_charges_charge_request_header() :: map().
-type get_charges_charge_request_cookie() :: map().
-type get_charges_charge_request_body() :: #{}.
-type get_charges_charge_response() :: stripe_model:error() | stripe_model:charge().
-type post_invoices_invoice_mark_uncollectible_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_mark_uncollectible_request_query(),
      header => post_invoices_invoice_mark_uncollectible_request_header(),
      cookie => post_invoices_invoice_mark_uncollectible_request_cookie(),
      body => {binary(), post_invoices_invoice_mark_uncollectible_request_body()}}.
-type post_invoices_invoice_mark_uncollectible_request_query() :: map().
-type post_invoices_invoice_mark_uncollectible_request_header() :: map().
-type post_invoices_invoice_mark_uncollectible_request_cookie() :: map().
-type post_invoices_invoice_mark_uncollectible_request_body() :: #{expand => [binary()]}.
-type post_invoices_invoice_mark_uncollectible_response() ::
    stripe_model:error() | stripe_model:invoice().
-type post_customers_customer_sources_id_verify_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_sources_id_verify_request_query(),
      header => post_customers_customer_sources_id_verify_request_header(),
      cookie => post_customers_customer_sources_id_verify_request_cookie(),
      body => {binary(), post_customers_customer_sources_id_verify_request_body()}}.
-type post_customers_customer_sources_id_verify_request_query() :: map().
-type post_customers_customer_sources_id_verify_request_header() :: map().
-type post_customers_customer_sources_id_verify_request_cookie() :: map().
-type post_customers_customer_sources_id_verify_request_body() ::
    #{expand => [binary()], amounts => [integer()]}.
-type post_customers_customer_sources_id_verify_response() ::
    stripe_model:error() | stripe_model:bank_account().
-type post_orders_id_pay_request() ::
    #{id := binary(),
      query => post_orders_id_pay_request_query(),
      header => post_orders_id_pay_request_header(),
      cookie => post_orders_id_pay_request_cookie(),
      body => {binary(), post_orders_id_pay_request_body()}}.
-type post_orders_id_pay_request_query() :: map().
-type post_orders_id_pay_request_header() :: map().
-type post_orders_id_pay_request_cookie() :: map().
-type post_orders_id_pay_request_body() ::
    #{source => binary(),
      metadata => json:value(),
      expand => [binary()],
      email => binary(),
      customer => binary(),
      application_fee => integer()}.
-type post_orders_id_pay_response() :: stripe_model:error() | stripe_model:order().
-type post_customers_customer_bank_accounts_id_verify_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_bank_accounts_id_verify_request_query(),
      header => post_customers_customer_bank_accounts_id_verify_request_header(),
      cookie => post_customers_customer_bank_accounts_id_verify_request_cookie(),
      body => {binary(), post_customers_customer_bank_accounts_id_verify_request_body()}}.
-type post_customers_customer_bank_accounts_id_verify_request_query() :: map().
-type post_customers_customer_bank_accounts_id_verify_request_header() :: map().
-type post_customers_customer_bank_accounts_id_verify_request_cookie() :: map().
-type post_customers_customer_bank_accounts_id_verify_request_body() ::
    #{expand => [binary()], amounts => [integer()]}.
-type post_customers_customer_bank_accounts_id_verify_response() ::
    stripe_model:error() | stripe_model:bank_account().
-type delete_account_people_person_request() ::
    #{person := binary(),
      query => delete_account_people_person_request_query(),
      header => delete_account_people_person_request_header(),
      cookie => delete_account_people_person_request_cookie(),
      body => {binary(), delete_account_people_person_request_body()}}.
-type delete_account_people_person_request_query() :: map().
-type delete_account_people_person_request_header() :: map().
-type delete_account_people_person_request_cookie() :: map().
-type delete_account_people_person_request_body() :: #{}.
-type delete_account_people_person_response() ::
    stripe_model:error() | stripe_model:deleted_person().
-type post_account_people_person_request() ::
    #{person := binary(),
      query => post_account_people_person_request_query(),
      header => post_account_people_person_request_header(),
      cookie => post_account_people_person_request_cookie(),
      body => {binary(), post_account_people_person_request_body()}}.
-type post_account_people_person_request_query() :: map().
-type post_account_people_person_request_header() :: map().
-type post_account_people_person_request_cookie() :: map().
-type post_account_people_person_request_body() ::
    #{verification =>
          #{document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            additional_document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            _ := json:value()},
      ssn_last_4 => binary(),
      relationship =>
          #{title => binary(),
            representative => boolean(),
            percent_ownership => number() | '',
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      political_exposure => binary(),
      phone => binary(),
      person_token => binary(),
      nationality => binary(),
      metadata => json:value() | '',
      maiden_name => binary(),
      last_name_kanji => binary(),
      last_name_kana => binary(),
      last_name => binary(),
      id_number => binary(),
      gender => binary(),
      full_name_aliases => [binary()] | '',
      first_name_kanji => binary(),
      first_name_kana => binary(),
      first_name => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{visa => #{files => [binary()], _ := json:value()},
            passport => #{files => [binary()], _ := json:value()},
            company_authorization => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      dob =>
          #{year := integer(),
            month := integer(),
            day := integer(),
            _ := json:value()} |
          '',
      address_kanji =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address_kana =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      account => binary()}.
-type post_account_people_person_response() ::
    stripe_model:error() | stripe_model:person().
-type get_account_people_person_request() ::
    #{person := binary(),
      query => get_account_people_person_request_query(),
      header => get_account_people_person_request_header(),
      cookie => get_account_people_person_request_cookie(),
      body => {binary(), get_account_people_person_request_body()}}.
-type get_account_people_person_request_query() :: #{expand => [binary()]}.
-type get_account_people_person_request_header() :: map().
-type get_account_people_person_request_cookie() :: map().
-type get_account_people_person_request_body() :: #{}.
-type get_account_people_person_response() ::
    stripe_model:error() | stripe_model:person().
-type post_checkout_sessions_request() ::
    #{query => post_checkout_sessions_request_query(),
      header => post_checkout_sessions_request_header(),
      cookie => post_checkout_sessions_request_cookie(),
      body := {binary(), post_checkout_sessions_request_body()}}.
-type post_checkout_sessions_request_query() :: map().
-type post_checkout_sessions_request_header() :: map().
-type post_checkout_sessions_request_cookie() :: map().
-type post_checkout_sessions_request_body() ::
    #{tax_id_collection => #{enabled := boolean(), _ := json:value()},
      success_url := binary(),
      subscription_data =>
          #{trial_period_days => integer(),
            trial_end => integer(),
            transfer_data =>
                #{destination := binary(),
                  amount_percent => number(),
                  _ := json:value()},
            metadata => json:value(),
            items =>
                [#{tax_rates => [binary()],
                   quantity => integer(),
                   plan := binary(),
                   _ := json:value()}],
            default_tax_rates => [binary()],
            application_fee_percent => number(),
            _ := json:value()},
      submit_type => auto | book | donate | pay,
      shipping_options =>
          [#{shipping_rate_data =>
                 #{type => fixed_amount,
                   tax_code => binary(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   metadata => json:value(),
                   fixed_amount =>
                       #{currency := binary(),
                         amount := integer(),
                         _ := json:value()},
                   display_name := binary(),
                   delivery_estimate =>
                       #{minimum =>
                             #{value := integer(),
                               unit := business_day | day | hour | month | week,
                               _ := json:value()},
                         maximum =>
                             #{value := integer(),
                               unit := business_day | day | hour | month | week,
                               _ := json:value()},
                         _ := json:value()},
                   _ := json:value()},
             shipping_rate => binary(),
             _ := json:value()}],
      shipping_address_collection =>
          #{allowed_countries :=
                ['AC' | 'AD' | 'AE' | 'AF' | 'AG' | 'AI' | 'AL' | 'AM' | 'AO' | 'AQ' | 'AR' | 'AT' |
                 'AU' | 'AW' | 'AX' | 'AZ' | 'BA' | 'BB' | 'BD' | 'BE' | 'BF' | 'BG' | 'BH' | 'BI' |
                 'BJ' | 'BL' | 'BM' | 'BN' | 'BO' | 'BQ' | 'BR' | 'BS' | 'BT' | 'BV' | 'BW' | 'BY' |
                 'BZ' | 'CA' | 'CD' | 'CF' | 'CG' | 'CH' | 'CI' | 'CK' | 'CL' | 'CM' | 'CN' | 'CO' |
                 'CR' | 'CV' | 'CW' | 'CY' | 'CZ' | 'DE' | 'DJ' | 'DK' | 'DM' | 'DO' | 'DZ' | 'EC' |
                 'EE' | 'EG' | 'EH' | 'ER' | 'ES' | 'ET' | 'FI' | 'FJ' | 'FK' | 'FO' | 'FR' | 'GA' |
                 'GB' | 'GD' | 'GE' | 'GF' | 'GG' | 'GH' | 'GI' | 'GL' | 'GM' | 'GN' | 'GP' | 'GQ' |
                 'GR' | 'GS' | 'GT' | 'GU' | 'GW' | 'GY' | 'HK' | 'HN' | 'HR' | 'HT' | 'HU' | 'ID' |
                 'IE' | 'IL' | 'IM' | 'IN' | 'IO' | 'IQ' | 'IS' | 'IT' | 'JE' | 'JM' | 'JO' | 'JP' |
                 'KE' | 'KG' | 'KH' | 'KI' | 'KM' | 'KN' | 'KR' | 'KW' | 'KY' | 'KZ' | 'LA' | 'LB' |
                 'LC' | 'LI' | 'LK' | 'LR' | 'LS' | 'LT' | 'LU' | 'LV' | 'LY' | 'MA' | 'MC' | 'MD' |
                 'ME' | 'MF' | 'MG' | 'MK' | 'ML' | 'MM' | 'MN' | 'MO' | 'MQ' | 'MR' | 'MS' | 'MT' |
                 'MU' | 'MV' | 'MW' | 'MX' | 'MY' | 'MZ' | 'NA' | 'NC' | 'NE' | 'NG' | 'NI' | 'NL' |
                 'NO' | 'NP' | 'NR' | 'NU' | 'NZ' | 'OM' | 'PA' | 'PE' | 'PF' | 'PG' | 'PH' | 'PK' |
                 'PL' | 'PM' | 'PN' | 'PR' | 'PS' | 'PT' | 'PY' | 'QA' | 'RE' | 'RO' | 'RS' | 'RU' |
                 'RW' | 'SA' | 'SB' | 'SC' | 'SE' | 'SG' | 'SH' | 'SI' | 'SJ' | 'SK' | 'SL' | 'SM' |
                 'SN' | 'SO' | 'SR' | 'SS' | 'ST' | 'SV' | 'SX' | 'SZ' | 'TA' | 'TC' | 'TD' | 'TF' |
                 'TG' | 'TH' | 'TJ' | 'TK' | 'TL' | 'TM' | 'TN' | 'TO' | 'TR' | 'TT' | 'TV' | 'TW' |
                 'TZ' | 'UA' | 'UG' | 'US' | 'UY' | 'UZ' | 'VA' | 'VC' | 'VE' | 'VG' | 'VN' | 'VU' |
                 'WF' | 'WS' | 'XK' | 'YE' | 'YT' | 'ZA' | 'ZM' | 'ZW' | 'ZZ'],
            _ := json:value()},
      setup_intent_data =>
          #{on_behalf_of => binary(),
            metadata => json:value(),
            description => binary(),
            _ := json:value()},
      phone_number_collection => #{enabled := boolean(), _ := json:value()},
      payment_method_types =>
          [acss_debit |
           afterpay_clearpay |
           alipay |
           au_becs_debit |
           bacs_debit |
           bancontact |
           boleto |
           card |
           eps |
           fpx |
           giropay |
           grabpay |
           ideal |
           klarna |
           oxxo |
           p24 |
           sepa_debit |
           sofort |
           wechat_pay],
      payment_method_options =>
          #{wechat_pay =>
                #{client := android | ios | web,
                  app_id => binary(),
                  _ := json:value()},
            oxxo => #{expires_after_days => integer(), _ := json:value()},
            boleto => #{expires_after_days => integer(), _ := json:value()},
            acss_debit =>
                #{verification_method => automatic | instant | microdeposits,
                  mandate_options =>
                      #{transaction_type => business | personal,
                        payment_schedule => combined | interval | sporadic,
                        interval_description => binary(),
                        default_for => [invoice | subscription],
                        custom_mandate_url => binary() | '',
                        _ := json:value()},
                  currency => cad | usd,
                  _ := json:value()},
            _ := json:value()},
      payment_intent_data =>
          #{transfer_group => binary(),
            transfer_data =>
                #{destination := binary(),
                  amount => integer(),
                  _ := json:value()},
            statement_descriptor_suffix => binary(),
            statement_descriptor => binary(),
            shipping =>
                #{tracking_number => binary(),
                  phone => binary(),
                  name := binary(),
                  carrier => binary(),
                  address :=
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 := binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  _ := json:value()},
            setup_future_usage => off_session | on_session,
            receipt_email => binary(),
            on_behalf_of => binary(),
            metadata => json:value(),
            description => binary(),
            capture_method => automatic | manual,
            application_fee_amount => integer(),
            _ := json:value()},
      mode => payment | setup | subscription,
      metadata => json:value(),
      locale =>
          auto | bg | cs | da | de | el | en | 'en-GB' | es | 'es-419' | et | fi | fil | fr |
          'fr-CA' | hr | hu | id | it | ja | ko | lt | lv | ms | mt | nb | nl | pl | pt | 'pt-BR' |
          ro | ru | sk | sl | sv | th | tr | vi | zh | 'zh-HK' | 'zh-TW',
      line_items =>
          [#{tax_rates => [binary()],
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring =>
                       #{interval_count => integer(),
                         interval := day | month | week | year,
                         _ := json:value()},
                   product_data =>
                       #{tax_code => binary(),
                         name := binary(),
                         metadata => json:value(),
                         images => [binary()],
                         description => binary(),
                         _ := json:value()},
                   product => binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             dynamic_tax_rates => [binary()],
             adjustable_quantity =>
                 #{minimum => integer(),
                   maximum => integer(),
                   enabled := boolean(),
                   _ := json:value()},
             _ := json:value()}],
      expires_at => integer(),
      expand => [binary()],
      discounts =>
          [#{promotion_code => binary(),
             coupon => binary(),
             _ := json:value()}],
      customer_update =>
          #{shipping => auto | never,
            name => auto | never,
            address => auto | never,
            _ := json:value()},
      customer_email => binary(),
      customer_creation => always | if_required,
      customer => binary(),
      consent_collection => #{promotions => auto, _ := json:value()},
      client_reference_id => binary(),
      cancel_url := binary(),
      billing_address_collection => auto | required,
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      allow_promotion_codes => boolean(),
      after_expiration =>
          #{recovery =>
                #{enabled := boolean(),
                  allow_promotion_codes => boolean(),
                  _ := json:value()},
            _ := json:value()}}.
-type post_checkout_sessions_response() ::
    stripe_model:error() | stripe_model:checkout_session().
-type get_checkout_sessions_request() ::
    #{query => get_checkout_sessions_request_query(),
      header => get_checkout_sessions_request_header(),
      cookie => get_checkout_sessions_request_cookie(),
      body => {binary(), get_checkout_sessions_request_body()}}.
-type get_checkout_sessions_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary(),
      subscription => binary()}.
-type get_checkout_sessions_request_header() :: map().
-type get_checkout_sessions_request_cookie() :: map().
-type get_checkout_sessions_request_body() :: #{}.
-type get_checkout_sessions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:checkout_session()],
      _ := json:value()}.
-type post_accounts_account_login_links_request() ::
    #{account := binary(),
      query => post_accounts_account_login_links_request_query(),
      header => post_accounts_account_login_links_request_header(),
      cookie => post_accounts_account_login_links_request_cookie(),
      body => {binary(), post_accounts_account_login_links_request_body()}}.
-type post_accounts_account_login_links_request_query() :: map().
-type post_accounts_account_login_links_request_header() :: map().
-type post_accounts_account_login_links_request_cookie() :: map().
-type post_accounts_account_login_links_request_body() ::
    #{redirect_url => binary(), expand => [binary()]}.
-type post_accounts_account_login_links_response() ::
    stripe_model:error() | stripe_model:login_link().
-type post_terminal_readers_request() ::
    #{query => post_terminal_readers_request_query(),
      header => post_terminal_readers_request_header(),
      cookie => post_terminal_readers_request_cookie(),
      body := {binary(), post_terminal_readers_request_body()}}.
-type post_terminal_readers_request_query() :: map().
-type post_terminal_readers_request_header() :: map().
-type post_terminal_readers_request_cookie() :: map().
-type post_terminal_readers_request_body() ::
    #{registration_code := binary(),
      metadata => json:value() | '',
      location => binary(),
      label => binary(),
      expand => [binary()]}.
-type post_terminal_readers_response() ::
    stripe_model:error() | stripe_model:terminal_reader().
-type get_terminal_readers_request() ::
    #{query => get_terminal_readers_request_query(),
      header => get_terminal_readers_request_header(),
      cookie => get_terminal_readers_request_cookie(),
      body => {binary(), get_terminal_readers_request_body()}}.
-type get_terminal_readers_request_query() ::
    #{device_type =>
          bbpos_chipper2x | bbpos_wisepad3 | bbpos_wisepos_e | stripe_m2 | verifone_P400,
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      location => binary(),
      starting_after => binary(),
      status => offline | online}.
-type get_terminal_readers_request_header() :: map().
-type get_terminal_readers_request_cookie() :: map().
-type get_terminal_readers_request_body() :: #{}.
-type get_terminal_readers_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:terminal_reader()],
      _ := json:value()}.
-type post_issuing_disputes_request() ::
    #{query => post_issuing_disputes_request_query(),
      header => post_issuing_disputes_request_header(),
      cookie => post_issuing_disputes_request_cookie(),
      body := {binary(), post_issuing_disputes_request_body()}}.
-type post_issuing_disputes_request_query() :: map().
-type post_issuing_disputes_request_header() :: map().
-type post_issuing_disputes_request_cookie() :: map().
-type post_issuing_disputes_request_body() ::
    #{transaction := binary(),
      metadata => json:value(),
      expand => [binary()],
      evidence =>
          #{service_not_as_described =>
                #{received_at => integer() | '',
                  explanation => binary(),
                  cancellation_reason => binary(),
                  canceled_at => integer() | '',
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            reason =>
                canceled |
                duplicate |
                fraudulent |
                merchandise_not_as_described |
                not_received |
                other |
                service_not_as_described,
            other =>
                #{product_type => '' | merchandise | service,
                  product_description => binary(),
                  explanation => binary(),
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            not_received =>
                #{product_type => '' | merchandise | service,
                  product_description => binary(),
                  explanation => binary(),
                  expected_at => integer() | '',
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            merchandise_not_as_described =>
                #{returned_at => integer() | '',
                  return_status => '' | merchant_rejected | successful,
                  return_description => binary(),
                  received_at => integer() | '',
                  explanation => binary(),
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            fraudulent =>
                #{explanation => binary(),
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            duplicate =>
                #{original_transaction => binary(),
                  explanation => binary(),
                  check_image => binary() | '',
                  cash_receipt => binary() | '',
                  card_statement => binary() | '',
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            canceled =>
                #{returned_at => integer() | '',
                  return_status => '' | merchant_rejected | successful,
                  product_type => '' | merchandise | service,
                  product_description => binary(),
                  explanation => binary(),
                  expected_at => integer() | '',
                  cancellation_reason => binary(),
                  cancellation_policy_provided => boolean() | '',
                  canceled_at => integer() | '',
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            _ := json:value()}}.
-type post_issuing_disputes_response() ::
    stripe_model:error() | stripe_model:issuing_dispute().
-type get_issuing_disputes_request() ::
    #{query => get_issuing_disputes_request_query(),
      header => get_issuing_disputes_request_header(),
      cookie => get_issuing_disputes_request_cookie(),
      body => {binary(), get_issuing_disputes_request_body()}}.
-type get_issuing_disputes_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => expired | lost | submitted | unsubmitted | won,
      transaction => binary()}.
-type get_issuing_disputes_request_header() :: map().
-type get_issuing_disputes_request_cookie() :: map().
-type get_issuing_disputes_request_body() :: #{}.
-type get_issuing_disputes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_dispute()],
      _ := json:value()}.
-type post3d_secure_request() ::
    #{query => post3d_secure_request_query(),
      header => post3d_secure_request_header(),
      cookie => post3d_secure_request_cookie(),
      body := {binary(), post3d_secure_request_body()}}.
-type post3d_secure_request_query() :: map().
-type post3d_secure_request_header() :: map().
-type post3d_secure_request_cookie() :: map().
-type post3d_secure_request_body() ::
    #{return_url := binary(),
      expand => [binary()],
      customer => binary(),
      currency := binary(),
      card => binary(),
      amount := integer()}.
-type post3d_secure_response() :: stripe_model:error() | stripe_model:three_d_secure().
-type post_prices_request() ::
    #{query => post_prices_request_query(),
      header => post_prices_request_header(),
      cookie => post_prices_request_cookie(),
      body := {binary(), post_prices_request_body()}}.
-type post_prices_request_query() :: map().
-type post_prices_request_header() :: map().
-type post_prices_request_cookie() :: map().
-type post_prices_request_body() ::
    #{unit_amount_decimal => binary(),
      unit_amount => integer(),
      transform_quantity =>
          #{round := down | up,
            divide_by := integer(),
            _ := json:value()},
      transfer_lookup_key => boolean(),
      tiers_mode => graduated | volume,
      tiers =>
          [#{up_to := inf | integer(),
             unit_amount_decimal => binary(),
             unit_amount => integer(),
             flat_amount_decimal => binary(),
             flat_amount => integer(),
             _ := json:value()}],
      tax_behavior => exclusive | inclusive | unspecified,
      recurring =>
          #{usage_type => licensed | metered,
            interval_count => integer(),
            interval := day | month | week | year,
            aggregate_usage => last_during_period | last_ever | max | sum,
            _ := json:value()},
      product_data =>
          #{unit_label => binary(),
            tax_code => binary(),
            statement_descriptor => binary(),
            name := binary(),
            metadata => json:value(),
            id => binary(),
            active => boolean(),
            _ := json:value()},
      product => binary(),
      nickname => binary(),
      metadata => json:value(),
      lookup_key => binary(),
      expand => [binary()],
      currency := binary(),
      billing_scheme => per_unit | tiered,
      active => boolean()}.
-type post_prices_response() :: stripe_model:error() | stripe_model:price().
-type get_prices_request() ::
    #{query => get_prices_request_query(),
      header => get_prices_request_header(),
      cookie => get_prices_request_cookie(),
      body => {binary(), get_prices_request_body()}}.
-type get_prices_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      currency => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      lookup_keys => [binary()],
      product => binary(),
      recurring =>
          #{usage_type => licensed | metered,
            interval => day | month | week | year,
            _ := json:value()},
      starting_after => binary(),
      type => one_time | recurring}.
-type get_prices_request_header() :: map().
-type get_prices_request_cookie() :: map().
-type get_prices_request_body() :: #{}.
-type get_prices_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:price()],
      _ := json:value()}.
-type delete_invoices_invoice_request() ::
    #{invoice := binary(),
      query => delete_invoices_invoice_request_query(),
      header => delete_invoices_invoice_request_header(),
      cookie => delete_invoices_invoice_request_cookie(),
      body => {binary(), delete_invoices_invoice_request_body()}}.
-type delete_invoices_invoice_request_query() :: map().
-type delete_invoices_invoice_request_header() :: map().
-type delete_invoices_invoice_request_cookie() :: map().
-type delete_invoices_invoice_request_body() :: #{}.
-type delete_invoices_invoice_response() ::
    stripe_model:error() | stripe_model:deleted_invoice().
-type post_invoices_invoice_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_request_query(),
      header => post_invoices_invoice_request_header(),
      cookie => post_invoices_invoice_request_cookie(),
      body => {binary(), post_invoices_invoice_request_body()}}.
-type post_invoices_invoice_request_query() :: map().
-type post_invoices_invoice_request_header() :: map().
-type post_invoices_invoice_request_cookie() :: map().
-type post_invoices_invoice_request_body() ::
    #{transfer_data =>
          #{destination := binary(),
            amount => integer(),
            _ := json:value()} |
          '',
      statement_descriptor => binary(),
      payment_settings =>
          #{payment_method_types =>
                [ach_credit_transfer |
                 ach_debit |
                 acss_debit |
                 au_becs_debit |
                 bacs_debit |
                 bancontact |
                 boleto |
                 card |
                 fpx |
                 giropay |
                 grabpay |
                 ideal |
                 sepa_debit |
                 sofort |
                 wechat_pay] |
                '',
            payment_method_options =>
                #{card => #{request_three_d_secure => any | automatic, _ := json:value()} | '',
                  bancontact => #{preferred_language => de | en | fr | nl, _ := json:value()} | '',
                  acss_debit =>
                      #{verification_method => automatic | instant | microdeposits,
                        mandate_options =>
                            #{transaction_type => business | personal, _ := json:value()},
                        _ := json:value()} |
                      '',
                  _ := json:value()},
            _ := json:value()},
      on_behalf_of => binary() | '',
      metadata => json:value() | '',
      footer => binary(),
      expand => [binary()],
      due_date => integer(),
      discounts =>
          [#{discount => binary(),
             coupon => binary(),
             _ := json:value()}] |
          '',
      description => binary(),
      default_tax_rates => [binary()] | '',
      default_source => binary(),
      default_payment_method => binary(),
      days_until_due => integer(),
      custom_fields =>
          [#{value := binary(),
             name := binary(),
             _ := json:value()}] |
          '',
      collection_method => charge_automatically | send_invoice,
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      auto_advance => boolean(),
      application_fee_amount => integer(),
      account_tax_ids => [binary()] | ''}.
-type post_invoices_invoice_response() :: stripe_model:error() | stripe_model:invoice().
-type get_invoices_invoice_request() ::
    #{invoice := binary(),
      query => get_invoices_invoice_request_query(),
      header => get_invoices_invoice_request_header(),
      cookie => get_invoices_invoice_request_cookie(),
      body => {binary(), get_invoices_invoice_request_body()}}.
-type get_invoices_invoice_request_query() :: #{expand => [binary()]}.
-type get_invoices_invoice_request_header() :: map().
-type get_invoices_invoice_request_cookie() :: map().
-type get_invoices_invoice_request_body() :: #{}.
-type get_invoices_invoice_response() :: stripe_model:error() | stripe_model:invoice().
-type post_identity_verification_sessions_session_request() ::
    #{session := binary(),
      query => post_identity_verification_sessions_session_request_query(),
      header => post_identity_verification_sessions_session_request_header(),
      cookie => post_identity_verification_sessions_session_request_cookie(),
      body => {binary(), post_identity_verification_sessions_session_request_body()}}.
-type post_identity_verification_sessions_session_request_query() :: map().
-type post_identity_verification_sessions_session_request_header() :: map().
-type post_identity_verification_sessions_session_request_cookie() :: map().
-type post_identity_verification_sessions_session_request_body() ::
    #{type => document | id_number,
      options =>
          #{document =>
                #{require_matching_selfie => boolean(),
                  require_live_capture => boolean(),
                  require_id_number => boolean(),
                  allowed_types => [driving_license | id_card | passport],
                  _ := json:value()} |
                '',
            _ := json:value()},
      metadata => json:value(),
      expand => [binary()]}.
-type post_identity_verification_sessions_session_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type get_identity_verification_sessions_session_request() ::
    #{session := binary(),
      query => get_identity_verification_sessions_session_request_query(),
      header => get_identity_verification_sessions_session_request_header(),
      cookie => get_identity_verification_sessions_session_request_cookie(),
      body => {binary(), get_identity_verification_sessions_session_request_body()}}.
-type get_identity_verification_sessions_session_request_query() ::
    #{expand => [binary()]}.
-type get_identity_verification_sessions_session_request_header() :: map().
-type get_identity_verification_sessions_session_request_cookie() :: map().
-type get_identity_verification_sessions_session_request_body() :: #{}.
-type get_identity_verification_sessions_session_response() ::
    stripe_model:error() | stripe_model:identity_verification_session().
-type get_balance_transactions_id_request() ::
    #{id := binary(),
      query => get_balance_transactions_id_request_query(),
      header => get_balance_transactions_id_request_header(),
      cookie => get_balance_transactions_id_request_cookie(),
      body => {binary(), get_balance_transactions_id_request_body()}}.
-type get_balance_transactions_id_request_query() :: #{expand => [binary()]}.
-type get_balance_transactions_id_request_header() :: map().
-type get_balance_transactions_id_request_cookie() :: map().
-type get_balance_transactions_id_request_body() :: #{}.
-type get_balance_transactions_id_response() ::
    stripe_model:error() | stripe_model:balance_transaction().
-type post_setup_intents_intent_cancel_request() ::
    #{intent := binary(),
      query => post_setup_intents_intent_cancel_request_query(),
      header => post_setup_intents_intent_cancel_request_header(),
      cookie => post_setup_intents_intent_cancel_request_cookie(),
      body => {binary(), post_setup_intents_intent_cancel_request_body()}}.
-type post_setup_intents_intent_cancel_request_query() :: map().
-type post_setup_intents_intent_cancel_request_header() :: map().
-type post_setup_intents_intent_cancel_request_cookie() :: map().
-type post_setup_intents_intent_cancel_request_body() ::
    #{expand => [binary()],
      cancellation_reason => abandoned | duplicate | requested_by_customer}.
-type post_setup_intents_intent_cancel_response() ::
    stripe_model:error() | stripe_model:setup_intent().
-type post_issuing_transactions_transaction_request() ::
    #{transaction := binary(),
      query => post_issuing_transactions_transaction_request_query(),
      header => post_issuing_transactions_transaction_request_header(),
      cookie => post_issuing_transactions_transaction_request_cookie(),
      body => {binary(), post_issuing_transactions_transaction_request_body()}}.
-type post_issuing_transactions_transaction_request_query() :: map().
-type post_issuing_transactions_transaction_request_header() :: map().
-type post_issuing_transactions_transaction_request_cookie() :: map().
-type post_issuing_transactions_transaction_request_body() ::
    #{metadata => json:value() | '', expand => [binary()]}.
-type post_issuing_transactions_transaction_response() ::
    stripe_model:error() | stripe_model:issuing_transaction().
-type get_issuing_transactions_transaction_request() ::
    #{transaction := binary(),
      query => get_issuing_transactions_transaction_request_query(),
      header => get_issuing_transactions_transaction_request_header(),
      cookie => get_issuing_transactions_transaction_request_cookie(),
      body => {binary(), get_issuing_transactions_transaction_request_body()}}.
-type get_issuing_transactions_transaction_request_query() :: #{expand => [binary()]}.
-type get_issuing_transactions_transaction_request_header() :: map().
-type get_issuing_transactions_transaction_request_cookie() :: map().
-type get_issuing_transactions_transaction_request_body() :: #{}.
-type get_issuing_transactions_transaction_response() ::
    stripe_model:error() | stripe_model:issuing_transaction().
-type post_terminal_connection_tokens_request() ::
    #{query => post_terminal_connection_tokens_request_query(),
      header => post_terminal_connection_tokens_request_header(),
      cookie => post_terminal_connection_tokens_request_cookie(),
      body => {binary(), post_terminal_connection_tokens_request_body()}}.
-type post_terminal_connection_tokens_request_query() :: map().
-type post_terminal_connection_tokens_request_header() :: map().
-type post_terminal_connection_tokens_request_cookie() :: map().
-type post_terminal_connection_tokens_request_body() ::
    #{location => binary(), expand => [binary()]}.
-type post_terminal_connection_tokens_response() ::
    stripe_model:error() | stripe_model:terminal_connection_token().
-type get_reviews_request() ::
    #{query => get_reviews_request_query(),
      header => get_reviews_request_header(),
      cookie => get_reviews_request_cookie(),
      body => {binary(), get_reviews_request_body()}}.
-type get_reviews_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_reviews_request_header() :: map().
-type get_reviews_request_cookie() :: map().
-type get_reviews_request_body() :: #{}.
-type get_reviews_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:review()],
      _ := json:value()}.
-type post_promotion_codes_request() ::
    #{query => post_promotion_codes_request_query(),
      header => post_promotion_codes_request_header(),
      cookie => post_promotion_codes_request_cookie(),
      body := {binary(), post_promotion_codes_request_body()}}.
-type post_promotion_codes_request_query() :: map().
-type post_promotion_codes_request_header() :: map().
-type post_promotion_codes_request_cookie() :: map().
-type post_promotion_codes_request_body() ::
    #{restrictions =>
          #{minimum_amount_currency => binary(),
            minimum_amount => integer(),
            first_time_transaction => boolean(),
            _ := json:value()},
      metadata => json:value(),
      max_redemptions => integer(),
      expires_at => integer(),
      expand => [binary()],
      customer => binary(),
      coupon := binary(),
      code => binary(),
      active => boolean()}.
-type post_promotion_codes_response() ::
    stripe_model:error() | stripe_model:promotion_code().
-type get_promotion_codes_request() ::
    #{query => get_promotion_codes_request_query(),
      header => get_promotion_codes_request_header(),
      cookie => get_promotion_codes_request_cookie(),
      body => {binary(), get_promotion_codes_request_body()}}.
-type get_promotion_codes_request_query() ::
    #{active => boolean(),
      code => binary(),
      coupon => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_promotion_codes_request_header() :: map().
-type get_promotion_codes_request_cookie() :: map().
-type get_promotion_codes_request_body() :: #{}.
-type get_promotion_codes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:promotion_code()],
      _ := json:value()}.
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query =>
          delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_query(),
      header =>
          delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_header(),
      cookie =>
          delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie(),
      body =>
          {binary(),
           delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_body()}}.
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_query() ::
    map().
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_header() ::
    map().
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie() ::
    map().
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_request_body() ::
    #{}.
-type
delete_customers_customer_subscriptions_subscription_exposed_id_discount_response() ::
    stripe_model:error() | stripe_model:deleted_discount().
-type get_customers_customer_subscriptions_subscription_exposed_id_discount_request() ::
    #{customer := binary(),
      subscription_exposed_id := binary(),
      query =>
          get_customers_customer_subscriptions_subscription_exposed_id_discount_request_query(),
      header =>
          get_customers_customer_subscriptions_subscription_exposed_id_discount_request_header(),
      cookie =>
          get_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie(),
      body =>
          {binary(),
           get_customers_customer_subscriptions_subscription_exposed_id_discount_request_body()}}.
-type
get_customers_customer_subscriptions_subscription_exposed_id_discount_request_query() ::
    #{expand => [binary()]}.
-type
get_customers_customer_subscriptions_subscription_exposed_id_discount_request_header() ::
    map().
-type
get_customers_customer_subscriptions_subscription_exposed_id_discount_request_cookie() ::
    map().
-type
get_customers_customer_subscriptions_subscription_exposed_id_discount_request_body() ::
    #{}.
-type get_customers_customer_subscriptions_subscription_exposed_id_discount_response() ::
    stripe_model:error() | stripe_model:discount().
-type get_quotes_quote_computed_upfront_line_items_request() ::
    #{quote := binary(),
      query => get_quotes_quote_computed_upfront_line_items_request_query(),
      header => get_quotes_quote_computed_upfront_line_items_request_header(),
      cookie => get_quotes_quote_computed_upfront_line_items_request_cookie(),
      body => {binary(), get_quotes_quote_computed_upfront_line_items_request_body()}}.
-type get_quotes_quote_computed_upfront_line_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_quotes_quote_computed_upfront_line_items_request_header() :: map().
-type get_quotes_quote_computed_upfront_line_items_request_cookie() :: map().
-type get_quotes_quote_computed_upfront_line_items_request_body() :: #{}.
-type get_quotes_quote_computed_upfront_line_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:item()],
      _ := json:value()}.
-type delete_radar_value_list_items_item_request() ::
    #{item := binary(),
      query => delete_radar_value_list_items_item_request_query(),
      header => delete_radar_value_list_items_item_request_header(),
      cookie => delete_radar_value_list_items_item_request_cookie(),
      body => {binary(), delete_radar_value_list_items_item_request_body()}}.
-type delete_radar_value_list_items_item_request_query() :: map().
-type delete_radar_value_list_items_item_request_header() :: map().
-type delete_radar_value_list_items_item_request_cookie() :: map().
-type delete_radar_value_list_items_item_request_body() :: #{}.
-type delete_radar_value_list_items_item_response() ::
    stripe_model:error() | stripe_model:deleted_radar_value_list_item().
-type get_radar_value_list_items_item_request() ::
    #{item := binary(),
      query => get_radar_value_list_items_item_request_query(),
      header => get_radar_value_list_items_item_request_header(),
      cookie => get_radar_value_list_items_item_request_cookie(),
      body => {binary(), get_radar_value_list_items_item_request_body()}}.
-type get_radar_value_list_items_item_request_query() :: #{expand => [binary()]}.
-type get_radar_value_list_items_item_request_header() :: map().
-type get_radar_value_list_items_item_request_cookie() :: map().
-type get_radar_value_list_items_item_request_body() :: #{}.
-type get_radar_value_list_items_item_response() ::
    stripe_model:error() | stripe_model:radar_value_list_item().
-type get_issuer_fraud_records_request() ::
    #{query => get_issuer_fraud_records_request_query(),
      header => get_issuer_fraud_records_request_header(),
      cookie => get_issuer_fraud_records_request_cookie(),
      body => {binary(), get_issuer_fraud_records_request_body()}}.
-type get_issuer_fraud_records_request_query() ::
    #{charge => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_issuer_fraud_records_request_header() :: map().
-type get_issuer_fraud_records_request_cookie() :: map().
-type get_issuer_fraud_records_request_body() :: #{}.
-type get_issuer_fraud_records_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuer_fraud_record()],
      _ := json:value()}.
-type post_tax_rates_tax_rate_request() ::
    #{tax_rate := binary(),
      query => post_tax_rates_tax_rate_request_query(),
      header => post_tax_rates_tax_rate_request_header(),
      cookie => post_tax_rates_tax_rate_request_cookie(),
      body => {binary(), post_tax_rates_tax_rate_request_body()}}.
-type post_tax_rates_tax_rate_request_query() :: map().
-type post_tax_rates_tax_rate_request_header() :: map().
-type post_tax_rates_tax_rate_request_cookie() :: map().
-type post_tax_rates_tax_rate_request_body() ::
    #{tax_type => gst | hst | jct | pst | qst | rst | sales_tax | vat,
      state => binary(),
      metadata => json:value() | '',
      jurisdiction => binary(),
      expand => [binary()],
      display_name => binary(),
      description => binary(),
      country => binary(),
      active => boolean()}.
-type post_tax_rates_tax_rate_response() ::
    stripe_model:error() | stripe_model:tax_rate().
-type get_tax_rates_tax_rate_request() ::
    #{tax_rate := binary(),
      query => get_tax_rates_tax_rate_request_query(),
      header => get_tax_rates_tax_rate_request_header(),
      cookie => get_tax_rates_tax_rate_request_cookie(),
      body => {binary(), get_tax_rates_tax_rate_request_body()}}.
-type get_tax_rates_tax_rate_request_query() :: #{expand => [binary()]}.
-type get_tax_rates_tax_rate_request_header() :: map().
-type get_tax_rates_tax_rate_request_cookie() :: map().
-type get_tax_rates_tax_rate_request_body() :: #{}.
-type get_tax_rates_tax_rate_response() :: stripe_model:error() | stripe_model:tax_rate().
-type post_recipients_request() ::
    #{query => post_recipients_request_query(),
      header => post_recipients_request_header(),
      cookie => post_recipients_request_cookie(),
      body := {binary(), post_recipients_request_body()}}.
-type post_recipients_request_query() :: map().
-type post_recipients_request_header() :: map().
-type post_recipients_request_cookie() :: map().
-type post_recipients_request_body() ::
    #{type := binary(),
      tax_id => binary(),
      name := binary(),
      metadata => json:value() | '',
      expand => [binary()],
      email => binary(),
      description => binary(),
      card => binary(),
      bank_account => binary()}.
-type post_recipients_response() :: stripe_model:error() | stripe_model:recipient().
-type get_recipients_request() ::
    #{query => get_recipients_request_query(),
      header => get_recipients_request_header(),
      cookie => get_recipients_request_cookie(),
      body => {binary(), get_recipients_request_body()}}.
-type get_recipients_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type => corporation | individual,
      verified => boolean()}.
-type get_recipients_request_header() :: map().
-type get_recipients_request_cookie() :: map().
-type get_recipients_request_body() :: #{}.
-type get_recipients_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:recipient()],
      _ := json:value()}.
-type post_plans_request() ::
    #{query => post_plans_request_query(),
      header => post_plans_request_header(),
      cookie => post_plans_request_cookie(),
      body := {binary(), post_plans_request_body()}}.
-type post_plans_request_query() :: map().
-type post_plans_request_header() :: map().
-type post_plans_request_cookie() :: map().
-type post_plans_request_body() ::
    #{usage_type => licensed | metered,
      trial_period_days => integer(),
      transform_usage =>
          #{round := down | up,
            divide_by := integer(),
            _ := json:value()},
      tiers_mode => graduated | volume,
      tiers =>
          [#{up_to := inf | integer(),
             unit_amount_decimal => binary(),
             unit_amount => integer(),
             flat_amount_decimal => binary(),
             flat_amount => integer(),
             _ := json:value()}],
      product =>
          #{unit_label => binary(),
            tax_code => binary(),
            statement_descriptor => binary(),
            name := binary(),
            metadata => json:value(),
            id => binary(),
            active => boolean(),
            _ := json:value()} |
          binary(),
      nickname => binary(),
      metadata => json:value() | '',
      interval_count => integer(),
      interval := day | month | week | year,
      id => binary(),
      expand => [binary()],
      currency := binary(),
      billing_scheme => per_unit | tiered,
      amount_decimal => binary(),
      amount => integer(),
      aggregate_usage => last_during_period | last_ever | max | sum,
      active => boolean()}.
-type post_plans_response() :: stripe_model:error() | stripe_model:plan().
-type get_plans_request() ::
    #{query => get_plans_request_query(),
      header => get_plans_request_header(),
      cookie => get_plans_request_cookie(),
      body => {binary(), get_plans_request_body()}}.
-type get_plans_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      product => binary(),
      starting_after => binary()}.
-type get_plans_request_header() :: map().
-type get_plans_request_cookie() :: map().
-type get_plans_request_body() :: #{}.
-type get_plans_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:plan()],
      _ := json:value()}.
-type post_customers_customer_balance_transactions_request() ::
    #{customer := binary(),
      query => post_customers_customer_balance_transactions_request_query(),
      header => post_customers_customer_balance_transactions_request_header(),
      cookie => post_customers_customer_balance_transactions_request_cookie(),
      body := {binary(), post_customers_customer_balance_transactions_request_body()}}.
-type post_customers_customer_balance_transactions_request_query() :: map().
-type post_customers_customer_balance_transactions_request_header() :: map().
-type post_customers_customer_balance_transactions_request_cookie() :: map().
-type post_customers_customer_balance_transactions_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      description => binary(),
      currency := binary(),
      amount := integer()}.
-type post_customers_customer_balance_transactions_response() ::
    stripe_model:error() | stripe_model:customer_balance_transaction().
-type get_customers_customer_balance_transactions_request() ::
    #{customer := binary(),
      query => get_customers_customer_balance_transactions_request_query(),
      header => get_customers_customer_balance_transactions_request_header(),
      cookie => get_customers_customer_balance_transactions_request_cookie(),
      body => {binary(), get_customers_customer_balance_transactions_request_body()}}.
-type get_customers_customer_balance_transactions_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_balance_transactions_request_header() :: map().
-type get_customers_customer_balance_transactions_request_cookie() :: map().
-type get_customers_customer_balance_transactions_request_body() :: #{}.
-type get_customers_customer_balance_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:customer_balance_transaction()],
      _ := json:value()}.
-type post_reviews_review_approve_request() ::
    #{review := binary(),
      query => post_reviews_review_approve_request_query(),
      header => post_reviews_review_approve_request_header(),
      cookie => post_reviews_review_approve_request_cookie(),
      body => {binary(), post_reviews_review_approve_request_body()}}.
-type post_reviews_review_approve_request_query() :: map().
-type post_reviews_review_approve_request_header() :: map().
-type post_reviews_review_approve_request_cookie() :: map().
-type post_reviews_review_approve_request_body() :: #{expand => [binary()]}.
-type post_reviews_review_approve_response() ::
    stripe_model:error() | stripe_model:review().
-type post_customers_customer_tax_ids_request() ::
    #{customer := binary(),
      query => post_customers_customer_tax_ids_request_query(),
      header => post_customers_customer_tax_ids_request_header(),
      cookie => post_customers_customer_tax_ids_request_cookie(),
      body := {binary(), post_customers_customer_tax_ids_request_body()}}.
-type post_customers_customer_tax_ids_request_query() :: map().
-type post_customers_customer_tax_ids_request_header() :: map().
-type post_customers_customer_tax_ids_request_cookie() :: map().
-type post_customers_customer_tax_ids_request_body() ::
    #{value := binary(),
      type :=
          ae_trn | au_abn | au_arn | br_cnpj | br_cpf | ca_bn | ca_gst_hst | ca_pst_bc | ca_pst_mb |
          ca_pst_sk | ca_qst | ch_vat | cl_tin | es_cif | eu_vat | gb_vat | ge_vat | hk_br |
          id_npwp | il_vat | in_gst | is_vat | jp_cn | jp_rn | kr_brn | li_uid | mx_rfc | my_frp |
          my_itn | my_sst | no_vat | nz_gst | ru_inn | ru_kpp | sa_vat | sg_gst | sg_uen | th_vat |
          tw_vat | ua_vat | us_ein | za_vat,
      expand => [binary()]}.
-type post_customers_customer_tax_ids_response() ::
    stripe_model:error() | stripe_model:tax_id().
-type get_customers_customer_tax_ids_request() ::
    #{customer := binary(),
      query => get_customers_customer_tax_ids_request_query(),
      header => get_customers_customer_tax_ids_request_header(),
      cookie => get_customers_customer_tax_ids_request_cookie(),
      body => {binary(), get_customers_customer_tax_ids_request_body()}}.
-type get_customers_customer_tax_ids_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_customer_tax_ids_request_header() :: map().
-type get_customers_customer_tax_ids_request_cookie() :: map().
-type get_customers_customer_tax_ids_request_body() :: #{}.
-type get_customers_customer_tax_ids_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:tax_id()],
      _ := json:value()}.
-type get_tokens_token_request() ::
    #{token := binary(),
      query => get_tokens_token_request_query(),
      header => get_tokens_token_request_header(),
      cookie => get_tokens_token_request_cookie(),
      body => {binary(), get_tokens_token_request_body()}}.
-type get_tokens_token_request_query() :: #{expand => [binary()]}.
-type get_tokens_token_request_header() :: map().
-type get_tokens_token_request_cookie() :: map().
-type get_tokens_token_request_body() :: #{}.
-type get_tokens_token_response() :: stripe_model:error() | stripe_model:token().
-type get_balance_transactions_request() ::
    #{query => get_balance_transactions_request_query(),
      header => get_balance_transactions_request_header(),
      cookie => get_balance_transactions_request_cookie(),
      body => {binary(), get_balance_transactions_request_body()}}.
-type get_balance_transactions_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      currency => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payout => binary(),
      source => binary(),
      starting_after => binary(),
      type => binary()}.
-type get_balance_transactions_request_header() :: map().
-type get_balance_transactions_request_cookie() :: map().
-type get_balance_transactions_request_body() :: #{}.
-type get_balance_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:balance_transaction()],
      _ := json:value()}.
-type get_tax_codes_id_request() ::
    #{id := binary(),
      query => get_tax_codes_id_request_query(),
      header => get_tax_codes_id_request_header(),
      cookie => get_tax_codes_id_request_cookie(),
      body => {binary(), get_tax_codes_id_request_body()}}.
-type get_tax_codes_id_request_query() :: #{expand => [binary()]}.
-type get_tax_codes_id_request_header() :: map().
-type get_tax_codes_id_request_cookie() :: map().
-type get_tax_codes_id_request_body() :: #{}.
-type get_tax_codes_id_response() :: stripe_model:error() | stripe_model:tax_code().
-type post_accounts_account_reject_request() ::
    #{account := binary(),
      query => post_accounts_account_reject_request_query(),
      header => post_accounts_account_reject_request_header(),
      cookie => post_accounts_account_reject_request_cookie(),
      body := {binary(), post_accounts_account_reject_request_body()}}.
-type post_accounts_account_reject_request_query() :: map().
-type post_accounts_account_reject_request_header() :: map().
-type post_accounts_account_reject_request_cookie() :: map().
-type post_accounts_account_reject_request_body() ::
    #{reason := binary(), expand => [binary()]}.
-type post_accounts_account_reject_response() ::
    stripe_model:error() | stripe_model:account().
-type delete_subscriptions_subscription_exposed_id_request() ::
    #{subscription_exposed_id := binary(),
      query => delete_subscriptions_subscription_exposed_id_request_query(),
      header => delete_subscriptions_subscription_exposed_id_request_header(),
      cookie => delete_subscriptions_subscription_exposed_id_request_cookie(),
      body => {binary(), delete_subscriptions_subscription_exposed_id_request_body()}}.
-type delete_subscriptions_subscription_exposed_id_request_query() :: map().
-type delete_subscriptions_subscription_exposed_id_request_header() :: map().
-type delete_subscriptions_subscription_exposed_id_request_cookie() :: map().
-type delete_subscriptions_subscription_exposed_id_request_body() ::
    #{prorate => boolean(),
      invoice_now => boolean(),
      expand => [binary()]}.
-type delete_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type post_subscriptions_subscription_exposed_id_request() ::
    #{subscription_exposed_id := binary(),
      query => post_subscriptions_subscription_exposed_id_request_query(),
      header => post_subscriptions_subscription_exposed_id_request_header(),
      cookie => post_subscriptions_subscription_exposed_id_request_cookie(),
      body => {binary(), post_subscriptions_subscription_exposed_id_request_body()}}.
-type post_subscriptions_subscription_exposed_id_request_query() :: map().
-type post_subscriptions_subscription_exposed_id_request_header() :: map().
-type post_subscriptions_subscription_exposed_id_request_cookie() :: map().
-type post_subscriptions_subscription_exposed_id_request_body() ::
    #{trial_from_plan => boolean(),
      trial_end => now | integer(),
      transfer_data =>
          #{destination := binary(),
            amount_percent => number(),
            _ := json:value()} |
          '',
      proration_date => integer(),
      proration_behavior => always_invoice | create_prorations | none,
      promotion_code => binary(),
      pending_invoice_item_interval =>
          #{interval_count => integer(),
            interval := day | month | week | year,
            _ := json:value()} |
          '',
      payment_settings =>
          #{payment_method_types =>
                [ach_credit_transfer |
                 ach_debit |
                 acss_debit |
                 au_becs_debit |
                 bacs_debit |
                 bancontact |
                 boleto |
                 card |
                 fpx |
                 giropay |
                 grabpay |
                 ideal |
                 sepa_debit |
                 sofort |
                 wechat_pay] |
                '',
            payment_method_options =>
                #{card =>
                      #{request_three_d_secure => any | automatic,
                        mandate_options =>
                            #{description => binary(),
                              amount_type => fixed | maximum,
                              amount => integer(),
                              _ := json:value()},
                        _ := json:value()} |
                      '',
                  bancontact => #{preferred_language => de | en | fr | nl, _ := json:value()} | '',
                  acss_debit =>
                      #{verification_method => automatic | instant | microdeposits,
                        mandate_options =>
                            #{transaction_type => business | personal, _ := json:value()},
                        _ := json:value()} |
                      '',
                  _ := json:value()},
            _ := json:value()},
      payment_behavior =>
          allow_incomplete | default_incomplete | error_if_incomplete | pending_if_incomplete,
      pause_collection =>
          #{resumes_at => integer(),
            behavior := keep_as_draft | mark_uncollectible | void,
            _ := json:value()} |
          '',
      off_session => boolean(),
      metadata => json:value() | '',
      items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring :=
                       #{interval_count => integer(),
                         interval := day | month | week | year,
                         _ := json:value()},
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             metadata => json:value() | '',
             id => binary(),
             deleted => boolean(),
             clear_usage => boolean(),
             billing_thresholds => #{usage_gte := integer(), _ := json:value()} | '',
             _ := json:value()}],
      expand => [binary()],
      default_tax_rates => [binary()] | '',
      default_source => binary(),
      default_payment_method => binary(),
      days_until_due => integer(),
      coupon => binary(),
      collection_method => charge_automatically | send_invoice,
      cancel_at_period_end => boolean(),
      cancel_at => integer() | '',
      billing_thresholds =>
          #{reset_billing_cycle_anchor => boolean(),
            amount_gte => integer(),
            _ := json:value()} |
          '',
      billing_cycle_anchor => now | unchanged,
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      application_fee_percent => number(),
      add_invoice_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             _ := json:value()}]}.
-type post_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_subscriptions_subscription_exposed_id_request() ::
    #{subscription_exposed_id := binary(),
      query => get_subscriptions_subscription_exposed_id_request_query(),
      header => get_subscriptions_subscription_exposed_id_request_header(),
      cookie => get_subscriptions_subscription_exposed_id_request_cookie(),
      body => {binary(), get_subscriptions_subscription_exposed_id_request_body()}}.
-type get_subscriptions_subscription_exposed_id_request_query() ::
    #{expand => [binary()]}.
-type get_subscriptions_subscription_exposed_id_request_header() :: map().
-type get_subscriptions_subscription_exposed_id_request_cookie() :: map().
-type get_subscriptions_subscription_exposed_id_request_body() :: #{}.
-type get_subscriptions_subscription_exposed_id_response() ::
    stripe_model:error() | stripe_model:subscription().
-type get_country_specs_country_request() ::
    #{country := binary(),
      query => get_country_specs_country_request_query(),
      header => get_country_specs_country_request_header(),
      cookie => get_country_specs_country_request_cookie(),
      body => {binary(), get_country_specs_country_request_body()}}.
-type get_country_specs_country_request_query() :: #{expand => [binary()]}.
-type get_country_specs_country_request_header() :: map().
-type get_country_specs_country_request_cookie() :: map().
-type get_country_specs_country_request_body() :: #{}.
-type get_country_specs_country_response() ::
    stripe_model:error() | stripe_model:country_spec().
-type post_invoices_invoice_finalize_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_finalize_request_query(),
      header => post_invoices_invoice_finalize_request_header(),
      cookie => post_invoices_invoice_finalize_request_cookie(),
      body => {binary(), post_invoices_invoice_finalize_request_body()}}.
-type post_invoices_invoice_finalize_request_query() :: map().
-type post_invoices_invoice_finalize_request_header() :: map().
-type post_invoices_invoice_finalize_request_cookie() :: map().
-type post_invoices_invoice_finalize_request_body() ::
    #{expand => [binary()], auto_advance => boolean()}.
-type post_invoices_invoice_finalize_response() ::
    stripe_model:error() | stripe_model:invoice().
-type delete_terminal_locations_location_request() ::
    #{location := binary(),
      query => delete_terminal_locations_location_request_query(),
      header => delete_terminal_locations_location_request_header(),
      cookie => delete_terminal_locations_location_request_cookie(),
      body => {binary(), delete_terminal_locations_location_request_body()}}.
-type delete_terminal_locations_location_request_query() :: map().
-type delete_terminal_locations_location_request_header() :: map().
-type delete_terminal_locations_location_request_cookie() :: map().
-type delete_terminal_locations_location_request_body() :: #{}.
-type delete_terminal_locations_location_response() ::
    stripe_model:error() | stripe_model:deleted_terminal_location().
-type post_terminal_locations_location_request() ::
    #{location := binary(),
      query => post_terminal_locations_location_request_query(),
      header => post_terminal_locations_location_request_header(),
      cookie => post_terminal_locations_location_request_cookie(),
      body => {binary(), post_terminal_locations_location_request_body()}}.
-type post_terminal_locations_location_request_query() :: map().
-type post_terminal_locations_location_request_header() :: map().
-type post_terminal_locations_location_request_cookie() :: map().
-type post_terminal_locations_location_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      display_name => binary(),
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()}}.
-type post_terminal_locations_location_response() ::
    stripe_model:error() | stripe_model:terminal_location().
-type get_terminal_locations_location_request() ::
    #{location := binary(),
      query => get_terminal_locations_location_request_query(),
      header => get_terminal_locations_location_request_header(),
      cookie => get_terminal_locations_location_request_cookie(),
      body => {binary(), get_terminal_locations_location_request_body()}}.
-type get_terminal_locations_location_request_query() :: #{expand => [binary()]}.
-type get_terminal_locations_location_request_header() :: map().
-type get_terminal_locations_location_request_cookie() :: map().
-type get_terminal_locations_location_request_body() :: #{}.
-type get_terminal_locations_location_response() ::
    stripe_model:error() | stripe_model:terminal_location().
-type delete_account_request() ::
    #{query => delete_account_request_query(),
      header => delete_account_request_header(),
      cookie => delete_account_request_cookie(),
      body => {binary(), delete_account_request_body()}}.
-type delete_account_request_query() :: map().
-type delete_account_request_header() :: map().
-type delete_account_request_cookie() :: map().
-type delete_account_request_body() :: #{account => binary()}.
-type delete_account_response() :: stripe_model:error() | stripe_model:deleted_account().
-type post_account_request() ::
    #{query => post_account_request_query(),
      header => post_account_request_header(),
      cookie => post_account_request_cookie(),
      body => {binary(), post_account_request_body()}}.
-type post_account_request_query() :: map().
-type post_account_request_header() :: map().
-type post_account_request_cookie() :: map().
-type post_account_request_body() ::
    #{tos_acceptance =>
          #{user_agent => binary(),
            service_agreement => binary(),
            ip => binary(),
            date => integer(),
            _ := json:value()},
      settings =>
          #{payouts =>
                #{statement_descriptor => binary(),
                  schedule =>
                      #{weekly_anchor =>
                            friday | monday | saturday | sunday | thursday | tuesday | wednesday,
                        monthly_anchor => integer(),
                        interval => daily | manual | monthly | weekly,
                        delay_days => minimum | integer(),
                        _ := json:value()},
                  debit_negative_balances => boolean(),
                  _ := json:value()},
            payments =>
                #{statement_descriptor_kanji => binary(),
                  statement_descriptor_kana => binary(),
                  statement_descriptor => binary(),
                  _ := json:value()},
            card_payments =>
                #{statement_descriptor_prefix => binary(),
                  decline_on =>
                      #{cvc_failure => boolean(),
                        avs_failure => boolean(),
                        _ := json:value()},
                  _ := json:value()},
            card_issuing =>
                #{tos_acceptance =>
                      #{user_agent => binary(),
                        ip => binary(),
                        date => integer(),
                        _ := json:value()},
                  _ := json:value()},
            branding =>
                #{secondary_color => binary(),
                  primary_color => binary(),
                  logo => binary(),
                  icon => binary(),
                  _ := json:value()},
            _ := json:value()},
      metadata => json:value() | '',
      individual =>
          #{verification =>
                #{document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  additional_document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  _ := json:value()},
            ssn_last_4 => binary(),
            political_exposure => existing | none,
            phone => binary(),
            metadata => json:value() | '',
            maiden_name => binary(),
            last_name_kanji => binary(),
            last_name_kana => binary(),
            last_name => binary(),
            id_number => binary(),
            gender => binary(),
            full_name_aliases => [binary()] | '',
            first_name_kanji => binary(),
            first_name_kana => binary(),
            first_name => binary(),
            email => binary(),
            dob =>
                #{year := integer(),
                  month := integer(),
                  day := integer(),
                  _ := json:value()} |
                '',
            address_kanji =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address_kana =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      external_account => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{proof_of_registration => #{files => [binary()], _ := json:value()},
            company_tax_id_verification => #{files => [binary()], _ := json:value()},
            company_registration_verification => #{files => [binary()], _ := json:value()},
            company_ministerial_decree => #{files => [binary()], _ := json:value()},
            company_memorandum_of_association => #{files => [binary()], _ := json:value()},
            company_license => #{files => [binary()], _ := json:value()},
            bank_account_ownership_verification => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      default_currency => binary(),
      company =>
          #{verification =>
                #{document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  _ := json:value()},
            vat_id => binary(),
            tax_id_registrar => binary(),
            tax_id => binary(),
            structure =>
                '' |
                free_zone_establishment |
                free_zone_llc |
                government_instrumentality |
                governmental_unit |
                incorporated_non_profit |
                limited_liability_partnership |
                llc |
                multi_member_llc |
                private_company |
                private_corporation |
                private_partnership |
                public_company |
                public_corporation |
                public_partnership |
                single_member_llc |
                sole_establishment |
                sole_proprietorship |
                tax_exempt_government_instrumentality |
                unincorporated_association |
                unincorporated_non_profit,
            registration_number => binary(),
            phone => binary(),
            ownership_declaration =>
                #{user_agent => binary(),
                  ip => binary(),
                  date => integer(),
                  _ := json:value()},
            owners_provided => boolean(),
            name_kanji => binary(),
            name_kana => binary(),
            name => binary(),
            executives_provided => boolean(),
            directors_provided => boolean(),
            address_kanji =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address_kana =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      capabilities =>
          #{transfers => #{requested => boolean(), _ := json:value()},
            tax_reporting_us_1099_misc => #{requested => boolean(), _ := json:value()},
            tax_reporting_us_1099_k => #{requested => boolean(), _ := json:value()},
            sofort_payments => #{requested => boolean(), _ := json:value()},
            sepa_debit_payments => #{requested => boolean(), _ := json:value()},
            p24_payments => #{requested => boolean(), _ := json:value()},
            oxxo_payments => #{requested => boolean(), _ := json:value()},
            legacy_payments => #{requested => boolean(), _ := json:value()},
            klarna_payments => #{requested => boolean(), _ := json:value()},
            jcb_payments => #{requested => boolean(), _ := json:value()},
            ideal_payments => #{requested => boolean(), _ := json:value()},
            grabpay_payments => #{requested => boolean(), _ := json:value()},
            giropay_payments => #{requested => boolean(), _ := json:value()},
            fpx_payments => #{requested => boolean(), _ := json:value()},
            eps_payments => #{requested => boolean(), _ := json:value()},
            cartes_bancaires_payments => #{requested => boolean(), _ := json:value()},
            card_payments => #{requested => boolean(), _ := json:value()},
            card_issuing => #{requested => boolean(), _ := json:value()},
            boleto_payments => #{requested => boolean(), _ := json:value()},
            bancontact_payments => #{requested => boolean(), _ := json:value()},
            bacs_debit_payments => #{requested => boolean(), _ := json:value()},
            au_becs_debit_payments => #{requested => boolean(), _ := json:value()},
            afterpay_clearpay_payments => #{requested => boolean(), _ := json:value()},
            acss_debit_payments => #{requested => boolean(), _ := json:value()},
            _ := json:value()},
      business_type => company | government_entity | individual | non_profit,
      business_profile =>
          #{url => binary(),
            support_url => binary() | '',
            support_phone => binary(),
            support_email => binary(),
            support_address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            product_description => binary(),
            name => binary(),
            mcc => binary(),
            _ := json:value()},
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_type => checking | futsu | savings | toza,
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary(),
      account_token => binary()}.
-type post_account_response() :: stripe_model:error() | stripe_model:account().
-type get_account_request() ::
    #{query => get_account_request_query(),
      header => get_account_request_header(),
      cookie => get_account_request_cookie(),
      body => {binary(), get_account_request_body()}}.
-type get_account_request_query() :: #{expand => [binary()]}.
-type get_account_request_header() :: map().
-type get_account_request_cookie() :: map().
-type get_account_request_body() :: #{}.
-type get_account_response() :: stripe_model:error() | stripe_model:account().
-type post_shipping_rates_shipping_rate_token_request() ::
    #{shipping_rate_token := binary(),
      query => post_shipping_rates_shipping_rate_token_request_query(),
      header => post_shipping_rates_shipping_rate_token_request_header(),
      cookie => post_shipping_rates_shipping_rate_token_request_cookie(),
      body => {binary(), post_shipping_rates_shipping_rate_token_request_body()}}.
-type post_shipping_rates_shipping_rate_token_request_query() :: map().
-type post_shipping_rates_shipping_rate_token_request_header() :: map().
-type post_shipping_rates_shipping_rate_token_request_cookie() :: map().
-type post_shipping_rates_shipping_rate_token_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      active => boolean()}.
-type post_shipping_rates_shipping_rate_token_response() ::
    stripe_model:error() | stripe_model:shipping_rate().
-type get_shipping_rates_shipping_rate_token_request() ::
    #{shipping_rate_token := binary(),
      query => get_shipping_rates_shipping_rate_token_request_query(),
      header => get_shipping_rates_shipping_rate_token_request_header(),
      cookie => get_shipping_rates_shipping_rate_token_request_cookie(),
      body => {binary(), get_shipping_rates_shipping_rate_token_request_body()}}.
-type get_shipping_rates_shipping_rate_token_request_query() :: #{expand => [binary()]}.
-type get_shipping_rates_shipping_rate_token_request_header() :: map().
-type get_shipping_rates_shipping_rate_token_request_cookie() :: map().
-type get_shipping_rates_shipping_rate_token_request_body() :: #{}.
-type get_shipping_rates_shipping_rate_token_response() ::
    stripe_model:error() | stripe_model:shipping_rate().
-type get_invoices_upcoming_lines_request() ::
    #{query => get_invoices_upcoming_lines_request_query(),
      header => get_invoices_upcoming_lines_request_header(),
      cookie => get_invoices_upcoming_lines_request_cookie(),
      body => {binary(), get_invoices_upcoming_lines_request_body()}}.
-type get_invoices_upcoming_lines_request_query() ::
    #{automatic_tax => #{enabled := boolean(), _ := json:value()},
      coupon => binary(),
      customer => binary(),
      customer_details =>
          #{tax_ids =>
                [#{value := binary(),
                   type :=
                       ae_trn | au_abn | au_arn | br_cnpj | br_cpf | ca_bn | ca_gst_hst |
                       ca_pst_bc | ca_pst_mb | ca_pst_sk | ca_qst | ch_vat | cl_tin | es_cif |
                       eu_vat | gb_vat | ge_vat | hk_br | id_npwp | il_vat | in_gst | is_vat |
                       jp_cn | jp_rn | kr_brn | li_uid | mx_rfc | my_frp | my_itn | my_sst |
                       no_vat | nz_gst | ru_inn | ru_kpp | sa_vat | sg_gst | sg_uen | th_vat |
                       tw_vat | ua_vat | us_ein | za_vat,
                   _ := json:value()}],
            tax_exempt => '' | exempt | none | reverse,
            tax => #{ip_address => binary() | '', _ := json:value()},
            shipping =>
                #{phone => binary(),
                  name := binary(),
                  address :=
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  _ := json:value()} |
                '',
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()} |
                '',
            _ := json:value()},
      discounts =>
          [#{discount => binary(),
             coupon => binary(),
             _ := json:value()}] |
          '',
      ending_before => binary(),
      expand => [binary()],
      invoice_items =>
          [#{unit_amount_decimal => binary(),
             unit_amount => integer(),
             tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             period =>
                 #{start := integer(),
                   'end' := integer(),
                   _ := json:value()},
             metadata => json:value() | '',
             invoiceitem => binary(),
             discounts =>
                 [#{discount => binary(),
                    coupon => binary(),
                    _ := json:value()}] |
                 '',
             discountable => boolean(),
             description => binary(),
             currency => binary(),
             amount => integer(),
             _ := json:value()}],
      limit => integer(),
      schedule => binary(),
      starting_after => binary(),
      subscription => binary(),
      subscription_billing_cycle_anchor => now | unchanged | integer(),
      subscription_cancel_at => integer() | '',
      subscription_cancel_at_period_end => boolean(),
      subscription_cancel_now => boolean(),
      subscription_default_tax_rates => [binary()] | '',
      subscription_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring :=
                       #{interval_count => integer(),
                         interval := day | month | week | year,
                         _ := json:value()},
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             metadata => json:value() | '',
             id => binary(),
             deleted => boolean(),
             clear_usage => boolean(),
             billing_thresholds => #{usage_gte := integer(), _ := json:value()} | '',
             _ := json:value()}],
      subscription_proration_behavior => always_invoice | create_prorations | none,
      subscription_proration_date => integer(),
      subscription_start_date => integer(),
      subscription_trial_end => now | integer(),
      subscription_trial_from_plan => boolean()}.
-type get_invoices_upcoming_lines_request_header() :: map().
-type get_invoices_upcoming_lines_request_cookie() :: map().
-type get_invoices_upcoming_lines_request_body() :: #{}.
-type get_invoices_upcoming_lines_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:line_item()],
      _ := json:value()}.
-type post_issuing_cardholders_request() ::
    #{query => post_issuing_cardholders_request_query(),
      header => post_issuing_cardholders_request_header(),
      cookie => post_issuing_cardholders_request_cookie(),
      body := {binary(), post_issuing_cardholders_request_body()}}.
-type post_issuing_cardholders_request_query() :: map().
-type post_issuing_cardholders_request_header() :: map().
-type post_issuing_cardholders_request_cookie() :: map().
-type post_issuing_cardholders_request_body() ::
    #{type := company | individual,
      status => active | inactive,
      spending_controls =>
          #{spending_limits_currency => binary(),
            spending_limits =>
                [#{interval := all_time | daily | monthly | per_authorization | weekly | yearly,
                   categories =>
                       [ac_refrigeration_repair | accounting_bookkeeping_services |
                        advertising_services | agricultural_cooperative | airlines_air_carriers |
                        airports_flying_fields | ambulance_services | amusement_parks_carnivals |
                        antique_reproductions | antique_shops | aquariums |
                        architectural_surveying_services | art_dealers_and_galleries |
                        artists_supply_and_craft_shops | auto_and_home_supply_stores |
                        auto_body_repair_shops | auto_paint_shops | auto_service_shops |
                        automated_cash_disburse | automated_fuel_dispensers |
                        automobile_associations | automotive_parts_and_accessories_stores |
                        automotive_tire_stores | bail_and_bond_payments | bakeries |
                        bands_orchestras | barber_and_beauty_shops | betting_casino_gambling |
                        bicycle_shops | billiard_pool_establishments | boat_dealers |
                        boat_rentals_and_leases | book_stores | books_periodicals_and_newspapers |
                        bowling_alleys | bus_lines | business_secretarial_schools |
                        buying_shopping_services |
                        cable_satellite_and_other_pay_television_and_radio |
                        camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                        car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                        car_rental_agencies | car_washes | carpentry_services |
                        carpet_upholstery_cleaning | caterers |
                        charitable_and_social_service_organizations_fundraising |
                        chemicals_and_allied_products | child_care_services |
                        childrens_and_infants_wear_stores | chiropodists_podiatrists |
                        chiropractors | cigar_stores_and_stands |
                        civic_social_fraternal_associations | cleaning_and_maintenance |
                        clothing_rental | colleges_universities | commercial_equipment |
                        commercial_footwear | commercial_photography_art_and_graphics |
                        commuter_transport_and_ferries | computer_network_services |
                        computer_programming | computer_repair | computer_software_stores |
                        computers_peripherals_and_software | concrete_work_services |
                        construction_materials | consulting_public_relations |
                        correspondence_schools | cosmetic_stores | counseling_services |
                        country_clubs | courier_services | court_costs | credit_reporting_agencies |
                        cruise_lines | dairy_products_stores | dance_hall_studios_schools |
                        dating_escort_services | dentists_orthodontists | department_stores |
                        detective_agencies | digital_goods_applications | digital_goods_games |
                        digital_goods_large_volume | digital_goods_media |
                        direct_marketing_catalog_merchant |
                        direct_marketing_combination_catalog_and_retail_merchant |
                        direct_marketing_inbound_telemarketing |
                        direct_marketing_insurance_services | direct_marketing_other |
                        direct_marketing_outbound_telemarketing | direct_marketing_subscription |
                        direct_marketing_travel | discount_stores | doctors | door_to_door_sales |
                        drapery_window_covering_and_upholstery_stores | drinking_places |
                        drug_stores_and_pharmacies |
                        drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners |
                        durable_goods | duty_free_stores | eating_places_restaurants |
                        educational_services | electric_razor_stores |
                        electrical_parts_and_equipment | electrical_services |
                        electronics_repair_shops | electronics_stores |
                        elementary_secondary_schools | employment_temp_agencies | equipment_rental |
                        exterminating_services | family_clothing_stores | fast_food_restaurants |
                        financial_institutions | fines_government_administrative_entities |
                        fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                        florists | florists_supplies_nursery_stock_and_flowers |
                        freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                        funeral_services_crematories |
                        furniture_home_furnishings_and_equipment_stores_except_appliances |
                        furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                        gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                        glassware_crystal_stores | golf_courses_public | government_services |
                        grocery_stores_supermarkets | hardware_equipment_and_supplies |
                        hardware_stores | health_and_beauty_spas | hearing_aids_sales_and_supplies |
                        heating_plumbing_a_c | hobby_toy_and_game_shops |
                        home_supply_warehouse_stores | hospitals | hotels_motels_and_resorts |
                        household_appliance_stores | industrial_supplies |
                        information_retrieval_services | insurance_default |
                        insurance_underwriting_premiums | intra_company_purchases |
                        jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                        laundries | laundry_cleaning_services | legal_services_attorneys |
                        luggage_and_leather_goods_stores | lumber_building_materials_stores |
                        manual_cash_disburse | marinas_service_and_supplies |
                        masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                        medical_dental_ophthalmic_and_hospital_equipment_and_supplies |
                        medical_services | membership_organizations |
                        mens_and_boys_clothing_and_accessories_stores |
                        mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                        miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                        miscellaneous_business_services | miscellaneous_food_stores |
                        miscellaneous_general_merchandise | miscellaneous_general_services |
                        miscellaneous_home_furnishing_specialty_stores |
                        miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                        miscellaneous_repair_shops | miscellaneous_specialty_retail |
                        mobile_home_dealers | motion_picture_theaters |
                        motor_freight_carriers_and_trucking | motor_homes_dealers |
                        motor_vehicle_supplies_and_new_parts | motorcycle_shops_and_dealers |
                        motorcycle_shops_dealers |
                        music_stores_musical_instruments_pianos_and_sheet_music |
                        news_dealers_and_newsstands | non_fi_money_orders |
                        non_fi_stored_value_card_purchase_load | nondurable_goods |
                        nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                        office_and_commercial_furniture | opticians_eyeglasses |
                        optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices |
                        osteopaths | package_stores_beer_wine_and_liquor |
                        paints_varnishes_and_supplies | parking_lots_garages | passenger_railways |
                        pawn_shops | pet_shops_pet_food_and_supplies |
                        petroleum_and_petroleum_products | photo_developing |
                        photographic_photocopy_microfilm_equipment_and_supplies |
                        photographic_studios | picture_video_production |
                        piece_goods_notions_and_other_dry_goods |
                        plumbing_heating_equipment_and_supplies | political_organizations |
                        postal_services_government_only |
                        precious_stones_and_metals_watches_and_jewelry | professional_services |
                        public_warehousing_and_storage | quick_copy_repro_and_blueprint |
                        railroads | real_estate_agents_and_managers_rentals | record_stores |
                        recreational_vehicle_rentals | religious_goods_stores |
                        religious_organizations | roofing_siding_sheet_metal |
                        secretarial_support_services | security_brokers_dealers | service_stations |
                        sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                        shoe_stores | small_appliance_repair | snowmobile_dealers |
                        special_trade_services | specialty_cleaning | sporting_goods_stores |
                        sporting_recreation_camps | sports_and_riding_apparel_stores |
                        sports_clubs_fields | stamp_and_coin_stores |
                        stationary_office_supplies_printing_and_writing_paper |
                        stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                        t_ui_travel_germany | tailors_alterations |
                        tax_payments_government_agencies | tax_preparation_services |
                        taxicabs_limousines | telecommunication_equipment_and_telephone_sales |
                        telecommunication_services | telegraph_services | tent_and_awning_shops |
                        testing_laboratories | theatrical_ticket_agencies | timeshares |
                        tire_retreading_and_repair | tolls_bridge_fees |
                        tourist_attractions_and_exhibits | towing_services |
                        trailer_parks_campgrounds | transportation_services |
                        travel_agencies_tour_operators | truck_stop_iteration |
                        truck_utility_trailer_rentals |
                        typesetting_plate_making_and_related_services | typewriter_stores |
                        u_s_federal_government_agencies_or_departments |
                        uniforms_commercial_clothing | used_merchandise_and_secondhand_stores |
                        utilities | variety_stores | veterinary_services |
                        video_amusement_game_supplies | video_game_arcades |
                        video_tape_rental_stores | vocational_trade_schools | watch_jewelry_repair |
                        welding_repair | wholesale_clubs | wig_and_toupee_stores |
                        wires_money_orders | womens_accessory_and_specialty_shops |
                        womens_ready_to_wear_stores | wrecking_and_salvage_yards],
                   amount := integer(),
                   _ := json:value()}],
            blocked_categories =>
                [ac_refrigeration_repair | accounting_bookkeeping_services | advertising_services |
                 agricultural_cooperative | airlines_air_carriers | airports_flying_fields |
                 ambulance_services | amusement_parks_carnivals | antique_reproductions |
                 antique_shops | aquariums | architectural_surveying_services |
                 art_dealers_and_galleries | artists_supply_and_craft_shops |
                 auto_and_home_supply_stores | auto_body_repair_shops | auto_paint_shops |
                 auto_service_shops | automated_cash_disburse | automated_fuel_dispensers |
                 automobile_associations | automotive_parts_and_accessories_stores |
                 automotive_tire_stores | bail_and_bond_payments | bakeries | bands_orchestras |
                 barber_and_beauty_shops | betting_casino_gambling | bicycle_shops |
                 billiard_pool_establishments | boat_dealers | boat_rentals_and_leases |
                 book_stores | books_periodicals_and_newspapers | bowling_alleys | bus_lines |
                 business_secretarial_schools | buying_shopping_services |
                 cable_satellite_and_other_pay_television_and_radio |
                 camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                 car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                 car_rental_agencies | car_washes | carpentry_services |
                 carpet_upholstery_cleaning | caterers |
                 charitable_and_social_service_organizations_fundraising |
                 chemicals_and_allied_products | child_care_services |
                 childrens_and_infants_wear_stores | chiropodists_podiatrists | chiropractors |
                 cigar_stores_and_stands | civic_social_fraternal_associations |
                 cleaning_and_maintenance | clothing_rental | colleges_universities |
                 commercial_equipment | commercial_footwear |
                 commercial_photography_art_and_graphics | commuter_transport_and_ferries |
                 computer_network_services | computer_programming | computer_repair |
                 computer_software_stores | computers_peripherals_and_software |
                 concrete_work_services | construction_materials | consulting_public_relations |
                 correspondence_schools | cosmetic_stores | counseling_services | country_clubs |
                 courier_services | court_costs | credit_reporting_agencies | cruise_lines |
                 dairy_products_stores | dance_hall_studios_schools | dating_escort_services |
                 dentists_orthodontists | department_stores | detective_agencies |
                 digital_goods_applications | digital_goods_games | digital_goods_large_volume |
                 digital_goods_media | direct_marketing_catalog_merchant |
                 direct_marketing_combination_catalog_and_retail_merchant |
                 direct_marketing_inbound_telemarketing | direct_marketing_insurance_services |
                 direct_marketing_other | direct_marketing_outbound_telemarketing |
                 direct_marketing_subscription | direct_marketing_travel | discount_stores |
                 doctors | door_to_door_sales | drapery_window_covering_and_upholstery_stores |
                 drinking_places | drug_stores_and_pharmacies |
                 drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners | durable_goods |
                 duty_free_stores | eating_places_restaurants | educational_services |
                 electric_razor_stores | electrical_parts_and_equipment | electrical_services |
                 electronics_repair_shops | electronics_stores | elementary_secondary_schools |
                 employment_temp_agencies | equipment_rental | exterminating_services |
                 family_clothing_stores | fast_food_restaurants | financial_institutions |
                 fines_government_administrative_entities |
                 fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                 florists | florists_supplies_nursery_stock_and_flowers |
                 freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                 funeral_services_crematories |
                 furniture_home_furnishings_and_equipment_stores_except_appliances |
                 furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                 gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                 glassware_crystal_stores | golf_courses_public | government_services |
                 grocery_stores_supermarkets | hardware_equipment_and_supplies | hardware_stores |
                 health_and_beauty_spas | hearing_aids_sales_and_supplies | heating_plumbing_a_c |
                 hobby_toy_and_game_shops | home_supply_warehouse_stores | hospitals |
                 hotels_motels_and_resorts | household_appliance_stores | industrial_supplies |
                 information_retrieval_services | insurance_default |
                 insurance_underwriting_premiums | intra_company_purchases |
                 jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                 laundries | laundry_cleaning_services | legal_services_attorneys |
                 luggage_and_leather_goods_stores | lumber_building_materials_stores |
                 manual_cash_disburse | marinas_service_and_supplies |
                 masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                 medical_dental_ophthalmic_and_hospital_equipment_and_supplies | medical_services |
                 membership_organizations | mens_and_boys_clothing_and_accessories_stores |
                 mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                 miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                 miscellaneous_business_services | miscellaneous_food_stores |
                 miscellaneous_general_merchandise | miscellaneous_general_services |
                 miscellaneous_home_furnishing_specialty_stores |
                 miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                 miscellaneous_repair_shops | miscellaneous_specialty_retail | mobile_home_dealers |
                 motion_picture_theaters | motor_freight_carriers_and_trucking |
                 motor_homes_dealers | motor_vehicle_supplies_and_new_parts |
                 motorcycle_shops_and_dealers | motorcycle_shops_dealers |
                 music_stores_musical_instruments_pianos_and_sheet_music |
                 news_dealers_and_newsstands | non_fi_money_orders |
                 non_fi_stored_value_card_purchase_load | nondurable_goods |
                 nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                 office_and_commercial_furniture | opticians_eyeglasses |
                 optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices | osteopaths |
                 package_stores_beer_wine_and_liquor | paints_varnishes_and_supplies |
                 parking_lots_garages | passenger_railways | pawn_shops |
                 pet_shops_pet_food_and_supplies | petroleum_and_petroleum_products |
                 photo_developing | photographic_photocopy_microfilm_equipment_and_supplies |
                 photographic_studios | picture_video_production |
                 piece_goods_notions_and_other_dry_goods | plumbing_heating_equipment_and_supplies |
                 political_organizations | postal_services_government_only |
                 precious_stones_and_metals_watches_and_jewelry | professional_services |
                 public_warehousing_and_storage | quick_copy_repro_and_blueprint | railroads |
                 real_estate_agents_and_managers_rentals | record_stores |
                 recreational_vehicle_rentals | religious_goods_stores | religious_organizations |
                 roofing_siding_sheet_metal | secretarial_support_services |
                 security_brokers_dealers | service_stations |
                 sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                 shoe_stores | small_appliance_repair | snowmobile_dealers |
                 special_trade_services | specialty_cleaning | sporting_goods_stores |
                 sporting_recreation_camps | sports_and_riding_apparel_stores |
                 sports_clubs_fields | stamp_and_coin_stores |
                 stationary_office_supplies_printing_and_writing_paper |
                 stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                 t_ui_travel_germany | tailors_alterations | tax_payments_government_agencies |
                 tax_preparation_services | taxicabs_limousines |
                 telecommunication_equipment_and_telephone_sales | telecommunication_services |
                 telegraph_services | tent_and_awning_shops | testing_laboratories |
                 theatrical_ticket_agencies | timeshares | tire_retreading_and_repair |
                 tolls_bridge_fees | tourist_attractions_and_exhibits | towing_services |
                 trailer_parks_campgrounds | transportation_services |
                 travel_agencies_tour_operators | truck_stop_iteration |
                 truck_utility_trailer_rentals | typesetting_plate_making_and_related_services |
                 typewriter_stores | u_s_federal_government_agencies_or_departments |
                 uniforms_commercial_clothing | used_merchandise_and_secondhand_stores | utilities |
                 variety_stores | veterinary_services | video_amusement_game_supplies |
                 video_game_arcades | video_tape_rental_stores | vocational_trade_schools |
                 watch_jewelry_repair | welding_repair | wholesale_clubs | wig_and_toupee_stores |
                 wires_money_orders | womens_accessory_and_specialty_shops |
                 womens_ready_to_wear_stores | wrecking_and_salvage_yards],
            allowed_categories =>
                [ac_refrigeration_repair | accounting_bookkeeping_services | advertising_services |
                 agricultural_cooperative | airlines_air_carriers | airports_flying_fields |
                 ambulance_services | amusement_parks_carnivals | antique_reproductions |
                 antique_shops | aquariums | architectural_surveying_services |
                 art_dealers_and_galleries | artists_supply_and_craft_shops |
                 auto_and_home_supply_stores | auto_body_repair_shops | auto_paint_shops |
                 auto_service_shops | automated_cash_disburse | automated_fuel_dispensers |
                 automobile_associations | automotive_parts_and_accessories_stores |
                 automotive_tire_stores | bail_and_bond_payments | bakeries | bands_orchestras |
                 barber_and_beauty_shops | betting_casino_gambling | bicycle_shops |
                 billiard_pool_establishments | boat_dealers | boat_rentals_and_leases |
                 book_stores | books_periodicals_and_newspapers | bowling_alleys | bus_lines |
                 business_secretarial_schools | buying_shopping_services |
                 cable_satellite_and_other_pay_television_and_radio |
                 camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                 car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                 car_rental_agencies | car_washes | carpentry_services |
                 carpet_upholstery_cleaning | caterers |
                 charitable_and_social_service_organizations_fundraising |
                 chemicals_and_allied_products | child_care_services |
                 childrens_and_infants_wear_stores | chiropodists_podiatrists | chiropractors |
                 cigar_stores_and_stands | civic_social_fraternal_associations |
                 cleaning_and_maintenance | clothing_rental | colleges_universities |
                 commercial_equipment | commercial_footwear |
                 commercial_photography_art_and_graphics | commuter_transport_and_ferries |
                 computer_network_services | computer_programming | computer_repair |
                 computer_software_stores | computers_peripherals_and_software |
                 concrete_work_services | construction_materials | consulting_public_relations |
                 correspondence_schools | cosmetic_stores | counseling_services | country_clubs |
                 courier_services | court_costs | credit_reporting_agencies | cruise_lines |
                 dairy_products_stores | dance_hall_studios_schools | dating_escort_services |
                 dentists_orthodontists | department_stores | detective_agencies |
                 digital_goods_applications | digital_goods_games | digital_goods_large_volume |
                 digital_goods_media | direct_marketing_catalog_merchant |
                 direct_marketing_combination_catalog_and_retail_merchant |
                 direct_marketing_inbound_telemarketing | direct_marketing_insurance_services |
                 direct_marketing_other | direct_marketing_outbound_telemarketing |
                 direct_marketing_subscription | direct_marketing_travel | discount_stores |
                 doctors | door_to_door_sales | drapery_window_covering_and_upholstery_stores |
                 drinking_places | drug_stores_and_pharmacies |
                 drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners | durable_goods |
                 duty_free_stores | eating_places_restaurants | educational_services |
                 electric_razor_stores | electrical_parts_and_equipment | electrical_services |
                 electronics_repair_shops | electronics_stores | elementary_secondary_schools |
                 employment_temp_agencies | equipment_rental | exterminating_services |
                 family_clothing_stores | fast_food_restaurants | financial_institutions |
                 fines_government_administrative_entities |
                 fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                 florists | florists_supplies_nursery_stock_and_flowers |
                 freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                 funeral_services_crematories |
                 furniture_home_furnishings_and_equipment_stores_except_appliances |
                 furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                 gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                 glassware_crystal_stores | golf_courses_public | government_services |
                 grocery_stores_supermarkets | hardware_equipment_and_supplies | hardware_stores |
                 health_and_beauty_spas | hearing_aids_sales_and_supplies | heating_plumbing_a_c |
                 hobby_toy_and_game_shops | home_supply_warehouse_stores | hospitals |
                 hotels_motels_and_resorts | household_appliance_stores | industrial_supplies |
                 information_retrieval_services | insurance_default |
                 insurance_underwriting_premiums | intra_company_purchases |
                 jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                 laundries | laundry_cleaning_services | legal_services_attorneys |
                 luggage_and_leather_goods_stores | lumber_building_materials_stores |
                 manual_cash_disburse | marinas_service_and_supplies |
                 masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                 medical_dental_ophthalmic_and_hospital_equipment_and_supplies | medical_services |
                 membership_organizations | mens_and_boys_clothing_and_accessories_stores |
                 mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                 miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                 miscellaneous_business_services | miscellaneous_food_stores |
                 miscellaneous_general_merchandise | miscellaneous_general_services |
                 miscellaneous_home_furnishing_specialty_stores |
                 miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                 miscellaneous_repair_shops | miscellaneous_specialty_retail | mobile_home_dealers |
                 motion_picture_theaters | motor_freight_carriers_and_trucking |
                 motor_homes_dealers | motor_vehicle_supplies_and_new_parts |
                 motorcycle_shops_and_dealers | motorcycle_shops_dealers |
                 music_stores_musical_instruments_pianos_and_sheet_music |
                 news_dealers_and_newsstands | non_fi_money_orders |
                 non_fi_stored_value_card_purchase_load | nondurable_goods |
                 nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                 office_and_commercial_furniture | opticians_eyeglasses |
                 optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices | osteopaths |
                 package_stores_beer_wine_and_liquor | paints_varnishes_and_supplies |
                 parking_lots_garages | passenger_railways | pawn_shops |
                 pet_shops_pet_food_and_supplies | petroleum_and_petroleum_products |
                 photo_developing | photographic_photocopy_microfilm_equipment_and_supplies |
                 photographic_studios | picture_video_production |
                 piece_goods_notions_and_other_dry_goods | plumbing_heating_equipment_and_supplies |
                 political_organizations | postal_services_government_only |
                 precious_stones_and_metals_watches_and_jewelry | professional_services |
                 public_warehousing_and_storage | quick_copy_repro_and_blueprint | railroads |
                 real_estate_agents_and_managers_rentals | record_stores |
                 recreational_vehicle_rentals | religious_goods_stores | religious_organizations |
                 roofing_siding_sheet_metal | secretarial_support_services |
                 security_brokers_dealers | service_stations |
                 sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                 shoe_stores | small_appliance_repair | snowmobile_dealers |
                 special_trade_services | specialty_cleaning | sporting_goods_stores |
                 sporting_recreation_camps | sports_and_riding_apparel_stores |
                 sports_clubs_fields | stamp_and_coin_stores |
                 stationary_office_supplies_printing_and_writing_paper |
                 stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                 t_ui_travel_germany | tailors_alterations | tax_payments_government_agencies |
                 tax_preparation_services | taxicabs_limousines |
                 telecommunication_equipment_and_telephone_sales | telecommunication_services |
                 telegraph_services | tent_and_awning_shops | testing_laboratories |
                 theatrical_ticket_agencies | timeshares | tire_retreading_and_repair |
                 tolls_bridge_fees | tourist_attractions_and_exhibits | towing_services |
                 trailer_parks_campgrounds | transportation_services |
                 travel_agencies_tour_operators | truck_stop_iteration |
                 truck_utility_trailer_rentals | typesetting_plate_making_and_related_services |
                 typewriter_stores | u_s_federal_government_agencies_or_departments |
                 uniforms_commercial_clothing | used_merchandise_and_secondhand_stores | utilities |
                 variety_stores | veterinary_services | video_amusement_game_supplies |
                 video_game_arcades | video_tape_rental_stores | vocational_trade_schools |
                 watch_jewelry_repair | welding_repair | wholesale_clubs | wig_and_toupee_stores |
                 wires_money_orders | womens_accessory_and_specialty_shops |
                 womens_ready_to_wear_stores | wrecking_and_salvage_yards],
            _ := json:value()},
      phone_number => binary(),
      name := binary(),
      metadata => json:value(),
      individual =>
          #{verification =>
                #{document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  _ := json:value()},
            last_name := binary(),
            first_name := binary(),
            dob =>
                #{year := integer(),
                  month := integer(),
                  day := integer(),
                  _ := json:value()},
            _ := json:value()},
      expand => [binary()],
      email => binary(),
      company => #{tax_id => binary(), _ := json:value()},
      billing :=
          #{address :=
                #{state => binary(),
                  postal_code := binary(),
                  line2 => binary(),
                  line1 := binary(),
                  country := binary(),
                  city := binary(),
                  _ := json:value()},
            _ := json:value()}}.
-type post_issuing_cardholders_response() ::
    stripe_model:error() | stripe_model:issuing_cardholder().
-type get_issuing_cardholders_request() ::
    #{query => get_issuing_cardholders_request_query(),
      header => get_issuing_cardholders_request_header(),
      cookie => get_issuing_cardholders_request_cookie(),
      body => {binary(), get_issuing_cardholders_request_body()}}.
-type get_issuing_cardholders_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      email => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      phone_number => binary(),
      starting_after => binary(),
      status => active | blocked | inactive,
      type => company | individual}.
-type get_issuing_cardholders_request_header() :: map().
-type get_issuing_cardholders_request_cookie() :: map().
-type get_issuing_cardholders_request_body() :: #{}.
-type get_issuing_cardholders_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_cardholder()],
      _ := json:value()}.
-type delete_customers_customer_sources_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => delete_customers_customer_sources_id_request_query(),
      header => delete_customers_customer_sources_id_request_header(),
      cookie => delete_customers_customer_sources_id_request_cookie(),
      body => {binary(), delete_customers_customer_sources_id_request_body()}}.
-type delete_customers_customer_sources_id_request_query() :: map().
-type delete_customers_customer_sources_id_request_header() :: map().
-type delete_customers_customer_sources_id_request_cookie() :: map().
-type delete_customers_customer_sources_id_request_body() :: #{expand => [binary()]}.
-type delete_customers_customer_sources_id_response() ::
    stripe_model:error() |
    stripe_model:payment_source() |
    stripe_model:deleted_payment_source().
-type post_customers_customer_sources_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_sources_id_request_query(),
      header => post_customers_customer_sources_id_request_header(),
      cookie => post_customers_customer_sources_id_request_cookie(),
      body => {binary(), post_customers_customer_sources_id_request_body()}}.
-type post_customers_customer_sources_id_request_query() :: map().
-type post_customers_customer_sources_id_request_header() :: map().
-type post_customers_customer_sources_id_request_cookie() :: map().
-type post_customers_customer_sources_id_request_body() ::
    #{owner =>
          #{phone => binary(),
            name => binary(),
            email => binary(),
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      name => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      exp_year => binary(),
      exp_month => binary(),
      address_zip => binary(),
      address_state => binary(),
      address_line2 => binary(),
      address_line1 => binary(),
      address_country => binary(),
      address_city => binary(),
      account_holder_type => company | individual,
      account_holder_name => binary()}.
-type post_customers_customer_sources_id_response() ::
    stripe_model:error() |
    stripe_model:card() |
    stripe_model:bank_account() |
    stripe_model:source().
-type get_customers_customer_sources_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => get_customers_customer_sources_id_request_query(),
      header => get_customers_customer_sources_id_request_header(),
      cookie => get_customers_customer_sources_id_request_cookie(),
      body => {binary(), get_customers_customer_sources_id_request_body()}}.
-type get_customers_customer_sources_id_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_sources_id_request_header() :: map().
-type get_customers_customer_sources_id_request_cookie() :: map().
-type get_customers_customer_sources_id_request_body() :: #{}.
-type get_customers_customer_sources_id_response() ::
    stripe_model:error() | stripe_model:payment_source().
-type get_application_fees_request() ::
    #{query => get_application_fees_request_query(),
      header => get_application_fees_request_header(),
      cookie => get_application_fees_request_cookie(),
      body => {binary(), get_application_fees_request_body()}}.
-type get_application_fees_request_query() ::
    #{charge => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_application_fees_request_header() :: map().
-type get_application_fees_request_cookie() :: map().
-type get_application_fees_request_body() :: #{}.
-type get_application_fees_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:application_fee()],
      _ := json:value()}.
-type get_bitcoin_receivers_request() ::
    #{query => get_bitcoin_receivers_request_query(),
      header => get_bitcoin_receivers_request_header(),
      cookie => get_bitcoin_receivers_request_cookie(),
      body => {binary(), get_bitcoin_receivers_request_body()}}.
-type get_bitcoin_receivers_request_query() ::
    #{active => boolean(),
      ending_before => binary(),
      expand => [binary()],
      filled => boolean(),
      limit => integer(),
      starting_after => binary(),
      uncaptured_funds => boolean()}.
-type get_bitcoin_receivers_request_header() :: map().
-type get_bitcoin_receivers_request_cookie() :: map().
-type get_bitcoin_receivers_request_body() :: #{}.
-type get_bitcoin_receivers_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bitcoin_receiver()],
      _ := json:value()}.
-type post_refunds_refund_request() ::
    #{refund := binary(),
      query => post_refunds_refund_request_query(),
      header => post_refunds_refund_request_header(),
      cookie => post_refunds_refund_request_cookie(),
      body => {binary(), post_refunds_refund_request_body()}}.
-type post_refunds_refund_request_query() :: map().
-type post_refunds_refund_request_header() :: map().
-type post_refunds_refund_request_cookie() :: map().
-type post_refunds_refund_request_body() ::
    #{metadata => json:value() | '', expand => [binary()]}.
-type post_refunds_refund_response() :: stripe_model:error() | stripe_model:refund().
-type get_refunds_refund_request() ::
    #{refund := binary(),
      query => get_refunds_refund_request_query(),
      header => get_refunds_refund_request_header(),
      cookie => get_refunds_refund_request_cookie(),
      body => {binary(), get_refunds_refund_request_body()}}.
-type get_refunds_refund_request_query() :: #{expand => [binary()]}.
-type get_refunds_refund_request_header() :: map().
-type get_refunds_refund_request_cookie() :: map().
-type get_refunds_refund_request_body() :: #{}.
-type get_refunds_refund_response() :: stripe_model:error() | stripe_model:refund().
-type post_account_login_links_request() ::
    #{query => post_account_login_links_request_query(),
      header => post_account_login_links_request_header(),
      cookie => post_account_login_links_request_cookie(),
      body := {binary(), post_account_login_links_request_body()}}.
-type post_account_login_links_request_query() :: map().
-type post_account_login_links_request_header() :: map().
-type post_account_login_links_request_cookie() :: map().
-type post_account_login_links_request_body() ::
    #{redirect_url => binary(),
      expand => [binary()],
      account := binary()}.
-type post_account_login_links_response() ::
    stripe_model:error() | stripe_model:login_link().
-type post_tax_rates_request() ::
    #{query => post_tax_rates_request_query(),
      header => post_tax_rates_request_header(),
      cookie => post_tax_rates_request_cookie(),
      body := {binary(), post_tax_rates_request_body()}}.
-type post_tax_rates_request_query() :: map().
-type post_tax_rates_request_header() :: map().
-type post_tax_rates_request_cookie() :: map().
-type post_tax_rates_request_body() ::
    #{tax_type => gst | hst | jct | pst | qst | rst | sales_tax | vat,
      state => binary(),
      percentage := number(),
      metadata => json:value(),
      jurisdiction => binary(),
      inclusive := boolean(),
      expand => [binary()],
      display_name := binary(),
      description => binary(),
      country => binary(),
      active => boolean()}.
-type post_tax_rates_response() :: stripe_model:error() | stripe_model:tax_rate().
-type get_tax_rates_request() ::
    #{query => get_tax_rates_request_query(),
      header => get_tax_rates_request_header(),
      cookie => get_tax_rates_request_cookie(),
      body => {binary(), get_tax_rates_request_body()}}.
-type get_tax_rates_request_query() ::
    #{active => boolean(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      inclusive => boolean(),
      limit => integer(),
      starting_after => binary()}.
-type get_tax_rates_request_header() :: map().
-type get_tax_rates_request_cookie() :: map().
-type get_tax_rates_request_body() :: #{}.
-type get_tax_rates_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:tax_rate()],
      _ := json:value()}.
-type post_accounts_account_people_request() ::
    #{account := binary(),
      query => post_accounts_account_people_request_query(),
      header => post_accounts_account_people_request_header(),
      cookie => post_accounts_account_people_request_cookie(),
      body => {binary(), post_accounts_account_people_request_body()}}.
-type post_accounts_account_people_request_query() :: map().
-type post_accounts_account_people_request_header() :: map().
-type post_accounts_account_people_request_cookie() :: map().
-type post_accounts_account_people_request_body() ::
    #{verification =>
          #{document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            additional_document =>
                #{front => binary(),
                  back => binary(),
                  _ := json:value()},
            _ := json:value()},
      ssn_last_4 => binary(),
      relationship =>
          #{title => binary(),
            representative => boolean(),
            percent_ownership => number() | '',
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      political_exposure => binary(),
      phone => binary(),
      person_token => binary(),
      nationality => binary(),
      metadata => json:value() | '',
      maiden_name => binary(),
      last_name_kanji => binary(),
      last_name_kana => binary(),
      last_name => binary(),
      id_number => binary(),
      gender => binary(),
      full_name_aliases => [binary()] | '',
      first_name_kanji => binary(),
      first_name_kana => binary(),
      first_name => binary(),
      expand => [binary()],
      email => binary(),
      documents =>
          #{visa => #{files => [binary()], _ := json:value()},
            passport => #{files => [binary()], _ := json:value()},
            company_authorization => #{files => [binary()], _ := json:value()},
            _ := json:value()},
      dob =>
          #{year := integer(),
            month := integer(),
            day := integer(),
            _ := json:value()} |
          '',
      address_kanji =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address_kana =>
          #{town => binary(),
            state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()},
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()}}.
-type post_accounts_account_people_response() ::
    stripe_model:error() | stripe_model:person().
-type get_accounts_account_people_request() ::
    #{account := binary(),
      query => get_accounts_account_people_request_query(),
      header => get_accounts_account_people_request_header(),
      cookie => get_accounts_account_people_request_cookie(),
      body => {binary(), get_accounts_account_people_request_body()}}.
-type get_accounts_account_people_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      relationship =>
          #{representative => boolean(),
            owner => boolean(),
            executive => boolean(),
            director => boolean(),
            _ := json:value()},
      starting_after => binary()}.
-type get_accounts_account_people_request_header() :: map().
-type get_accounts_account_people_request_cookie() :: map().
-type get_accounts_account_people_request_body() :: #{}.
-type get_accounts_account_people_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:person()],
      _ := json:value()}.
-type post_issuing_disputes_dispute_submit_request() ::
    #{dispute := binary(),
      query => post_issuing_disputes_dispute_submit_request_query(),
      header => post_issuing_disputes_dispute_submit_request_header(),
      cookie => post_issuing_disputes_dispute_submit_request_cookie(),
      body => {binary(), post_issuing_disputes_dispute_submit_request_body()}}.
-type post_issuing_disputes_dispute_submit_request_query() :: map().
-type post_issuing_disputes_dispute_submit_request_header() :: map().
-type post_issuing_disputes_dispute_submit_request_cookie() :: map().
-type post_issuing_disputes_dispute_submit_request_body() ::
    #{metadata => json:value() | '', expand => [binary()]}.
-type post_issuing_disputes_dispute_submit_response() ::
    stripe_model:error() | stripe_model:issuing_dispute().
-type post_sources_source_request() ::
    #{source := binary(),
      query => post_sources_source_request_query(),
      header => post_sources_source_request_header(),
      cookie => post_sources_source_request_cookie(),
      body => {binary(), post_sources_source_request_body()}}.
-type post_sources_source_request_query() :: map().
-type post_sources_source_request_header() :: map().
-type post_sources_source_request_cookie() :: map().
-type post_sources_source_request_body() ::
    #{source_order =>
          #{shipping =>
                #{tracking_number => binary(),
                  phone => binary(),
                  name => binary(),
                  carrier => binary(),
                  address :=
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 := binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  _ := json:value()},
            items =>
                [#{type => discount | shipping | sku | tax,
                   quantity => integer(),
                   parent => binary(),
                   description => binary(),
                   currency => binary(),
                   amount => integer(),
                   _ := json:value()}],
            _ := json:value()},
      owner =>
          #{phone => binary(),
            name => binary(),
            email => binary(),
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      metadata => json:value() | '',
      mandate =>
          #{notification_method => deprecated_none | email | manual | none | stripe_email,
            interval => one_time | scheduled | variable,
            currency => binary(),
            amount => integer() | '',
            acceptance =>
                #{user_agent => binary(),
                  type => offline | online,
                  status := accepted | pending | refused | revoked,
                  online =>
                      #{user_agent => binary(),
                        ip => binary(),
                        date => integer(),
                        _ := json:value()},
                  offline => #{contact_email := binary(), _ := json:value()},
                  ip => binary(),
                  date => integer(),
                  _ := json:value()},
            _ := json:value()},
      expand => [binary()],
      amount => integer()}.
-type post_sources_source_response() :: stripe_model:error() | stripe_model:source().
-type get_sources_source_request() ::
    #{source := binary(),
      query => get_sources_source_request_query(),
      header => get_sources_source_request_header(),
      cookie => get_sources_source_request_cookie(),
      body => {binary(), get_sources_source_request_body()}}.
-type get_sources_source_request_query() ::
    #{client_secret => binary(), expand => [binary()]}.
-type get_sources_source_request_header() :: map().
-type get_sources_source_request_cookie() :: map().
-type get_sources_source_request_body() :: #{}.
-type get_sources_source_response() :: stripe_model:error() | stripe_model:source().
-type get_checkout_sessions_session_request() ::
    #{session := binary(),
      query => get_checkout_sessions_session_request_query(),
      header => get_checkout_sessions_session_request_header(),
      cookie => get_checkout_sessions_session_request_cookie(),
      body => {binary(), get_checkout_sessions_session_request_body()}}.
-type get_checkout_sessions_session_request_query() :: #{expand => [binary()]}.
-type get_checkout_sessions_session_request_header() :: map().
-type get_checkout_sessions_session_request_cookie() :: map().
-type get_checkout_sessions_session_request_body() :: #{}.
-type get_checkout_sessions_session_response() ::
    stripe_model:error() | stripe_model:checkout_session().
-type post_payment_methods_payment_method_detach_request() ::
    #{payment_method := binary(),
      query => post_payment_methods_payment_method_detach_request_query(),
      header => post_payment_methods_payment_method_detach_request_header(),
      cookie => post_payment_methods_payment_method_detach_request_cookie(),
      body => {binary(), post_payment_methods_payment_method_detach_request_body()}}.
-type post_payment_methods_payment_method_detach_request_query() :: map().
-type post_payment_methods_payment_method_detach_request_header() :: map().
-type post_payment_methods_payment_method_detach_request_cookie() :: map().
-type post_payment_methods_payment_method_detach_request_body() ::
    #{expand => [binary()]}.
-type post_payment_methods_payment_method_detach_response() ::
    stripe_model:error() | stripe_model:payment_method().
-type post_customers_request() ::
    #{query => post_customers_request_query(),
      header => post_customers_request_header(),
      cookie => post_customers_request_cookie(),
      body => {binary(), post_customers_request_body()}}.
-type post_customers_request_query() :: map().
-type post_customers_request_header() :: map().
-type post_customers_request_cookie() :: map().
-type post_customers_request_body() ::
    #{tax_id_data =>
          [#{value := binary(),
             type :=
                 ae_trn | au_abn | au_arn | br_cnpj | br_cpf | ca_bn | ca_gst_hst | ca_pst_bc |
                 ca_pst_mb | ca_pst_sk | ca_qst | ch_vat | cl_tin | es_cif | eu_vat | gb_vat |
                 ge_vat | hk_br | id_npwp | il_vat | in_gst | is_vat | jp_cn | jp_rn | kr_brn |
                 li_uid | mx_rfc | my_frp | my_itn | my_sst | no_vat | nz_gst | ru_inn | ru_kpp |
                 sa_vat | sg_gst | sg_uen | th_vat | tw_vat | ua_vat | us_ein | za_vat,
             _ := json:value()}],
      tax_exempt => '' | exempt | none | reverse,
      tax => #{ip_address => binary() | '', _ := json:value()},
      source => binary(),
      shipping =>
          #{phone => binary(),
            name := binary(),
            address :=
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()} |
          '',
      promotion_code => binary(),
      preferred_locales => [binary()],
      phone => binary(),
      payment_method => binary(),
      next_invoice_sequence => integer(),
      name => binary(),
      metadata => json:value() | '',
      invoice_settings =>
          #{footer => binary(),
            default_payment_method => binary(),
            custom_fields =>
                [#{value := binary(),
                   name := binary(),
                   _ := json:value()}] |
                '',
            _ := json:value()},
      invoice_prefix => binary(),
      expand => [binary()],
      email => binary(),
      description => binary(),
      coupon => binary(),
      balance => integer(),
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()} |
          ''}.
-type post_customers_response() :: stripe_model:error() | stripe_model:customer().
-type get_customers_request() ::
    #{query => get_customers_request_query(),
      header => get_customers_request_header(),
      cookie => get_customers_request_cookie(),
      body => {binary(), get_customers_request_body()}}.
-type get_customers_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      email => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_customers_request_header() :: map().
-type get_customers_request_cookie() :: map().
-type get_customers_request_body() :: #{}.
-type get_customers_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:customer()],
      _ := json:value()}.
-type post_account_bank_accounts_request() ::
    #{query => post_account_bank_accounts_request_query(),
      header => post_account_bank_accounts_request_header(),
      cookie => post_account_bank_accounts_request_cookie(),
      body => {binary(), post_account_bank_accounts_request_body()}}.
-type post_account_bank_accounts_request_query() :: map().
-type post_account_bank_accounts_request_header() :: map().
-type post_account_bank_accounts_request_cookie() :: map().
-type post_account_bank_accounts_request_body() ::
    #{metadata => json:value(),
      external_account => binary(),
      expand => [binary()],
      default_for_currency => boolean(),
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_type => checking | futsu | savings | toza,
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary()}.
-type post_account_bank_accounts_response() ::
    stripe_model:error() | stripe_model:external_account().
-type post_issuing_disputes_dispute_request() ::
    #{dispute := binary(),
      query => post_issuing_disputes_dispute_request_query(),
      header => post_issuing_disputes_dispute_request_header(),
      cookie => post_issuing_disputes_dispute_request_cookie(),
      body => {binary(), post_issuing_disputes_dispute_request_body()}}.
-type post_issuing_disputes_dispute_request_query() :: map().
-type post_issuing_disputes_dispute_request_header() :: map().
-type post_issuing_disputes_dispute_request_cookie() :: map().
-type post_issuing_disputes_dispute_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      evidence =>
          #{service_not_as_described =>
                #{received_at => integer() | '',
                  explanation => binary(),
                  cancellation_reason => binary(),
                  canceled_at => integer() | '',
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            reason =>
                canceled |
                duplicate |
                fraudulent |
                merchandise_not_as_described |
                not_received |
                other |
                service_not_as_described,
            other =>
                #{product_type => '' | merchandise | service,
                  product_description => binary(),
                  explanation => binary(),
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            not_received =>
                #{product_type => '' | merchandise | service,
                  product_description => binary(),
                  explanation => binary(),
                  expected_at => integer() | '',
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            merchandise_not_as_described =>
                #{returned_at => integer() | '',
                  return_status => '' | merchant_rejected | successful,
                  return_description => binary(),
                  received_at => integer() | '',
                  explanation => binary(),
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            fraudulent =>
                #{explanation => binary(),
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            duplicate =>
                #{original_transaction => binary(),
                  explanation => binary(),
                  check_image => binary() | '',
                  cash_receipt => binary() | '',
                  card_statement => binary() | '',
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            canceled =>
                #{returned_at => integer() | '',
                  return_status => '' | merchant_rejected | successful,
                  product_type => '' | merchandise | service,
                  product_description => binary(),
                  explanation => binary(),
                  expected_at => integer() | '',
                  cancellation_reason => binary(),
                  cancellation_policy_provided => boolean() | '',
                  canceled_at => integer() | '',
                  additional_documentation => binary() | '',
                  _ := json:value()} |
                '',
            _ := json:value()}}.
-type post_issuing_disputes_dispute_response() ::
    stripe_model:error() | stripe_model:issuing_dispute().
-type get_issuing_disputes_dispute_request() ::
    #{dispute := binary(),
      query => get_issuing_disputes_dispute_request_query(),
      header => get_issuing_disputes_dispute_request_header(),
      cookie => get_issuing_disputes_dispute_request_cookie(),
      body => {binary(), get_issuing_disputes_dispute_request_body()}}.
-type get_issuing_disputes_dispute_request_query() :: #{expand => [binary()]}.
-type get_issuing_disputes_dispute_request_header() :: map().
-type get_issuing_disputes_dispute_request_cookie() :: map().
-type get_issuing_disputes_dispute_request_body() :: #{}.
-type get_issuing_disputes_dispute_response() ::
    stripe_model:error() | stripe_model:issuing_dispute().
-type post_disputes_dispute_close_request() ::
    #{dispute := binary(),
      query => post_disputes_dispute_close_request_query(),
      header => post_disputes_dispute_close_request_header(),
      cookie => post_disputes_dispute_close_request_cookie(),
      body => {binary(), post_disputes_dispute_close_request_body()}}.
-type post_disputes_dispute_close_request_query() :: map().
-type post_disputes_dispute_close_request_header() :: map().
-type post_disputes_dispute_close_request_cookie() :: map().
-type post_disputes_dispute_close_request_body() :: #{expand => [binary()]}.
-type post_disputes_dispute_close_response() ::
    stripe_model:error() | stripe_model:dispute().
-type post_quotes_quote_cancel_request() ::
    #{quote := binary(),
      query => post_quotes_quote_cancel_request_query(),
      header => post_quotes_quote_cancel_request_header(),
      cookie => post_quotes_quote_cancel_request_cookie(),
      body => {binary(), post_quotes_quote_cancel_request_body()}}.
-type post_quotes_quote_cancel_request_query() :: map().
-type post_quotes_quote_cancel_request_header() :: map().
-type post_quotes_quote_cancel_request_cookie() :: map().
-type post_quotes_quote_cancel_request_body() :: #{expand => [binary()]}.
-type post_quotes_quote_cancel_response() :: stripe_model:error() | stripe_model:quote().
-type get_customers_customer_payment_methods_request() ::
    #{customer := binary(),
      query => get_customers_customer_payment_methods_request_query(),
      header => get_customers_customer_payment_methods_request_header(),
      cookie => get_customers_customer_payment_methods_request_cookie(),
      body => {binary(), get_customers_customer_payment_methods_request_body()}}.
-type get_customers_customer_payment_methods_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      type :=
          acss_debit |
          afterpay_clearpay |
          alipay |
          au_becs_debit |
          bacs_debit |
          bancontact |
          boleto |
          card |
          eps |
          fpx |
          giropay |
          grabpay |
          ideal |
          klarna |
          oxxo |
          p24 |
          sepa_debit |
          sofort |
          wechat_pay}.
-type get_customers_customer_payment_methods_request_header() :: map().
-type get_customers_customer_payment_methods_request_cookie() :: map().
-type get_customers_customer_payment_methods_request_body() :: #{}.
-type get_customers_customer_payment_methods_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payment_method()],
      _ := json:value()}.
-type post_refunds_request() ::
    #{query => post_refunds_request_query(),
      header => post_refunds_request_header(),
      cookie => post_refunds_request_cookie(),
      body => {binary(), post_refunds_request_body()}}.
-type post_refunds_request_query() :: map().
-type post_refunds_request_header() :: map().
-type post_refunds_request_cookie() :: map().
-type post_refunds_request_body() ::
    #{reverse_transfer => boolean(),
      refund_application_fee => boolean(),
      reason => duplicate | fraudulent | requested_by_customer,
      payment_intent => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      charge => binary(),
      amount => integer()}.
-type post_refunds_response() :: stripe_model:error() | stripe_model:refund().
-type get_refunds_request() ::
    #{query => get_refunds_request_query(),
      header => get_refunds_request_header(),
      cookie => get_refunds_request_cookie(),
      body => {binary(), get_refunds_request_body()}}.
-type get_refunds_request_query() ::
    #{charge => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_intent => binary(),
      starting_after => binary()}.
-type get_refunds_request_header() :: map().
-type get_refunds_request_cookie() :: map().
-type get_refunds_request_body() :: #{}.
-type get_refunds_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:refund()],
      _ := json:value()}.
-type post_credit_notes_id_request() ::
    #{id := binary(),
      query => post_credit_notes_id_request_query(),
      header => post_credit_notes_id_request_header(),
      cookie => post_credit_notes_id_request_cookie(),
      body => {binary(), post_credit_notes_id_request_body()}}.
-type post_credit_notes_id_request_query() :: map().
-type post_credit_notes_id_request_header() :: map().
-type post_credit_notes_id_request_cookie() :: map().
-type post_credit_notes_id_request_body() ::
    #{metadata => json:value(),
      memo => binary(),
      expand => [binary()]}.
-type post_credit_notes_id_response() ::
    stripe_model:error() | stripe_model:credit_note().
-type get_credit_notes_id_request() ::
    #{id := binary(),
      query => get_credit_notes_id_request_query(),
      header => get_credit_notes_id_request_header(),
      cookie => get_credit_notes_id_request_cookie(),
      body => {binary(), get_credit_notes_id_request_body()}}.
-type get_credit_notes_id_request_query() :: #{expand => [binary()]}.
-type get_credit_notes_id_request_header() :: map().
-type get_credit_notes_id_request_cookie() :: map().
-type get_credit_notes_id_request_body() :: #{}.
-type get_credit_notes_id_response() :: stripe_model:error() | stripe_model:credit_note().
-type get_bitcoin_transactions_request() ::
    #{query => get_bitcoin_transactions_request_query(),
      header => get_bitcoin_transactions_request_header(),
      cookie => get_bitcoin_transactions_request_cookie(),
      body => {binary(), get_bitcoin_transactions_request_body()}}.
-type get_bitcoin_transactions_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      receiver => binary(),
      starting_after => binary()}.
-type get_bitcoin_transactions_request_header() :: map().
-type get_bitcoin_transactions_request_cookie() :: map().
-type get_bitcoin_transactions_request_body() :: #{}.
-type get_bitcoin_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:bitcoin_transaction()],
      _ := json:value()}.
-type post_setup_intents_request() ::
    #{query => post_setup_intents_request_query(),
      header => post_setup_intents_request_header(),
      cookie => post_setup_intents_request_cookie(),
      body => {binary(), post_setup_intents_request_body()}}.
-type post_setup_intents_request_query() :: map().
-type post_setup_intents_request_header() :: map().
-type post_setup_intents_request_cookie() :: map().
-type post_setup_intents_request_body() ::
    #{usage => off_session | on_session,
      single_use =>
          #{currency := binary(),
            amount := integer(),
            _ := json:value()},
      return_url => binary(),
      payment_method_types => [binary()],
      payment_method_options =>
          #{sepa_debit => #{mandate_options => #{_ := json:value()}, _ := json:value()},
            card => #{request_three_d_secure => any | automatic, _ := json:value()},
            acss_debit =>
                #{verification_method => automatic | instant | microdeposits,
                  mandate_options =>
                      #{transaction_type => business | personal,
                        payment_schedule => combined | interval | sporadic,
                        interval_description => binary(),
                        default_for => [invoice | subscription],
                        custom_mandate_url => binary() | '',
                        _ := json:value()},
                  currency => cad | usd,
                  _ := json:value()},
            _ := json:value()},
      payment_method => binary(),
      on_behalf_of => binary(),
      metadata => json:value(),
      mandate_data =>
          #{customer_acceptance :=
                #{type := offline | online,
                  online =>
                      #{user_agent := binary(),
                        ip_address := binary(),
                        _ := json:value()},
                  offline => #{_ := json:value()},
                  accepted_at => integer(),
                  _ := json:value()},
            _ := json:value()},
      expand => [binary()],
      description => binary(),
      customer => binary(),
      confirm => boolean()}.
-type post_setup_intents_response() :: stripe_model:error() | stripe_model:setup_intent().
-type get_setup_intents_request() ::
    #{query => get_setup_intents_request_query(),
      header => get_setup_intents_request_header(),
      cookie => get_setup_intents_request_cookie(),
      body => {binary(), get_setup_intents_request_body()}}.
-type get_setup_intents_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      payment_method => binary(),
      starting_after => binary()}.
-type get_setup_intents_request_header() :: map().
-type get_setup_intents_request_cookie() :: map().
-type get_setup_intents_request_body() :: #{}.
-type get_setup_intents_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:setup_intent()],
      _ := json:value()}.
-type post_payouts_payout_cancel_request() ::
    #{payout := binary(),
      query => post_payouts_payout_cancel_request_query(),
      header => post_payouts_payout_cancel_request_header(),
      cookie => post_payouts_payout_cancel_request_cookie(),
      body => {binary(), post_payouts_payout_cancel_request_body()}}.
-type post_payouts_payout_cancel_request_query() :: map().
-type post_payouts_payout_cancel_request_header() :: map().
-type post_payouts_payout_cancel_request_cookie() :: map().
-type post_payouts_payout_cancel_request_body() :: #{expand => [binary()]}.
-type post_payouts_payout_cancel_response() ::
    stripe_model:error() | stripe_model:payout().
-type post_issuing_authorizations_authorization_approve_request() ::
    #{authorization := binary(),
      query => post_issuing_authorizations_authorization_approve_request_query(),
      header => post_issuing_authorizations_authorization_approve_request_header(),
      cookie => post_issuing_authorizations_authorization_approve_request_cookie(),
      body => {binary(), post_issuing_authorizations_authorization_approve_request_body()}}.
-type post_issuing_authorizations_authorization_approve_request_query() :: map().
-type post_issuing_authorizations_authorization_approve_request_header() :: map().
-type post_issuing_authorizations_authorization_approve_request_cookie() :: map().
-type post_issuing_authorizations_authorization_approve_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      amount => integer()}.
-type post_issuing_authorizations_authorization_approve_response() ::
    stripe_model:error() | stripe_model:issuing_authorization().
-type post_issuing_authorizations_authorization_decline_request() ::
    #{authorization := binary(),
      query => post_issuing_authorizations_authorization_decline_request_query(),
      header => post_issuing_authorizations_authorization_decline_request_header(),
      cookie => post_issuing_authorizations_authorization_decline_request_cookie(),
      body => {binary(), post_issuing_authorizations_authorization_decline_request_body()}}.
-type post_issuing_authorizations_authorization_decline_request_query() :: map().
-type post_issuing_authorizations_authorization_decline_request_header() :: map().
-type post_issuing_authorizations_authorization_decline_request_cookie() :: map().
-type post_issuing_authorizations_authorization_decline_request_body() ::
    #{metadata => json:value() | '', expand => [binary()]}.
-type post_issuing_authorizations_authorization_decline_response() ::
    stripe_model:error() | stripe_model:issuing_authorization().
-type post_reporting_report_runs_request() ::
    #{query => post_reporting_report_runs_request_query(),
      header => post_reporting_report_runs_request_header(),
      cookie => post_reporting_report_runs_request_cookie(),
      body := {binary(), post_reporting_report_runs_request_body()}}.
-type post_reporting_report_runs_request_query() :: map().
-type post_reporting_report_runs_request_header() :: map().
-type post_reporting_report_runs_request_cookie() :: map().
-type post_reporting_report_runs_request_body() ::
    #{report_type := binary(),
      parameters =>
          #{timezone =>
                'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' |
                'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' |
                'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' |
                'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' |
                'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' |
                'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' |
                'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' |
                'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' |
                'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' |
                'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' |
                'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' |
                'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' |
                'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' |
                'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' |
                'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' |
                'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' |
                'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' |
                'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' |
                'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' |
                'America/Argentina/Salta' | 'America/Argentina/San_Juan' |
                'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' |
                'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' |
                'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' |
                'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' |
                'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' |
                'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' |
                'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' |
                'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' |
                'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' |
                'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' |
                'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' |
                'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' |
                'America/Ensenada' | 'America/Fort_Nelson' | 'America/Fort_Wayne' |
                'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' |
                'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' |
                'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' |
                'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' |
                'America/Indiana/Indianapolis' | 'America/Indiana/Knox' |
                'America/Indiana/Marengo' | 'America/Indiana/Petersburg' |
                'America/Indiana/Tell_City' | 'America/Indiana/Vevay' |
                'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' |
                'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' |
                'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' |
                'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' |
                'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' |
                'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' |
                'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' |
                'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' |
                'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' |
                'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' |
                'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' |
                'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' |
                'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' |
                'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' |
                'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' |
                'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' |
                'America/Puerto_Rico' | 'America/Punta_Arenas' | 'America/Rainy_River' |
                'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' |
                'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' |
                'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' |
                'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' |
                'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' |
                'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' |
                'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' |
                'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' |
                'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' |
                'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' |
                'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' |
                'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' |
                'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' |
                'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' |
                'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' |
                'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Atyrau' |
                'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Barnaul' |
                'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' |
                'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' |
                'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' |
                'Asia/Dushanbe' | 'Asia/Famagusta' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' |
                'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' |
                'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' |
                'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' |
                'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' |
                'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' |
                'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' |
                'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' |
                'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' |
                'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qostanay' | 'Asia/Qyzylorda' |
                'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' |
                'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' |
                'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' |
                'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' |
                'Asia/Tomsk' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' |
                'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' |
                'Asia/Yakutsk' | 'Asia/Yangon' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' |
                'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' |
                'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' |
                'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' |
                'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' |
                'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' |
                'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' |
                'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' |
                'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' |
                'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' |
                'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' |
                'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'CET' | 'CST6CDT' |
                'Canada/Atlantic' | 'Canada/Central' | 'Canada/Eastern' | 'Canada/Mountain' |
                'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' |
                'Chile/Continental' | 'Chile/EasterIsland' | 'Cuba' | 'EET' | 'EST' | 'EST5EDT' |
                'Egypt' | 'Eire' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' |
                'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' |
                'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' |
                'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' |
                'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' |
                'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' |
                'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' |
                'Europe/Astrakhan' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' |
                'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' |
                'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' |
                'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' |
                'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' |
                'Europe/Kiev' | 'Europe/Kirov' | 'Europe/Lisbon' | 'Europe/Ljubljana' |
                'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' |
                'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' |
                'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' |
                'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' |
                'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Saratov' | 'Europe/Simferopol' |
                'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' |
                'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Ulyanovsk' | 'Europe/Uzhgorod' |
                'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' |
                'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' |
                'Europe/Zurich' | 'Factory' | 'GB' | 'GB-Eire' | 'GMT' | 'GMT+0' | 'GMT-0' |
                'GMT0' | 'Greenwich' | 'HST' | 'Hongkong' | 'Iceland' | 'Indian/Antananarivo' |
                'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' |
                'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' |
                'Indian/Mayotte' | 'Indian/Reunion' | 'Iran' | 'Israel' | 'Jamaica' | 'Japan' |
                'Kwajalein' | 'Libya' | 'MET' | 'MST' | 'MST7MDT' | 'Mexico/BajaNorte' |
                'Mexico/BajaSur' | 'Mexico/General' | 'NZ' | 'NZ-CHAT' | 'Navajo' | 'PRC' |
                'PST8PDT' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Bougainville' |
                'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' |
                'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' |
                'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' |
                'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' |
                'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' |
                'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' |
                'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' |
                'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' |
                'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' |
                'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap' | 'Poland' |
                'Portugal' | 'ROC' | 'ROK' | 'Singapore' | 'Turkey' | 'UCT' | 'US/Alaska' |
                'US/Aleutian' | 'US/Arizona' | 'US/Central' | 'US/East-Indiana' | 'US/Eastern' |
                'US/Hawaii' | 'US/Indiana-Starke' | 'US/Michigan' | 'US/Mountain' | 'US/Pacific' |
                'US/Pacific-New' | 'US/Samoa' | 'UTC' | 'Universal' | 'W-SU' | 'WET' | 'Zulu',
            reporting_category =>
                advance | advance_funding | anticipation_repayment | charge | charge_failure |
                connect_collection_transfer | connect_reserved_funds | contribution | dispute |
                dispute_reversal | fee | financing_paydown | financing_paydown_reversal |
                financing_payout | financing_payout_reversal | issuing_authorization_hold |
                issuing_authorization_release | issuing_dispute | issuing_transaction |
                network_cost | other_adjustment | partial_capture_reversal | payout |
                payout_reversal | platform_earning | platform_earning_refund | refund |
                refund_failure | risk_reserved_funds | tax | topup | topup_reversal | transfer |
                transfer_reversal,
            payout => binary(),
            interval_start => integer(),
            interval_end => integer(),
            currency => binary(),
            connected_account => binary(),
            columns => [binary()],
            _ := json:value()},
      expand => [binary()]}.
-type post_reporting_report_runs_response() ::
    stripe_model:error() | stripe_model:reporting_report_run().
-type get_reporting_report_runs_request() ::
    #{query => get_reporting_report_runs_request_query(),
      header => get_reporting_report_runs_request_header(),
      cookie => get_reporting_report_runs_request_cookie(),
      body => {binary(), get_reporting_report_runs_request_body()}}.
-type get_reporting_report_runs_request_query() ::
    #{created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_reporting_report_runs_request_header() :: map().
-type get_reporting_report_runs_request_cookie() :: map().
-type get_reporting_report_runs_request_body() :: #{}.
-type get_reporting_report_runs_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:reporting_report_run()],
      _ := json:value()}.
-type post_invoices_invoice_void_request() ::
    #{invoice := binary(),
      query => post_invoices_invoice_void_request_query(),
      header => post_invoices_invoice_void_request_header(),
      cookie => post_invoices_invoice_void_request_cookie(),
      body => {binary(), post_invoices_invoice_void_request_body()}}.
-type post_invoices_invoice_void_request_query() :: map().
-type post_invoices_invoice_void_request_header() :: map().
-type post_invoices_invoice_void_request_cookie() :: map().
-type post_invoices_invoice_void_request_body() :: #{expand => [binary()]}.
-type post_invoices_invoice_void_response() ::
    stripe_model:error() | stripe_model:invoice().
-type post_sources_request() ::
    #{query => post_sources_request_query(),
      header => post_sources_request_header(),
      cookie => post_sources_request_cookie(),
      body => {binary(), post_sources_request_body()}}.
-type post_sources_request_query() :: map().
-type post_sources_request_header() :: map().
-type post_sources_request_cookie() :: map().
-type post_sources_request_body() ::
    #{usage => reusable | single_use,
      type => binary(),
      token => binary(),
      statement_descriptor => binary(),
      source_order =>
          #{shipping =>
                #{tracking_number => binary(),
                  phone => binary(),
                  name => binary(),
                  carrier => binary(),
                  address :=
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 := binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  _ := json:value()},
            items =>
                [#{type => discount | shipping | sku | tax,
                   quantity => integer(),
                   parent => binary(),
                   description => binary(),
                   currency => binary(),
                   amount => integer(),
                   _ := json:value()}],
            _ := json:value()},
      redirect => #{return_url := binary(), _ := json:value()},
      receiver => #{refund_attributes_method => email | manual | none, _ := json:value()},
      owner =>
          #{phone => binary(),
            name => binary(),
            email => binary(),
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      original_source => binary(),
      metadata => json:value(),
      mandate =>
          #{notification_method => deprecated_none | email | manual | none | stripe_email,
            interval => one_time | scheduled | variable,
            currency => binary(),
            amount => integer() | '',
            acceptance =>
                #{user_agent => binary(),
                  type => offline | online,
                  status := accepted | pending | refused | revoked,
                  online =>
                      #{user_agent => binary(),
                        ip => binary(),
                        date => integer(),
                        _ := json:value()},
                  offline => #{contact_email := binary(), _ := json:value()},
                  ip => binary(),
                  date => integer(),
                  _ := json:value()},
            _ := json:value()},
      flow => code_verification | none | receiver | redirect,
      expand => [binary()],
      customer => binary(),
      currency => binary(),
      amount => integer()}.
-type post_sources_response() :: stripe_model:error() | stripe_model:source().
-type post_billing_portal_configurations_request() ::
    #{query => post_billing_portal_configurations_request_query(),
      header => post_billing_portal_configurations_request_header(),
      cookie => post_billing_portal_configurations_request_cookie(),
      body := {binary(), post_billing_portal_configurations_request_body()}}.
-type post_billing_portal_configurations_request_query() :: map().
-type post_billing_portal_configurations_request_header() :: map().
-type post_billing_portal_configurations_request_cookie() :: map().
-type post_billing_portal_configurations_request_body() ::
    #{metadata => json:value(),
      features :=
          #{subscription_update =>
                #{proration_behavior => always_invoice | create_prorations | none,
                  products :=
                      [#{product := binary(),
                         prices := [binary()],
                         _ := json:value()}] |
                      '',
                  enabled := boolean(),
                  default_allowed_updates := [price | promotion_code | quantity] | '',
                  _ := json:value()},
            subscription_pause => #{enabled => boolean(), _ := json:value()},
            subscription_cancel =>
                #{proration_behavior => always_invoice | create_prorations | none,
                  mode => at_period_end | immediately,
                  enabled := boolean(),
                  cancellation_reason =>
                      #{options :=
                            [customer_service |
                             low_quality |
                             missing_features |
                             other |
                             switched_service |
                             too_complex |
                             too_expensive |
                             unused] |
                            '',
                        enabled := boolean(),
                        _ := json:value()},
                  _ := json:value()},
            payment_method_update => #{enabled := boolean(), _ := json:value()},
            invoice_history => #{enabled := boolean(), _ := json:value()},
            customer_update =>
                #{enabled := boolean(),
                  allowed_updates := [address | email | phone | shipping | tax_id] | '',
                  _ := json:value()},
            _ := json:value()},
      expand => [binary()],
      default_return_url => binary() | '',
      business_profile :=
          #{terms_of_service_url := binary(),
            privacy_policy_url := binary(),
            headline => binary(),
            _ := json:value()}}.
-type post_billing_portal_configurations_response() ::
    stripe_model:error() | stripe_model:billing_portal_configuration().
-type get_billing_portal_configurations_request() ::
    #{query => get_billing_portal_configurations_request_query(),
      header => get_billing_portal_configurations_request_header(),
      cookie => get_billing_portal_configurations_request_cookie(),
      body => {binary(), get_billing_portal_configurations_request_body()}}.
-type get_billing_portal_configurations_request_query() ::
    #{active => boolean(),
      ending_before => binary(),
      expand => [binary()],
      is_default => boolean(),
      limit => integer(),
      starting_after => binary()}.
-type get_billing_portal_configurations_request_header() :: map().
-type get_billing_portal_configurations_request_cookie() :: map().
-type get_billing_portal_configurations_request_body() :: #{}.
-type get_billing_portal_configurations_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:billing_portal_configuration()],
      _ := json:value()}.
-type post_quotes_request() ::
    #{query => post_quotes_request_query(),
      header => post_quotes_request_header(),
      cookie => post_quotes_request_cookie(),
      body => {binary(), post_quotes_request_body()}}.
-type post_quotes_request_query() :: map().
-type post_quotes_request_header() :: map().
-type post_quotes_request_cookie() :: map().
-type post_quotes_request_body() ::
    #{transfer_data =>
          #{destination := binary(),
            amount_percent => number(),
            amount => integer(),
            _ := json:value()} |
          '',
      subscription_data =>
          #{trial_period_days => integer() | '',
            effective_date => current_period_end | integer() | '',
            _ := json:value()},
      on_behalf_of => binary() | '',
      metadata => json:value(),
      line_items =>
          [#{tax_rates => [binary()] | '',
             quantity => integer(),
             price_data =>
                 #{unit_amount_decimal => binary(),
                   unit_amount => integer(),
                   tax_behavior => exclusive | inclusive | unspecified,
                   recurring =>
                       #{interval_count => integer(),
                         interval := day | month | week | year,
                         _ := json:value()},
                   product := binary(),
                   currency := binary(),
                   _ := json:value()},
             price => binary(),
             _ := json:value()}],
      invoice_settings => #{days_until_due => integer(), _ := json:value()},
      header => binary(),
      from_quote =>
          #{quote := binary(),
            is_revision => boolean(),
            _ := json:value()},
      footer => binary(),
      expires_at => integer(),
      expand => [binary()],
      discounts =>
          [#{discount => binary(),
             coupon => binary(),
             _ := json:value()}] |
          '',
      description => binary(),
      default_tax_rates => [binary()] | '',
      customer => binary(),
      collection_method => charge_automatically | send_invoice,
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      application_fee_percent => number() | '',
      application_fee_amount => integer() | ''}.
-type post_quotes_response() :: stripe_model:error() | stripe_model:quote().
-type get_quotes_request() ::
    #{query => get_quotes_request_query(),
      header => get_quotes_request_header(),
      cookie => get_quotes_request_cookie(),
      body => {binary(), get_quotes_request_body()}}.
-type get_quotes_request_query() ::
    #{customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary(),
      status => accepted | canceled | draft | open}.
-type get_quotes_request_header() :: map().
-type get_quotes_request_cookie() :: map().
-type get_quotes_request_body() :: #{}.
-type get_quotes_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:quote()],
      _ := json:value()}.
-type post_transfers_transfer_request() ::
    #{transfer := binary(),
      query => post_transfers_transfer_request_query(),
      header => post_transfers_transfer_request_header(),
      cookie => post_transfers_transfer_request_cookie(),
      body => {binary(), post_transfers_transfer_request_body()}}.
-type post_transfers_transfer_request_query() :: map().
-type post_transfers_transfer_request_header() :: map().
-type post_transfers_transfer_request_cookie() :: map().
-type post_transfers_transfer_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      description => binary()}.
-type post_transfers_transfer_response() ::
    stripe_model:error() | stripe_model:transfer().
-type get_transfers_transfer_request() ::
    #{transfer := binary(),
      query => get_transfers_transfer_request_query(),
      header => get_transfers_transfer_request_header(),
      cookie => get_transfers_transfer_request_cookie(),
      body => {binary(), get_transfers_transfer_request_body()}}.
-type get_transfers_transfer_request_query() :: #{expand => [binary()]}.
-type get_transfers_transfer_request_header() :: map().
-type get_transfers_transfer_request_cookie() :: map().
-type get_transfers_transfer_request_body() :: #{}.
-type get_transfers_transfer_response() :: stripe_model:error() | stripe_model:transfer().
-type get_quotes_quote_line_items_request() ::
    #{quote := binary(),
      query => get_quotes_quote_line_items_request_query(),
      header => get_quotes_quote_line_items_request_header(),
      cookie => get_quotes_quote_line_items_request_cookie(),
      body => {binary(), get_quotes_quote_line_items_request_body()}}.
-type get_quotes_quote_line_items_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_quotes_quote_line_items_request_header() :: map().
-type get_quotes_quote_line_items_request_cookie() :: map().
-type get_quotes_quote_line_items_request_body() :: #{}.
-type get_quotes_quote_line_items_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:item()],
      _ := json:value()}.
-type delete_invoiceitems_invoiceitem_request() ::
    #{invoiceitem := binary(),
      query => delete_invoiceitems_invoiceitem_request_query(),
      header => delete_invoiceitems_invoiceitem_request_header(),
      cookie => delete_invoiceitems_invoiceitem_request_cookie(),
      body => {binary(), delete_invoiceitems_invoiceitem_request_body()}}.
-type delete_invoiceitems_invoiceitem_request_query() :: map().
-type delete_invoiceitems_invoiceitem_request_header() :: map().
-type delete_invoiceitems_invoiceitem_request_cookie() :: map().
-type delete_invoiceitems_invoiceitem_request_body() :: #{}.
-type delete_invoiceitems_invoiceitem_response() ::
    stripe_model:error() | stripe_model:deleted_invoiceitem().
-type post_invoiceitems_invoiceitem_request() ::
    #{invoiceitem := binary(),
      query => post_invoiceitems_invoiceitem_request_query(),
      header => post_invoiceitems_invoiceitem_request_header(),
      cookie => post_invoiceitems_invoiceitem_request_cookie(),
      body => {binary(), post_invoiceitems_invoiceitem_request_body()}}.
-type post_invoiceitems_invoiceitem_request_query() :: map().
-type post_invoiceitems_invoiceitem_request_header() :: map().
-type post_invoiceitems_invoiceitem_request_cookie() :: map().
-type post_invoiceitems_invoiceitem_request_body() ::
    #{unit_amount_decimal => binary(),
      unit_amount => integer(),
      tax_rates => [binary()] | '',
      quantity => integer(),
      price_data =>
          #{unit_amount_decimal => binary(),
            unit_amount => integer(),
            tax_behavior => exclusive | inclusive | unspecified,
            product := binary(),
            currency := binary(),
            _ := json:value()},
      price => binary(),
      period =>
          #{start := integer(),
            'end' := integer(),
            _ := json:value()},
      metadata => json:value() | '',
      expand => [binary()],
      discounts =>
          [#{discount => binary(),
             coupon => binary(),
             _ := json:value()}] |
          '',
      discountable => boolean(),
      description => binary(),
      amount => integer()}.
-type post_invoiceitems_invoiceitem_response() ::
    stripe_model:error() | stripe_model:invoiceitem().
-type get_invoiceitems_invoiceitem_request() ::
    #{invoiceitem := binary(),
      query => get_invoiceitems_invoiceitem_request_query(),
      header => get_invoiceitems_invoiceitem_request_header(),
      cookie => get_invoiceitems_invoiceitem_request_cookie(),
      body => {binary(), get_invoiceitems_invoiceitem_request_body()}}.
-type get_invoiceitems_invoiceitem_request_query() :: #{expand => [binary()]}.
-type get_invoiceitems_invoiceitem_request_header() :: map().
-type get_invoiceitems_invoiceitem_request_cookie() :: map().
-type get_invoiceitems_invoiceitem_request_body() :: #{}.
-type get_invoiceitems_invoiceitem_response() ::
    stripe_model:error() | stripe_model:invoiceitem().
-type post_payment_intents_intent_capture_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_capture_request_query(),
      header => post_payment_intents_intent_capture_request_header(),
      cookie => post_payment_intents_intent_capture_request_cookie(),
      body => {binary(), post_payment_intents_intent_capture_request_body()}}.
-type post_payment_intents_intent_capture_request_query() :: map().
-type post_payment_intents_intent_capture_request_header() :: map().
-type post_payment_intents_intent_capture_request_cookie() :: map().
-type post_payment_intents_intent_capture_request_body() ::
    #{transfer_data => #{amount => integer(), _ := json:value()},
      statement_descriptor_suffix => binary(),
      statement_descriptor => binary(),
      expand => [binary()],
      application_fee_amount => integer(),
      amount_to_capture => integer()}.
-type post_payment_intents_intent_capture_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type post_issuing_cards_request() ::
    #{query => post_issuing_cards_request_query(),
      header => post_issuing_cards_request_header(),
      cookie => post_issuing_cards_request_cookie(),
      body := {binary(), post_issuing_cards_request_body()}}.
-type post_issuing_cards_request_query() :: map().
-type post_issuing_cards_request_header() :: map().
-type post_issuing_cards_request_cookie() :: map().
-type post_issuing_cards_request_body() ::
    #{type := physical | virtual,
      status => active | inactive,
      spending_controls =>
          #{spending_limits =>
                [#{interval := all_time | daily | monthly | per_authorization | weekly | yearly,
                   categories =>
                       [ac_refrigeration_repair | accounting_bookkeeping_services |
                        advertising_services | agricultural_cooperative | airlines_air_carriers |
                        airports_flying_fields | ambulance_services | amusement_parks_carnivals |
                        antique_reproductions | antique_shops | aquariums |
                        architectural_surveying_services | art_dealers_and_galleries |
                        artists_supply_and_craft_shops | auto_and_home_supply_stores |
                        auto_body_repair_shops | auto_paint_shops | auto_service_shops |
                        automated_cash_disburse | automated_fuel_dispensers |
                        automobile_associations | automotive_parts_and_accessories_stores |
                        automotive_tire_stores | bail_and_bond_payments | bakeries |
                        bands_orchestras | barber_and_beauty_shops | betting_casino_gambling |
                        bicycle_shops | billiard_pool_establishments | boat_dealers |
                        boat_rentals_and_leases | book_stores | books_periodicals_and_newspapers |
                        bowling_alleys | bus_lines | business_secretarial_schools |
                        buying_shopping_services |
                        cable_satellite_and_other_pay_television_and_radio |
                        camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                        car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                        car_rental_agencies | car_washes | carpentry_services |
                        carpet_upholstery_cleaning | caterers |
                        charitable_and_social_service_organizations_fundraising |
                        chemicals_and_allied_products | child_care_services |
                        childrens_and_infants_wear_stores | chiropodists_podiatrists |
                        chiropractors | cigar_stores_and_stands |
                        civic_social_fraternal_associations | cleaning_and_maintenance |
                        clothing_rental | colleges_universities | commercial_equipment |
                        commercial_footwear | commercial_photography_art_and_graphics |
                        commuter_transport_and_ferries | computer_network_services |
                        computer_programming | computer_repair | computer_software_stores |
                        computers_peripherals_and_software | concrete_work_services |
                        construction_materials | consulting_public_relations |
                        correspondence_schools | cosmetic_stores | counseling_services |
                        country_clubs | courier_services | court_costs | credit_reporting_agencies |
                        cruise_lines | dairy_products_stores | dance_hall_studios_schools |
                        dating_escort_services | dentists_orthodontists | department_stores |
                        detective_agencies | digital_goods_applications | digital_goods_games |
                        digital_goods_large_volume | digital_goods_media |
                        direct_marketing_catalog_merchant |
                        direct_marketing_combination_catalog_and_retail_merchant |
                        direct_marketing_inbound_telemarketing |
                        direct_marketing_insurance_services | direct_marketing_other |
                        direct_marketing_outbound_telemarketing | direct_marketing_subscription |
                        direct_marketing_travel | discount_stores | doctors | door_to_door_sales |
                        drapery_window_covering_and_upholstery_stores | drinking_places |
                        drug_stores_and_pharmacies |
                        drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners |
                        durable_goods | duty_free_stores | eating_places_restaurants |
                        educational_services | electric_razor_stores |
                        electrical_parts_and_equipment | electrical_services |
                        electronics_repair_shops | electronics_stores |
                        elementary_secondary_schools | employment_temp_agencies | equipment_rental |
                        exterminating_services | family_clothing_stores | fast_food_restaurants |
                        financial_institutions | fines_government_administrative_entities |
                        fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                        florists | florists_supplies_nursery_stock_and_flowers |
                        freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                        funeral_services_crematories |
                        furniture_home_furnishings_and_equipment_stores_except_appliances |
                        furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                        gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                        glassware_crystal_stores | golf_courses_public | government_services |
                        grocery_stores_supermarkets | hardware_equipment_and_supplies |
                        hardware_stores | health_and_beauty_spas | hearing_aids_sales_and_supplies |
                        heating_plumbing_a_c | hobby_toy_and_game_shops |
                        home_supply_warehouse_stores | hospitals | hotels_motels_and_resorts |
                        household_appliance_stores | industrial_supplies |
                        information_retrieval_services | insurance_default |
                        insurance_underwriting_premiums | intra_company_purchases |
                        jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                        laundries | laundry_cleaning_services | legal_services_attorneys |
                        luggage_and_leather_goods_stores | lumber_building_materials_stores |
                        manual_cash_disburse | marinas_service_and_supplies |
                        masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                        medical_dental_ophthalmic_and_hospital_equipment_and_supplies |
                        medical_services | membership_organizations |
                        mens_and_boys_clothing_and_accessories_stores |
                        mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                        miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                        miscellaneous_business_services | miscellaneous_food_stores |
                        miscellaneous_general_merchandise | miscellaneous_general_services |
                        miscellaneous_home_furnishing_specialty_stores |
                        miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                        miscellaneous_repair_shops | miscellaneous_specialty_retail |
                        mobile_home_dealers | motion_picture_theaters |
                        motor_freight_carriers_and_trucking | motor_homes_dealers |
                        motor_vehicle_supplies_and_new_parts | motorcycle_shops_and_dealers |
                        motorcycle_shops_dealers |
                        music_stores_musical_instruments_pianos_and_sheet_music |
                        news_dealers_and_newsstands | non_fi_money_orders |
                        non_fi_stored_value_card_purchase_load | nondurable_goods |
                        nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                        office_and_commercial_furniture | opticians_eyeglasses |
                        optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices |
                        osteopaths | package_stores_beer_wine_and_liquor |
                        paints_varnishes_and_supplies | parking_lots_garages | passenger_railways |
                        pawn_shops | pet_shops_pet_food_and_supplies |
                        petroleum_and_petroleum_products | photo_developing |
                        photographic_photocopy_microfilm_equipment_and_supplies |
                        photographic_studios | picture_video_production |
                        piece_goods_notions_and_other_dry_goods |
                        plumbing_heating_equipment_and_supplies | political_organizations |
                        postal_services_government_only |
                        precious_stones_and_metals_watches_and_jewelry | professional_services |
                        public_warehousing_and_storage | quick_copy_repro_and_blueprint |
                        railroads | real_estate_agents_and_managers_rentals | record_stores |
                        recreational_vehicle_rentals | religious_goods_stores |
                        religious_organizations | roofing_siding_sheet_metal |
                        secretarial_support_services | security_brokers_dealers | service_stations |
                        sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                        shoe_stores | small_appliance_repair | snowmobile_dealers |
                        special_trade_services | specialty_cleaning | sporting_goods_stores |
                        sporting_recreation_camps | sports_and_riding_apparel_stores |
                        sports_clubs_fields | stamp_and_coin_stores |
                        stationary_office_supplies_printing_and_writing_paper |
                        stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                        t_ui_travel_germany | tailors_alterations |
                        tax_payments_government_agencies | tax_preparation_services |
                        taxicabs_limousines | telecommunication_equipment_and_telephone_sales |
                        telecommunication_services | telegraph_services | tent_and_awning_shops |
                        testing_laboratories | theatrical_ticket_agencies | timeshares |
                        tire_retreading_and_repair | tolls_bridge_fees |
                        tourist_attractions_and_exhibits | towing_services |
                        trailer_parks_campgrounds | transportation_services |
                        travel_agencies_tour_operators | truck_stop_iteration |
                        truck_utility_trailer_rentals |
                        typesetting_plate_making_and_related_services | typewriter_stores |
                        u_s_federal_government_agencies_or_departments |
                        uniforms_commercial_clothing | used_merchandise_and_secondhand_stores |
                        utilities | variety_stores | veterinary_services |
                        video_amusement_game_supplies | video_game_arcades |
                        video_tape_rental_stores | vocational_trade_schools | watch_jewelry_repair |
                        welding_repair | wholesale_clubs | wig_and_toupee_stores |
                        wires_money_orders | womens_accessory_and_specialty_shops |
                        womens_ready_to_wear_stores | wrecking_and_salvage_yards],
                   amount := integer(),
                   _ := json:value()}],
            blocked_categories =>
                [ac_refrigeration_repair | accounting_bookkeeping_services | advertising_services |
                 agricultural_cooperative | airlines_air_carriers | airports_flying_fields |
                 ambulance_services | amusement_parks_carnivals | antique_reproductions |
                 antique_shops | aquariums | architectural_surveying_services |
                 art_dealers_and_galleries | artists_supply_and_craft_shops |
                 auto_and_home_supply_stores | auto_body_repair_shops | auto_paint_shops |
                 auto_service_shops | automated_cash_disburse | automated_fuel_dispensers |
                 automobile_associations | automotive_parts_and_accessories_stores |
                 automotive_tire_stores | bail_and_bond_payments | bakeries | bands_orchestras |
                 barber_and_beauty_shops | betting_casino_gambling | bicycle_shops |
                 billiard_pool_establishments | boat_dealers | boat_rentals_and_leases |
                 book_stores | books_periodicals_and_newspapers | bowling_alleys | bus_lines |
                 business_secretarial_schools | buying_shopping_services |
                 cable_satellite_and_other_pay_television_and_radio |
                 camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                 car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                 car_rental_agencies | car_washes | carpentry_services |
                 carpet_upholstery_cleaning | caterers |
                 charitable_and_social_service_organizations_fundraising |
                 chemicals_and_allied_products | child_care_services |
                 childrens_and_infants_wear_stores | chiropodists_podiatrists | chiropractors |
                 cigar_stores_and_stands | civic_social_fraternal_associations |
                 cleaning_and_maintenance | clothing_rental | colleges_universities |
                 commercial_equipment | commercial_footwear |
                 commercial_photography_art_and_graphics | commuter_transport_and_ferries |
                 computer_network_services | computer_programming | computer_repair |
                 computer_software_stores | computers_peripherals_and_software |
                 concrete_work_services | construction_materials | consulting_public_relations |
                 correspondence_schools | cosmetic_stores | counseling_services | country_clubs |
                 courier_services | court_costs | credit_reporting_agencies | cruise_lines |
                 dairy_products_stores | dance_hall_studios_schools | dating_escort_services |
                 dentists_orthodontists | department_stores | detective_agencies |
                 digital_goods_applications | digital_goods_games | digital_goods_large_volume |
                 digital_goods_media | direct_marketing_catalog_merchant |
                 direct_marketing_combination_catalog_and_retail_merchant |
                 direct_marketing_inbound_telemarketing | direct_marketing_insurance_services |
                 direct_marketing_other | direct_marketing_outbound_telemarketing |
                 direct_marketing_subscription | direct_marketing_travel | discount_stores |
                 doctors | door_to_door_sales | drapery_window_covering_and_upholstery_stores |
                 drinking_places | drug_stores_and_pharmacies |
                 drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners | durable_goods |
                 duty_free_stores | eating_places_restaurants | educational_services |
                 electric_razor_stores | electrical_parts_and_equipment | electrical_services |
                 electronics_repair_shops | electronics_stores | elementary_secondary_schools |
                 employment_temp_agencies | equipment_rental | exterminating_services |
                 family_clothing_stores | fast_food_restaurants | financial_institutions |
                 fines_government_administrative_entities |
                 fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                 florists | florists_supplies_nursery_stock_and_flowers |
                 freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                 funeral_services_crematories |
                 furniture_home_furnishings_and_equipment_stores_except_appliances |
                 furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                 gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                 glassware_crystal_stores | golf_courses_public | government_services |
                 grocery_stores_supermarkets | hardware_equipment_and_supplies | hardware_stores |
                 health_and_beauty_spas | hearing_aids_sales_and_supplies | heating_plumbing_a_c |
                 hobby_toy_and_game_shops | home_supply_warehouse_stores | hospitals |
                 hotels_motels_and_resorts | household_appliance_stores | industrial_supplies |
                 information_retrieval_services | insurance_default |
                 insurance_underwriting_premiums | intra_company_purchases |
                 jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                 laundries | laundry_cleaning_services | legal_services_attorneys |
                 luggage_and_leather_goods_stores | lumber_building_materials_stores |
                 manual_cash_disburse | marinas_service_and_supplies |
                 masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                 medical_dental_ophthalmic_and_hospital_equipment_and_supplies | medical_services |
                 membership_organizations | mens_and_boys_clothing_and_accessories_stores |
                 mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                 miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                 miscellaneous_business_services | miscellaneous_food_stores |
                 miscellaneous_general_merchandise | miscellaneous_general_services |
                 miscellaneous_home_furnishing_specialty_stores |
                 miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                 miscellaneous_repair_shops | miscellaneous_specialty_retail | mobile_home_dealers |
                 motion_picture_theaters | motor_freight_carriers_and_trucking |
                 motor_homes_dealers | motor_vehicle_supplies_and_new_parts |
                 motorcycle_shops_and_dealers | motorcycle_shops_dealers |
                 music_stores_musical_instruments_pianos_and_sheet_music |
                 news_dealers_and_newsstands | non_fi_money_orders |
                 non_fi_stored_value_card_purchase_load | nondurable_goods |
                 nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                 office_and_commercial_furniture | opticians_eyeglasses |
                 optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices | osteopaths |
                 package_stores_beer_wine_and_liquor | paints_varnishes_and_supplies |
                 parking_lots_garages | passenger_railways | pawn_shops |
                 pet_shops_pet_food_and_supplies | petroleum_and_petroleum_products |
                 photo_developing | photographic_photocopy_microfilm_equipment_and_supplies |
                 photographic_studios | picture_video_production |
                 piece_goods_notions_and_other_dry_goods | plumbing_heating_equipment_and_supplies |
                 political_organizations | postal_services_government_only |
                 precious_stones_and_metals_watches_and_jewelry | professional_services |
                 public_warehousing_and_storage | quick_copy_repro_and_blueprint | railroads |
                 real_estate_agents_and_managers_rentals | record_stores |
                 recreational_vehicle_rentals | religious_goods_stores | religious_organizations |
                 roofing_siding_sheet_metal | secretarial_support_services |
                 security_brokers_dealers | service_stations |
                 sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                 shoe_stores | small_appliance_repair | snowmobile_dealers |
                 special_trade_services | specialty_cleaning | sporting_goods_stores |
                 sporting_recreation_camps | sports_and_riding_apparel_stores |
                 sports_clubs_fields | stamp_and_coin_stores |
                 stationary_office_supplies_printing_and_writing_paper |
                 stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                 t_ui_travel_germany | tailors_alterations | tax_payments_government_agencies |
                 tax_preparation_services | taxicabs_limousines |
                 telecommunication_equipment_and_telephone_sales | telecommunication_services |
                 telegraph_services | tent_and_awning_shops | testing_laboratories |
                 theatrical_ticket_agencies | timeshares | tire_retreading_and_repair |
                 tolls_bridge_fees | tourist_attractions_and_exhibits | towing_services |
                 trailer_parks_campgrounds | transportation_services |
                 travel_agencies_tour_operators | truck_stop_iteration |
                 truck_utility_trailer_rentals | typesetting_plate_making_and_related_services |
                 typewriter_stores | u_s_federal_government_agencies_or_departments |
                 uniforms_commercial_clothing | used_merchandise_and_secondhand_stores | utilities |
                 variety_stores | veterinary_services | video_amusement_game_supplies |
                 video_game_arcades | video_tape_rental_stores | vocational_trade_schools |
                 watch_jewelry_repair | welding_repair | wholesale_clubs | wig_and_toupee_stores |
                 wires_money_orders | womens_accessory_and_specialty_shops |
                 womens_ready_to_wear_stores | wrecking_and_salvage_yards],
            allowed_categories =>
                [ac_refrigeration_repair | accounting_bookkeeping_services | advertising_services |
                 agricultural_cooperative | airlines_air_carriers | airports_flying_fields |
                 ambulance_services | amusement_parks_carnivals | antique_reproductions |
                 antique_shops | aquariums | architectural_surveying_services |
                 art_dealers_and_galleries | artists_supply_and_craft_shops |
                 auto_and_home_supply_stores | auto_body_repair_shops | auto_paint_shops |
                 auto_service_shops | automated_cash_disburse | automated_fuel_dispensers |
                 automobile_associations | automotive_parts_and_accessories_stores |
                 automotive_tire_stores | bail_and_bond_payments | bakeries | bands_orchestras |
                 barber_and_beauty_shops | betting_casino_gambling | bicycle_shops |
                 billiard_pool_establishments | boat_dealers | boat_rentals_and_leases |
                 book_stores | books_periodicals_and_newspapers | bowling_alleys | bus_lines |
                 business_secretarial_schools | buying_shopping_services |
                 cable_satellite_and_other_pay_television_and_radio |
                 camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                 car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                 car_rental_agencies | car_washes | carpentry_services |
                 carpet_upholstery_cleaning | caterers |
                 charitable_and_social_service_organizations_fundraising |
                 chemicals_and_allied_products | child_care_services |
                 childrens_and_infants_wear_stores | chiropodists_podiatrists | chiropractors |
                 cigar_stores_and_stands | civic_social_fraternal_associations |
                 cleaning_and_maintenance | clothing_rental | colleges_universities |
                 commercial_equipment | commercial_footwear |
                 commercial_photography_art_and_graphics | commuter_transport_and_ferries |
                 computer_network_services | computer_programming | computer_repair |
                 computer_software_stores | computers_peripherals_and_software |
                 concrete_work_services | construction_materials | consulting_public_relations |
                 correspondence_schools | cosmetic_stores | counseling_services | country_clubs |
                 courier_services | court_costs | credit_reporting_agencies | cruise_lines |
                 dairy_products_stores | dance_hall_studios_schools | dating_escort_services |
                 dentists_orthodontists | department_stores | detective_agencies |
                 digital_goods_applications | digital_goods_games | digital_goods_large_volume |
                 digital_goods_media | direct_marketing_catalog_merchant |
                 direct_marketing_combination_catalog_and_retail_merchant |
                 direct_marketing_inbound_telemarketing | direct_marketing_insurance_services |
                 direct_marketing_other | direct_marketing_outbound_telemarketing |
                 direct_marketing_subscription | direct_marketing_travel | discount_stores |
                 doctors | door_to_door_sales | drapery_window_covering_and_upholstery_stores |
                 drinking_places | drug_stores_and_pharmacies |
                 drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners | durable_goods |
                 duty_free_stores | eating_places_restaurants | educational_services |
                 electric_razor_stores | electrical_parts_and_equipment | electrical_services |
                 electronics_repair_shops | electronics_stores | elementary_secondary_schools |
                 employment_temp_agencies | equipment_rental | exterminating_services |
                 family_clothing_stores | fast_food_restaurants | financial_institutions |
                 fines_government_administrative_entities |
                 fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                 florists | florists_supplies_nursery_stock_and_flowers |
                 freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                 funeral_services_crematories |
                 furniture_home_furnishings_and_equipment_stores_except_appliances |
                 furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                 gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                 glassware_crystal_stores | golf_courses_public | government_services |
                 grocery_stores_supermarkets | hardware_equipment_and_supplies | hardware_stores |
                 health_and_beauty_spas | hearing_aids_sales_and_supplies | heating_plumbing_a_c |
                 hobby_toy_and_game_shops | home_supply_warehouse_stores | hospitals |
                 hotels_motels_and_resorts | household_appliance_stores | industrial_supplies |
                 information_retrieval_services | insurance_default |
                 insurance_underwriting_premiums | intra_company_purchases |
                 jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                 laundries | laundry_cleaning_services | legal_services_attorneys |
                 luggage_and_leather_goods_stores | lumber_building_materials_stores |
                 manual_cash_disburse | marinas_service_and_supplies |
                 masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                 medical_dental_ophthalmic_and_hospital_equipment_and_supplies | medical_services |
                 membership_organizations | mens_and_boys_clothing_and_accessories_stores |
                 mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                 miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                 miscellaneous_business_services | miscellaneous_food_stores |
                 miscellaneous_general_merchandise | miscellaneous_general_services |
                 miscellaneous_home_furnishing_specialty_stores |
                 miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                 miscellaneous_repair_shops | miscellaneous_specialty_retail | mobile_home_dealers |
                 motion_picture_theaters | motor_freight_carriers_and_trucking |
                 motor_homes_dealers | motor_vehicle_supplies_and_new_parts |
                 motorcycle_shops_and_dealers | motorcycle_shops_dealers |
                 music_stores_musical_instruments_pianos_and_sheet_music |
                 news_dealers_and_newsstands | non_fi_money_orders |
                 non_fi_stored_value_card_purchase_load | nondurable_goods |
                 nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                 office_and_commercial_furniture | opticians_eyeglasses |
                 optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices | osteopaths |
                 package_stores_beer_wine_and_liquor | paints_varnishes_and_supplies |
                 parking_lots_garages | passenger_railways | pawn_shops |
                 pet_shops_pet_food_and_supplies | petroleum_and_petroleum_products |
                 photo_developing | photographic_photocopy_microfilm_equipment_and_supplies |
                 photographic_studios | picture_video_production |
                 piece_goods_notions_and_other_dry_goods | plumbing_heating_equipment_and_supplies |
                 political_organizations | postal_services_government_only |
                 precious_stones_and_metals_watches_and_jewelry | professional_services |
                 public_warehousing_and_storage | quick_copy_repro_and_blueprint | railroads |
                 real_estate_agents_and_managers_rentals | record_stores |
                 recreational_vehicle_rentals | religious_goods_stores | religious_organizations |
                 roofing_siding_sheet_metal | secretarial_support_services |
                 security_brokers_dealers | service_stations |
                 sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                 shoe_stores | small_appliance_repair | snowmobile_dealers |
                 special_trade_services | specialty_cleaning | sporting_goods_stores |
                 sporting_recreation_camps | sports_and_riding_apparel_stores |
                 sports_clubs_fields | stamp_and_coin_stores |
                 stationary_office_supplies_printing_and_writing_paper |
                 stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                 t_ui_travel_germany | tailors_alterations | tax_payments_government_agencies |
                 tax_preparation_services | taxicabs_limousines |
                 telecommunication_equipment_and_telephone_sales | telecommunication_services |
                 telegraph_services | tent_and_awning_shops | testing_laboratories |
                 theatrical_ticket_agencies | timeshares | tire_retreading_and_repair |
                 tolls_bridge_fees | tourist_attractions_and_exhibits | towing_services |
                 trailer_parks_campgrounds | transportation_services |
                 travel_agencies_tour_operators | truck_stop_iteration |
                 truck_utility_trailer_rentals | typesetting_plate_making_and_related_services |
                 typewriter_stores | u_s_federal_government_agencies_or_departments |
                 uniforms_commercial_clothing | used_merchandise_and_secondhand_stores | utilities |
                 variety_stores | veterinary_services | video_amusement_game_supplies |
                 video_game_arcades | video_tape_rental_stores | vocational_trade_schools |
                 watch_jewelry_repair | welding_repair | wholesale_clubs | wig_and_toupee_stores |
                 wires_money_orders | womens_accessory_and_specialty_shops |
                 womens_ready_to_wear_stores | wrecking_and_salvage_yards],
            _ := json:value()},
      shipping =>
          #{type => bulk | individual,
            service => express | priority | standard,
            name := binary(),
            address :=
                #{state => binary(),
                  postal_code := binary(),
                  line2 => binary(),
                  line1 := binary(),
                  country := binary(),
                  city := binary(),
                  _ := json:value()},
            _ := json:value()},
      replacement_reason => damaged | expired | lost | stolen,
      replacement_for => binary(),
      metadata => json:value(),
      expand => [binary()],
      currency := binary(),
      cardholder => binary()}.
-type post_issuing_cards_response() :: stripe_model:error() | stripe_model:issuing_card().
-type get_issuing_cards_request() ::
    #{query => get_issuing_cards_request_query(),
      header => get_issuing_cards_request_header(),
      cookie => get_issuing_cards_request_cookie(),
      body => {binary(), get_issuing_cards_request_body()}}.
-type get_issuing_cards_request_query() ::
    #{cardholder => binary(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      ending_before => binary(),
      exp_month => integer(),
      exp_year => integer(),
      expand => [binary()],
      last4 => binary(),
      limit => integer(),
      starting_after => binary(),
      status => active | canceled | inactive,
      type => physical | virtual}.
-type get_issuing_cards_request_header() :: map().
-type get_issuing_cards_request_cookie() :: map().
-type get_issuing_cards_request_body() :: #{}.
-type get_issuing_cards_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:issuing_card()],
      _ := json:value()}.
-type get_sources_source_source_transactions_request() ::
    #{source := binary(),
      query => get_sources_source_source_transactions_request_query(),
      header => get_sources_source_source_transactions_request_header(),
      cookie => get_sources_source_source_transactions_request_cookie(),
      body => {binary(), get_sources_source_source_transactions_request_body()}}.
-type get_sources_source_source_transactions_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_sources_source_source_transactions_request_header() :: map().
-type get_sources_source_source_transactions_request_cookie() :: map().
-type get_sources_source_source_transactions_request_body() :: #{}.
-type get_sources_source_source_transactions_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:source_transaction()],
      _ := json:value()}.
-type post_subscription_schedules_schedule_release_request() ::
    #{schedule := binary(),
      query => post_subscription_schedules_schedule_release_request_query(),
      header => post_subscription_schedules_schedule_release_request_header(),
      cookie => post_subscription_schedules_schedule_release_request_cookie(),
      body => {binary(), post_subscription_schedules_schedule_release_request_body()}}.
-type post_subscription_schedules_schedule_release_request_query() :: map().
-type post_subscription_schedules_schedule_release_request_header() :: map().
-type post_subscription_schedules_schedule_release_request_cookie() :: map().
-type post_subscription_schedules_schedule_release_request_body() ::
    #{preserve_cancel_date => boolean(), expand => [binary()]}.
-type post_subscription_schedules_schedule_release_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type delete_customers_customer_cards_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => delete_customers_customer_cards_id_request_query(),
      header => delete_customers_customer_cards_id_request_header(),
      cookie => delete_customers_customer_cards_id_request_cookie(),
      body => {binary(), delete_customers_customer_cards_id_request_body()}}.
-type delete_customers_customer_cards_id_request_query() :: map().
-type delete_customers_customer_cards_id_request_header() :: map().
-type delete_customers_customer_cards_id_request_cookie() :: map().
-type delete_customers_customer_cards_id_request_body() :: #{expand => [binary()]}.
-type delete_customers_customer_cards_id_response() ::
    stripe_model:error() |
    stripe_model:payment_source() |
    stripe_model:deleted_payment_source().
-type post_customers_customer_cards_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => post_customers_customer_cards_id_request_query(),
      header => post_customers_customer_cards_id_request_header(),
      cookie => post_customers_customer_cards_id_request_cookie(),
      body => {binary(), post_customers_customer_cards_id_request_body()}}.
-type post_customers_customer_cards_id_request_query() :: map().
-type post_customers_customer_cards_id_request_header() :: map().
-type post_customers_customer_cards_id_request_cookie() :: map().
-type post_customers_customer_cards_id_request_body() ::
    #{owner =>
          #{phone => binary(),
            name => binary(),
            email => binary(),
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      name => binary(),
      metadata => json:value() | '',
      expand => [binary()],
      exp_year => binary(),
      exp_month => binary(),
      address_zip => binary(),
      address_state => binary(),
      address_line2 => binary(),
      address_line1 => binary(),
      address_country => binary(),
      address_city => binary(),
      account_holder_type => company | individual,
      account_holder_name => binary()}.
-type post_customers_customer_cards_id_response() ::
    stripe_model:error() |
    stripe_model:card() |
    stripe_model:bank_account() |
    stripe_model:source().
-type get_customers_customer_cards_id_request() ::
    #{customer := binary(),
      id := binary(),
      query => get_customers_customer_cards_id_request_query(),
      header => get_customers_customer_cards_id_request_header(),
      cookie => get_customers_customer_cards_id_request_cookie(),
      body => {binary(), get_customers_customer_cards_id_request_body()}}.
-type get_customers_customer_cards_id_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_cards_id_request_header() :: map().
-type get_customers_customer_cards_id_request_cookie() :: map().
-type get_customers_customer_cards_id_request_body() :: #{}.
-type get_customers_customer_cards_id_response() ::
    stripe_model:error() | stripe_model:card().
-type post_charges_charge_dispute_request() ::
    #{charge := binary(),
      query => post_charges_charge_dispute_request_query(),
      header => post_charges_charge_dispute_request_header(),
      cookie => post_charges_charge_dispute_request_cookie(),
      body => {binary(), post_charges_charge_dispute_request_body()}}.
-type post_charges_charge_dispute_request_query() :: map().
-type post_charges_charge_dispute_request_header() :: map().
-type post_charges_charge_dispute_request_cookie() :: map().
-type post_charges_charge_dispute_request_body() ::
    #{submit => boolean(),
      metadata => json:value() | '',
      expand => [binary()],
      evidence =>
          #{uncategorized_text => binary(),
            uncategorized_file => binary(),
            shipping_tracking_number => binary(),
            shipping_documentation => binary(),
            shipping_date => binary(),
            shipping_carrier => binary(),
            shipping_address => binary(),
            service_documentation => binary(),
            service_date => binary(),
            refund_refusal_explanation => binary(),
            refund_policy_disclosure => binary(),
            refund_policy => binary(),
            receipt => binary(),
            product_description => binary(),
            duplicate_charge_id => binary(),
            duplicate_charge_explanation => binary(),
            duplicate_charge_documentation => binary(),
            customer_signature => binary(),
            customer_purchase_ip => binary(),
            customer_name => binary(),
            customer_email_address => binary(),
            customer_communication => binary(),
            cancellation_rebuttal => binary(),
            cancellation_policy_disclosure => binary(),
            cancellation_policy => binary(),
            billing_address => binary(),
            access_activity_log => binary(),
            _ := json:value()}}.
-type post_charges_charge_dispute_response() ::
    stripe_model:error() | stripe_model:dispute().
-type get_charges_charge_dispute_request() ::
    #{charge := binary(),
      query => get_charges_charge_dispute_request_query(),
      header => get_charges_charge_dispute_request_header(),
      cookie => get_charges_charge_dispute_request_cookie(),
      body => {binary(), get_charges_charge_dispute_request_body()}}.
-type get_charges_charge_dispute_request_query() :: #{expand => [binary()]}.
-type get_charges_charge_dispute_request_header() :: map().
-type get_charges_charge_dispute_request_cookie() :: map().
-type get_charges_charge_dispute_request_body() :: #{}.
-type get_charges_charge_dispute_response() ::
    stripe_model:error() | stripe_model:dispute().
-type post_quotes_quote_finalize_request() ::
    #{quote := binary(),
      query => post_quotes_quote_finalize_request_query(),
      header => post_quotes_quote_finalize_request_header(),
      cookie => post_quotes_quote_finalize_request_cookie(),
      body => {binary(), post_quotes_quote_finalize_request_body()}}.
-type post_quotes_quote_finalize_request_query() :: map().
-type post_quotes_quote_finalize_request_header() :: map().
-type post_quotes_quote_finalize_request_cookie() :: map().
-type post_quotes_quote_finalize_request_body() ::
    #{expires_at => integer(), expand => [binary()]}.
-type post_quotes_quote_finalize_response() ::
    stripe_model:error() | stripe_model:quote().
-type delete_skus_id_request() ::
    #{id := binary(),
      query => delete_skus_id_request_query(),
      header => delete_skus_id_request_header(),
      cookie => delete_skus_id_request_cookie(),
      body => {binary(), delete_skus_id_request_body()}}.
-type delete_skus_id_request_query() :: map().
-type delete_skus_id_request_header() :: map().
-type delete_skus_id_request_cookie() :: map().
-type delete_skus_id_request_body() :: #{}.
-type delete_skus_id_response() :: stripe_model:error() | stripe_model:deleted_sku().
-type post_skus_id_request() ::
    #{id := binary(),
      query => post_skus_id_request_query(),
      header => post_skus_id_request_header(),
      cookie => post_skus_id_request_cookie(),
      body => {binary(), post_skus_id_request_body()}}.
-type post_skus_id_request_query() :: map().
-type post_skus_id_request_header() :: map().
-type post_skus_id_request_cookie() :: map().
-type post_skus_id_request_body() ::
    #{product => binary(),
      price => integer(),
      package_dimensions =>
          #{width := number(),
            weight := number(),
            length := number(),
            height := number(),
            _ := json:value()} |
          '',
      metadata => json:value() | '',
      inventory =>
          #{value => '' | in_stock | limited | out_of_stock,
            type => bucket | finite | infinite,
            quantity => integer(),
            _ := json:value()},
      image => binary(),
      expand => [binary()],
      currency => binary(),
      attributes => json:value(),
      active => boolean()}.
-type post_skus_id_response() :: stripe_model:error() | stripe_model:sku().
-type get_skus_id_request() ::
    #{id := binary(),
      query => get_skus_id_request_query(),
      header => get_skus_id_request_header(),
      cookie => get_skus_id_request_cookie(),
      body => {binary(), get_skus_id_request_body()}}.
-type get_skus_id_request_query() :: #{expand => [binary()]}.
-type get_skus_id_request_header() :: map().
-type get_skus_id_request_cookie() :: map().
-type get_skus_id_request_body() :: #{}.
-type get_skus_id_response() ::
    stripe_model:error() | stripe_model:sku() | stripe_model:deleted_sku().
-type post_disputes_dispute_request() ::
    #{dispute := binary(),
      query => post_disputes_dispute_request_query(),
      header => post_disputes_dispute_request_header(),
      cookie => post_disputes_dispute_request_cookie(),
      body => {binary(), post_disputes_dispute_request_body()}}.
-type post_disputes_dispute_request_query() :: map().
-type post_disputes_dispute_request_header() :: map().
-type post_disputes_dispute_request_cookie() :: map().
-type post_disputes_dispute_request_body() ::
    #{submit => boolean(),
      metadata => json:value() | '',
      expand => [binary()],
      evidence =>
          #{uncategorized_text => binary(),
            uncategorized_file => binary(),
            shipping_tracking_number => binary(),
            shipping_documentation => binary(),
            shipping_date => binary(),
            shipping_carrier => binary(),
            shipping_address => binary(),
            service_documentation => binary(),
            service_date => binary(),
            refund_refusal_explanation => binary(),
            refund_policy_disclosure => binary(),
            refund_policy => binary(),
            receipt => binary(),
            product_description => binary(),
            duplicate_charge_id => binary(),
            duplicate_charge_explanation => binary(),
            duplicate_charge_documentation => binary(),
            customer_signature => binary(),
            customer_purchase_ip => binary(),
            customer_name => binary(),
            customer_email_address => binary(),
            customer_communication => binary(),
            cancellation_rebuttal => binary(),
            cancellation_policy_disclosure => binary(),
            cancellation_policy => binary(),
            billing_address => binary(),
            access_activity_log => binary(),
            _ := json:value()}}.
-type post_disputes_dispute_response() :: stripe_model:error() | stripe_model:dispute().
-type get_disputes_dispute_request() ::
    #{dispute := binary(),
      query => get_disputes_dispute_request_query(),
      header => get_disputes_dispute_request_header(),
      cookie => get_disputes_dispute_request_cookie(),
      body => {binary(), get_disputes_dispute_request_body()}}.
-type get_disputes_dispute_request_query() :: #{expand => [binary()]}.
-type get_disputes_dispute_request_header() :: map().
-type get_disputes_dispute_request_cookie() :: map().
-type get_disputes_dispute_request_body() :: #{}.
-type get_disputes_dispute_response() :: stripe_model:error() | stripe_model:dispute().
-type post_terminal_locations_request() ::
    #{query => post_terminal_locations_request_query(),
      header => post_terminal_locations_request_header(),
      cookie => post_terminal_locations_request_cookie(),
      body := {binary(), post_terminal_locations_request_body()}}.
-type post_terminal_locations_request_query() :: map().
-type post_terminal_locations_request_header() :: map().
-type post_terminal_locations_request_cookie() :: map().
-type post_terminal_locations_request_body() ::
    #{metadata => json:value() | '',
      expand => [binary()],
      display_name := binary(),
      address :=
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country := binary(),
            city => binary(),
            _ := json:value()}}.
-type post_terminal_locations_response() ::
    stripe_model:error() | stripe_model:terminal_location().
-type get_terminal_locations_request() ::
    #{query => get_terminal_locations_request_query(),
      header => get_terminal_locations_request_header(),
      cookie => get_terminal_locations_request_cookie(),
      body => {binary(), get_terminal_locations_request_body()}}.
-type get_terminal_locations_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_terminal_locations_request_header() :: map().
-type get_terminal_locations_request_cookie() :: map().
-type get_terminal_locations_request_body() :: #{}.
-type get_terminal_locations_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:terminal_location()],
      _ := json:value()}.
-type post_subscription_schedules_request() ::
    #{query => post_subscription_schedules_request_query(),
      header => post_subscription_schedules_request_header(),
      cookie => post_subscription_schedules_request_cookie(),
      body => {binary(), post_subscription_schedules_request_body()}}.
-type post_subscription_schedules_request_query() :: map().
-type post_subscription_schedules_request_header() :: map().
-type post_subscription_schedules_request_cookie() :: map().
-type post_subscription_schedules_request_body() ::
    #{start_date => integer() | now,
      phases =>
          [#{trial_end => integer(),
             trial => boolean(),
             transfer_data =>
                 #{destination := binary(),
                   amount_percent => number(),
                   _ := json:value()},
             proration_behavior => always_invoice | create_prorations | none,
             iterations => integer(),
             items :=
                 [#{tax_rates => [binary()] | '',
                    quantity => integer(),
                    price_data =>
                        #{unit_amount_decimal => binary(),
                          unit_amount => integer(),
                          tax_behavior => exclusive | inclusive | unspecified,
                          recurring :=
                              #{interval_count => integer(),
                                interval := day | month | week | year,
                                _ := json:value()},
                          product := binary(),
                          currency := binary(),
                          _ := json:value()},
                    price => binary(),
                    billing_thresholds => #{usage_gte := integer(), _ := json:value()} | '',
                    _ := json:value()}],
             invoice_settings => #{days_until_due => integer(), _ := json:value()},
             end_date => integer(),
             default_tax_rates => [binary()] | '',
             default_payment_method => binary(),
             coupon => binary(),
             collection_method => charge_automatically | send_invoice,
             billing_thresholds =>
                 #{reset_billing_cycle_anchor => boolean(),
                   amount_gte => integer(),
                   _ := json:value()} |
                 '',
             billing_cycle_anchor => automatic | phase_start,
             automatic_tax => #{enabled := boolean(), _ := json:value()},
             application_fee_percent => number(),
             add_invoice_items =>
                 [#{tax_rates => [binary()] | '',
                    quantity => integer(),
                    price_data =>
                        #{unit_amount_decimal => binary(),
                          unit_amount => integer(),
                          tax_behavior => exclusive | inclusive | unspecified,
                          product := binary(),
                          currency := binary(),
                          _ := json:value()},
                    price => binary(),
                    _ := json:value()}],
             _ := json:value()}],
      metadata => json:value() | '',
      from_subscription => binary(),
      expand => [binary()],
      end_behavior => cancel | none | release | renew,
      default_settings =>
          #{transfer_data =>
                #{destination := binary(),
                  amount_percent => number(),
                  _ := json:value()} |
                '',
            invoice_settings => #{days_until_due => integer(), _ := json:value()},
            default_payment_method => binary(),
            collection_method => charge_automatically | send_invoice,
            billing_thresholds =>
                #{reset_billing_cycle_anchor => boolean(),
                  amount_gte => integer(),
                  _ := json:value()} |
                '',
            billing_cycle_anchor => automatic | phase_start,
            automatic_tax => #{enabled := boolean(), _ := json:value()},
            application_fee_percent => number(),
            _ := json:value()},
      customer => binary()}.
-type post_subscription_schedules_response() ::
    stripe_model:error() | stripe_model:subscription_schedule().
-type get_subscription_schedules_request() ::
    #{query => get_subscription_schedules_request_query(),
      header => get_subscription_schedules_request_header(),
      cookie => get_subscription_schedules_request_cookie(),
      body => {binary(), get_subscription_schedules_request_body()}}.
-type get_subscription_schedules_request_query() ::
    #{canceled_at =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      completed_at =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      created =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      customer => binary(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      released_at =>
          #{lte => integer(),
            lt => integer(),
            gte => integer(),
            gt => integer(),
            _ := json:value()} |
          integer(),
      scheduled => boolean(),
      starting_after => binary()}.
-type get_subscription_schedules_request_header() :: map().
-type get_subscription_schedules_request_cookie() :: map().
-type get_subscription_schedules_request_body() :: #{}.
-type get_subscription_schedules_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:subscription_schedule()],
      _ := json:value()}.
-type post_payment_links_request() ::
    #{query => post_payment_links_request_query(),
      header => post_payment_links_request_header(),
      cookie => post_payment_links_request_cookie(),
      body => {binary(), post_payment_links_request_body()}}.
-type post_payment_links_request_query() :: map().
-type post_payment_links_request_header() :: map().
-type post_payment_links_request_cookie() :: map().
-type post_payment_links_request_body() ::
    #{transfer_data =>
          #{destination := binary(),
            amount => integer(),
            _ := json:value()},
      subscription_data => #{trial_period_days => integer(), _ := json:value()},
      shipping_address_collection =>
          #{allowed_countries :=
                ['AC' | 'AD' | 'AE' | 'AF' | 'AG' | 'AI' | 'AL' | 'AM' | 'AO' | 'AQ' | 'AR' | 'AT' |
                 'AU' | 'AW' | 'AX' | 'AZ' | 'BA' | 'BB' | 'BD' | 'BE' | 'BF' | 'BG' | 'BH' | 'BI' |
                 'BJ' | 'BL' | 'BM' | 'BN' | 'BO' | 'BQ' | 'BR' | 'BS' | 'BT' | 'BV' | 'BW' | 'BY' |
                 'BZ' | 'CA' | 'CD' | 'CF' | 'CG' | 'CH' | 'CI' | 'CK' | 'CL' | 'CM' | 'CN' | 'CO' |
                 'CR' | 'CV' | 'CW' | 'CY' | 'CZ' | 'DE' | 'DJ' | 'DK' | 'DM' | 'DO' | 'DZ' | 'EC' |
                 'EE' | 'EG' | 'EH' | 'ER' | 'ES' | 'ET' | 'FI' | 'FJ' | 'FK' | 'FO' | 'FR' | 'GA' |
                 'GB' | 'GD' | 'GE' | 'GF' | 'GG' | 'GH' | 'GI' | 'GL' | 'GM' | 'GN' | 'GP' | 'GQ' |
                 'GR' | 'GS' | 'GT' | 'GU' | 'GW' | 'GY' | 'HK' | 'HN' | 'HR' | 'HT' | 'HU' | 'ID' |
                 'IE' | 'IL' | 'IM' | 'IN' | 'IO' | 'IQ' | 'IS' | 'IT' | 'JE' | 'JM' | 'JO' | 'JP' |
                 'KE' | 'KG' | 'KH' | 'KI' | 'KM' | 'KN' | 'KR' | 'KW' | 'KY' | 'KZ' | 'LA' | 'LB' |
                 'LC' | 'LI' | 'LK' | 'LR' | 'LS' | 'LT' | 'LU' | 'LV' | 'LY' | 'MA' | 'MC' | 'MD' |
                 'ME' | 'MF' | 'MG' | 'MK' | 'ML' | 'MM' | 'MN' | 'MO' | 'MQ' | 'MR' | 'MS' | 'MT' |
                 'MU' | 'MV' | 'MW' | 'MX' | 'MY' | 'MZ' | 'NA' | 'NC' | 'NE' | 'NG' | 'NI' | 'NL' |
                 'NO' | 'NP' | 'NR' | 'NU' | 'NZ' | 'OM' | 'PA' | 'PE' | 'PF' | 'PG' | 'PH' | 'PK' |
                 'PL' | 'PM' | 'PN' | 'PR' | 'PS' | 'PT' | 'PY' | 'QA' | 'RE' | 'RO' | 'RS' | 'RU' |
                 'RW' | 'SA' | 'SB' | 'SC' | 'SE' | 'SG' | 'SH' | 'SI' | 'SJ' | 'SK' | 'SL' | 'SM' |
                 'SN' | 'SO' | 'SR' | 'SS' | 'ST' | 'SV' | 'SX' | 'SZ' | 'TA' | 'TC' | 'TD' | 'TF' |
                 'TG' | 'TH' | 'TJ' | 'TK' | 'TL' | 'TM' | 'TN' | 'TO' | 'TR' | 'TT' | 'TV' | 'TW' |
                 'TZ' | 'UA' | 'UG' | 'US' | 'UY' | 'UZ' | 'VA' | 'VC' | 'VE' | 'VG' | 'VN' | 'VU' |
                 'WF' | 'WS' | 'XK' | 'YE' | 'YT' | 'ZA' | 'ZM' | 'ZW' | 'ZZ'],
            _ := json:value()},
      phone_number_collection => #{enabled := boolean(), _ := json:value()},
      payment_method_types => [card],
      on_behalf_of => binary(),
      metadata => json:value(),
      line_items =>
          [#{quantity := integer(),
             price := binary(),
             adjustable_quantity =>
                 #{minimum => integer(),
                   maximum => integer(),
                   enabled := boolean(),
                   _ := json:value()},
             _ := json:value()}],
      expand => [binary()],
      billing_address_collection => auto | required,
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      application_fee_percent => number(),
      application_fee_amount => integer(),
      allow_promotion_codes => boolean(),
      after_completion =>
          #{type := hosted_confirmation | redirect,
            redirect => #{url := binary(), _ := json:value()},
            hosted_confirmation => #{custom_message => binary(), _ := json:value()},
            _ := json:value()}}.
-type post_payment_links_response() :: stripe_model:error() | stripe_model:payment_link().
-type get_payment_links_request() ::
    #{query => get_payment_links_request_query(),
      header => get_payment_links_request_header(),
      cookie => get_payment_links_request_cookie(),
      body => {binary(), get_payment_links_request_body()}}.
-type get_payment_links_request_query() ::
    #{active => boolean(),
      ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_payment_links_request_header() :: map().
-type get_payment_links_request_cookie() :: map().
-type get_payment_links_request_body() :: #{}.
-type get_payment_links_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:payment_link()],
      _ := json:value()}.
-type post_tokens_request() ::
    #{query => post_tokens_request_query(),
      header => post_tokens_request_header(),
      cookie => post_tokens_request_cookie(),
      body => {binary(), post_tokens_request_body()}}.
-type post_tokens_request_query() :: map().
-type post_tokens_request_header() :: map().
-type post_tokens_request_cookie() :: map().
-type post_tokens_request_body() ::
    #{pii => #{id_number => binary(), _ := json:value()},
      person =>
          #{verification =>
                #{document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  additional_document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  _ := json:value()},
            ssn_last_4 => binary(),
            relationship =>
                #{title => binary(),
                  representative => boolean(),
                  percent_ownership => number() | '',
                  owner => boolean(),
                  executive => boolean(),
                  director => boolean(),
                  _ := json:value()},
            political_exposure => binary(),
            phone => binary(),
            nationality => binary(),
            metadata => json:value() | '',
            maiden_name => binary(),
            last_name_kanji => binary(),
            last_name_kana => binary(),
            last_name => binary(),
            id_number => binary(),
            gender => binary(),
            full_name_aliases => [binary()] | '',
            first_name_kanji => binary(),
            first_name_kana => binary(),
            first_name => binary(),
            email => binary(),
            documents =>
                #{visa => #{files => [binary()], _ := json:value()},
                  passport => #{files => [binary()], _ := json:value()},
                  company_authorization => #{files => [binary()], _ := json:value()},
                  _ := json:value()},
            dob =>
                #{year := integer(),
                  month := integer(),
                  day := integer(),
                  _ := json:value()} |
                '',
            address_kanji =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address_kana =>
                #{town => binary(),
                  state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            address =>
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()},
      expand => [binary()],
      cvc_update => #{cvc := binary(), _ := json:value()},
      customer => binary(),
      card =>
          #{number := binary(),
            name => binary(),
            exp_year := binary(),
            exp_month := binary(),
            cvc => binary(),
            currency => binary(),
            address_zip => binary(),
            address_state => binary(),
            address_line2 => binary(),
            address_line1 => binary(),
            address_country => binary(),
            address_city => binary(),
            _ := json:value()} |
          binary(),
      bank_account =>
          #{routing_number => binary(),
            currency => binary(),
            country := binary(),
            account_type => checking | futsu | savings | toza,
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()},
      account =>
          #{tos_shown_and_accepted => boolean(),
            individual =>
                #{verification =>
                      #{document =>
                            #{front => binary(),
                              back => binary(),
                              _ := json:value()},
                        additional_document =>
                            #{front => binary(),
                              back => binary(),
                              _ := json:value()},
                        _ := json:value()},
                  ssn_last_4 => binary(),
                  political_exposure => existing | none,
                  phone => binary(),
                  metadata => json:value() | '',
                  maiden_name => binary(),
                  last_name_kanji => binary(),
                  last_name_kana => binary(),
                  last_name => binary(),
                  id_number => binary(),
                  gender => binary(),
                  full_name_aliases => [binary()] | '',
                  first_name_kanji => binary(),
                  first_name_kana => binary(),
                  first_name => binary(),
                  email => binary(),
                  dob =>
                      #{year := integer(),
                        month := integer(),
                        day := integer(),
                        _ := json:value()} |
                      '',
                  address_kanji =>
                      #{town => binary(),
                        state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  address_kana =>
                      #{town => binary(),
                        state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  address =>
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  _ := json:value()},
            company =>
                #{verification =>
                      #{document =>
                            #{front => binary(),
                              back => binary(),
                              _ := json:value()},
                        _ := json:value()},
                  vat_id => binary(),
                  tax_id_registrar => binary(),
                  tax_id => binary(),
                  structure =>
                      '' |
                      free_zone_establishment |
                      free_zone_llc |
                      government_instrumentality |
                      governmental_unit |
                      incorporated_non_profit |
                      limited_liability_partnership |
                      llc |
                      multi_member_llc |
                      private_company |
                      private_corporation |
                      private_partnership |
                      public_company |
                      public_corporation |
                      public_partnership |
                      single_member_llc |
                      sole_establishment |
                      sole_proprietorship |
                      tax_exempt_government_instrumentality |
                      unincorporated_association |
                      unincorporated_non_profit,
                  registration_number => binary(),
                  phone => binary(),
                  ownership_declaration_shown_and_signed => boolean(),
                  ownership_declaration =>
                      #{user_agent => binary(),
                        ip => binary(),
                        date => integer(),
                        _ := json:value()},
                  owners_provided => boolean(),
                  name_kanji => binary(),
                  name_kana => binary(),
                  name => binary(),
                  executives_provided => boolean(),
                  directors_provided => boolean(),
                  address_kanji =>
                      #{town => binary(),
                        state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  address_kana =>
                      #{town => binary(),
                        state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  address =>
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()},
                  _ := json:value()},
            business_type => company | government_entity | individual | non_profit,
            _ := json:value()}}.
-type post_tokens_response() :: stripe_model:error() | stripe_model:token().
-type post_issuing_cardholders_cardholder_request() ::
    #{cardholder := binary(),
      query => post_issuing_cardholders_cardholder_request_query(),
      header => post_issuing_cardholders_cardholder_request_header(),
      cookie => post_issuing_cardholders_cardholder_request_cookie(),
      body => {binary(), post_issuing_cardholders_cardholder_request_body()}}.
-type post_issuing_cardholders_cardholder_request_query() :: map().
-type post_issuing_cardholders_cardholder_request_header() :: map().
-type post_issuing_cardholders_cardholder_request_cookie() :: map().
-type post_issuing_cardholders_cardholder_request_body() ::
    #{status => active | inactive,
      spending_controls =>
          #{spending_limits_currency => binary(),
            spending_limits =>
                [#{interval := all_time | daily | monthly | per_authorization | weekly | yearly,
                   categories =>
                       [ac_refrigeration_repair | accounting_bookkeeping_services |
                        advertising_services | agricultural_cooperative | airlines_air_carriers |
                        airports_flying_fields | ambulance_services | amusement_parks_carnivals |
                        antique_reproductions | antique_shops | aquariums |
                        architectural_surveying_services | art_dealers_and_galleries |
                        artists_supply_and_craft_shops | auto_and_home_supply_stores |
                        auto_body_repair_shops | auto_paint_shops | auto_service_shops |
                        automated_cash_disburse | automated_fuel_dispensers |
                        automobile_associations | automotive_parts_and_accessories_stores |
                        automotive_tire_stores | bail_and_bond_payments | bakeries |
                        bands_orchestras | barber_and_beauty_shops | betting_casino_gambling |
                        bicycle_shops | billiard_pool_establishments | boat_dealers |
                        boat_rentals_and_leases | book_stores | books_periodicals_and_newspapers |
                        bowling_alleys | bus_lines | business_secretarial_schools |
                        buying_shopping_services |
                        cable_satellite_and_other_pay_television_and_radio |
                        camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                        car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                        car_rental_agencies | car_washes | carpentry_services |
                        carpet_upholstery_cleaning | caterers |
                        charitable_and_social_service_organizations_fundraising |
                        chemicals_and_allied_products | child_care_services |
                        childrens_and_infants_wear_stores | chiropodists_podiatrists |
                        chiropractors | cigar_stores_and_stands |
                        civic_social_fraternal_associations | cleaning_and_maintenance |
                        clothing_rental | colleges_universities | commercial_equipment |
                        commercial_footwear | commercial_photography_art_and_graphics |
                        commuter_transport_and_ferries | computer_network_services |
                        computer_programming | computer_repair | computer_software_stores |
                        computers_peripherals_and_software | concrete_work_services |
                        construction_materials | consulting_public_relations |
                        correspondence_schools | cosmetic_stores | counseling_services |
                        country_clubs | courier_services | court_costs | credit_reporting_agencies |
                        cruise_lines | dairy_products_stores | dance_hall_studios_schools |
                        dating_escort_services | dentists_orthodontists | department_stores |
                        detective_agencies | digital_goods_applications | digital_goods_games |
                        digital_goods_large_volume | digital_goods_media |
                        direct_marketing_catalog_merchant |
                        direct_marketing_combination_catalog_and_retail_merchant |
                        direct_marketing_inbound_telemarketing |
                        direct_marketing_insurance_services | direct_marketing_other |
                        direct_marketing_outbound_telemarketing | direct_marketing_subscription |
                        direct_marketing_travel | discount_stores | doctors | door_to_door_sales |
                        drapery_window_covering_and_upholstery_stores | drinking_places |
                        drug_stores_and_pharmacies |
                        drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners |
                        durable_goods | duty_free_stores | eating_places_restaurants |
                        educational_services | electric_razor_stores |
                        electrical_parts_and_equipment | electrical_services |
                        electronics_repair_shops | electronics_stores |
                        elementary_secondary_schools | employment_temp_agencies | equipment_rental |
                        exterminating_services | family_clothing_stores | fast_food_restaurants |
                        financial_institutions | fines_government_administrative_entities |
                        fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                        florists | florists_supplies_nursery_stock_and_flowers |
                        freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                        funeral_services_crematories |
                        furniture_home_furnishings_and_equipment_stores_except_appliances |
                        furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                        gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                        glassware_crystal_stores | golf_courses_public | government_services |
                        grocery_stores_supermarkets | hardware_equipment_and_supplies |
                        hardware_stores | health_and_beauty_spas | hearing_aids_sales_and_supplies |
                        heating_plumbing_a_c | hobby_toy_and_game_shops |
                        home_supply_warehouse_stores | hospitals | hotels_motels_and_resorts |
                        household_appliance_stores | industrial_supplies |
                        information_retrieval_services | insurance_default |
                        insurance_underwriting_premiums | intra_company_purchases |
                        jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                        laundries | laundry_cleaning_services | legal_services_attorneys |
                        luggage_and_leather_goods_stores | lumber_building_materials_stores |
                        manual_cash_disburse | marinas_service_and_supplies |
                        masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                        medical_dental_ophthalmic_and_hospital_equipment_and_supplies |
                        medical_services | membership_organizations |
                        mens_and_boys_clothing_and_accessories_stores |
                        mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                        miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                        miscellaneous_business_services | miscellaneous_food_stores |
                        miscellaneous_general_merchandise | miscellaneous_general_services |
                        miscellaneous_home_furnishing_specialty_stores |
                        miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                        miscellaneous_repair_shops | miscellaneous_specialty_retail |
                        mobile_home_dealers | motion_picture_theaters |
                        motor_freight_carriers_and_trucking | motor_homes_dealers |
                        motor_vehicle_supplies_and_new_parts | motorcycle_shops_and_dealers |
                        motorcycle_shops_dealers |
                        music_stores_musical_instruments_pianos_and_sheet_music |
                        news_dealers_and_newsstands | non_fi_money_orders |
                        non_fi_stored_value_card_purchase_load | nondurable_goods |
                        nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                        office_and_commercial_furniture | opticians_eyeglasses |
                        optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices |
                        osteopaths | package_stores_beer_wine_and_liquor |
                        paints_varnishes_and_supplies | parking_lots_garages | passenger_railways |
                        pawn_shops | pet_shops_pet_food_and_supplies |
                        petroleum_and_petroleum_products | photo_developing |
                        photographic_photocopy_microfilm_equipment_and_supplies |
                        photographic_studios | picture_video_production |
                        piece_goods_notions_and_other_dry_goods |
                        plumbing_heating_equipment_and_supplies | political_organizations |
                        postal_services_government_only |
                        precious_stones_and_metals_watches_and_jewelry | professional_services |
                        public_warehousing_and_storage | quick_copy_repro_and_blueprint |
                        railroads | real_estate_agents_and_managers_rentals | record_stores |
                        recreational_vehicle_rentals | religious_goods_stores |
                        religious_organizations | roofing_siding_sheet_metal |
                        secretarial_support_services | security_brokers_dealers | service_stations |
                        sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                        shoe_stores | small_appliance_repair | snowmobile_dealers |
                        special_trade_services | specialty_cleaning | sporting_goods_stores |
                        sporting_recreation_camps | sports_and_riding_apparel_stores |
                        sports_clubs_fields | stamp_and_coin_stores |
                        stationary_office_supplies_printing_and_writing_paper |
                        stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                        t_ui_travel_germany | tailors_alterations |
                        tax_payments_government_agencies | tax_preparation_services |
                        taxicabs_limousines | telecommunication_equipment_and_telephone_sales |
                        telecommunication_services | telegraph_services | tent_and_awning_shops |
                        testing_laboratories | theatrical_ticket_agencies | timeshares |
                        tire_retreading_and_repair | tolls_bridge_fees |
                        tourist_attractions_and_exhibits | towing_services |
                        trailer_parks_campgrounds | transportation_services |
                        travel_agencies_tour_operators | truck_stop_iteration |
                        truck_utility_trailer_rentals |
                        typesetting_plate_making_and_related_services | typewriter_stores |
                        u_s_federal_government_agencies_or_departments |
                        uniforms_commercial_clothing | used_merchandise_and_secondhand_stores |
                        utilities | variety_stores | veterinary_services |
                        video_amusement_game_supplies | video_game_arcades |
                        video_tape_rental_stores | vocational_trade_schools | watch_jewelry_repair |
                        welding_repair | wholesale_clubs | wig_and_toupee_stores |
                        wires_money_orders | womens_accessory_and_specialty_shops |
                        womens_ready_to_wear_stores | wrecking_and_salvage_yards],
                   amount := integer(),
                   _ := json:value()}],
            blocked_categories =>
                [ac_refrigeration_repair | accounting_bookkeeping_services | advertising_services |
                 agricultural_cooperative | airlines_air_carriers | airports_flying_fields |
                 ambulance_services | amusement_parks_carnivals | antique_reproductions |
                 antique_shops | aquariums | architectural_surveying_services |
                 art_dealers_and_galleries | artists_supply_and_craft_shops |
                 auto_and_home_supply_stores | auto_body_repair_shops | auto_paint_shops |
                 auto_service_shops | automated_cash_disburse | automated_fuel_dispensers |
                 automobile_associations | automotive_parts_and_accessories_stores |
                 automotive_tire_stores | bail_and_bond_payments | bakeries | bands_orchestras |
                 barber_and_beauty_shops | betting_casino_gambling | bicycle_shops |
                 billiard_pool_establishments | boat_dealers | boat_rentals_and_leases |
                 book_stores | books_periodicals_and_newspapers | bowling_alleys | bus_lines |
                 business_secretarial_schools | buying_shopping_services |
                 cable_satellite_and_other_pay_television_and_radio |
                 camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                 car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                 car_rental_agencies | car_washes | carpentry_services |
                 carpet_upholstery_cleaning | caterers |
                 charitable_and_social_service_organizations_fundraising |
                 chemicals_and_allied_products | child_care_services |
                 childrens_and_infants_wear_stores | chiropodists_podiatrists | chiropractors |
                 cigar_stores_and_stands | civic_social_fraternal_associations |
                 cleaning_and_maintenance | clothing_rental | colleges_universities |
                 commercial_equipment | commercial_footwear |
                 commercial_photography_art_and_graphics | commuter_transport_and_ferries |
                 computer_network_services | computer_programming | computer_repair |
                 computer_software_stores | computers_peripherals_and_software |
                 concrete_work_services | construction_materials | consulting_public_relations |
                 correspondence_schools | cosmetic_stores | counseling_services | country_clubs |
                 courier_services | court_costs | credit_reporting_agencies | cruise_lines |
                 dairy_products_stores | dance_hall_studios_schools | dating_escort_services |
                 dentists_orthodontists | department_stores | detective_agencies |
                 digital_goods_applications | digital_goods_games | digital_goods_large_volume |
                 digital_goods_media | direct_marketing_catalog_merchant |
                 direct_marketing_combination_catalog_and_retail_merchant |
                 direct_marketing_inbound_telemarketing | direct_marketing_insurance_services |
                 direct_marketing_other | direct_marketing_outbound_telemarketing |
                 direct_marketing_subscription | direct_marketing_travel | discount_stores |
                 doctors | door_to_door_sales | drapery_window_covering_and_upholstery_stores |
                 drinking_places | drug_stores_and_pharmacies |
                 drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners | durable_goods |
                 duty_free_stores | eating_places_restaurants | educational_services |
                 electric_razor_stores | electrical_parts_and_equipment | electrical_services |
                 electronics_repair_shops | electronics_stores | elementary_secondary_schools |
                 employment_temp_agencies | equipment_rental | exterminating_services |
                 family_clothing_stores | fast_food_restaurants | financial_institutions |
                 fines_government_administrative_entities |
                 fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                 florists | florists_supplies_nursery_stock_and_flowers |
                 freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                 funeral_services_crematories |
                 furniture_home_furnishings_and_equipment_stores_except_appliances |
                 furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                 gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                 glassware_crystal_stores | golf_courses_public | government_services |
                 grocery_stores_supermarkets | hardware_equipment_and_supplies | hardware_stores |
                 health_and_beauty_spas | hearing_aids_sales_and_supplies | heating_plumbing_a_c |
                 hobby_toy_and_game_shops | home_supply_warehouse_stores | hospitals |
                 hotels_motels_and_resorts | household_appliance_stores | industrial_supplies |
                 information_retrieval_services | insurance_default |
                 insurance_underwriting_premiums | intra_company_purchases |
                 jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                 laundries | laundry_cleaning_services | legal_services_attorneys |
                 luggage_and_leather_goods_stores | lumber_building_materials_stores |
                 manual_cash_disburse | marinas_service_and_supplies |
                 masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                 medical_dental_ophthalmic_and_hospital_equipment_and_supplies | medical_services |
                 membership_organizations | mens_and_boys_clothing_and_accessories_stores |
                 mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                 miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                 miscellaneous_business_services | miscellaneous_food_stores |
                 miscellaneous_general_merchandise | miscellaneous_general_services |
                 miscellaneous_home_furnishing_specialty_stores |
                 miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                 miscellaneous_repair_shops | miscellaneous_specialty_retail | mobile_home_dealers |
                 motion_picture_theaters | motor_freight_carriers_and_trucking |
                 motor_homes_dealers | motor_vehicle_supplies_and_new_parts |
                 motorcycle_shops_and_dealers | motorcycle_shops_dealers |
                 music_stores_musical_instruments_pianos_and_sheet_music |
                 news_dealers_and_newsstands | non_fi_money_orders |
                 non_fi_stored_value_card_purchase_load | nondurable_goods |
                 nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                 office_and_commercial_furniture | opticians_eyeglasses |
                 optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices | osteopaths |
                 package_stores_beer_wine_and_liquor | paints_varnishes_and_supplies |
                 parking_lots_garages | passenger_railways | pawn_shops |
                 pet_shops_pet_food_and_supplies | petroleum_and_petroleum_products |
                 photo_developing | photographic_photocopy_microfilm_equipment_and_supplies |
                 photographic_studios | picture_video_production |
                 piece_goods_notions_and_other_dry_goods | plumbing_heating_equipment_and_supplies |
                 political_organizations | postal_services_government_only |
                 precious_stones_and_metals_watches_and_jewelry | professional_services |
                 public_warehousing_and_storage | quick_copy_repro_and_blueprint | railroads |
                 real_estate_agents_and_managers_rentals | record_stores |
                 recreational_vehicle_rentals | religious_goods_stores | religious_organizations |
                 roofing_siding_sheet_metal | secretarial_support_services |
                 security_brokers_dealers | service_stations |
                 sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                 shoe_stores | small_appliance_repair | snowmobile_dealers |
                 special_trade_services | specialty_cleaning | sporting_goods_stores |
                 sporting_recreation_camps | sports_and_riding_apparel_stores |
                 sports_clubs_fields | stamp_and_coin_stores |
                 stationary_office_supplies_printing_and_writing_paper |
                 stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                 t_ui_travel_germany | tailors_alterations | tax_payments_government_agencies |
                 tax_preparation_services | taxicabs_limousines |
                 telecommunication_equipment_and_telephone_sales | telecommunication_services |
                 telegraph_services | tent_and_awning_shops | testing_laboratories |
                 theatrical_ticket_agencies | timeshares | tire_retreading_and_repair |
                 tolls_bridge_fees | tourist_attractions_and_exhibits | towing_services |
                 trailer_parks_campgrounds | transportation_services |
                 travel_agencies_tour_operators | truck_stop_iteration |
                 truck_utility_trailer_rentals | typesetting_plate_making_and_related_services |
                 typewriter_stores | u_s_federal_government_agencies_or_departments |
                 uniforms_commercial_clothing | used_merchandise_and_secondhand_stores | utilities |
                 variety_stores | veterinary_services | video_amusement_game_supplies |
                 video_game_arcades | video_tape_rental_stores | vocational_trade_schools |
                 watch_jewelry_repair | welding_repair | wholesale_clubs | wig_and_toupee_stores |
                 wires_money_orders | womens_accessory_and_specialty_shops |
                 womens_ready_to_wear_stores | wrecking_and_salvage_yards],
            allowed_categories =>
                [ac_refrigeration_repair | accounting_bookkeeping_services | advertising_services |
                 agricultural_cooperative | airlines_air_carriers | airports_flying_fields |
                 ambulance_services | amusement_parks_carnivals | antique_reproductions |
                 antique_shops | aquariums | architectural_surveying_services |
                 art_dealers_and_galleries | artists_supply_and_craft_shops |
                 auto_and_home_supply_stores | auto_body_repair_shops | auto_paint_shops |
                 auto_service_shops | automated_cash_disburse | automated_fuel_dispensers |
                 automobile_associations | automotive_parts_and_accessories_stores |
                 automotive_tire_stores | bail_and_bond_payments | bakeries | bands_orchestras |
                 barber_and_beauty_shops | betting_casino_gambling | bicycle_shops |
                 billiard_pool_establishments | boat_dealers | boat_rentals_and_leases |
                 book_stores | books_periodicals_and_newspapers | bowling_alleys | bus_lines |
                 business_secretarial_schools | buying_shopping_services |
                 cable_satellite_and_other_pay_television_and_radio |
                 camera_and_photographic_supply_stores | candy_nut_and_confectionery_stores |
                 car_and_truck_dealers_new_used | car_and_truck_dealers_used_only |
                 car_rental_agencies | car_washes | carpentry_services |
                 carpet_upholstery_cleaning | caterers |
                 charitable_and_social_service_organizations_fundraising |
                 chemicals_and_allied_products | child_care_services |
                 childrens_and_infants_wear_stores | chiropodists_podiatrists | chiropractors |
                 cigar_stores_and_stands | civic_social_fraternal_associations |
                 cleaning_and_maintenance | clothing_rental | colleges_universities |
                 commercial_equipment | commercial_footwear |
                 commercial_photography_art_and_graphics | commuter_transport_and_ferries |
                 computer_network_services | computer_programming | computer_repair |
                 computer_software_stores | computers_peripherals_and_software |
                 concrete_work_services | construction_materials | consulting_public_relations |
                 correspondence_schools | cosmetic_stores | counseling_services | country_clubs |
                 courier_services | court_costs | credit_reporting_agencies | cruise_lines |
                 dairy_products_stores | dance_hall_studios_schools | dating_escort_services |
                 dentists_orthodontists | department_stores | detective_agencies |
                 digital_goods_applications | digital_goods_games | digital_goods_large_volume |
                 digital_goods_media | direct_marketing_catalog_merchant |
                 direct_marketing_combination_catalog_and_retail_merchant |
                 direct_marketing_inbound_telemarketing | direct_marketing_insurance_services |
                 direct_marketing_other | direct_marketing_outbound_telemarketing |
                 direct_marketing_subscription | direct_marketing_travel | discount_stores |
                 doctors | door_to_door_sales | drapery_window_covering_and_upholstery_stores |
                 drinking_places | drug_stores_and_pharmacies |
                 drugs_drug_proprietaries_and_druggist_sundries | dry_cleaners | durable_goods |
                 duty_free_stores | eating_places_restaurants | educational_services |
                 electric_razor_stores | electrical_parts_and_equipment | electrical_services |
                 electronics_repair_shops | electronics_stores | elementary_secondary_schools |
                 employment_temp_agencies | equipment_rental | exterminating_services |
                 family_clothing_stores | fast_food_restaurants | financial_institutions |
                 fines_government_administrative_entities |
                 fireplace_fireplace_screens_and_accessories_stores | floor_covering_stores |
                 florists | florists_supplies_nursery_stock_and_flowers |
                 freezer_and_locker_meat_provisioners | fuel_dealers_non_automotive |
                 funeral_services_crematories |
                 furniture_home_furnishings_and_equipment_stores_except_appliances |
                 furniture_repair_refinishing | furriers_and_fur_shops | general_services |
                 gift_card_novelty_and_souvenir_shops | glass_paint_and_wallpaper_stores |
                 glassware_crystal_stores | golf_courses_public | government_services |
                 grocery_stores_supermarkets | hardware_equipment_and_supplies | hardware_stores |
                 health_and_beauty_spas | hearing_aids_sales_and_supplies | heating_plumbing_a_c |
                 hobby_toy_and_game_shops | home_supply_warehouse_stores | hospitals |
                 hotels_motels_and_resorts | household_appliance_stores | industrial_supplies |
                 information_retrieval_services | insurance_default |
                 insurance_underwriting_premiums | intra_company_purchases |
                 jewelry_stores_watches_clocks_and_silverware_stores | landscaping_services |
                 laundries | laundry_cleaning_services | legal_services_attorneys |
                 luggage_and_leather_goods_stores | lumber_building_materials_stores |
                 manual_cash_disburse | marinas_service_and_supplies |
                 masonry_stonework_and_plaster | massage_parlors | medical_and_dental_labs |
                 medical_dental_ophthalmic_and_hospital_equipment_and_supplies | medical_services |
                 membership_organizations | mens_and_boys_clothing_and_accessories_stores |
                 mens_womens_clothing_stores | metal_service_centers | miscellaneous |
                 miscellaneous_apparel_and_accessory_shops | miscellaneous_auto_dealers |
                 miscellaneous_business_services | miscellaneous_food_stores |
                 miscellaneous_general_merchandise | miscellaneous_general_services |
                 miscellaneous_home_furnishing_specialty_stores |
                 miscellaneous_publishing_and_printing | miscellaneous_recreation_services |
                 miscellaneous_repair_shops | miscellaneous_specialty_retail | mobile_home_dealers |
                 motion_picture_theaters | motor_freight_carriers_and_trucking |
                 motor_homes_dealers | motor_vehicle_supplies_and_new_parts |
                 motorcycle_shops_and_dealers | motorcycle_shops_dealers |
                 music_stores_musical_instruments_pianos_and_sheet_music |
                 news_dealers_and_newsstands | non_fi_money_orders |
                 non_fi_stored_value_card_purchase_load | nondurable_goods |
                 nurseries_lawn_and_garden_supply_stores | nursing_personal_care |
                 office_and_commercial_furniture | opticians_eyeglasses |
                 optometrists_ophthalmologist | orthopedic_goods_prosthetic_devices | osteopaths |
                 package_stores_beer_wine_and_liquor | paints_varnishes_and_supplies |
                 parking_lots_garages | passenger_railways | pawn_shops |
                 pet_shops_pet_food_and_supplies | petroleum_and_petroleum_products |
                 photo_developing | photographic_photocopy_microfilm_equipment_and_supplies |
                 photographic_studios | picture_video_production |
                 piece_goods_notions_and_other_dry_goods | plumbing_heating_equipment_and_supplies |
                 political_organizations | postal_services_government_only |
                 precious_stones_and_metals_watches_and_jewelry | professional_services |
                 public_warehousing_and_storage | quick_copy_repro_and_blueprint | railroads |
                 real_estate_agents_and_managers_rentals | record_stores |
                 recreational_vehicle_rentals | religious_goods_stores | religious_organizations |
                 roofing_siding_sheet_metal | secretarial_support_services |
                 security_brokers_dealers | service_stations |
                 sewing_needlework_fabric_and_piece_goods_stores | shoe_repair_hat_cleaning |
                 shoe_stores | small_appliance_repair | snowmobile_dealers |
                 special_trade_services | specialty_cleaning | sporting_goods_stores |
                 sporting_recreation_camps | sports_and_riding_apparel_stores |
                 sports_clubs_fields | stamp_and_coin_stores |
                 stationary_office_supplies_printing_and_writing_paper |
                 stationery_stores_office_and_school_supply_stores | swimming_pools_sales |
                 t_ui_travel_germany | tailors_alterations | tax_payments_government_agencies |
                 tax_preparation_services | taxicabs_limousines |
                 telecommunication_equipment_and_telephone_sales | telecommunication_services |
                 telegraph_services | tent_and_awning_shops | testing_laboratories |
                 theatrical_ticket_agencies | timeshares | tire_retreading_and_repair |
                 tolls_bridge_fees | tourist_attractions_and_exhibits | towing_services |
                 trailer_parks_campgrounds | transportation_services |
                 travel_agencies_tour_operators | truck_stop_iteration |
                 truck_utility_trailer_rentals | typesetting_plate_making_and_related_services |
                 typewriter_stores | u_s_federal_government_agencies_or_departments |
                 uniforms_commercial_clothing | used_merchandise_and_secondhand_stores | utilities |
                 variety_stores | veterinary_services | video_amusement_game_supplies |
                 video_game_arcades | video_tape_rental_stores | vocational_trade_schools |
                 watch_jewelry_repair | welding_repair | wholesale_clubs | wig_and_toupee_stores |
                 wires_money_orders | womens_accessory_and_specialty_shops |
                 womens_ready_to_wear_stores | wrecking_and_salvage_yards],
            _ := json:value()},
      phone_number => binary(),
      metadata => json:value(),
      individual =>
          #{verification =>
                #{document =>
                      #{front => binary(),
                        back => binary(),
                        _ := json:value()},
                  _ := json:value()},
            last_name := binary(),
            first_name := binary(),
            dob =>
                #{year := integer(),
                  month := integer(),
                  day := integer(),
                  _ := json:value()},
            _ := json:value()},
      expand => [binary()],
      email => binary(),
      company => #{tax_id => binary(), _ := json:value()},
      billing =>
          #{address :=
                #{state => binary(),
                  postal_code := binary(),
                  line2 => binary(),
                  line1 := binary(),
                  country := binary(),
                  city := binary(),
                  _ := json:value()},
            _ := json:value()}}.
-type post_issuing_cardholders_cardholder_response() ::
    stripe_model:error() | stripe_model:issuing_cardholder().
-type get_issuing_cardholders_cardholder_request() ::
    #{cardholder := binary(),
      query => get_issuing_cardholders_cardholder_request_query(),
      header => get_issuing_cardholders_cardholder_request_header(),
      cookie => get_issuing_cardholders_cardholder_request_cookie(),
      body => {binary(), get_issuing_cardholders_cardholder_request_body()}}.
-type get_issuing_cardholders_cardholder_request_query() :: #{expand => [binary()]}.
-type get_issuing_cardholders_cardholder_request_header() :: map().
-type get_issuing_cardholders_cardholder_request_cookie() :: map().
-type get_issuing_cardholders_cardholder_request_body() :: #{}.
-type get_issuing_cardholders_cardholder_response() ::
    stripe_model:error() | stripe_model:issuing_cardholder().
-type get_application_fees_id_request() ::
    #{id := binary(),
      query => get_application_fees_id_request_query(),
      header => get_application_fees_id_request_header(),
      cookie => get_application_fees_id_request_cookie(),
      body => {binary(), get_application_fees_id_request_body()}}.
-type get_application_fees_id_request_query() :: #{expand => [binary()]}.
-type get_application_fees_id_request_header() :: map().
-type get_application_fees_id_request_cookie() :: map().
-type get_application_fees_id_request_body() :: #{}.
-type get_application_fees_id_response() ::
    stripe_model:error() | stripe_model:application_fee().
-type get_exchange_rates_rate_id_request() ::
    #{rate_id := binary(),
      query => get_exchange_rates_rate_id_request_query(),
      header => get_exchange_rates_rate_id_request_header(),
      cookie => get_exchange_rates_rate_id_request_cookie(),
      body => {binary(), get_exchange_rates_rate_id_request_body()}}.
-type get_exchange_rates_rate_id_request_query() :: #{expand => [binary()]}.
-type get_exchange_rates_rate_id_request_header() :: map().
-type get_exchange_rates_rate_id_request_cookie() :: map().
-type get_exchange_rates_rate_id_request_body() :: #{}.
-type get_exchange_rates_rate_id_response() ::
    stripe_model:error() | stripe_model:exchange_rate().
-type post_payment_intents_intent_confirm_request() ::
    #{intent := binary(),
      query => post_payment_intents_intent_confirm_request_query(),
      header => post_payment_intents_intent_confirm_request_header(),
      cookie => post_payment_intents_intent_confirm_request_cookie(),
      body => {binary(), post_payment_intents_intent_confirm_request_body()}}.
-type post_payment_intents_intent_confirm_request_query() :: map().
-type post_payment_intents_intent_confirm_request_header() :: map().
-type post_payment_intents_intent_confirm_request_cookie() :: map().
-type post_payment_intents_intent_confirm_request_body() ::
    #{use_stripe_sdk => boolean(),
      shipping =>
          #{tracking_number => binary(),
            phone => binary(),
            name := binary(),
            carrier => binary(),
            address :=
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()} |
          '',
      setup_future_usage => '' | off_session | on_session,
      return_url => binary(),
      receipt_email => binary() | '',
      payment_method_types => [binary()],
      payment_method_options =>
          #{wechat_pay =>
                #{setup_future_usage => none,
                  client := android | ios | web,
                  app_id => binary(),
                  _ := json:value()} |
                '',
            sofort =>
                #{setup_future_usage => '' | none | off_session,
                  preferred_language => '' | de | en | es | fr | it | nl | pl,
                  _ := json:value()} |
                '',
            sepa_debit =>
                #{setup_future_usage => '' | none | off_session | on_session,
                  mandate_options => #{_ := json:value()},
                  _ := json:value()} |
                '',
            p24 =>
                #{tos_shown_and_accepted => boolean(),
                  setup_future_usage => none,
                  _ := json:value()} |
                '',
            oxxo =>
                #{setup_future_usage => none,
                  expires_after_days => integer(),
                  _ := json:value()} |
                '',
            klarna =>
                #{setup_future_usage => none,
                  preferred_locale =>
                      'da-DK' | 'de-AT' | 'de-DE' | 'en-AT' | 'en-BE' | 'en-DE' | 'en-DK' |
                      'en-ES' | 'en-FI' | 'en-FR' | 'en-GB' | 'en-IE' | 'en-IT' | 'en-NL' |
                      'en-NO' | 'en-SE' | 'en-US' | 'es-ES' | 'es-US' | 'fi-FI' | 'fr-BE' |
                      'fr-FR' | 'it-IT' | 'nb-NO' | 'nl-BE' | 'nl-NL' | 'sv-FI' | 'sv-SE',
                  _ := json:value()} |
                '',
            interac_present => #{_ := json:value()} | '',
            ideal => #{setup_future_usage => '' | none | off_session, _ := json:value()} | '',
            grabpay => #{setup_future_usage => none, _ := json:value()} | '',
            giropay => #{setup_future_usage => none, _ := json:value()} | '',
            fpx => #{setup_future_usage => none, _ := json:value()} | '',
            eps => #{setup_future_usage => none, _ := json:value()} | '',
            card_present => #{_ := json:value()} | '',
            card =>
                #{setup_future_usage => '' | none | off_session | on_session,
                  request_three_d_secure => any | automatic,
                  network =>
                      amex |
                      cartes_bancaires |
                      diners |
                      discover |
                      interac |
                      jcb |
                      mastercard |
                      unionpay |
                      unknown |
                      visa,
                  installments =>
                      #{plan =>
                            #{type := fixed_count,
                              interval := month,
                              count := integer(),
                              _ := json:value()} |
                            '',
                        enabled => boolean(),
                        _ := json:value()},
                  cvc_token => binary(),
                  _ := json:value()} |
                '',
            boleto =>
                #{setup_future_usage => '' | none | off_session | on_session,
                  expires_after_days => integer(),
                  _ := json:value()} |
                '',
            bancontact =>
                #{setup_future_usage => '' | none | off_session,
                  preferred_language => de | en | fr | nl,
                  _ := json:value()} |
                '',
            bacs_debit =>
                #{setup_future_usage => '' | none | off_session | on_session, _ := json:value()} |
                '',
            au_becs_debit =>
                #{setup_future_usage => '' | none | off_session | on_session, _ := json:value()} |
                '',
            alipay => #{setup_future_usage => '' | none | off_session, _ := json:value()} | '',
            afterpay_clearpay =>
                #{setup_future_usage => none,
                  reference => binary(),
                  _ := json:value()} |
                '',
            acss_debit =>
                #{verification_method => automatic | instant | microdeposits,
                  setup_future_usage => '' | none | off_session | on_session,
                  mandate_options =>
                      #{transaction_type => business | personal,
                        payment_schedule => combined | interval | sporadic,
                        interval_description => binary(),
                        custom_mandate_url => binary() | '',
                        _ := json:value()},
                  _ := json:value()} |
                '',
            _ := json:value()},
      payment_method_data =>
          #{wechat_pay => #{_ := json:value()},
            type :=
                acss_debit |
                afterpay_clearpay |
                alipay |
                au_becs_debit |
                bacs_debit |
                bancontact |
                boleto |
                eps |
                fpx |
                giropay |
                grabpay |
                ideal |
                klarna |
                oxxo |
                p24 |
                sepa_debit |
                sofort |
                wechat_pay,
            sofort => #{country := 'AT' | 'BE' | 'DE' | 'ES' | 'IT' | 'NL', _ := json:value()},
            sepa_debit => #{iban := binary(), _ := json:value()},
            p24 =>
                #{bank =>
                      alior_bank |
                      bank_millennium |
                      bank_nowy_bfg_sa |
                      bank_pekao_sa |
                      banki_spbdzielcze |
                      blik |
                      bnp_paribas |
                      boz |
                      citi_handlowy |
                      credit_agricole |
                      envelobank |
                      etransfer_pocztowy24 |
                      getin_bank |
                      ideabank |
                      ing |
                      inteligo |
                      mbank_mtransfer |
                      nest_przelew |
                      noble_pay |
                      pbac_z_ipko |
                      plus_bank |
                      santander_przelew24 |
                      tmobile_usbugi_bankowe |
                      toyota_bank |
                      volkswagen_bank,
                  _ := json:value()},
            oxxo => #{_ := json:value()},
            metadata => json:value(),
            klarna =>
                #{dob =>
                      #{year := integer(),
                        month := integer(),
                        day := integer(),
                        _ := json:value()},
                  _ := json:value()},
            interac_present => #{_ := json:value()},
            ideal =>
                #{bank =>
                      abn_amro |
                      asn_bank |
                      bunq |
                      handelsbanken |
                      ing |
                      knab |
                      moneyou |
                      rabobank |
                      regiobank |
                      revolut |
                      sns_bank |
                      triodos_bank |
                      van_lanschot,
                  _ := json:value()},
            grabpay => #{_ := json:value()},
            giropay => #{_ := json:value()},
            fpx =>
                #{bank :=
                      affin_bank |
                      agrobank |
                      alliance_bank |
                      ambank |
                      bank_islam |
                      bank_muamalat |
                      bank_rakyat |
                      bsn |
                      cimb |
                      deutsche_bank |
                      hong_leong_bank |
                      hsbc |
                      kfh |
                      maybank2e |
                      maybank2u |
                      ocbc |
                      pb_enterprise |
                      public_bank |
                      rhb |
                      standard_chartered |
                      uob,
                  _ := json:value()},
            eps =>
                #{bank =>
                      arzte_und_apotheker_bank | austrian_anadi_bank_ag | bank_austria |
                      bankhaus_carl_spangler | bankhaus_schelhammer_und_schattera_ag |
                      bawag_psk_ag | bks_bank_ag | brull_kallmus_bank_ag | btv_vier_lander_bank |
                      capital_bank_grawe_gruppe_ag | dolomitenbank | easybank_ag |
                      erste_bank_und_sparkassen | hypo_alpeadriabank_international_ag |
                      hypo_bank_burgenland_aktiengesellschaft |
                      hypo_noe_lb_fur_niederosterreich_u_wien |
                      hypo_oberosterreich_salzburg_steiermark | hypo_tirol_bank_ag |
                      hypo_vorarlberg_bank_ag | marchfelder_bank | oberbank_ag |
                      raiffeisen_bankengruppe_osterreich | schoellerbank_ag | sparda_bank_wien |
                      volksbank_gruppe | volkskreditbank_ag | vr_bank_braunau,
                  _ := json:value()},
            boleto => #{tax_id := binary(), _ := json:value()},
            billing_details =>
                #{phone => binary(),
                  name => binary(),
                  email => binary() | '',
                  address =>
                      #{state => binary(),
                        postal_code => binary(),
                        line2 => binary(),
                        line1 => binary(),
                        country => binary(),
                        city => binary(),
                        _ := json:value()} |
                      '',
                  _ := json:value()},
            bancontact => #{_ := json:value()},
            bacs_debit =>
                #{sort_code => binary(),
                  account_number => binary(),
                  _ := json:value()},
            au_becs_debit =>
                #{bsb_number := binary(),
                  account_number := binary(),
                  _ := json:value()},
            alipay => #{_ := json:value()},
            afterpay_clearpay => #{_ := json:value()},
            acss_debit =>
                #{transit_number := binary(),
                  institution_number := binary(),
                  account_number := binary(),
                  _ := json:value()},
            _ := json:value()},
      payment_method => binary(),
      off_session => boolean() | one_off | recurring,
      mandate_data =>
          #{customer_acceptance :=
                #{type := offline | online,
                  online =>
                      #{user_agent := binary(),
                        ip_address := binary(),
                        _ := json:value()},
                  offline => #{_ := json:value()},
                  accepted_at => integer(),
                  _ := json:value()},
            _ := json:value()} |
          #{customer_acceptance :=
                #{type := online,
                  online :=
                      #{user_agent => binary(),
                        ip_address => binary(),
                        _ := json:value()},
                  _ := json:value()},
            _ := json:value()},
      mandate => binary(),
      expand => [binary()],
      error_on_requires_action => boolean(),
      client_secret => binary()}.
-type post_payment_intents_intent_confirm_response() ::
    stripe_model:error() | stripe_model:payment_intent().
-type get_credit_notes_preview_request() ::
    #{query => get_credit_notes_preview_request_query(),
      header => get_credit_notes_preview_request_header(),
      cookie => get_credit_notes_preview_request_cookie(),
      body => {binary(), get_credit_notes_preview_request_body()}}.
-type get_credit_notes_preview_request_query() ::
    #{amount => integer(),
      credit_amount => integer(),
      expand => [binary()],
      invoice := binary(),
      lines =>
          [#{unit_amount_decimal => binary(),
             unit_amount => integer(),
             type := custom_line_item | invoice_line_item,
             tax_rates => [binary()] | '',
             quantity => integer(),
             invoice_line_item => binary(),
             description => binary(),
             amount => integer(),
             _ := json:value()}],
      memo => binary(),
      metadata => json:value(),
      out_of_band_amount => integer(),
      reason => duplicate | fraudulent | order_change | product_unsatisfactory,
      refund => binary(),
      refund_amount => integer()}.
-type get_credit_notes_preview_request_header() :: map().
-type get_credit_notes_preview_request_cookie() :: map().
-type get_credit_notes_preview_request_body() :: #{}.
-type get_credit_notes_preview_response() ::
    stripe_model:error() | stripe_model:credit_note().
-type get_balance_history_id_request() ::
    #{id := binary(),
      query => get_balance_history_id_request_query(),
      header => get_balance_history_id_request_header(),
      cookie => get_balance_history_id_request_cookie(),
      body => {binary(), get_balance_history_id_request_body()}}.
-type get_balance_history_id_request_query() :: #{expand => [binary()]}.
-type get_balance_history_id_request_header() :: map().
-type get_balance_history_id_request_cookie() :: map().
-type get_balance_history_id_request_body() :: #{}.
-type get_balance_history_id_response() ::
    stripe_model:error() | stripe_model:balance_transaction().
-type post_payouts_payout_reverse_request() ::
    #{payout := binary(),
      query => post_payouts_payout_reverse_request_query(),
      header => post_payouts_payout_reverse_request_header(),
      cookie => post_payouts_payout_reverse_request_cookie(),
      body => {binary(), post_payouts_payout_reverse_request_body()}}.
-type post_payouts_payout_reverse_request_query() :: map().
-type post_payouts_payout_reverse_request_header() :: map().
-type post_payouts_payout_reverse_request_cookie() :: map().
-type post_payouts_payout_reverse_request_body() ::
    #{metadata => json:value(), expand => [binary()]}.
-type post_payouts_payout_reverse_response() ::
    stripe_model:error() | stripe_model:payout().
-type get_reporting_report_runs_report_run_request() ::
    #{report_run := binary(),
      query => get_reporting_report_runs_report_run_request_query(),
      header => get_reporting_report_runs_report_run_request_header(),
      cookie => get_reporting_report_runs_report_run_request_cookie(),
      body => {binary(), get_reporting_report_runs_report_run_request_body()}}.
-type get_reporting_report_runs_report_run_request_query() :: #{expand => [binary()]}.
-type get_reporting_report_runs_report_run_request_header() :: map().
-type get_reporting_report_runs_report_run_request_cookie() :: map().
-type get_reporting_report_runs_report_run_request_body() :: #{}.
-type get_reporting_report_runs_report_run_response() ::
    stripe_model:error() | stripe_model:reporting_report_run().
-type get_sources_source_source_transactions_source_transaction_request() ::
    #{source := binary(),
      source_transaction := binary(),
      query => get_sources_source_source_transactions_source_transaction_request_query(),
      header => get_sources_source_source_transactions_source_transaction_request_header(),
      cookie => get_sources_source_source_transactions_source_transaction_request_cookie(),
      body =>
          {binary(), get_sources_source_source_transactions_source_transaction_request_body()}}.
-type get_sources_source_source_transactions_source_transaction_request_query() ::
    #{expand => [binary()]}.
-type get_sources_source_source_transactions_source_transaction_request_header() :: map().
-type get_sources_source_source_transactions_source_transaction_request_cookie() :: map().
-type get_sources_source_source_transactions_source_transaction_request_body() :: #{}.
-type get_sources_source_source_transactions_source_transaction_response() ::
    stripe_model:error() | stripe_model:source_transaction().
-type delete_customers_customer_request() ::
    #{customer := binary(),
      query => delete_customers_customer_request_query(),
      header => delete_customers_customer_request_header(),
      cookie => delete_customers_customer_request_cookie(),
      body => {binary(), delete_customers_customer_request_body()}}.
-type delete_customers_customer_request_query() :: map().
-type delete_customers_customer_request_header() :: map().
-type delete_customers_customer_request_cookie() :: map().
-type delete_customers_customer_request_body() :: #{}.
-type delete_customers_customer_response() ::
    stripe_model:error() | stripe_model:deleted_customer().
-type post_customers_customer_request() ::
    #{customer := binary(),
      query => post_customers_customer_request_query(),
      header => post_customers_customer_request_header(),
      cookie => post_customers_customer_request_cookie(),
      body => {binary(), post_customers_customer_request_body()}}.
-type post_customers_customer_request_query() :: map().
-type post_customers_customer_request_header() :: map().
-type post_customers_customer_request_cookie() :: map().
-type post_customers_customer_request_body() ::
    #{trial_end => now | integer(),
      tax_exempt => '' | exempt | none | reverse,
      tax => #{ip_address => binary() | '', _ := json:value()},
      source => binary(),
      shipping =>
          #{phone => binary(),
            name := binary(),
            address :=
                #{state => binary(),
                  postal_code => binary(),
                  line2 => binary(),
                  line1 => binary(),
                  country => binary(),
                  city => binary(),
                  _ := json:value()},
            _ := json:value()} |
          '',
      promotion_code => binary(),
      preferred_locales => [binary()],
      phone => binary(),
      next_invoice_sequence => integer(),
      name => binary(),
      metadata => json:value() | '',
      invoice_settings =>
          #{footer => binary(),
            default_payment_method => binary(),
            custom_fields =>
                [#{value := binary(),
                   name := binary(),
                   _ := json:value()}] |
                '',
            _ := json:value()},
      invoice_prefix => binary(),
      expand => [binary()],
      email => binary(),
      description => binary(),
      default_source => binary(),
      default_card => binary(),
      default_bank_account => binary(),
      default_alipay_account => binary(),
      coupon => binary(),
      card =>
          #{object => card,
            number := binary(),
            name => binary(),
            metadata => json:value(),
            exp_year := integer(),
            exp_month := integer(),
            cvc => binary(),
            address_zip => binary(),
            address_state => binary(),
            address_line2 => binary(),
            address_line1 => binary(),
            address_country => binary(),
            address_city => binary(),
            _ := json:value()} |
          binary(),
      bank_account =>
          #{routing_number => binary(),
            object => bank_account,
            currency => binary(),
            country := binary(),
            account_number := binary(),
            account_holder_type => company | individual,
            account_holder_name => binary(),
            _ := json:value()} |
          binary(),
      balance => integer(),
      address =>
          #{state => binary(),
            postal_code => binary(),
            line2 => binary(),
            line1 => binary(),
            country => binary(),
            city => binary(),
            _ := json:value()} |
          ''}.
-type post_customers_customer_response() ::
    stripe_model:error() | stripe_model:customer().
-type get_customers_customer_request() ::
    #{customer := binary(),
      query => get_customers_customer_request_query(),
      header => get_customers_customer_request_header(),
      cookie => get_customers_customer_request_cookie(),
      body => {binary(), get_customers_customer_request_body()}}.
-type get_customers_customer_request_query() :: #{expand => [binary()]}.
-type get_customers_customer_request_header() :: map().
-type get_customers_customer_request_cookie() :: map().
-type get_customers_customer_request_body() :: #{}.
-type get_customers_customer_response() ::
    stripe_model:error() | stripe_model:customer() | stripe_model:deleted_customer().
-type post_billing_portal_sessions_request() ::
    #{query => post_billing_portal_sessions_request_query(),
      header => post_billing_portal_sessions_request_header(),
      cookie => post_billing_portal_sessions_request_cookie(),
      body := {binary(), post_billing_portal_sessions_request_body()}}.
-type post_billing_portal_sessions_request_query() :: map().
-type post_billing_portal_sessions_request_header() :: map().
-type post_billing_portal_sessions_request_cookie() :: map().
-type post_billing_portal_sessions_request_body() ::
    #{return_url => binary(),
      on_behalf_of => binary(),
      locale =>
          auto | bg | cs | da | de | el | en | 'en-AU' | 'en-CA' | 'en-GB' | 'en-IE' | 'en-IN' |
          'en-NZ' | 'en-SG' | es | 'es-419' | et | fi | fil | fr | 'fr-CA' | hr | hu | id | it |
          ja | ko | lt | lv | ms | mt | nb | nl | pl | pt | 'pt-BR' | ro | ru | sk | sl | sv | th |
          tr | vi | zh | 'zh-HK' | 'zh-TW',
      expand => [binary()],
      customer := binary(),
      configuration => binary()}.
-type post_billing_portal_sessions_response() ::
    stripe_model:error() | stripe_model:billing_portal_session().
-type post_payment_links_payment_link_request() ::
    #{payment_link := binary(),
      query => post_payment_links_payment_link_request_query(),
      header => post_payment_links_payment_link_request_header(),
      cookie => post_payment_links_payment_link_request_cookie(),
      body => {binary(), post_payment_links_payment_link_request_body()}}.
-type post_payment_links_payment_link_request_query() :: map().
-type post_payment_links_payment_link_request_header() :: map().
-type post_payment_links_payment_link_request_cookie() :: map().
-type post_payment_links_payment_link_request_body() ::
    #{shipping_address_collection =>
          #{allowed_countries :=
                ['AC' | 'AD' | 'AE' | 'AF' | 'AG' | 'AI' | 'AL' | 'AM' | 'AO' | 'AQ' | 'AR' | 'AT' |
                 'AU' | 'AW' | 'AX' | 'AZ' | 'BA' | 'BB' | 'BD' | 'BE' | 'BF' | 'BG' | 'BH' | 'BI' |
                 'BJ' | 'BL' | 'BM' | 'BN' | 'BO' | 'BQ' | 'BR' | 'BS' | 'BT' | 'BV' | 'BW' | 'BY' |
                 'BZ' | 'CA' | 'CD' | 'CF' | 'CG' | 'CH' | 'CI' | 'CK' | 'CL' | 'CM' | 'CN' | 'CO' |
                 'CR' | 'CV' | 'CW' | 'CY' | 'CZ' | 'DE' | 'DJ' | 'DK' | 'DM' | 'DO' | 'DZ' | 'EC' |
                 'EE' | 'EG' | 'EH' | 'ER' | 'ES' | 'ET' | 'FI' | 'FJ' | 'FK' | 'FO' | 'FR' | 'GA' |
                 'GB' | 'GD' | 'GE' | 'GF' | 'GG' | 'GH' | 'GI' | 'GL' | 'GM' | 'GN' | 'GP' | 'GQ' |
                 'GR' | 'GS' | 'GT' | 'GU' | 'GW' | 'GY' | 'HK' | 'HN' | 'HR' | 'HT' | 'HU' | 'ID' |
                 'IE' | 'IL' | 'IM' | 'IN' | 'IO' | 'IQ' | 'IS' | 'IT' | 'JE' | 'JM' | 'JO' | 'JP' |
                 'KE' | 'KG' | 'KH' | 'KI' | 'KM' | 'KN' | 'KR' | 'KW' | 'KY' | 'KZ' | 'LA' | 'LB' |
                 'LC' | 'LI' | 'LK' | 'LR' | 'LS' | 'LT' | 'LU' | 'LV' | 'LY' | 'MA' | 'MC' | 'MD' |
                 'ME' | 'MF' | 'MG' | 'MK' | 'ML' | 'MM' | 'MN' | 'MO' | 'MQ' | 'MR' | 'MS' | 'MT' |
                 'MU' | 'MV' | 'MW' | 'MX' | 'MY' | 'MZ' | 'NA' | 'NC' | 'NE' | 'NG' | 'NI' | 'NL' |
                 'NO' | 'NP' | 'NR' | 'NU' | 'NZ' | 'OM' | 'PA' | 'PE' | 'PF' | 'PG' | 'PH' | 'PK' |
                 'PL' | 'PM' | 'PN' | 'PR' | 'PS' | 'PT' | 'PY' | 'QA' | 'RE' | 'RO' | 'RS' | 'RU' |
                 'RW' | 'SA' | 'SB' | 'SC' | 'SE' | 'SG' | 'SH' | 'SI' | 'SJ' | 'SK' | 'SL' | 'SM' |
                 'SN' | 'SO' | 'SR' | 'SS' | 'ST' | 'SV' | 'SX' | 'SZ' | 'TA' | 'TC' | 'TD' | 'TF' |
                 'TG' | 'TH' | 'TJ' | 'TK' | 'TL' | 'TM' | 'TN' | 'TO' | 'TR' | 'TT' | 'TV' | 'TW' |
                 'TZ' | 'UA' | 'UG' | 'US' | 'UY' | 'UZ' | 'VA' | 'VC' | 'VE' | 'VG' | 'VN' | 'VU' |
                 'WF' | 'WS' | 'XK' | 'YE' | 'YT' | 'ZA' | 'ZM' | 'ZW' | 'ZZ'],
            _ := json:value()} |
          '',
      payment_method_types => [card] | '',
      metadata => json:value(),
      line_items =>
          [#{quantity => integer(),
             id := binary(),
             adjustable_quantity =>
                 #{minimum => integer(),
                   maximum => integer(),
                   enabled := boolean(),
                   _ := json:value()},
             _ := json:value()}],
      expand => [binary()],
      billing_address_collection => auto | required,
      automatic_tax => #{enabled := boolean(), _ := json:value()},
      allow_promotion_codes => boolean(),
      after_completion =>
          #{type := hosted_confirmation | redirect,
            redirect => #{url := binary(), _ := json:value()},
            hosted_confirmation => #{custom_message => binary(), _ := json:value()},
            _ := json:value()},
      active => boolean()}.
-type post_payment_links_payment_link_response() ::
    stripe_model:error() | stripe_model:payment_link().
-type get_payment_links_payment_link_request() ::
    #{payment_link := binary(),
      query => get_payment_links_payment_link_request_query(),
      header => get_payment_links_payment_link_request_header(),
      cookie => get_payment_links_payment_link_request_cookie(),
      body => {binary(), get_payment_links_payment_link_request_body()}}.
-type get_payment_links_payment_link_request_query() :: #{expand => [binary()]}.
-type get_payment_links_payment_link_request_header() :: map().
-type get_payment_links_payment_link_request_cookie() :: map().
-type get_payment_links_payment_link_request_body() :: #{}.
-type get_payment_links_payment_link_response() ::
    stripe_model:error() | stripe_model:payment_link().
-type get_credit_notes_credit_note_lines_request() ::
    #{credit_note := binary(),
      query => get_credit_notes_credit_note_lines_request_query(),
      header => get_credit_notes_credit_note_lines_request_header(),
      cookie => get_credit_notes_credit_note_lines_request_cookie(),
      body => {binary(), get_credit_notes_credit_note_lines_request_body()}}.
-type get_credit_notes_credit_note_lines_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_credit_notes_credit_note_lines_request_header() :: map().
-type get_credit_notes_credit_note_lines_request_cookie() :: map().
-type get_credit_notes_credit_note_lines_request_body() :: #{}.
-type get_credit_notes_credit_note_lines_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:credit_note_line_item()],
      _ := json:value()}.
-type get_sigma_scheduled_query_runs_request() ::
    #{query => get_sigma_scheduled_query_runs_request_query(),
      header => get_sigma_scheduled_query_runs_request_header(),
      cookie => get_sigma_scheduled_query_runs_request_cookie(),
      body => {binary(), get_sigma_scheduled_query_runs_request_body()}}.
-type get_sigma_scheduled_query_runs_request_query() ::
    #{ending_before => binary(),
      expand => [binary()],
      limit => integer(),
      starting_after => binary()}.
-type get_sigma_scheduled_query_runs_request_header() :: map().
-type get_sigma_scheduled_query_runs_request_cookie() :: map().
-type get_sigma_scheduled_query_runs_request_body() :: #{}.
-type get_sigma_scheduled_query_runs_response() ::
    stripe_model:error() |
    #{url := binary(),
      object := list,
      has_more := boolean(),
      data := [stripe_model:scheduled_query_run()],
      _ := json:value()}.

-spec get_radar_early_fraud_warnings(get_radar_early_fraud_warnings_request()) ->
                                        result(get_radar_early_fraud_warnings_response()).
get_radar_early_fraud_warnings(Args) ->
    get_radar_early_fraud_warnings(Args, #{}).

-spec get_radar_early_fraud_warnings(get_radar_early_fraud_warnings_request(),
                                     options()) ->
                                        result(get_radar_early_fraud_warnings_response()).
get_radar_early_fraud_warnings(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             radar_early_fraud_warning}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_charges_charge_refunds(post_charges_charge_refunds_request()) ->
                                     result(post_charges_charge_refunds_response()).
post_charges_charge_refunds(Args) ->
    post_charges_charge_refunds(Args, #{}).

-spec post_charges_charge_refunds(post_charges_charge_refunds_request(), options()) ->
                                     result(post_charges_charge_refunds_response()).
post_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refunds", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, refund},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_charges_charge_refunds(get_charges_charge_refunds_request()) ->
                                    result(get_charges_charge_refunds_response()).
get_charges_charge_refunds(Args) ->
    get_charges_charge_refunds(Args, #{}).

-spec get_charges_charge_refunds(get_charges_charge_refunds_request(), options()) ->
                                    result(get_charges_charge_refunds_response()).
get_charges_charge_refunds(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refunds", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, refund}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_identity_verification_sessions_session_redact(post_identity_verification_sessions_session_redact_request()) ->
                                                          result(post_identity_verification_sessions_session_redact_response()).
post_identity_verification_sessions_session_redact(Args) ->
    post_identity_verification_sessions_session_redact(Args, #{}).

-spec
    post_identity_verification_sessions_session_redact(post_identity_verification_sessions_session_redact_request(),
                                                       options()) ->
                                                          result(post_identity_verification_sessions_session_redact_response()).
post_identity_verification_sessions_session_redact(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s/redact", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref,
                                                         stripe,
                                                         identity_verification_session},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_billing_portal_configurations_configuration(post_billing_portal_configurations_configuration_request()) ->
                                                        result(post_billing_portal_configurations_configuration_response()).
post_billing_portal_configurations_configuration(Args) ->
    post_billing_portal_configurations_configuration(Args, #{}).

-spec
    post_billing_portal_configurations_configuration(post_billing_portal_configurations_configuration_request(),
                                                     options()) ->
                                                        result(post_billing_portal_configurations_configuration_response()).
post_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/configurations/~s", [VarConfiguration]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, billing_portal_configuration},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_billing_portal_configurations_configuration(get_billing_portal_configurations_configuration_request()) ->
                                                       result(get_billing_portal_configurations_configuration_response()).
get_billing_portal_configurations_configuration(Args) ->
    get_billing_portal_configurations_configuration(Args, #{}).

-spec
    get_billing_portal_configurations_configuration(get_billing_portal_configurations_configuration_request(),
                                                    options()) ->
                                                       result(get_billing_portal_configurations_configuration_response()).
get_billing_portal_configurations_configuration(Args, Options) ->
    VarConfiguration = maps:get(configuration, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/configurations/~s", [VarConfiguration]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, billing_portal_configuration},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payment_methods(post_payment_methods_request()) ->
                              result(post_payment_methods_response()).
post_payment_methods(Args) ->
    post_payment_methods(Args, #{}).

-spec post_payment_methods(post_payment_methods_request(), options()) ->
                              result(post_payment_methods_response()).
post_payment_methods(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_method},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_payment_methods(get_payment_methods_request()) ->
                             result(get_payment_methods_response()).
get_payment_methods(Args) ->
    get_payment_methods(Args, #{}).

-spec get_payment_methods(get_payment_methods_request(), options()) ->
                             result(get_payment_methods_response()).
get_payment_methods(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             payment_method}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_radar_value_lists_value_list(delete_radar_value_lists_value_list_request()) ->
                                           result(delete_radar_value_lists_value_list_response()).
delete_radar_value_lists_value_list(Args) ->
    delete_radar_value_lists_value_list(Args, #{}).

-spec delete_radar_value_lists_value_list(delete_radar_value_lists_value_list_request(),
                                          options()) ->
                                             result(delete_radar_value_lists_value_list_response()).
delete_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, deleted_radar_value_list},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_radar_value_lists_value_list(post_radar_value_lists_value_list_request()) ->
                                           result(post_radar_value_lists_value_list_response()).
post_radar_value_lists_value_list(Args) ->
    post_radar_value_lists_value_list(Args, #{}).

-spec post_radar_value_lists_value_list(post_radar_value_lists_value_list_request(),
                                        options()) ->
                                           result(post_radar_value_lists_value_list_response()).
post_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, radar_value_list},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_radar_value_lists_value_list(get_radar_value_lists_value_list_request()) ->
                                          result(get_radar_value_lists_value_list_response()).
get_radar_value_lists_value_list(Args) ->
    get_radar_value_lists_value_list(Args, #{}).

-spec get_radar_value_lists_value_list(get_radar_value_lists_value_list_request(),
                                       options()) ->
                                          result(get_radar_value_lists_value_list_response()).
get_radar_value_lists_value_list(Args, Options) ->
    VarValueList = maps:get(value_list, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists/~s", [VarValueList]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, radar_value_list},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_charges_charge_capture(post_charges_charge_capture_request()) ->
                                     result(post_charges_charge_capture_response()).
post_charges_charge_capture(Args) ->
    post_charges_charge_capture(Args, #{}).

-spec post_charges_charge_capture(post_charges_charge_capture_request(), options()) ->
                                     result(post_charges_charge_capture_response()).
post_charges_charge_capture(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/capture", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, charge},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_disputes(get_disputes_request()) -> result(get_disputes_response()).
get_disputes(Args) ->
    get_disputes(Args, #{}).

-spec get_disputes(get_disputes_request(), options()) -> result(get_disputes_response()).
get_disputes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/disputes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             dispute}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_prices_price(post_prices_price_request()) ->
                           result(post_prices_price_response()).
post_prices_price(Args) ->
    post_prices_price(Args, #{}).

-spec post_prices_price(post_prices_price_request(), options()) ->
                           result(post_prices_price_response()).
post_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/prices/~s", [VarPrice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, price},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_prices_price(get_prices_price_request()) -> result(get_prices_price_response()).
get_prices_price(Args) ->
    get_prices_price(Args, #{}).

-spec get_prices_price(get_prices_price_request(), options()) ->
                          result(get_prices_price_response()).
get_prices_price(Args, Options) ->
    VarPrice = maps:get(price, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/prices/~s", [VarPrice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, price},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_accounts(post_accounts_request()) -> result(post_accounts_response()).
post_accounts(Args) ->
    post_accounts(Args, #{}).

-spec post_accounts(post_accounts_request(), options()) ->
                       result(post_accounts_response()).
post_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_accounts(get_accounts_request()) -> result(get_accounts_response()).
get_accounts(Args) ->
    get_accounts(Args, #{}).

-spec get_accounts(get_accounts_request(), options()) -> result(get_accounts_response()).
get_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             account}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_identity_verification_sessions_session_cancel(post_identity_verification_sessions_session_cancel_request()) ->
                                                          result(post_identity_verification_sessions_session_cancel_response()).
post_identity_verification_sessions_session_cancel(Args) ->
    post_identity_verification_sessions_session_cancel(Args, #{}).

-spec
    post_identity_verification_sessions_session_cancel(post_identity_verification_sessions_session_cancel_request(),
                                                       options()) ->
                                                          result(post_identity_verification_sessions_session_cancel_response()).
post_identity_verification_sessions_session_cancel(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s/cancel", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref,
                                                         stripe,
                                                         identity_verification_session},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_account_persons_person(delete_account_persons_person_request()) ->
                                       result(delete_account_persons_person_response()).
delete_account_persons_person(Args) ->
    delete_account_persons_person(Args, #{}).

-spec delete_account_persons_person(delete_account_persons_person_request(), options()) ->
                                       result(delete_account_persons_person_response()).
delete_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_persons_person(post_account_persons_person_request()) ->
                                     result(post_account_persons_person_response()).
post_account_persons_person(Args) ->
    post_account_persons_person(Args, #{}).

-spec post_account_persons_person(post_account_persons_person_request(), options()) ->
                                     result(post_account_persons_person_response()).
post_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_account_persons_person(get_account_persons_person_request()) ->
                                    result(get_account_persons_person_response()).
get_account_persons_person(Args) ->
    get_account_persons_person(Args, #{}).

-spec get_account_persons_person(get_account_persons_person_request(), options()) ->
                                    result(get_account_persons_person_response()).
get_account_persons_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_issuing_authorizations_authorization(post_issuing_authorizations_authorization_request()) ->
                                                 result(post_issuing_authorizations_authorization_response()).
post_issuing_authorizations_authorization(Args) ->
    post_issuing_authorizations_authorization(Args, #{}).

-spec
    post_issuing_authorizations_authorization(post_issuing_authorizations_authorization_request(),
                                              options()) ->
                                                 result(post_issuing_authorizations_authorization_response()).
post_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s", [VarAuthorization]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_authorization},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_issuing_authorizations_authorization(get_issuing_authorizations_authorization_request()) ->
                                                result(get_issuing_authorizations_authorization_response()).
get_issuing_authorizations_authorization(Args) ->
    get_issuing_authorizations_authorization(Args, #{}).

-spec
    get_issuing_authorizations_authorization(get_issuing_authorizations_authorization_request(),
                                             options()) ->
                                                result(get_issuing_authorizations_authorization_response()).
get_issuing_authorizations_authorization(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s", [VarAuthorization]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_authorization},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_files_file(get_files_file_request()) -> result(get_files_file_response()).
get_files_file(Args) ->
    get_files_file(Args, #{}).

-spec get_files_file(get_files_file_request(), options()) ->
                        result(get_files_file_response()).
get_files_file(Args, Options) ->
    VarFile = maps:get(file, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/files/~s", [VarFile]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, file},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_issuing_cards_card(post_issuing_cards_card_request()) ->
                                 result(post_issuing_cards_card_response()).
post_issuing_cards_card(Args) ->
    post_issuing_cards_card(Args, #{}).

-spec post_issuing_cards_card(post_issuing_cards_card_request(), options()) ->
                                 result(post_issuing_cards_card_response()).
post_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cards/~s", [VarCard]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_card},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_cards_card(get_issuing_cards_card_request()) ->
                                result(get_issuing_cards_card_response()).
get_issuing_cards_card(Args) ->
    get_issuing_cards_card(Args, #{}).

-spec get_issuing_cards_card(get_issuing_cards_card_request(), options()) ->
                                result(get_issuing_cards_card_response()).
get_issuing_cards_card(Args, Options) ->
    VarCard = maps:get(card, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cards/~s", [VarCard]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_card},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_sources_source_verify(post_sources_source_verify_request()) ->
                                    result(post_sources_source_verify_response()).
post_sources_source_verify(Args) ->
    post_sources_source_verify(Args, #{}).

-spec post_sources_source_verify(post_sources_source_verify_request(), options()) ->
                                    result(post_sources_source_verify_response()).
post_sources_source_verify(Args, Options) ->
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources/~s/verify", [VarSource]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, source},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_invoiceitems(post_invoiceitems_request()) ->
                           result(post_invoiceitems_response()).
post_invoiceitems(Args) ->
    post_invoiceitems(Args, #{}).

-spec post_invoiceitems(post_invoiceitems_request(), options()) ->
                           result(post_invoiceitems_response()).
post_invoiceitems(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoiceitem},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_invoiceitems(get_invoiceitems_request()) -> result(get_invoiceitems_response()).
get_invoiceitems(Args) ->
    get_invoiceitems(Args, #{}).

-spec get_invoiceitems(get_invoiceitems_request(), options()) ->
                          result(get_invoiceitems_response()).
get_invoiceitems(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({pending, Value}) ->
                encode_q(form, false, <<"pending">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             invoiceitem}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_ephemeral_keys_key(delete_ephemeral_keys_key_request()) ->
                                   result(delete_ephemeral_keys_key_response()).
delete_ephemeral_keys_key(Args) ->
    delete_ephemeral_keys_key(Args, #{}).

-spec delete_ephemeral_keys_key(delete_ephemeral_keys_key_request(), options()) ->
                                   result(delete_ephemeral_keys_key_response()).
delete_ephemeral_keys_key(Args, Options) ->
    VarKey = maps:get(key, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/ephemeral_keys/~s", [VarKey]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, ephemeral_key},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_exchange_rates(get_exchange_rates_request()) ->
                            result(get_exchange_rates_response()).
get_exchange_rates(Args) ->
    get_exchange_rates(Args, #{}).

-spec get_exchange_rates(get_exchange_rates_request(), options()) ->
                            result(get_exchange_rates_response()).
get_exchange_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/exchange_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             exchange_rate}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_setup_intents_intent(post_setup_intents_intent_request()) ->
                                   result(post_setup_intents_intent_response()).
post_setup_intents_intent(Args) ->
    post_setup_intents_intent(Args, #{}).

-spec post_setup_intents_intent(post_setup_intents_intent_request(), options()) ->
                                   result(post_setup_intents_intent_response()).
post_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, setup_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_setup_intents_intent(get_setup_intents_intent_request()) ->
                                  result(get_setup_intents_intent_response()).
get_setup_intents_intent(Args) ->
    get_setup_intents_intent(Args, #{}).

-spec get_setup_intents_intent(get_setup_intents_intent_request(), options()) ->
                                  result(get_setup_intents_intent_response()).
get_setup_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({client_secret, Value}) ->
                encode_q(form, false, <<"client_secret">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, setup_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_files(post_files_request()) -> result(post_files_response()).
post_files(Args) ->
    post_files(Args, #{}).

-spec post_files(post_files_request(), options()) -> result(post_files_response()).
post_files(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/files", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, file},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_files(get_files_request()) -> result(get_files_response()).
get_files(Args) ->
    get_files(Args, #{}).

-spec get_files(get_files_request(), options()) -> result(get_files_response()).
get_files(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({purpose, Value}) ->
                encode_q(form, false, <<"purpose">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/files", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, file}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_customers_customer_bank_accounts_id(delete_customers_customer_bank_accounts_id_request()) ->
                                                  result(delete_customers_customer_bank_accounts_id_response()).
delete_customers_customer_bank_accounts_id(Args) ->
    delete_customers_customer_bank_accounts_id(Args, #{}).

-spec
    delete_customers_customer_bank_accounts_id(delete_customers_customer_bank_accounts_id_request(),
                                               options()) ->
                                                  result(delete_customers_customer_bank_accounts_id_response()).
delete_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, payment_source},
                                                          {ref, stripe, deleted_payment_source}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_customers_customer_bank_accounts_id(post_customers_customer_bank_accounts_id_request()) ->
                                                result(post_customers_customer_bank_accounts_id_response()).
post_customers_customer_bank_accounts_id(Args) ->
    post_customers_customer_bank_accounts_id(Args, #{}).

-spec
    post_customers_customer_bank_accounts_id(post_customers_customer_bank_accounts_id_request(),
                                             options()) ->
                                                result(post_customers_customer_bank_accounts_id_response()).
post_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, card},
                                                          {ref, stripe, bank_account},
                                                          {ref, stripe, source}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_customers_customer_bank_accounts_id(get_customers_customer_bank_accounts_id_request()) ->
                                               result(get_customers_customer_bank_accounts_id_response()).
get_customers_customer_bank_accounts_id(Args) ->
    get_customers_customer_bank_accounts_id(Args, #{}).

-spec
    get_customers_customer_bank_accounts_id(get_customers_customer_bank_accounts_id_request(),
                                            options()) ->
                                               result(get_customers_customer_bank_accounts_id_response()).
get_customers_customer_bank_accounts_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, bank_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_issuer_fraud_records_issuer_fraud_record(get_issuer_fraud_records_issuer_fraud_record_request()) ->
                                                    result(get_issuer_fraud_records_issuer_fraud_record_response()).
get_issuer_fraud_records_issuer_fraud_record(Args) ->
    get_issuer_fraud_records_issuer_fraud_record(Args, #{}).

-spec
    get_issuer_fraud_records_issuer_fraud_record(get_issuer_fraud_records_issuer_fraud_record_request(),
                                                 options()) ->
                                                    result(get_issuer_fraud_records_issuer_fraud_record_response()).
get_issuer_fraud_records_issuer_fraud_record(Args, Options) ->
    VarIssuerFraudRecord = maps:get(issuer_fraud_record, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuer_fraud_records/~s", [VarIssuerFraudRecord]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuer_fraud_record},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_accounts_account_people_person(delete_accounts_account_people_person_request()) ->
                                             result(delete_accounts_account_people_person_response()).
delete_accounts_account_people_person(Args) ->
    delete_accounts_account_people_person(Args, #{}).

-spec
    delete_accounts_account_people_person(delete_accounts_account_people_person_request(),
                                          options()) ->
                                             result(delete_accounts_account_people_person_response()).
delete_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_accounts_account_people_person(post_accounts_account_people_person_request()) ->
                                           result(post_accounts_account_people_person_response()).
post_accounts_account_people_person(Args) ->
    post_accounts_account_people_person(Args, #{}).

-spec post_accounts_account_people_person(post_accounts_account_people_person_request(),
                                          options()) ->
                                             result(post_accounts_account_people_person_response()).
post_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_accounts_account_people_person(get_accounts_account_people_person_request()) ->
                                            result(get_accounts_account_people_person_response()).
get_accounts_account_people_person(Args) ->
    get_accounts_account_people_person(Args, #{}).

-spec get_accounts_account_people_person(get_accounts_account_people_person_request(),
                                         options()) ->
                                            result(get_accounts_account_people_person_response()).
get_accounts_account_people_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payouts(post_payouts_request()) -> result(post_payouts_response()).
post_payouts(Args) ->
    post_payouts(Args, #{}).

-spec post_payouts(post_payouts_request(), options()) -> result(post_payouts_response()).
post_payouts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payout},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_payouts(get_payouts_request()) -> result(get_payouts_response()).
get_payouts(Args) ->
    get_payouts(Args, #{}).

-spec get_payouts(get_payouts_request(), options()) -> result(get_payouts_response()).
get_payouts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({arrival_date, Value}) ->
                encode_q(deepObject, true, <<"arrival_date">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({destination, Value}) ->
                encode_q(form, false, <<"destination">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, payout}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_account_capabilities_capability(post_account_capabilities_capability_request()) ->
                                            result(post_account_capabilities_capability_response()).
post_account_capabilities_capability(Args) ->
    post_account_capabilities_capability(Args, #{}).

-spec post_account_capabilities_capability(post_account_capabilities_capability_request(),
                                           options()) ->
                                              result(post_account_capabilities_capability_response()).
post_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/capabilities/~s", [VarCapability]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, capability},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_account_capabilities_capability(get_account_capabilities_capability_request()) ->
                                           result(get_account_capabilities_capability_response()).
get_account_capabilities_capability(Args) ->
    get_account_capabilities_capability(Args, #{}).

-spec get_account_capabilities_capability(get_account_capabilities_capability_request(),
                                          options()) ->
                                             result(get_account_capabilities_capability_response()).
get_account_capabilities_capability(Args, Options) ->
    VarCapability = maps:get(capability, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/capabilities/~s", [VarCapability]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, capability},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_sources_source_mandate_notifications_mandate_notification(get_sources_source_mandate_notifications_mandate_notification_request()) ->
                                                                     result(get_sources_source_mandate_notifications_mandate_notification_response()).
get_sources_source_mandate_notifications_mandate_notification(Args) ->
    get_sources_source_mandate_notifications_mandate_notification(Args, #{}).

-spec
    get_sources_source_mandate_notifications_mandate_notification(get_sources_source_mandate_notifications_mandate_notification_request(),
                                                                  options()) ->
                                                                     result(get_sources_source_mandate_notifications_mandate_notification_response()).
get_sources_source_mandate_notifications_mandate_notification(Args, Options) ->
    VarMandateNotification = maps:get(mandate_notification, Args),
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/sources/~s/mandate_notifications/~s",
                      [VarSource, VarMandateNotification]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, source_mandate_notification},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_application_fees_fee_refunds_id(post_application_fees_fee_refunds_id_request()) ->
                                            result(post_application_fees_fee_refunds_id_response()).
post_application_fees_fee_refunds_id(Args) ->
    post_application_fees_fee_refunds_id(Args, #{}).

-spec post_application_fees_fee_refunds_id(post_application_fees_fee_refunds_id_request(),
                                           options()) ->
                                              result(post_application_fees_fee_refunds_id_response()).
post_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds/~s", [VarFee, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, fee_refund},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_application_fees_fee_refunds_id(get_application_fees_fee_refunds_id_request()) ->
                                           result(get_application_fees_fee_refunds_id_response()).
get_application_fees_fee_refunds_id(Args) ->
    get_application_fees_fee_refunds_id(Args, #{}).

-spec get_application_fees_fee_refunds_id(get_application_fees_fee_refunds_id_request(),
                                          options()) ->
                                             result(get_application_fees_fee_refunds_id_response()).
get_application_fees_fee_refunds_id(Args, Options) ->
    VarFee = maps:get(fee, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds/~s", [VarFee, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, fee_refund},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_customers_customer_discount(delete_customers_customer_discount_request()) ->
                                            result(delete_customers_customer_discount_response()).
delete_customers_customer_discount(Args) ->
    delete_customers_customer_discount(Args, #{}).

-spec delete_customers_customer_discount(delete_customers_customer_discount_request(),
                                         options()) ->
                                            result(delete_customers_customer_discount_response()).
delete_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/discount", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_discount},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_customers_customer_discount(get_customers_customer_discount_request()) ->
                                         result(get_customers_customer_discount_response()).
get_customers_customer_discount(Args) ->
    get_customers_customer_discount(Args, #{}).

-spec get_customers_customer_discount(get_customers_customer_discount_request(),
                                      options()) ->
                                         result(get_customers_customer_discount_response()).
get_customers_customer_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/discount", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, discount},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_coupons(post_coupons_request()) -> result(post_coupons_response()).
post_coupons(Args) ->
    post_coupons(Args, #{}).

-spec post_coupons(post_coupons_request(), options()) -> result(post_coupons_response()).
post_coupons(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, coupon},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_coupons(get_coupons_request()) -> result(get_coupons_response()).
get_coupons(Args) ->
    get_coupons(Args, #{}).

-spec get_coupons(get_coupons_request(), options()) -> result(get_coupons_response()).
get_coupons(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, coupon}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_charges_charge_dispute_close(post_charges_charge_dispute_close_request()) ->
                                           result(post_charges_charge_dispute_close_response()).
post_charges_charge_dispute_close(Args) ->
    post_charges_charge_dispute_close(Args, #{}).

-spec post_charges_charge_dispute_close(post_charges_charge_dispute_close_request(),
                                        options()) ->
                                           result(post_charges_charge_dispute_close_response()).
post_charges_charge_dispute_close(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/dispute/close", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_plans_plan(delete_plans_plan_request()) ->
                           result(delete_plans_plan_response()).
delete_plans_plan(Args) ->
    delete_plans_plan(Args, #{}).

-spec delete_plans_plan(delete_plans_plan_request(), options()) ->
                           result(delete_plans_plan_response()).
delete_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_plan},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_plans_plan(post_plans_plan_request()) -> result(post_plans_plan_response()).
post_plans_plan(Args) ->
    post_plans_plan(Args, #{}).

-spec post_plans_plan(post_plans_plan_request(), options()) ->
                         result(post_plans_plan_response()).
post_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, plan},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_plans_plan(get_plans_plan_request()) -> result(get_plans_plan_response()).
get_plans_plan(Args) ->
    get_plans_plan(Args, #{}).

-spec get_plans_plan(get_plans_plan_request(), options()) ->
                        result(get_plans_plan_response()).
get_plans_plan(Args, Options) ->
    VarPlan = maps:get(plan, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans/~s", [VarPlan]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, plan},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_customers_customer_bank_accounts(post_customers_customer_bank_accounts_request()) ->
                                             result(post_customers_customer_bank_accounts_response()).
post_customers_customer_bank_accounts(Args) ->
    post_customers_customer_bank_accounts(Args, #{}).

-spec
    post_customers_customer_bank_accounts(post_customers_customer_bank_accounts_request(),
                                          options()) ->
                                             result(post_customers_customer_bank_accounts_response()).
post_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_source},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_customers_customer_bank_accounts(get_customers_customer_bank_accounts_request()) ->
                                            result(get_customers_customer_bank_accounts_response()).
get_customers_customer_bank_accounts(Args) ->
    get_customers_customer_bank_accounts(Args, #{}).

-spec get_customers_customer_bank_accounts(get_customers_customer_bank_accounts_request(),
                                           options()) ->
                                              result(get_customers_customer_bank_accounts_response()).
get_customers_customer_bank_accounts(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             bank_account}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_terminal_readers_reader(delete_terminal_readers_reader_request()) ->
                                        result(delete_terminal_readers_reader_response()).
delete_terminal_readers_reader(Args) ->
    delete_terminal_readers_reader(Args, #{}).

-spec delete_terminal_readers_reader(delete_terminal_readers_reader_request(),
                                     options()) ->
                                        result(delete_terminal_readers_reader_response()).
delete_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_terminal_reader},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_terminal_readers_reader(post_terminal_readers_reader_request()) ->
                                      result(post_terminal_readers_reader_response()).
post_terminal_readers_reader(Args) ->
    post_terminal_readers_reader(Args, #{}).

-spec post_terminal_readers_reader(post_terminal_readers_reader_request(), options()) ->
                                      result(post_terminal_readers_reader_response()).
post_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, terminal_reader},
                                                          {ref, stripe, deleted_terminal_reader}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_terminal_readers_reader(get_terminal_readers_reader_request()) ->
                                     result(get_terminal_readers_reader_response()).
get_terminal_readers_reader(Args) ->
    get_terminal_readers_reader(Args, #{}).

-spec get_terminal_readers_reader(get_terminal_readers_reader_request(), options()) ->
                                     result(get_terminal_readers_reader_response()).
get_terminal_readers_reader(Args, Options) ->
    VarReader = maps:get(reader, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers/~s", [VarReader]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, terminal_reader},
                                                          {ref, stripe, deleted_terminal_reader}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_accounts_account_persons_person(delete_accounts_account_persons_person_request()) ->
                                              result(delete_accounts_account_persons_person_response()).
delete_accounts_account_persons_person(Args) ->
    delete_accounts_account_persons_person(Args, #{}).

-spec
    delete_accounts_account_persons_person(delete_accounts_account_persons_person_request(),
                                           options()) ->
                                              result(delete_accounts_account_persons_person_response()).
delete_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_accounts_account_persons_person(post_accounts_account_persons_person_request()) ->
                                            result(post_accounts_account_persons_person_response()).
post_accounts_account_persons_person(Args) ->
    post_accounts_account_persons_person(Args, #{}).

-spec post_accounts_account_persons_person(post_accounts_account_persons_person_request(),
                                           options()) ->
                                              result(post_accounts_account_persons_person_response()).
post_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_accounts_account_persons_person(get_accounts_account_persons_person_request()) ->
                                           result(get_accounts_account_persons_person_response()).
get_accounts_account_persons_person(Args) ->
    get_accounts_account_persons_person(Args, #{}).

-spec get_accounts_account_persons_person(get_accounts_account_persons_person_request(),
                                          options()) ->
                                             result(get_accounts_account_persons_person_response()).
get_accounts_account_persons_person(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons/~s", [VarAccount, VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_credit_notes_id_void(post_credit_notes_id_void_request()) ->
                                   result(post_credit_notes_id_void_response()).
post_credit_notes_id_void(Args) ->
    post_credit_notes_id_void(Args, #{}).

-spec post_credit_notes_id_void(post_credit_notes_id_void_request(), options()) ->
                                   result(post_credit_notes_id_void_response()).
post_credit_notes_id_void(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/~s/void", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, credit_note},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_customers_customer_sources(post_customers_customer_sources_request()) ->
                                         result(post_customers_customer_sources_response()).
post_customers_customer_sources(Args) ->
    post_customers_customer_sources(Args, #{}).

-spec post_customers_customer_sources(post_customers_customer_sources_request(),
                                      options()) ->
                                         result(post_customers_customer_sources_response()).
post_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_source},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_customers_customer_sources(get_customers_customer_sources_request()) ->
                                        result(get_customers_customer_sources_response()).
get_customers_customer_sources(Args) ->
    get_customers_customer_sources(Args, #{}).

-spec get_customers_customer_sources(get_customers_customer_sources_request(),
                                     options()) ->
                                        result(get_customers_customer_sources_response()).
get_customers_customer_sources(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({object, Value}) ->
                encode_q(form, false, <<"object">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {one_of,
                                                                             [{ref,
                                                                               stripe,
                                                                               alipay_account},
                                                                              {ref,
                                                                               stripe,
                                                                               bank_account},
                                                                              {ref,
                                                                               stripe,
                                                                               bitcoin_receiver},
                                                                              {ref, stripe, card},
                                                                              {ref,
                                                                               stripe,
                                                                               source}]}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_links(post_account_links_request()) ->
                            result(post_account_links_response()).
post_account_links(Args) ->
    post_account_links(Args, #{}).

-spec post_account_links(post_account_links_request(), options()) ->
                            result(post_account_links_response()).
post_account_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, account_link},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payouts_payout(post_payouts_payout_request()) ->
                             result(post_payouts_payout_response()).
post_payouts_payout(Args) ->
    post_payouts_payout(Args, #{}).

-spec post_payouts_payout(post_payouts_payout_request(), options()) ->
                             result(post_payouts_payout_response()).
post_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts/~s", [VarPayout]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payout},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_payouts_payout(get_payouts_payout_request()) ->
                            result(get_payouts_payout_response()).
get_payouts_payout(Args) ->
    get_payouts_payout(Args, #{}).

-spec get_payouts_payout(get_payouts_payout_request(), options()) ->
                            result(get_payouts_payout_response()).
get_payouts_payout(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts/~s", [VarPayout]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payout},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_subscription_items_item(delete_subscription_items_item_request()) ->
                                        result(delete_subscription_items_item_response()).
delete_subscription_items_item(Args) ->
    delete_subscription_items_item(Args, #{}).

-spec delete_subscription_items_item(delete_subscription_items_item_request(),
                                     options()) ->
                                        result(delete_subscription_items_item_response()).
delete_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, deleted_subscription_item},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_subscription_items_item(post_subscription_items_item_request()) ->
                                      result(post_subscription_items_item_response()).
post_subscription_items_item(Args) ->
    post_subscription_items_item(Args, #{}).

-spec post_subscription_items_item(post_subscription_items_item_request(), options()) ->
                                      result(post_subscription_items_item_response()).
post_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription_item},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_subscription_items_item(get_subscription_items_item_request()) ->
                                     result(get_subscription_items_item_response()).
get_subscription_items_item(Args) ->
    get_subscription_items_item(Args, #{}).

-spec get_subscription_items_item(get_subscription_items_item_request(), options()) ->
                                     result(get_subscription_items_item_response()).
get_subscription_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription_item},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_products(post_products_request()) -> result(post_products_response()).
post_products(Args) ->
    post_products(Args, #{}).

-spec post_products(post_products_request(), options()) ->
                       result(post_products_response()).
post_products(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, product},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_products(get_products_request()) -> result(get_products_response()).
get_products(Args) ->
    get_products(Args, #{}).

-spec get_products(get_products_request(), options()) -> result(get_products_response()).
get_products(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({ids, Value}) ->
                encode_q(deepObject, true, <<"ids">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({shippable, Value}) ->
                encode_q(form, false, <<"shippable">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({url, Value}) ->
                encode_q(form, false, <<"url">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             product}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_reporting_report_types_report_type(get_reporting_report_types_report_type_request()) ->
                                              result(get_reporting_report_types_report_type_response()).
get_reporting_report_types_report_type(Args) ->
    get_reporting_report_types_report_type(Args, #{}).

-spec
    get_reporting_report_types_report_type(get_reporting_report_types_report_type_request(),
                                           options()) ->
                                              result(get_reporting_report_types_report_type_response()).
get_reporting_report_types_report_type(Args, Options) ->
    VarReportType = maps:get(report_type, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_types/~s", [VarReportType]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, reporting_report_type},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_quotes_quote_accept(post_quotes_quote_accept_request()) ->
                                  result(post_quotes_quote_accept_response()).
post_quotes_quote_accept(Args) ->
    post_quotes_quote_accept(Args, #{}).

-spec post_quotes_quote_accept(post_quotes_quote_accept_request(), options()) ->
                                  result(post_quotes_quote_accept_response()).
post_quotes_quote_accept(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/accept", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, quote},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_mandates_mandate(get_mandates_mandate_request()) ->
                              result(get_mandates_mandate_response()).
get_mandates_mandate(Args) ->
    get_mandates_mandate(Args, #{}).

-spec get_mandates_mandate(get_mandates_mandate_request(), options()) ->
                              result(get_mandates_mandate_response()).
get_mandates_mandate(Args, Options) ->
    VarMandate = maps:get(mandate, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/mandates/~s", [VarMandate]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, mandate},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_customers_customer_subscriptions(post_customers_customer_subscriptions_request()) ->
                                             result(post_customers_customer_subscriptions_response()).
post_customers_customer_subscriptions(Args) ->
    post_customers_customer_subscriptions(Args, #{}).

-spec
    post_customers_customer_subscriptions(post_customers_customer_subscriptions_request(),
                                          options()) ->
                                             result(post_customers_customer_subscriptions_response()).
post_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/subscriptions", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_customers_customer_subscriptions(get_customers_customer_subscriptions_request()) ->
                                            result(get_customers_customer_subscriptions_response()).
get_customers_customer_subscriptions(Args) ->
    get_customers_customer_subscriptions(Args, #{}).

-spec get_customers_customer_subscriptions(get_customers_customer_subscriptions_request(),
                                           options()) ->
                                              result(get_customers_customer_subscriptions_response()).
get_customers_customer_subscriptions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/subscriptions", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             subscription}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_order_returns_id(get_order_returns_id_request()) ->
                              result(get_order_returns_id_response()).
get_order_returns_id(Args) ->
    get_order_returns_id(Args, #{}).

-spec get_order_returns_id(get_order_returns_id_request(), options()) ->
                              result(get_order_returns_id_response()).
get_order_returns_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/order_returns/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, order_return},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_transfers_id_reversals(post_transfers_id_reversals_request()) ->
                                     result(post_transfers_id_reversals_response()).
post_transfers_id_reversals(Args) ->
    post_transfers_id_reversals(Args, #{}).

-spec post_transfers_id_reversals(post_transfers_id_reversals_request(), options()) ->
                                     result(post_transfers_id_reversals_response()).
post_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s/reversals", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, transfer_reversal},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_transfers_id_reversals(get_transfers_id_reversals_request()) ->
                                    result(get_transfers_id_reversals_response()).
get_transfers_id_reversals(Args) ->
    get_transfers_id_reversals(Args, #{}).

-spec get_transfers_id_reversals(get_transfers_id_reversals_request(), options()) ->
                                    result(get_transfers_id_reversals_response()).
get_transfers_id_reversals(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s/reversals", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             transfer_reversal}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_reviews_review(get_reviews_review_request()) ->
                            result(get_reviews_review_response()).
get_reviews_review(Args) ->
    get_reviews_review(Args, #{}).

-spec get_reviews_review(get_reviews_review_request(), options()) ->
                            result(get_reviews_review_response()).
get_reviews_review(Args, Options) ->
    VarReview = maps:get(review, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reviews/~s", [VarReview]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, review},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_accounts_account_bank_accounts_id(delete_accounts_account_bank_accounts_id_request()) ->
                                                result(delete_accounts_account_bank_accounts_id_response()).
delete_accounts_account_bank_accounts_id(Args) ->
    delete_accounts_account_bank_accounts_id(Args, #{}).

-spec
    delete_accounts_account_bank_accounts_id(delete_accounts_account_bank_accounts_id_request(),
                                             options()) ->
                                                result(delete_accounts_account_bank_accounts_id_response()).
delete_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, deleted_external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_accounts_account_bank_accounts_id(post_accounts_account_bank_accounts_id_request()) ->
                                              result(post_accounts_account_bank_accounts_id_response()).
post_accounts_account_bank_accounts_id(Args) ->
    post_accounts_account_bank_accounts_id(Args, #{}).

-spec
    post_accounts_account_bank_accounts_id(post_accounts_account_bank_accounts_id_request(),
                                           options()) ->
                                              result(post_accounts_account_bank_accounts_id_response()).
post_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_accounts_account_bank_accounts_id(get_accounts_account_bank_accounts_id_request()) ->
                                             result(get_accounts_account_bank_accounts_id_response()).
get_accounts_account_bank_accounts_id(Args) ->
    get_accounts_account_bank_accounts_id(Args, #{}).

-spec
    get_accounts_account_bank_accounts_id(get_accounts_account_bank_accounts_id_request(),
                                          options()) ->
                                             result(get_accounts_account_bank_accounts_id_response()).
get_accounts_account_bank_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_issuing_settlements_settlement(post_issuing_settlements_settlement_request()) ->
                                           result(post_issuing_settlements_settlement_response()).
post_issuing_settlements_settlement(Args) ->
    post_issuing_settlements_settlement(Args, #{}).

-spec post_issuing_settlements_settlement(post_issuing_settlements_settlement_request(),
                                          options()) ->
                                             result(post_issuing_settlements_settlement_response()).
post_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/settlements/~s", [VarSettlement]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_settlement},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_settlements_settlement(get_issuing_settlements_settlement_request()) ->
                                            result(get_issuing_settlements_settlement_response()).
get_issuing_settlements_settlement(Args) ->
    get_issuing_settlements_settlement(Args, #{}).

-spec get_issuing_settlements_settlement(get_issuing_settlements_settlement_request(),
                                         options()) ->
                                            result(get_issuing_settlements_settlement_response()).
get_issuing_settlements_settlement(Args, Options) ->
    VarSettlement = maps:get(settlement, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/settlements/~s", [VarSettlement]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_settlement},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_promotion_codes_promotion_code(post_promotion_codes_promotion_code_request()) ->
                                           result(post_promotion_codes_promotion_code_response()).
post_promotion_codes_promotion_code(Args) ->
    post_promotion_codes_promotion_code(Args, #{}).

-spec post_promotion_codes_promotion_code(post_promotion_codes_promotion_code_request(),
                                          options()) ->
                                             result(post_promotion_codes_promotion_code_response()).
post_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/promotion_codes/~s", [VarPromotionCode]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, promotion_code},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_promotion_codes_promotion_code(get_promotion_codes_promotion_code_request()) ->
                                            result(get_promotion_codes_promotion_code_response()).
get_promotion_codes_promotion_code(Args) ->
    get_promotion_codes_promotion_code(Args, #{}).

-spec get_promotion_codes_promotion_code(get_promotion_codes_promotion_code_request(),
                                         options()) ->
                                            result(get_promotion_codes_promotion_code_response()).
get_promotion_codes_promotion_code(Args, Options) ->
    VarPromotionCode = maps:get(promotion_code, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/promotion_codes/~s", [VarPromotionCode]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, promotion_code},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_subscription_schedules_schedule_cancel(post_subscription_schedules_schedule_cancel_request()) ->
                                                   result(post_subscription_schedules_schedule_cancel_response()).
post_subscription_schedules_schedule_cancel(Args) ->
    post_subscription_schedules_schedule_cancel(Args, #{}).

-spec
    post_subscription_schedules_schedule_cancel(post_subscription_schedules_schedule_cancel_request(),
                                                options()) ->
                                                   result(post_subscription_schedules_schedule_cancel_response()).
post_subscription_schedules_schedule_cancel(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules/~s/cancel", [VarSchedule]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription_schedule},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_identity_verification_sessions(post_identity_verification_sessions_request()) ->
                                           result(post_identity_verification_sessions_response()).
post_identity_verification_sessions(Args) ->
    post_identity_verification_sessions(Args, #{}).

-spec post_identity_verification_sessions(post_identity_verification_sessions_request(),
                                          options()) ->
                                             result(post_identity_verification_sessions_response()).
post_identity_verification_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref,
                                                         stripe,
                                                         identity_verification_session},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_identity_verification_sessions(get_identity_verification_sessions_request()) ->
                                            result(get_identity_verification_sessions_response()).
get_identity_verification_sessions(Args) ->
    get_identity_verification_sessions(Args, #{}).

-spec get_identity_verification_sessions(get_identity_verification_sessions_request(),
                                         options()) ->
                                            result(get_identity_verification_sessions_response()).
get_identity_verification_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             identity_verification_session}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_radar_value_list_items(post_radar_value_list_items_request()) ->
                                     result(post_radar_value_list_items_response()).
post_radar_value_list_items(Args) ->
    post_radar_value_list_items(Args, #{}).

-spec post_radar_value_list_items(post_radar_value_list_items_request(), options()) ->
                                     result(post_radar_value_list_items_response()).
post_radar_value_list_items(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, radar_value_list_item},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_radar_value_list_items(get_radar_value_list_items_request()) ->
                                    result(get_radar_value_list_items_response()).
get_radar_value_list_items(Args) ->
    get_radar_value_list_items(Args, #{}).

-spec get_radar_value_list_items(get_radar_value_list_items_request(), options()) ->
                                    result(get_radar_value_list_items_response()).
get_radar_value_list_items(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({value, Value}) ->
                encode_q(form, false, <<"value">>, Value);
            ({value_list, Value}) ->
                encode_q(form, false, <<"value_list">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_list_items", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             radar_value_list_item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_events_id(get_events_id_request()) -> result(get_events_id_response()).
get_events_id(Args) ->
    get_events_id(Args, #{}).

-spec get_events_id(get_events_id_request(), options()) ->
                       result(get_events_id_response()).
get_events_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/events/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, event},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_country_specs(get_country_specs_request()) ->
                           result(get_country_specs_response()).
get_country_specs(Args) ->
    get_country_specs(Args, #{}).

-spec get_country_specs(get_country_specs_request(), options()) ->
                           result(get_country_specs_response()).
get_country_specs(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/country_specs", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             country_spec}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_payment_intents_intent_verify_microdeposits(post_payment_intents_intent_verify_microdeposits_request()) ->
                                                        result(post_payment_intents_intent_verify_microdeposits_response()).
post_payment_intents_intent_verify_microdeposits(Args) ->
    post_payment_intents_intent_verify_microdeposits(Args, #{}).

-spec
    post_payment_intents_intent_verify_microdeposits(post_payment_intents_intent_verify_microdeposits_request(),
                                                     options()) ->
                                                        result(post_payment_intents_intent_verify_microdeposits_response()).
post_payment_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s/verify_microdeposits", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_subscription_items_subscription_item_usage_records(post_subscription_items_subscription_item_usage_records_request()) ->
                                                               result(post_subscription_items_subscription_item_usage_records_response()).
post_subscription_items_subscription_item_usage_records(Args) ->
    post_subscription_items_subscription_item_usage_records(Args, #{}).

-spec
    post_subscription_items_subscription_item_usage_records(post_subscription_items_subscription_item_usage_records_request(),
                                                            options()) ->
                                                               result(post_subscription_items_subscription_item_usage_records_response()).
post_subscription_items_subscription_item_usage_records(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items/~s/usage_records", [VarSubscriptionItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, usage_record},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_balance_history(get_balance_history_request()) ->
                             result(get_balance_history_response()).
get_balance_history(Args) ->
    get_balance_history(Args, #{}).

-spec get_balance_history(get_balance_history_request(), options()) ->
                             result(get_balance_history_response()).
get_balance_history(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payout, Value}) ->
                encode_q(form, false, <<"payout">>, Value);
            ({source, Value}) ->
                encode_q(form, false, <<"source">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance/history", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             balance_transaction}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_order_returns(get_order_returns_request()) ->
                           result(get_order_returns_response()).
get_order_returns(Args) ->
    get_order_returns(Args, #{}).

-spec get_order_returns(get_order_returns_request(), options()) ->
                           result(get_order_returns_response()).
get_order_returns(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({order, Value}) ->
                encode_q(form, false, <<"order">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/order_returns", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             order_return}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_account_external_accounts_id(delete_account_external_accounts_id_request()) ->
                                           result(delete_account_external_accounts_id_response()).
delete_account_external_accounts_id(Args) ->
    delete_account_external_accounts_id(Args, #{}).

-spec delete_account_external_accounts_id(delete_account_external_accounts_id_request(),
                                          options()) ->
                                             result(delete_account_external_accounts_id_response()).
delete_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, deleted_external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_external_accounts_id(post_account_external_accounts_id_request()) ->
                                           result(post_account_external_accounts_id_response()).
post_account_external_accounts_id(Args) ->
    post_account_external_accounts_id(Args, #{}).

-spec post_account_external_accounts_id(post_account_external_accounts_id_request(),
                                        options()) ->
                                           result(post_account_external_accounts_id_response()).
post_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_account_external_accounts_id(get_account_external_accounts_id_request()) ->
                                          result(get_account_external_accounts_id_response()).
get_account_external_accounts_id(Args) ->
    get_account_external_accounts_id(Args, #{}).

-spec get_account_external_accounts_id(get_account_external_accounts_id_request(),
                                       options()) ->
                                          result(get_account_external_accounts_id_response()).
get_account_external_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_apple_pay_domains(post_apple_pay_domains_request()) ->
                                result(post_apple_pay_domains_response()).
post_apple_pay_domains(Args) ->
    post_apple_pay_domains(Args, #{}).

-spec post_apple_pay_domains(post_apple_pay_domains_request(), options()) ->
                                result(post_apple_pay_domains_response()).
post_apple_pay_domains(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, apple_pay_domain},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_apple_pay_domains(get_apple_pay_domains_request()) ->
                               result(get_apple_pay_domains_response()).
get_apple_pay_domains(Args) ->
    get_apple_pay_domains(Args, #{}).

-spec get_apple_pay_domains(get_apple_pay_domains_request(), options()) ->
                               result(get_apple_pay_domains_response()).
get_apple_pay_domains(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({domain_name, Value}) ->
                encode_q(form, false, <<"domain_name">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/apple_pay/domains", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             apple_pay_domain}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_credit_notes(post_credit_notes_request()) ->
                           result(post_credit_notes_response()).
post_credit_notes(Args) ->
    post_credit_notes(Args, #{}).

-spec post_credit_notes(post_credit_notes_request(), options()) ->
                           result(post_credit_notes_response()).
post_credit_notes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, credit_note},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_credit_notes(get_credit_notes_request()) -> result(get_credit_notes_response()).
get_credit_notes(Args) ->
    get_credit_notes(Args, #{}).

-spec get_credit_notes(get_credit_notes_request(), options()) ->
                          result(get_credit_notes_response()).
get_credit_notes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             credit_note}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_sigma_scheduled_query_runs_scheduled_query_run(get_sigma_scheduled_query_runs_scheduled_query_run_request()) ->
                                                          result(get_sigma_scheduled_query_runs_scheduled_query_run_response()).
get_sigma_scheduled_query_runs_scheduled_query_run(Args) ->
    get_sigma_scheduled_query_runs_scheduled_query_run(Args, #{}).

-spec
    get_sigma_scheduled_query_runs_scheduled_query_run(get_sigma_scheduled_query_runs_scheduled_query_run_request(),
                                                       options()) ->
                                                          result(get_sigma_scheduled_query_runs_scheduled_query_run_response()).
get_sigma_scheduled_query_runs_scheduled_query_run(Args, Options) ->
    VarScheduledQueryRun = maps:get(scheduled_query_run, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs/~s", [VarScheduledQueryRun]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, scheduled_query_run},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_coupons_coupon(delete_coupons_coupon_request()) ->
                               result(delete_coupons_coupon_response()).
delete_coupons_coupon(Args) ->
    delete_coupons_coupon(Args, #{}).

-spec delete_coupons_coupon(delete_coupons_coupon_request(), options()) ->
                               result(delete_coupons_coupon_response()).
delete_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_coupon},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_coupons_coupon(post_coupons_coupon_request()) ->
                             result(post_coupons_coupon_response()).
post_coupons_coupon(Args) ->
    post_coupons_coupon(Args, #{}).

-spec post_coupons_coupon(post_coupons_coupon_request(), options()) ->
                             result(post_coupons_coupon_response()).
post_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, coupon},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_coupons_coupon(get_coupons_coupon_request()) ->
                            result(get_coupons_coupon_response()).
get_coupons_coupon(Args) ->
    get_coupons_coupon(Args, #{}).

-spec get_coupons_coupon(get_coupons_coupon_request(), options()) ->
                            result(get_coupons_coupon_response()).
get_coupons_coupon(Args, Options) ->
    VarCoupon = maps:get(coupon, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/coupons/~s", [VarCoupon]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, coupon},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_customers_customer_tax_ids_id(delete_customers_customer_tax_ids_id_request()) ->
                                            result(delete_customers_customer_tax_ids_id_response()).
delete_customers_customer_tax_ids_id(Args) ->
    delete_customers_customer_tax_ids_id(Args, #{}).

-spec delete_customers_customer_tax_ids_id(delete_customers_customer_tax_ids_id_request(),
                                           options()) ->
                                              result(delete_customers_customer_tax_ids_id_response()).
delete_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_tax_id},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_customers_customer_tax_ids_id(get_customers_customer_tax_ids_id_request()) ->
                                           result(get_customers_customer_tax_ids_id_response()).
get_customers_customer_tax_ids_id(Args) ->
    get_customers_customer_tax_ids_id(Args, #{}).

-spec get_customers_customer_tax_ids_id(get_customers_customer_tax_ids_id_request(),
                                        options()) ->
                                           result(get_customers_customer_tax_ids_id_response()).
get_customers_customer_tax_ids_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, tax_id},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_radar_early_fraud_warnings_early_fraud_warning(get_radar_early_fraud_warnings_early_fraud_warning_request()) ->
                                                          result(get_radar_early_fraud_warnings_early_fraud_warning_response()).
get_radar_early_fraud_warnings_early_fraud_warning(Args) ->
    get_radar_early_fraud_warnings_early_fraud_warning(Args, #{}).

-spec
    get_radar_early_fraud_warnings_early_fraud_warning(get_radar_early_fraud_warnings_early_fraud_warning_request(),
                                                       options()) ->
                                                          result(get_radar_early_fraud_warnings_early_fraud_warning_response()).
get_radar_early_fraud_warnings_early_fraud_warning(Args, Options) ->
    VarEarlyFraudWarning = maps:get(early_fraud_warning, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/early_fraud_warnings/~s", [VarEarlyFraudWarning]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, radar_early_fraud_warning},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_settlements(get_issuing_settlements_request()) ->
                                 result(get_issuing_settlements_response()).
get_issuing_settlements(Args) ->
    get_issuing_settlements(Args, #{}).

-spec get_issuing_settlements(get_issuing_settlements_request(), options()) ->
                                 result(get_issuing_settlements_response()).
get_issuing_settlements(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/settlements", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             issuing_settlement}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_file_links(post_file_links_request()) -> result(post_file_links_response()).
post_file_links(Args) ->
    post_file_links(Args, #{}).

-spec post_file_links(post_file_links_request(), options()) ->
                         result(post_file_links_response()).
post_file_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/file_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, file_link},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_file_links(get_file_links_request()) -> result(get_file_links_response()).
get_file_links(Args) ->
    get_file_links(Args, #{}).

-spec get_file_links(get_file_links_request(), options()) ->
                        result(get_file_links_response()).
get_file_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({expired, Value}) ->
                encode_q(form, false, <<"expired">>, Value);
            ({file, Value}) ->
                encode_q(form, false, <<"file">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/file_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             file_link}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_identity_verification_reports_report(get_identity_verification_reports_report_request()) ->
                                                result(get_identity_verification_reports_report_response()).
get_identity_verification_reports_report(Args) ->
    get_identity_verification_reports_report(Args, #{}).

-spec
    get_identity_verification_reports_report(get_identity_verification_reports_report_request(),
                                             options()) ->
                                                result(get_identity_verification_reports_report_response()).
get_identity_verification_reports_report(Args, Options) ->
    VarReport = maps:get(report, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_reports/~s", [VarReport]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, identity_verification_report},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_transfers(post_transfers_request()) -> result(post_transfers_response()).
post_transfers(Args) ->
    post_transfers(Args, #{}).

-spec post_transfers(post_transfers_request(), options()) ->
                        result(post_transfers_response()).
post_transfers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, transfer},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_transfers(get_transfers_request()) -> result(get_transfers_response()).
get_transfers(Args) ->
    get_transfers(Args, #{}).

-spec get_transfers(get_transfers_request(), options()) ->
                       result(get_transfers_response()).
get_transfers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({destination, Value}) ->
                encode_q(form, false, <<"destination">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({transfer_group, Value}) ->
                encode_q(form, false, <<"transfer_group">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             transfer}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_subscriptions_subscription_exposed_id_discount(delete_subscriptions_subscription_exposed_id_discount_request()) ->
                                                             result(delete_subscriptions_subscription_exposed_id_discount_response()).
delete_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec
    delete_subscriptions_subscription_exposed_id_discount(delete_subscriptions_subscription_exposed_id_discount_request(),
                                                          options()) ->
                                                             result(delete_subscriptions_subscription_exposed_id_discount_response()).
delete_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions/~s/discount", [VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_discount},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_application_fees_id_refunds(post_application_fees_id_refunds_request()) ->
                                          result(post_application_fees_id_refunds_response()).
post_application_fees_id_refunds(Args) ->
    post_application_fees_id_refunds(Args, #{}).

-spec post_application_fees_id_refunds(post_application_fees_id_refunds_request(),
                                       options()) ->
                                          result(post_application_fees_id_refunds_response()).
post_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, fee_refund},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_application_fees_id_refunds(get_application_fees_id_refunds_request()) ->
                                         result(get_application_fees_id_refunds_response()).
get_application_fees_id_refunds(Args) ->
    get_application_fees_id_refunds(Args, #{}).

-spec get_application_fees_id_refunds(get_application_fees_id_refunds_request(),
                                      options()) ->
                                         result(get_application_fees_id_refunds_response()).
get_application_fees_id_refunds(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refunds", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             fee_refund}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_accounts_account_bank_accounts(post_accounts_account_bank_accounts_request()) ->
                                           result(post_accounts_account_bank_accounts_response()).
post_accounts_account_bank_accounts(Args) ->
    post_accounts_account_bank_accounts(Args, #{}).

-spec post_accounts_account_bank_accounts(post_accounts_account_bank_accounts_request(),
                                          options()) ->
                                             result(post_accounts_account_bank_accounts_response()).
post_accounts_account_bank_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/bank_accounts", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_accounts_account(delete_accounts_account_request()) ->
                                 result(delete_accounts_account_response()).
delete_accounts_account(Args) ->
    delete_accounts_account(Args, #{}).

-spec delete_accounts_account(delete_accounts_account_request(), options()) ->
                                 result(delete_accounts_account_response()).
delete_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_accounts_account(post_accounts_account_request()) ->
                               result(post_accounts_account_response()).
post_accounts_account(Args) ->
    post_accounts_account(Args, #{}).

-spec post_accounts_account(post_accounts_account_request(), options()) ->
                               result(post_accounts_account_response()).
post_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_accounts_account(get_accounts_account_request()) ->
                              result(get_accounts_account_response()).
get_accounts_account(Args) ->
    get_accounts_account(Args, #{}).

-spec get_accounts_account(get_accounts_account_request(), options()) ->
                              result(get_accounts_account_response()).
get_accounts_account(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_subscription_schedules_schedule(post_subscription_schedules_schedule_request()) ->
                                            result(post_subscription_schedules_schedule_response()).
post_subscription_schedules_schedule(Args) ->
    post_subscription_schedules_schedule(Args, #{}).

-spec post_subscription_schedules_schedule(post_subscription_schedules_schedule_request(),
                                           options()) ->
                                              result(post_subscription_schedules_schedule_response()).
post_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules/~s", [VarSchedule]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription_schedule},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_subscription_schedules_schedule(get_subscription_schedules_schedule_request()) ->
                                           result(get_subscription_schedules_schedule_response()).
get_subscription_schedules_schedule(Args) ->
    get_subscription_schedules_schedule(Args, #{}).

-spec get_subscription_schedules_schedule(get_subscription_schedules_schedule_request(),
                                          options()) ->
                                             result(get_subscription_schedules_schedule_response()).
get_subscription_schedules_schedule(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules/~s", [VarSchedule]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription_schedule},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_invoices_invoice_pay(post_invoices_invoice_pay_request()) ->
                                   result(post_invoices_invoice_pay_response()).
post_invoices_invoice_pay(Args) ->
    post_invoices_invoice_pay(Args, #{}).

-spec post_invoices_invoice_pay(post_invoices_invoice_pay_request(), options()) ->
                                   result(post_invoices_invoice_pay_response()).
post_invoices_invoice_pay(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/pay", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_transfers_transfer_reversals_id(post_transfers_transfer_reversals_id_request()) ->
                                            result(post_transfers_transfer_reversals_id_response()).
post_transfers_transfer_reversals_id(Args) ->
    post_transfers_transfer_reversals_id(Args, #{}).

-spec post_transfers_transfer_reversals_id(post_transfers_transfer_reversals_id_request(),
                                           options()) ->
                                              result(post_transfers_transfer_reversals_id_response()).
post_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s/reversals/~s", [VarTransfer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, transfer_reversal},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_transfers_transfer_reversals_id(get_transfers_transfer_reversals_id_request()) ->
                                           result(get_transfers_transfer_reversals_id_response()).
get_transfers_transfer_reversals_id(Args) ->
    get_transfers_transfer_reversals_id(Args, #{}).

-spec get_transfers_transfer_reversals_id(get_transfers_transfer_reversals_id_request(),
                                          options()) ->
                                             result(get_transfers_transfer_reversals_id_response()).
get_transfers_transfer_reversals_id(Args, Options) ->
    VarId = maps:get(id, Args),
    VarTransfer = maps:get(transfer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s/reversals/~s", [VarTransfer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, transfer_reversal},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_topups_topup(post_topups_topup_request()) ->
                           result(post_topups_topup_response()).
post_topups_topup(Args) ->
    post_topups_topup(Args, #{}).

-spec post_topups_topup(post_topups_topup_request(), options()) ->
                           result(post_topups_topup_response()).
post_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups/~s", [VarTopup]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, topup},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_topups_topup(get_topups_topup_request()) -> result(get_topups_topup_response()).
get_topups_topup(Args) ->
    get_topups_topup(Args, #{}).

-spec get_topups_topup(get_topups_topup_request(), options()) ->
                          result(get_topups_topup_response()).
get_topups_topup(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups/~s", [VarTopup]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, topup},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_recipients_id(delete_recipients_id_request()) ->
                              result(delete_recipients_id_response()).
delete_recipients_id(Args) ->
    delete_recipients_id(Args, #{}).

-spec delete_recipients_id(delete_recipients_id_request(), options()) ->
                              result(delete_recipients_id_response()).
delete_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_recipient},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_recipients_id(post_recipients_id_request()) ->
                            result(post_recipients_id_response()).
post_recipients_id(Args) ->
    post_recipients_id(Args, #{}).

-spec post_recipients_id(post_recipients_id_request(), options()) ->
                            result(post_recipients_id_response()).
post_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, recipient},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_recipients_id(get_recipients_id_request()) ->
                           result(get_recipients_id_response()).
get_recipients_id(Args) ->
    get_recipients_id(Args, #{}).

-spec get_recipients_id(get_recipients_id_request(), options()) ->
                           result(get_recipients_id_response()).
get_recipients_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, recipient},
                                                          {ref, stripe, deleted_recipient}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_invoices_invoice_lines(get_invoices_invoice_lines_request()) ->
                                    result(get_invoices_invoice_lines_response()).
get_invoices_invoice_lines(Args) ->
    get_invoices_invoice_lines(Args, #{}).

-spec get_invoices_invoice_lines(get_invoices_invoice_lines_request(), options()) ->
                                    result(get_invoices_invoice_lines_response()).
get_invoices_invoice_lines(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/lines", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             line_item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_accounts_account_external_accounts_id(delete_accounts_account_external_accounts_id_request()) ->
                                                    result(delete_accounts_account_external_accounts_id_response()).
delete_accounts_account_external_accounts_id(Args) ->
    delete_accounts_account_external_accounts_id(Args, #{}).

-spec
    delete_accounts_account_external_accounts_id(delete_accounts_account_external_accounts_id_request(),
                                                 options()) ->
                                                    result(delete_accounts_account_external_accounts_id_response()).
delete_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, deleted_external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_accounts_account_external_accounts_id(post_accounts_account_external_accounts_id_request()) ->
                                                  result(post_accounts_account_external_accounts_id_response()).
post_accounts_account_external_accounts_id(Args) ->
    post_accounts_account_external_accounts_id(Args, #{}).

-spec
    post_accounts_account_external_accounts_id(post_accounts_account_external_accounts_id_request(),
                                               options()) ->
                                                  result(post_accounts_account_external_accounts_id_response()).
post_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_accounts_account_external_accounts_id(get_accounts_account_external_accounts_id_request()) ->
                                                 result(get_accounts_account_external_accounts_id_response()).
get_accounts_account_external_accounts_id(Args) ->
    get_accounts_account_external_accounts_id(Args, #{}).

-spec
    get_accounts_account_external_accounts_id(get_accounts_account_external_accounts_id_request(),
                                              options()) ->
                                                 result(get_accounts_account_external_accounts_id_response()).
get_accounts_account_external_accounts_id(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts/~s", [VarAccount, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_topups(post_topups_request()) -> result(post_topups_response()).
post_topups(Args) ->
    post_topups(Args, #{}).

-spec post_topups(post_topups_request(), options()) -> result(post_topups_response()).
post_topups(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, topup},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_topups(get_topups_request()) -> result(get_topups_response()).
get_topups(Args) ->
    get_topups(Args, #{}).

-spec get_topups(get_topups_request(), options()) -> result(get_topups_response()).
get_topups(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({amount, Value}) ->
                encode_q(deepObject, true, <<"amount">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, topup}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_orders_id_returns(post_orders_id_returns_request()) ->
                                result(post_orders_id_returns_response()).
post_orders_id_returns(Args) ->
    post_orders_id_returns(Args, #{}).

-spec post_orders_id_returns(post_orders_id_returns_request(), options()) ->
                                result(post_orders_id_returns_response()).
post_orders_id_returns(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders/~s/returns", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, order_return},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_orders_id(post_orders_id_request()) -> result(post_orders_id_response()).
post_orders_id(Args) ->
    post_orders_id(Args, #{}).

-spec post_orders_id(post_orders_id_request(), options()) ->
                        result(post_orders_id_response()).
post_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, order},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_orders_id(get_orders_id_request()) -> result(get_orders_id_response()).
get_orders_id(Args) ->
    get_orders_id(Args, #{}).

-spec get_orders_id(get_orders_id_request(), options()) ->
                       result(get_orders_id_response()).
get_orders_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, order},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_apple_pay_domains_domain(delete_apple_pay_domains_domain_request()) ->
                                         result(delete_apple_pay_domains_domain_response()).
delete_apple_pay_domains_domain(Args) ->
    delete_apple_pay_domains_domain(Args, #{}).

-spec delete_apple_pay_domains_domain(delete_apple_pay_domains_domain_request(),
                                      options()) ->
                                         result(delete_apple_pay_domains_domain_response()).
delete_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/apple_pay/domains/~s", [VarDomain]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, deleted_apple_pay_domain},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_apple_pay_domains_domain(get_apple_pay_domains_domain_request()) ->
                                      result(get_apple_pay_domains_domain_response()).
get_apple_pay_domains_domain(Args) ->
    get_apple_pay_domains_domain(Args, #{}).

-spec get_apple_pay_domains_domain(get_apple_pay_domains_domain_request(), options()) ->
                                      result(get_apple_pay_domains_domain_response()).
get_apple_pay_domains_domain(Args, Options) ->
    VarDomain = maps:get(domain, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/apple_pay/domains/~s", [VarDomain]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, apple_pay_domain},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_transactions(get_issuing_transactions_request()) ->
                                  result(get_issuing_transactions_response()).
get_issuing_transactions(Args) ->
    get_issuing_transactions(Args, #{}).

-spec get_issuing_transactions(get_issuing_transactions_request(), options()) ->
                                  result(get_issuing_transactions_response()).
get_issuing_transactions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({card, Value}) ->
                encode_q(form, false, <<"card">>, Value);
            ({cardholder, Value}) ->
                encode_q(form, false, <<"cardholder">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/transactions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             issuing_transaction}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_charges_charge_refund(post_charges_charge_refund_request()) ->
                                    result(post_charges_charge_refund_response()).
post_charges_charge_refund(Args) ->
    post_charges_charge_refund(Args, #{}).

-spec post_charges_charge_refund(post_charges_charge_refund_request(), options()) ->
                                    result(post_charges_charge_refund_response()).
post_charges_charge_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refund", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, charge},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_payment_methods_payment_method_attach(post_payment_methods_payment_method_attach_request()) ->
                                                  result(post_payment_methods_payment_method_attach_response()).
post_payment_methods_payment_method_attach(Args) ->
    post_payment_methods_payment_method_attach(Args, #{}).

-spec
    post_payment_methods_payment_method_attach(post_payment_methods_payment_method_attach_request(),
                                               options()) ->
                                                  result(post_payment_methods_payment_method_attach_response()).
post_payment_methods_payment_method_attach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods/~s/attach", [VarPaymentMethod]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_method},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payment_intents_intent_cancel(post_payment_intents_intent_cancel_request()) ->
                                            result(post_payment_intents_intent_cancel_response()).
post_payment_intents_intent_cancel(Args) ->
    post_payment_intents_intent_cancel(Args, #{}).

-spec post_payment_intents_intent_cancel(post_payment_intents_intent_cancel_request(),
                                         options()) ->
                                            result(post_payment_intents_intent_cancel_response()).
post_payment_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s/cancel", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_accounts_account_capabilities(get_accounts_account_capabilities_request()) ->
                                           result(get_accounts_account_capabilities_response()).
get_accounts_account_capabilities(Args) ->
    get_accounts_account_capabilities(Args, #{}).

-spec get_accounts_account_capabilities(get_accounts_account_capabilities_request(),
                                        options()) ->
                                           result(get_accounts_account_capabilities_response()).
get_accounts_account_capabilities(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             capability}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_credit_notes_preview_lines(get_credit_notes_preview_lines_request()) ->
                                        result(get_credit_notes_preview_lines_response()).
get_credit_notes_preview_lines(Args) ->
    get_credit_notes_preview_lines(Args, #{}).

-spec get_credit_notes_preview_lines(get_credit_notes_preview_lines_request(),
                                     options()) ->
                                        result(get_credit_notes_preview_lines_response()).
get_credit_notes_preview_lines(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({amount, Value}) ->
                encode_q(form, false, <<"amount">>, Value);
            ({credit_amount, Value}) ->
                encode_q(form, false, <<"credit_amount">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({lines, Value}) ->
                encode_q(deepObject, true, <<"lines">>, Value);
            ({memo, Value}) ->
                encode_q(form, false, <<"memo">>, Value);
            ({metadata, Value}) ->
                encode_q(deepObject, true, <<"metadata">>, Value);
            ({out_of_band_amount, Value}) ->
                encode_q(form, false, <<"out_of_band_amount">>, Value);
            ({reason, Value}) ->
                encode_q(form, false, <<"reason">>, Value);
            ({refund, Value}) ->
                encode_q(form, false, <<"refund">>, Value);
            ({refund_amount, Value}) ->
                encode_q(form, false, <<"refund_amount">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/preview/lines", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             credit_note_line_item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_subscriptions(post_subscriptions_request()) ->
                            result(post_subscriptions_response()).
post_subscriptions(Args) ->
    post_subscriptions(Args, #{}).

-spec post_subscriptions(post_subscriptions_request(), options()) ->
                            result(post_subscriptions_response()).
post_subscriptions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_subscriptions(get_subscriptions_request()) ->
                           result(get_subscriptions_response()).
get_subscriptions(Args) ->
    get_subscriptions(Args, #{}).

-spec get_subscriptions(get_subscriptions_request(), options()) ->
                           result(get_subscriptions_response()).
get_subscriptions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({collection_method, Value}) ->
                encode_q(form, false, <<"collection_method">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({current_period_end, Value}) ->
                encode_q(deepObject, true, <<"current_period_end">>, Value);
            ({current_period_start, Value}) ->
                encode_q(deepObject, true, <<"current_period_start">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({price, Value}) ->
                encode_q(form, false, <<"price">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             subscription}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_setup_attempts(get_setup_attempts_request()) ->
                            result(get_setup_attempts_response()).
get_setup_attempts(Args) ->
    get_setup_attempts(Args, #{}).

-spec get_setup_attempts(get_setup_attempts_request(), options()) ->
                            result(get_setup_attempts_response()).
get_setup_attempts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({setup_intent, Value}) ->
                encode_q(form, false, <<"setup_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_attempts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             setup_attempt}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id(delete_customers_customer_subscriptions_subscription_exposed_id_request()) ->
                                                                       result(delete_customers_customer_subscriptions_subscription_exposed_id_response()).
delete_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id(delete_customers_customer_subscriptions_subscription_exposed_id_request(),
                                                                    options()) ->
                                                                       result(delete_customers_customer_subscriptions_subscription_exposed_id_response()).
delete_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_customers_customer_subscriptions_subscription_exposed_id(post_customers_customer_subscriptions_subscription_exposed_id_request()) ->
                                                                     result(post_customers_customer_subscriptions_subscription_exposed_id_response()).
post_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    post_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    post_customers_customer_subscriptions_subscription_exposed_id(post_customers_customer_subscriptions_subscription_exposed_id_request(),
                                                                  options()) ->
                                                                     result(post_customers_customer_subscriptions_subscription_exposed_id_response()).
post_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_customers_customer_subscriptions_subscription_exposed_id(get_customers_customer_subscriptions_subscription_exposed_id_request()) ->
                                                                    result(get_customers_customer_subscriptions_subscription_exposed_id_response()).
get_customers_customer_subscriptions_subscription_exposed_id(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    get_customers_customer_subscriptions_subscription_exposed_id(get_customers_customer_subscriptions_subscription_exposed_id_request(),
                                                                 options()) ->
                                                                    result(get_customers_customer_subscriptions_subscription_exposed_id_response()).
get_customers_customer_subscriptions_subscription_exposed_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_bitcoin_receivers_id(get_bitcoin_receivers_id_request()) ->
                                  result(get_bitcoin_receivers_id_response()).
get_bitcoin_receivers_id(Args) ->
    get_bitcoin_receivers_id(Args, #{}).

-spec get_bitcoin_receivers_id(get_bitcoin_receivers_id_request(), options()) ->
                                  result(get_bitcoin_receivers_id_response()).
get_bitcoin_receivers_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/bitcoin/receivers/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, bitcoin_receiver},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_orders(post_orders_request()) -> result(post_orders_response()).
post_orders(Args) ->
    post_orders(Args, #{}).

-spec post_orders(post_orders_request(), options()) -> result(post_orders_response()).
post_orders(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, order},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_orders(get_orders_request()) -> result(get_orders_response()).
get_orders(Args) ->
    get_orders(Args, #{}).

-spec get_orders(get_orders_request(), options()) -> result(get_orders_response()).
get_orders(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({ids, Value}) ->
                encode_q(deepObject, true, <<"ids">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({status_transitions, Value}) ->
                encode_q(deepObject, true, <<"status_transitions">>, Value);
            ({upstream_ids, Value}) ->
                encode_q(deepObject, true, <<"upstream_ids">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, order}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_ephemeral_keys(post_ephemeral_keys_request()) ->
                             result(post_ephemeral_keys_response()).
post_ephemeral_keys(Args) ->
    post_ephemeral_keys(Args, #{}).

-spec post_ephemeral_keys(post_ephemeral_keys_request(), options()) ->
                             result(post_ephemeral_keys_response()).
post_ephemeral_keys(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/ephemeral_keys", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, ephemeral_key},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_webhook_endpoints_webhook_endpoint(delete_webhook_endpoints_webhook_endpoint_request()) ->
                                                 result(delete_webhook_endpoints_webhook_endpoint_response()).
delete_webhook_endpoints_webhook_endpoint(Args) ->
    delete_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec
    delete_webhook_endpoints_webhook_endpoint(delete_webhook_endpoints_webhook_endpoint_request(),
                                              options()) ->
                                                 result(delete_webhook_endpoints_webhook_endpoint_response()).
delete_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, deleted_webhook_endpoint},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_webhook_endpoints_webhook_endpoint(post_webhook_endpoints_webhook_endpoint_request()) ->
                                               result(post_webhook_endpoints_webhook_endpoint_response()).
post_webhook_endpoints_webhook_endpoint(Args) ->
    post_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec
    post_webhook_endpoints_webhook_endpoint(post_webhook_endpoints_webhook_endpoint_request(),
                                            options()) ->
                                               result(post_webhook_endpoints_webhook_endpoint_response()).
post_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, webhook_endpoint},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_webhook_endpoints_webhook_endpoint(get_webhook_endpoints_webhook_endpoint_request()) ->
                                              result(get_webhook_endpoints_webhook_endpoint_response()).
get_webhook_endpoints_webhook_endpoint(Args) ->
    get_webhook_endpoints_webhook_endpoint(Args, #{}).

-spec
    get_webhook_endpoints_webhook_endpoint(get_webhook_endpoints_webhook_endpoint_request(),
                                           options()) ->
                                              result(get_webhook_endpoints_webhook_endpoint_response()).
get_webhook_endpoints_webhook_endpoint(Args, Options) ->
    VarWebhookEndpoint = maps:get(webhook_endpoint, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints/~s", [VarWebhookEndpoint]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, webhook_endpoint},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_persons(post_account_persons_request()) ->
                              result(post_account_persons_response()).
post_account_persons(Args) ->
    post_account_persons(Args, #{}).

-spec post_account_persons(post_account_persons_request(), options()) ->
                              result(post_account_persons_response()).
post_account_persons(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_account_persons(get_account_persons_request()) ->
                             result(get_account_persons_response()).
get_account_persons(Args) ->
    get_account_persons(Args, #{}).

-spec get_account_persons(get_account_persons_request(), options()) ->
                             result(get_account_persons_response()).
get_account_persons(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/persons", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, person}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_account_capabilities(get_account_capabilities_request()) ->
                                  result(get_account_capabilities_response()).
get_account_capabilities(Args) ->
    get_account_capabilities(Args, #{}).

-spec get_account_capabilities(get_account_capabilities_request(), options()) ->
                                  result(get_account_capabilities_response()).
get_account_capabilities(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/capabilities", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             capability}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_checkout_sessions_session_expire(post_checkout_sessions_session_expire_request()) ->
                                             result(post_checkout_sessions_session_expire_response()).
post_checkout_sessions_session_expire(Args) ->
    post_checkout_sessions_session_expire(Args, #{}).

-spec
    post_checkout_sessions_session_expire(post_checkout_sessions_session_expire_request(),
                                          options()) ->
                                             result(post_checkout_sessions_session_expire_response()).
post_checkout_sessions_session_expire(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions/~s/expire", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, checkout_session},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_bitcoin_receivers_receiver_transactions(get_bitcoin_receivers_receiver_transactions_request()) ->
                                                   result(get_bitcoin_receivers_receiver_transactions_response()).
get_bitcoin_receivers_receiver_transactions(Args) ->
    get_bitcoin_receivers_receiver_transactions(Args, #{}).

-spec
    get_bitcoin_receivers_receiver_transactions(get_bitcoin_receivers_receiver_transactions_request(),
                                                options()) ->
                                                   result(get_bitcoin_receivers_receiver_transactions_response()).
get_bitcoin_receivers_receiver_transactions(Args, Options) ->
    VarReceiver = maps:get(receiver, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/bitcoin/receivers/~s/transactions", [VarReceiver]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             bitcoin_transaction}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_quotes_quote(post_quotes_quote_request()) ->
                           result(post_quotes_quote_response()).
post_quotes_quote(Args) ->
    post_quotes_quote(Args, #{}).

-spec post_quotes_quote(post_quotes_quote_request(), options()) ->
                           result(post_quotes_quote_response()).
post_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, quote},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_quotes_quote(get_quotes_quote_request()) -> result(get_quotes_quote_response()).
get_quotes_quote(Args) ->
    get_quotes_quote(Args, #{}).

-spec get_quotes_quote(get_quotes_quote_request(), options()) ->
                          result(get_quotes_quote_response()).
get_quotes_quote(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, quote},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_people(post_account_people_request()) ->
                             result(post_account_people_response()).
post_account_people(Args) ->
    post_account_people(Args, #{}).

-spec post_account_people(post_account_people_request(), options()) ->
                             result(post_account_people_response()).
post_account_people(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_account_people(get_account_people_request()) ->
                            result(get_account_people_response()).
get_account_people(Args) ->
    get_account_people(Args, #{}).

-spec get_account_people(get_account_people_request(), options()) ->
                            result(get_account_people_response()).
get_account_people(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, person}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_setup_intents_intent_confirm(post_setup_intents_intent_confirm_request()) ->
                                           result(post_setup_intents_intent_confirm_response()).
post_setup_intents_intent_confirm(Args) ->
    post_setup_intents_intent_confirm(Args, #{}).

-spec post_setup_intents_intent_confirm(post_setup_intents_intent_confirm_request(),
                                        options()) ->
                                           result(post_setup_intents_intent_confirm_response()).
post_setup_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s/confirm", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, setup_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_customers_customer_cards(post_customers_customer_cards_request()) ->
                                       result(post_customers_customer_cards_response()).
post_customers_customer_cards(Args) ->
    post_customers_customer_cards(Args, #{}).

-spec post_customers_customer_cards(post_customers_customer_cards_request(), options()) ->
                                       result(post_customers_customer_cards_response()).
post_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_source},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_customers_customer_cards(get_customers_customer_cards_request()) ->
                                      result(get_customers_customer_cards_response()).
get_customers_customer_cards(Args) ->
    get_customers_customer_cards(Args, #{}).

-spec get_customers_customer_cards(get_customers_customer_cards_request(), options()) ->
                                      result(get_customers_customer_cards_response()).
get_customers_customer_cards(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, card}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_identity_verification_reports(get_identity_verification_reports_request()) ->
                                           result(get_identity_verification_reports_response()).
get_identity_verification_reports(Args) ->
    get_identity_verification_reports(Args, #{}).

-spec get_identity_verification_reports(get_identity_verification_reports_request(),
                                        options()) ->
                                           result(get_identity_verification_reports_response()).
get_identity_verification_reports(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({verification_session, Value}) ->
                encode_q(form, false, <<"verification_session">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_reports", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             identity_verification_report}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_accounts_account_persons(post_accounts_account_persons_request()) ->
                                       result(post_accounts_account_persons_response()).
post_accounts_account_persons(Args) ->
    post_accounts_account_persons(Args, #{}).

-spec post_accounts_account_persons(post_accounts_account_persons_request(), options()) ->
                                       result(post_accounts_account_persons_response()).
post_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_accounts_account_persons(get_accounts_account_persons_request()) ->
                                      result(get_accounts_account_persons_response()).
get_accounts_account_persons(Args) ->
    get_accounts_account_persons(Args, #{}).

-spec get_accounts_account_persons(get_accounts_account_persons_request(), options()) ->
                                      result(get_accounts_account_persons_response()).
get_accounts_account_persons(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/persons", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, person}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_application_fees_id_refund(post_application_fees_id_refund_request()) ->
                                         result(post_application_fees_id_refund_response()).
post_application_fees_id_refund(Args) ->
    post_application_fees_id_refund(Args, #{}).

-spec post_application_fees_id_refund(post_application_fees_id_refund_request(),
                                      options()) ->
                                         result(post_application_fees_id_refund_response()).
post_application_fees_id_refund(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s/refund", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, application_fee},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payment_intents(post_payment_intents_request()) ->
                              result(post_payment_intents_response()).
post_payment_intents(Args) ->
    post_payment_intents(Args, #{}).

-spec post_payment_intents(post_payment_intents_request(), options()) ->
                              result(post_payment_intents_response()).
post_payment_intents(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_payment_intents(get_payment_intents_request()) ->
                             result(get_payment_intents_response()).
get_payment_intents(Args) ->
    get_payment_intents(Args, #{}).

-spec get_payment_intents(get_payment_intents_request(), options()) ->
                             result(get_payment_intents_response()).
get_payment_intents(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             payment_intent}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_skus(post_skus_request()) -> result(post_skus_response()).
post_skus(Args) ->
    post_skus(Args, #{}).

-spec post_skus(post_skus_request(), options()) -> result(post_skus_response()).
post_skus(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, sku},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_skus(get_skus_request()) -> result(get_skus_response()).
get_skus(Args) ->
    get_skus(Args, #{}).

-spec get_skus(get_skus_request(), options()) -> result(get_skus_response()).
get_skus(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({attributes, Value}) ->
                encode_q(deepObject, true, <<"attributes">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({ids, Value}) ->
                encode_q(deepObject, true, <<"ids">>, Value);
            ({in_stock, Value}) ->
                encode_q(form, false, <<"in_stock">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({product, Value}) ->
                encode_q(form, false, <<"product">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, sku}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_webhook_endpoints(post_webhook_endpoints_request()) ->
                                result(post_webhook_endpoints_response()).
post_webhook_endpoints(Args) ->
    post_webhook_endpoints(Args, #{}).

-spec post_webhook_endpoints(post_webhook_endpoints_request(), options()) ->
                                result(post_webhook_endpoints_response()).
post_webhook_endpoints(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, webhook_endpoint},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_webhook_endpoints(get_webhook_endpoints_request()) ->
                               result(get_webhook_endpoints_response()).
get_webhook_endpoints(Args) ->
    get_webhook_endpoints(Args, #{}).

-spec get_webhook_endpoints(get_webhook_endpoints_request(), options()) ->
                               result(get_webhook_endpoints_response()).
get_webhook_endpoints(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/webhook_endpoints", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             webhook_endpoint}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_balance(get_balance_request()) -> result(get_balance_response()).
get_balance(Args) ->
    get_balance(Args, #{}).

-spec get_balance(get_balance_request(), options()) -> result(get_balance_response()).
get_balance(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, balance},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_customers_customer_balance_transactions_transaction(post_customers_customer_balance_transactions_transaction_request()) ->
                                                                result(post_customers_customer_balance_transactions_transaction_response()).
post_customers_customer_balance_transactions_transaction(Args) ->
    post_customers_customer_balance_transactions_transaction(Args, #{}).

-spec
    post_customers_customer_balance_transactions_transaction(post_customers_customer_balance_transactions_transaction_request(),
                                                             options()) ->
                                                                result(post_customers_customer_balance_transactions_transaction_response()).
post_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/balance_transactions/~s", [VarCustomer, VarTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, customer_balance_transaction},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_customers_customer_balance_transactions_transaction(get_customers_customer_balance_transactions_transaction_request()) ->
                                                               result(get_customers_customer_balance_transactions_transaction_response()).
get_customers_customer_balance_transactions_transaction(Args) ->
    get_customers_customer_balance_transactions_transaction(Args, #{}).

-spec
    get_customers_customer_balance_transactions_transaction(get_customers_customer_balance_transactions_transaction_request(),
                                                            options()) ->
                                                               result(get_customers_customer_balance_transactions_transaction_response()).
get_customers_customer_balance_transactions_transaction(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarTransaction = maps:get(transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/balance_transactions/~s", [VarCustomer, VarTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, customer_balance_transaction},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_payment_methods_payment_method(post_payment_methods_payment_method_request()) ->
                                           result(post_payment_methods_payment_method_response()).
post_payment_methods_payment_method(Args) ->
    post_payment_methods_payment_method(Args, #{}).

-spec post_payment_methods_payment_method(post_payment_methods_payment_method_request(),
                                          options()) ->
                                             result(post_payment_methods_payment_method_response()).
post_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods/~s", [VarPaymentMethod]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_method},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_payment_methods_payment_method(get_payment_methods_payment_method_request()) ->
                                            result(get_payment_methods_payment_method_response()).
get_payment_methods_payment_method(Args) ->
    get_payment_methods_payment_method(Args, #{}).

-spec get_payment_methods_payment_method(get_payment_methods_payment_method_request(),
                                         options()) ->
                                            result(get_payment_methods_payment_method_response()).
get_payment_methods_payment_method(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods/~s", [VarPaymentMethod]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_method},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_topups_topup_cancel(post_topups_topup_cancel_request()) ->
                                  result(post_topups_topup_cancel_response()).
post_topups_topup_cancel(Args) ->
    post_topups_topup_cancel(Args, #{}).

-spec post_topups_topup_cancel(post_topups_topup_cancel_request(), options()) ->
                                  result(post_topups_topup_cancel_response()).
post_topups_topup_cancel(Args, Options) ->
    VarTopup = maps:get(topup, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/topups/~s/cancel", [VarTopup]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, topup},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_events(get_events_request()) -> result(get_events_response()).
get_events(Args) ->
    get_events(Args, #{}).

-spec get_events(get_events_request(), options()) -> result(get_events_response()).
get_events(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({delivery_success, Value}) ->
                encode_q(form, false, <<"delivery_success">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({types, Value}) ->
                encode_q(deepObject, true, <<"types">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/events", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, event}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_charges_charge_refunds_refund(post_charges_charge_refunds_refund_request()) ->
                                            result(post_charges_charge_refunds_refund_response()).
post_charges_charge_refunds_refund(Args) ->
    post_charges_charge_refunds_refund(Args, #{}).

-spec post_charges_charge_refunds_refund(post_charges_charge_refunds_refund_request(),
                                         options()) ->
                                            result(post_charges_charge_refunds_refund_response()).
post_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refunds/~s", [VarCharge, VarRefund]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, refund},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_charges_charge_refunds_refund(get_charges_charge_refunds_refund_request()) ->
                                           result(get_charges_charge_refunds_refund_response()).
get_charges_charge_refunds_refund(Args) ->
    get_charges_charge_refunds_refund(Args, #{}).

-spec get_charges_charge_refunds_refund(get_charges_charge_refunds_refund_request(),
                                        options()) ->
                                           result(get_charges_charge_refunds_refund_response()).
get_charges_charge_refunds_refund(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    VarRefund = maps:get(refund, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/refunds/~s", [VarCharge, VarRefund]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, refund},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_accounts_account_capabilities_capability(post_accounts_account_capabilities_capability_request()) ->
                                                     result(post_accounts_account_capabilities_capability_response()).
post_accounts_account_capabilities_capability(Args) ->
    post_accounts_account_capabilities_capability(Args, #{}).

-spec
    post_accounts_account_capabilities_capability(post_accounts_account_capabilities_capability_request(),
                                                  options()) ->
                                                     result(post_accounts_account_capabilities_capability_response()).
post_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities/~s", [VarAccount, VarCapability]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, capability},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_accounts_account_capabilities_capability(get_accounts_account_capabilities_capability_request()) ->
                                                    result(get_accounts_account_capabilities_capability_response()).
get_accounts_account_capabilities_capability(Args) ->
    get_accounts_account_capabilities_capability(Args, #{}).

-spec
    get_accounts_account_capabilities_capability(get_accounts_account_capabilities_capability_request(),
                                                 options()) ->
                                                    result(get_accounts_account_capabilities_capability_response()).
get_accounts_account_capabilities_capability(Args, Options) ->
    VarAccount = maps:get(account, Args),
    VarCapability = maps:get(capability, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/capabilities/~s", [VarAccount, VarCapability]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, capability},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_subscription_items(post_subscription_items_request()) ->
                                 result(post_subscription_items_response()).
post_subscription_items(Args) ->
    post_subscription_items(Args, #{}).

-spec post_subscription_items(post_subscription_items_request(), options()) ->
                                 result(post_subscription_items_response()).
post_subscription_items(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription_item},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_subscription_items(get_subscription_items_request()) ->
                                result(get_subscription_items_response()).
get_subscription_items(Args) ->
    get_subscription_items(Args, #{}).

-spec get_subscription_items(get_subscription_items_request(), options()) ->
                                result(get_subscription_items_response()).
get_subscription_items(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_items", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             subscription_item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_quotes_quote_pdf(get_quotes_quote_pdf_request()) ->
                              result(get_quotes_quote_pdf_response()).
get_quotes_quote_pdf(Args) ->
    get_quotes_quote_pdf(Args, #{}).

-spec get_quotes_quote_pdf(get_quotes_quote_pdf_request(), options()) ->
                              result(get_quotes_quote_pdf_response()).
get_quotes_quote_pdf(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/pdf", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"pdf">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = string,
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_account_bank_accounts_id(delete_account_bank_accounts_id_request()) ->
                                         result(delete_account_bank_accounts_id_response()).
delete_account_bank_accounts_id(Args) ->
    delete_account_bank_accounts_id(Args, #{}).

-spec delete_account_bank_accounts_id(delete_account_bank_accounts_id_request(),
                                      options()) ->
                                         result(delete_account_bank_accounts_id_response()).
delete_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, deleted_external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_bank_accounts_id(post_account_bank_accounts_id_request()) ->
                                       result(post_account_bank_accounts_id_response()).
post_account_bank_accounts_id(Args) ->
    post_account_bank_accounts_id(Args, #{}).

-spec post_account_bank_accounts_id(post_account_bank_accounts_id_request(), options()) ->
                                       result(post_account_bank_accounts_id_response()).
post_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_account_bank_accounts_id(get_account_bank_accounts_id_request()) ->
                                      result(get_account_bank_accounts_id_response()).
get_account_bank_accounts_id(Args) ->
    get_account_bank_accounts_id(Args, #{}).

-spec get_account_bank_accounts_id(get_account_bank_accounts_id_request(), options()) ->
                                      result(get_account_bank_accounts_id_response()).
get_account_bank_accounts_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/bank_accounts/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_payment_links_payment_link_line_items(get_payment_links_payment_link_line_items_request()) ->
                                                 result(get_payment_links_payment_link_line_items_response()).
get_payment_links_payment_link_line_items(Args) ->
    get_payment_links_payment_link_line_items(Args, #{}).

-spec
    get_payment_links_payment_link_line_items(get_payment_links_payment_link_line_items_request(),
                                              options()) ->
                                                 result(get_payment_links_payment_link_line_items_response()).
get_payment_links_payment_link_line_items(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links/~s/line_items", [VarPaymentLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_subscription_items_subscription_item_usage_record_summaries(get_subscription_items_subscription_item_usage_record_summaries_request()) ->
                                                                       result(get_subscription_items_subscription_item_usage_record_summaries_response()).
get_subscription_items_subscription_item_usage_record_summaries(Args) ->
    get_subscription_items_subscription_item_usage_record_summaries(Args, #{}).

-spec
    get_subscription_items_subscription_item_usage_record_summaries(get_subscription_items_subscription_item_usage_record_summaries_request(),
                                                                    options()) ->
                                                                       result(get_subscription_items_subscription_item_usage_record_summaries_response()).
get_subscription_items_subscription_item_usage_record_summaries(Args, Options) ->
    VarSubscriptionItem = maps:get(subscription_item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/subscription_items/~s/usage_record_summaries", [VarSubscriptionItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             usage_record_summary}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payment_intents_intent(post_payment_intents_intent_request()) ->
                                     result(post_payment_intents_intent_response()).
post_payment_intents_intent(Args) ->
    post_payment_intents_intent(Args, #{}).

-spec post_payment_intents_intent(post_payment_intents_intent_request(), options()) ->
                                     result(post_payment_intents_intent_response()).
post_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_payment_intents_intent(get_payment_intents_intent_request()) ->
                                    result(get_payment_intents_intent_response()).
get_payment_intents_intent(Args) ->
    get_payment_intents_intent(Args, #{}).

-spec get_payment_intents_intent(get_payment_intents_intent_request(), options()) ->
                                    result(get_payment_intents_intent_response()).
get_payment_intents_intent(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({client_secret, Value}) ->
                encode_q(form, false, <<"client_secret">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_charges(post_charges_request()) -> result(post_charges_response()).
post_charges(Args) ->
    post_charges(Args, #{}).

-spec post_charges(post_charges_request(), options()) -> result(post_charges_response()).
post_charges(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, charge},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_charges(get_charges_request()) -> result(get_charges_response()).
get_charges(Args) ->
    get_charges(Args, #{}).

-spec get_charges(get_charges_request(), options()) -> result(get_charges_response()).
get_charges(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({transfer_group, Value}) ->
                encode_q(form, false, <<"transfer_group">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, charge}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_accounts_account_external_accounts(post_accounts_account_external_accounts_request()) ->
                                               result(post_accounts_account_external_accounts_response()).
post_accounts_account_external_accounts(Args) ->
    post_accounts_account_external_accounts(Args, #{}).

-spec
    post_accounts_account_external_accounts(post_accounts_account_external_accounts_request(),
                                            options()) ->
                                               result(post_accounts_account_external_accounts_response()).
post_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_accounts_account_external_accounts(get_accounts_account_external_accounts_request()) ->
                                              result(get_accounts_account_external_accounts_response()).
get_accounts_account_external_accounts(Args) ->
    get_accounts_account_external_accounts(Args, #{}).

-spec
    get_accounts_account_external_accounts(get_accounts_account_external_accounts_request(),
                                           options()) ->
                                              result(get_accounts_account_external_accounts_response()).
get_accounts_account_external_accounts(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/external_accounts", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {one_of,
                                                                             [{ref,
                                                                               stripe,
                                                                               bank_account},
                                                                              {ref,
                                                                               stripe,
                                                                               card}]}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_authorizations(get_issuing_authorizations_request()) ->
                                    result(get_issuing_authorizations_response()).
get_issuing_authorizations(Args) ->
    get_issuing_authorizations(Args, #{}).

-spec get_issuing_authorizations(get_issuing_authorizations_request(), options()) ->
                                    result(get_issuing_authorizations_response()).
get_issuing_authorizations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({card, Value}) ->
                encode_q(form, false, <<"card">>, Value);
            ({cardholder, Value}) ->
                encode_q(form, false, <<"cardholder">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             issuing_authorization}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_products_id(delete_products_id_request()) ->
                            result(delete_products_id_response()).
delete_products_id(Args) ->
    delete_products_id(Args, #{}).

-spec delete_products_id(delete_products_id_request(), options()) ->
                            result(delete_products_id_response()).
delete_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_product},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_products_id(post_products_id_request()) -> result(post_products_id_response()).
post_products_id(Args) ->
    post_products_id(Args, #{}).

-spec post_products_id(post_products_id_request(), options()) ->
                          result(post_products_id_response()).
post_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, product},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_products_id(get_products_id_request()) -> result(get_products_id_response()).
get_products_id(Args) ->
    get_products_id(Args, #{}).

-spec get_products_id(get_products_id_request(), options()) ->
                         result(get_products_id_response()).
get_products_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/products/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, product},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_setup_intents_intent_verify_microdeposits(post_setup_intents_intent_verify_microdeposits_request()) ->
                                                      result(post_setup_intents_intent_verify_microdeposits_response()).
post_setup_intents_intent_verify_microdeposits(Args) ->
    post_setup_intents_intent_verify_microdeposits(Args, #{}).

-spec
    post_setup_intents_intent_verify_microdeposits(post_setup_intents_intent_verify_microdeposits_request(),
                                                   options()) ->
                                                      result(post_setup_intents_intent_verify_microdeposits_response()).
post_setup_intents_intent_verify_microdeposits(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s/verify_microdeposits", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, setup_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_reporting_report_types(get_reporting_report_types_request()) ->
                                    result(get_reporting_report_types_response()).
get_reporting_report_types(Args) ->
    get_reporting_report_types(Args, #{}).

-spec get_reporting_report_types(get_reporting_report_types_request(), options()) ->
                                    result(get_reporting_report_types_response()).
get_reporting_report_types(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_types", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             reporting_report_type}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_external_accounts(post_account_external_accounts_request()) ->
                                        result(post_account_external_accounts_response()).
post_account_external_accounts(Args) ->
    post_account_external_accounts(Args, #{}).

-spec post_account_external_accounts(post_account_external_accounts_request(),
                                     options()) ->
                                        result(post_account_external_accounts_response()).
post_account_external_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_account_external_accounts(get_account_external_accounts_request()) ->
                                       result(get_account_external_accounts_response()).
get_account_external_accounts(Args) ->
    get_account_external_accounts(Args, #{}).

-spec get_account_external_accounts(get_account_external_accounts_request(), options()) ->
                                       result(get_account_external_accounts_response()).
get_account_external_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/external_accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {one_of,
                                                                             [{ref,
                                                                               stripe,
                                                                               bank_account},
                                                                              {ref,
                                                                               stripe,
                                                                               card}]}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_radar_value_lists(post_radar_value_lists_request()) ->
                                result(post_radar_value_lists_response()).
post_radar_value_lists(Args) ->
    post_radar_value_lists(Args, #{}).

-spec post_radar_value_lists(post_radar_value_lists_request(), options()) ->
                                result(post_radar_value_lists_response()).
post_radar_value_lists(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, radar_value_list},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_radar_value_lists(get_radar_value_lists_request()) ->
                               result(get_radar_value_lists_response()).
get_radar_value_lists(Args) ->
    get_radar_value_lists(Args, #{}).

-spec get_radar_value_lists(get_radar_value_lists_request(), options()) ->
                               result(get_radar_value_lists_response()).
get_radar_value_lists(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({alias, Value}) ->
                encode_q(form, false, <<"alias">>, Value);
            ({contains, Value}) ->
                encode_q(form, false, <<"contains">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_lists", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             radar_value_list}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_shipping_rates(post_shipping_rates_request()) ->
                             result(post_shipping_rates_response()).
post_shipping_rates(Args) ->
    post_shipping_rates(Args, #{}).

-spec post_shipping_rates(post_shipping_rates_request(), options()) ->
                             result(post_shipping_rates_response()).
post_shipping_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, shipping_rate},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_shipping_rates(get_shipping_rates_request()) ->
                            result(get_shipping_rates_response()).
get_shipping_rates(Args) ->
    get_shipping_rates(Args, #{}).

-spec get_shipping_rates(get_shipping_rates_request(), options()) ->
                            result(get_shipping_rates_response()).
get_shipping_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/shipping_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             shipping_rate}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_file_links_link(post_file_links_link_request()) ->
                              result(post_file_links_link_response()).
post_file_links_link(Args) ->
    post_file_links_link(Args, #{}).

-spec post_file_links_link(post_file_links_link_request(), options()) ->
                              result(post_file_links_link_response()).
post_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/file_links/~s", [VarLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, file_link},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_file_links_link(get_file_links_link_request()) ->
                             result(get_file_links_link_response()).
get_file_links_link(Args) ->
    get_file_links_link(Args, #{}).

-spec get_file_links_link(get_file_links_link_request(), options()) ->
                             result(get_file_links_link_response()).
get_file_links_link(Args, Options) ->
    VarLink = maps:get(link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/file_links/~s", [VarLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, file_link},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get3d_secure_three_d_secure(get3d_secure_three_d_secure_request()) ->
                                     result(get3d_secure_three_d_secure_response()).
get3d_secure_three_d_secure(Args) ->
    get3d_secure_three_d_secure(Args, #{}).

-spec get3d_secure_three_d_secure(get3d_secure_three_d_secure_request(), options()) ->
                                     result(get3d_secure_three_d_secure_response()).
get3d_secure_three_d_secure(Args, Options) ->
    VarThreeDSecure = maps:get(three_d_secure, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/3d_secure/~s", [VarThreeDSecure]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, three_d_secure},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_invoices_invoice_send(post_invoices_invoice_send_request()) ->
                                    result(post_invoices_invoice_send_response()).
post_invoices_invoice_send(Args) ->
    post_invoices_invoice_send(Args, #{}).

-spec post_invoices_invoice_send(post_invoices_invoice_send_request(), options()) ->
                                    result(post_invoices_invoice_send_response()).
post_invoices_invoice_send(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/send", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_invoices_upcoming(get_invoices_upcoming_request()) ->
                               result(get_invoices_upcoming_response()).
get_invoices_upcoming(Args) ->
    get_invoices_upcoming(Args, #{}).

-spec get_invoices_upcoming(get_invoices_upcoming_request(), options()) ->
                               result(get_invoices_upcoming_response()).
get_invoices_upcoming(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({automatic_tax, Value}) ->
                encode_q(deepObject, true, <<"automatic_tax">>, Value);
            ({coupon, Value}) ->
                encode_q(form, false, <<"coupon">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({customer_details, Value}) ->
                encode_q(deepObject, true, <<"customer_details">>, Value);
            ({discounts, Value}) ->
                encode_q(deepObject, true, <<"discounts">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice_items, Value}) ->
                encode_q(deepObject, true, <<"invoice_items">>, Value);
            ({schedule, Value}) ->
                encode_q(form, false, <<"schedule">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({subscription_billing_cycle_anchor, Value}) ->
                encode_q(deepObject, true, <<"subscription_billing_cycle_anchor">>, Value);
            ({subscription_cancel_at, Value}) ->
                encode_q(deepObject, true, <<"subscription_cancel_at">>, Value);
            ({subscription_cancel_at_period_end, Value}) ->
                encode_q(form, false, <<"subscription_cancel_at_period_end">>, Value);
            ({subscription_cancel_now, Value}) ->
                encode_q(form, false, <<"subscription_cancel_now">>, Value);
            ({subscription_default_tax_rates, Value}) ->
                encode_q(deepObject, true, <<"subscription_default_tax_rates">>, Value);
            ({subscription_items, Value}) ->
                encode_q(deepObject, true, <<"subscription_items">>, Value);
            ({subscription_proration_behavior, Value}) ->
                encode_q(form, false, <<"subscription_proration_behavior">>, Value);
            ({subscription_proration_date, Value}) ->
                encode_q(form, false, <<"subscription_proration_date">>, Value);
            ({subscription_start_date, Value}) ->
                encode_q(form, false, <<"subscription_start_date">>, Value);
            ({subscription_trial_end, Value}) ->
                encode_q(deepObject, true, <<"subscription_trial_end">>, Value);
            ({subscription_trial_from_plan, Value}) ->
                encode_q(form, false, <<"subscription_trial_from_plan">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/upcoming", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_checkout_sessions_session_line_items(get_checkout_sessions_session_line_items_request()) ->
                                                result(get_checkout_sessions_session_line_items_response()).
get_checkout_sessions_session_line_items(Args) ->
    get_checkout_sessions_session_line_items(Args, #{}).

-spec
    get_checkout_sessions_session_line_items(get_checkout_sessions_session_line_items_request(),
                                             options()) ->
                                                result(get_checkout_sessions_session_line_items_response()).
get_checkout_sessions_session_line_items(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions/~s/line_items", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_tax_codes(get_tax_codes_request()) -> result(get_tax_codes_response()).
get_tax_codes(Args) ->
    get_tax_codes(Args, #{}).

-spec get_tax_codes(get_tax_codes_request(), options()) ->
                       result(get_tax_codes_response()).
get_tax_codes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_codes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             tax_code}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_invoices(post_invoices_request()) -> result(post_invoices_response()).
post_invoices(Args) ->
    post_invoices(Args, #{}).

-spec post_invoices(post_invoices_request(), options()) ->
                       result(post_invoices_response()).
post_invoices(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_invoices(get_invoices_request()) -> result(get_invoices_response()).
get_invoices(Args) ->
    get_invoices(Args, #{}).

-spec get_invoices(get_invoices_request(), options()) -> result(get_invoices_response()).
get_invoices(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({collection_method, Value}) ->
                encode_q(form, false, <<"collection_method">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({due_date, Value}) ->
                encode_q(deepObject, true, <<"due_date">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             invoice}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_charges_charge(post_charges_charge_request()) ->
                             result(post_charges_charge_response()).
post_charges_charge(Args) ->
    post_charges_charge(Args, #{}).

-spec post_charges_charge(post_charges_charge_request(), options()) ->
                             result(post_charges_charge_response()).
post_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, charge},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_charges_charge(get_charges_charge_request()) ->
                            result(get_charges_charge_response()).
get_charges_charge(Args) ->
    get_charges_charge(Args, #{}).

-spec get_charges_charge(get_charges_charge_request(), options()) ->
                            result(get_charges_charge_response()).
get_charges_charge(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, charge},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_invoices_invoice_mark_uncollectible(post_invoices_invoice_mark_uncollectible_request()) ->
                                                result(post_invoices_invoice_mark_uncollectible_response()).
post_invoices_invoice_mark_uncollectible(Args) ->
    post_invoices_invoice_mark_uncollectible(Args, #{}).

-spec
    post_invoices_invoice_mark_uncollectible(post_invoices_invoice_mark_uncollectible_request(),
                                             options()) ->
                                                result(post_invoices_invoice_mark_uncollectible_response()).
post_invoices_invoice_mark_uncollectible(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/mark_uncollectible", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_customers_customer_sources_id_verify(post_customers_customer_sources_id_verify_request()) ->
                                                 result(post_customers_customer_sources_id_verify_response()).
post_customers_customer_sources_id_verify(Args) ->
    post_customers_customer_sources_id_verify(Args, #{}).

-spec
    post_customers_customer_sources_id_verify(post_customers_customer_sources_id_verify_request(),
                                              options()) ->
                                                 result(post_customers_customer_sources_id_verify_response()).
post_customers_customer_sources_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s/verify", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, bank_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_orders_id_pay(post_orders_id_pay_request()) ->
                            result(post_orders_id_pay_response()).
post_orders_id_pay(Args) ->
    post_orders_id_pay(Args, #{}).

-spec post_orders_id_pay(post_orders_id_pay_request(), options()) ->
                            result(post_orders_id_pay_response()).
post_orders_id_pay(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/orders/~s/pay", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, order},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_customers_customer_bank_accounts_id_verify(post_customers_customer_bank_accounts_id_verify_request()) ->
                                                       result(post_customers_customer_bank_accounts_id_verify_response()).
post_customers_customer_bank_accounts_id_verify(Args) ->
    post_customers_customer_bank_accounts_id_verify(Args, #{}).

-spec
    post_customers_customer_bank_accounts_id_verify(post_customers_customer_bank_accounts_id_verify_request(),
                                                    options()) ->
                                                       result(post_customers_customer_bank_accounts_id_verify_response()).
post_customers_customer_bank_accounts_id_verify(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/bank_accounts/~s/verify", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, bank_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_account_people_person(delete_account_people_person_request()) ->
                                      result(delete_account_people_person_response()).
delete_account_people_person(Args) ->
    delete_account_people_person(Args, #{}).

-spec delete_account_people_person(delete_account_people_person_request(), options()) ->
                                      result(delete_account_people_person_response()).
delete_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_people_person(post_account_people_person_request()) ->
                                    result(post_account_people_person_response()).
post_account_people_person(Args) ->
    post_account_people_person(Args, #{}).

-spec post_account_people_person(post_account_people_person_request(), options()) ->
                                    result(post_account_people_person_response()).
post_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_account_people_person(get_account_people_person_request()) ->
                                   result(get_account_people_person_response()).
get_account_people_person(Args) ->
    get_account_people_person(Args, #{}).

-spec get_account_people_person(get_account_people_person_request(), options()) ->
                                   result(get_account_people_person_response()).
get_account_people_person(Args, Options) ->
    VarPerson = maps:get(person, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/people/~s", [VarPerson]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_checkout_sessions(post_checkout_sessions_request()) ->
                                result(post_checkout_sessions_response()).
post_checkout_sessions(Args) ->
    post_checkout_sessions(Args, #{}).

-spec post_checkout_sessions(post_checkout_sessions_request(), options()) ->
                                result(post_checkout_sessions_response()).
post_checkout_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, checkout_session},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_checkout_sessions(get_checkout_sessions_request()) ->
                               result(get_checkout_sessions_response()).
get_checkout_sessions(Args) ->
    get_checkout_sessions(Args, #{}).

-spec get_checkout_sessions(get_checkout_sessions_request(), options()) ->
                               result(get_checkout_sessions_response()).
get_checkout_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             checkout_session}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_accounts_account_login_links(post_accounts_account_login_links_request()) ->
                                           result(post_accounts_account_login_links_response()).
post_accounts_account_login_links(Args) ->
    post_accounts_account_login_links(Args, #{}).

-spec post_accounts_account_login_links(post_accounts_account_login_links_request(),
                                        options()) ->
                                           result(post_accounts_account_login_links_response()).
post_accounts_account_login_links(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/login_links", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, login_link},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_terminal_readers(post_terminal_readers_request()) ->
                               result(post_terminal_readers_response()).
post_terminal_readers(Args) ->
    post_terminal_readers(Args, #{}).

-spec post_terminal_readers(post_terminal_readers_request(), options()) ->
                               result(post_terminal_readers_response()).
post_terminal_readers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, terminal_reader},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_terminal_readers(get_terminal_readers_request()) ->
                              result(get_terminal_readers_response()).
get_terminal_readers(Args) ->
    get_terminal_readers(Args, #{}).

-spec get_terminal_readers(get_terminal_readers_request(), options()) ->
                              result(get_terminal_readers_response()).
get_terminal_readers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({device_type, Value}) ->
                encode_q(form, false, <<"device_type">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({location, Value}) ->
                encode_q(form, false, <<"location">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/readers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             terminal_reader}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_issuing_disputes(post_issuing_disputes_request()) ->
                               result(post_issuing_disputes_response()).
post_issuing_disputes(Args) ->
    post_issuing_disputes(Args, #{}).

-spec post_issuing_disputes(post_issuing_disputes_request(), options()) ->
                               result(post_issuing_disputes_response()).
post_issuing_disputes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_disputes(get_issuing_disputes_request()) ->
                              result(get_issuing_disputes_response()).
get_issuing_disputes(Args) ->
    get_issuing_disputes(Args, #{}).

-spec get_issuing_disputes(get_issuing_disputes_request(), options()) ->
                              result(get_issuing_disputes_response()).
get_issuing_disputes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({transaction, Value}) ->
                encode_q(form, false, <<"transaction">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             issuing_dispute}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post3d_secure(post3d_secure_request()) -> result(post3d_secure_response()).
post3d_secure(Args) ->
    post3d_secure(Args, #{}).

-spec post3d_secure(post3d_secure_request(), options()) ->
                       result(post3d_secure_response()).
post3d_secure(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/3d_secure", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, three_d_secure},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_prices(post_prices_request()) -> result(post_prices_response()).
post_prices(Args) ->
    post_prices(Args, #{}).

-spec post_prices(post_prices_request(), options()) -> result(post_prices_response()).
post_prices(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/prices", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, price},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_prices(get_prices_request()) -> result(get_prices_response()).
get_prices(Args) ->
    get_prices(Args, #{}).

-spec get_prices(get_prices_request(), options()) -> result(get_prices_response()).
get_prices(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({lookup_keys, Value}) ->
                encode_q(deepObject, true, <<"lookup_keys">>, Value);
            ({product, Value}) ->
                encode_q(form, false, <<"product">>, Value);
            ({recurring, Value}) ->
                encode_q(deepObject, true, <<"recurring">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/prices", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, price}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_invoices_invoice(delete_invoices_invoice_request()) ->
                                 result(delete_invoices_invoice_response()).
delete_invoices_invoice(Args) ->
    delete_invoices_invoice(Args, #{}).

-spec delete_invoices_invoice(delete_invoices_invoice_request(), options()) ->
                                 result(delete_invoices_invoice_response()).
delete_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_invoices_invoice(post_invoices_invoice_request()) ->
                               result(post_invoices_invoice_response()).
post_invoices_invoice(Args) ->
    post_invoices_invoice(Args, #{}).

-spec post_invoices_invoice(post_invoices_invoice_request(), options()) ->
                               result(post_invoices_invoice_response()).
post_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_invoices_invoice(get_invoices_invoice_request()) ->
                              result(get_invoices_invoice_response()).
get_invoices_invoice(Args) ->
    get_invoices_invoice(Args, #{}).

-spec get_invoices_invoice(get_invoices_invoice_request(), options()) ->
                              result(get_invoices_invoice_response()).
get_invoices_invoice(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_identity_verification_sessions_session(post_identity_verification_sessions_session_request()) ->
                                                   result(post_identity_verification_sessions_session_response()).
post_identity_verification_sessions_session(Args) ->
    post_identity_verification_sessions_session(Args, #{}).

-spec
    post_identity_verification_sessions_session(post_identity_verification_sessions_session_request(),
                                                options()) ->
                                                   result(post_identity_verification_sessions_session_response()).
post_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref,
                                                         stripe,
                                                         identity_verification_session},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_identity_verification_sessions_session(get_identity_verification_sessions_session_request()) ->
                                                  result(get_identity_verification_sessions_session_response()).
get_identity_verification_sessions_session(Args) ->
    get_identity_verification_sessions_session(Args, #{}).

-spec
    get_identity_verification_sessions_session(get_identity_verification_sessions_session_request(),
                                               options()) ->
                                                  result(get_identity_verification_sessions_session_response()).
get_identity_verification_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/identity/verification_sessions/~s", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref,
                                                         stripe,
                                                         identity_verification_session},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_balance_transactions_id(get_balance_transactions_id_request()) ->
                                     result(get_balance_transactions_id_response()).
get_balance_transactions_id(Args) ->
    get_balance_transactions_id(Args, #{}).

-spec get_balance_transactions_id(get_balance_transactions_id_request(), options()) ->
                                     result(get_balance_transactions_id_response()).
get_balance_transactions_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance_transactions/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, balance_transaction},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_setup_intents_intent_cancel(post_setup_intents_intent_cancel_request()) ->
                                          result(post_setup_intents_intent_cancel_response()).
post_setup_intents_intent_cancel(Args) ->
    post_setup_intents_intent_cancel(Args, #{}).

-spec post_setup_intents_intent_cancel(post_setup_intents_intent_cancel_request(),
                                       options()) ->
                                          result(post_setup_intents_intent_cancel_response()).
post_setup_intents_intent_cancel(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents/~s/cancel", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, setup_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_issuing_transactions_transaction(post_issuing_transactions_transaction_request()) ->
                                             result(post_issuing_transactions_transaction_response()).
post_issuing_transactions_transaction(Args) ->
    post_issuing_transactions_transaction(Args, #{}).

-spec
    post_issuing_transactions_transaction(post_issuing_transactions_transaction_request(),
                                          options()) ->
                                             result(post_issuing_transactions_transaction_response()).
post_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/transactions/~s", [VarTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_transaction},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_issuing_transactions_transaction(get_issuing_transactions_transaction_request()) ->
                                            result(get_issuing_transactions_transaction_response()).
get_issuing_transactions_transaction(Args) ->
    get_issuing_transactions_transaction(Args, #{}).

-spec get_issuing_transactions_transaction(get_issuing_transactions_transaction_request(),
                                           options()) ->
                                              result(get_issuing_transactions_transaction_response()).
get_issuing_transactions_transaction(Args, Options) ->
    VarTransaction = maps:get(transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/transactions/~s", [VarTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_transaction},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_terminal_connection_tokens(post_terminal_connection_tokens_request()) ->
                                         result(post_terminal_connection_tokens_response()).
post_terminal_connection_tokens(Args) ->
    post_terminal_connection_tokens(Args, #{}).

-spec post_terminal_connection_tokens(post_terminal_connection_tokens_request(),
                                      options()) ->
                                         result(post_terminal_connection_tokens_response()).
post_terminal_connection_tokens(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/connection_tokens", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, terminal_connection_token},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_reviews(get_reviews_request()) -> result(get_reviews_response()).
get_reviews(Args) ->
    get_reviews(Args, #{}).

-spec get_reviews(get_reviews_request(), options()) -> result(get_reviews_response()).
get_reviews(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reviews", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, review}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_promotion_codes(post_promotion_codes_request()) ->
                              result(post_promotion_codes_response()).
post_promotion_codes(Args) ->
    post_promotion_codes(Args, #{}).

-spec post_promotion_codes(post_promotion_codes_request(), options()) ->
                              result(post_promotion_codes_response()).
post_promotion_codes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, promotion_code},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_promotion_codes(get_promotion_codes_request()) ->
                             result(get_promotion_codes_response()).
get_promotion_codes(Args) ->
    get_promotion_codes(Args, #{}).

-spec get_promotion_codes(get_promotion_codes_request(), options()) ->
                             result(get_promotion_codes_response()).
get_promotion_codes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({code, Value}) ->
                encode_q(form, false, <<"code">>, Value);
            ({coupon, Value}) ->
                encode_q(form, false, <<"coupon">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/promotion_codes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             promotion_code}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(delete_customers_customer_subscriptions_subscription_exposed_id_discount_request()) ->
                                                                                result(delete_customers_customer_subscriptions_subscription_exposed_id_discount_response()).
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec
    delete_customers_customer_subscriptions_subscription_exposed_id_discount(delete_customers_customer_subscriptions_subscription_exposed_id_discount_request(),
                                                                             options()) ->
                                                                                result(delete_customers_customer_subscriptions_subscription_exposed_id_discount_response()).
delete_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s/discount",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_discount},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_customers_customer_subscriptions_subscription_exposed_id_discount(get_customers_customer_subscriptions_subscription_exposed_id_discount_request()) ->
                                                                             result(get_customers_customer_subscriptions_subscription_exposed_id_discount_response()).
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args) ->
    get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, #{}).

-spec
    get_customers_customer_subscriptions_subscription_exposed_id_discount(get_customers_customer_subscriptions_subscription_exposed_id_discount_request(),
                                                                          options()) ->
                                                                             result(get_customers_customer_subscriptions_subscription_exposed_id_discount_response()).
get_customers_customer_subscriptions_subscription_exposed_id_discount(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/customers/~s/subscriptions/~s/discount",
                      [VarCustomer, VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, discount},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_quotes_quote_computed_upfront_line_items(get_quotes_quote_computed_upfront_line_items_request()) ->
                                                    result(get_quotes_quote_computed_upfront_line_items_response()).
get_quotes_quote_computed_upfront_line_items(Args) ->
    get_quotes_quote_computed_upfront_line_items(Args, #{}).

-spec
    get_quotes_quote_computed_upfront_line_items(get_quotes_quote_computed_upfront_line_items_request(),
                                                 options()) ->
                                                    result(get_quotes_quote_computed_upfront_line_items_response()).
get_quotes_quote_computed_upfront_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/computed_upfront_line_items", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_radar_value_list_items_item(delete_radar_value_list_items_item_request()) ->
                                            result(delete_radar_value_list_items_item_response()).
delete_radar_value_list_items_item(Args) ->
    delete_radar_value_list_items_item(Args, #{}).

-spec delete_radar_value_list_items_item(delete_radar_value_list_items_item_request(),
                                         options()) ->
                                            result(delete_radar_value_list_items_item_response()).
delete_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_list_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref,
                                                         stripe,
                                                         deleted_radar_value_list_item},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_radar_value_list_items_item(get_radar_value_list_items_item_request()) ->
                                         result(get_radar_value_list_items_item_response()).
get_radar_value_list_items_item(Args) ->
    get_radar_value_list_items_item(Args, #{}).

-spec get_radar_value_list_items_item(get_radar_value_list_items_item_request(),
                                      options()) ->
                                         result(get_radar_value_list_items_item_response()).
get_radar_value_list_items_item(Args, Options) ->
    VarItem = maps:get(item, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/radar/value_list_items/~s", [VarItem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, radar_value_list_item},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuer_fraud_records(get_issuer_fraud_records_request()) ->
                                  result(get_issuer_fraud_records_response()).
get_issuer_fraud_records(Args) ->
    get_issuer_fraud_records(Args, #{}).

-spec get_issuer_fraud_records(get_issuer_fraud_records_request(), options()) ->
                                  result(get_issuer_fraud_records_response()).
get_issuer_fraud_records(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuer_fraud_records", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             issuer_fraud_record}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_tax_rates_tax_rate(post_tax_rates_tax_rate_request()) ->
                                 result(post_tax_rates_tax_rate_response()).
post_tax_rates_tax_rate(Args) ->
    post_tax_rates_tax_rate(Args, #{}).

-spec post_tax_rates_tax_rate(post_tax_rates_tax_rate_request(), options()) ->
                                 result(post_tax_rates_tax_rate_response()).
post_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_rates/~s", [VarTaxRate]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, tax_rate},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_tax_rates_tax_rate(get_tax_rates_tax_rate_request()) ->
                                result(get_tax_rates_tax_rate_response()).
get_tax_rates_tax_rate(Args) ->
    get_tax_rates_tax_rate(Args, #{}).

-spec get_tax_rates_tax_rate(get_tax_rates_tax_rate_request(), options()) ->
                                result(get_tax_rates_tax_rate_response()).
get_tax_rates_tax_rate(Args, Options) ->
    VarTaxRate = maps:get(tax_rate, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_rates/~s", [VarTaxRate]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, tax_rate},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_recipients(post_recipients_request()) -> result(post_recipients_response()).
post_recipients(Args) ->
    post_recipients(Args, #{}).

-spec post_recipients(post_recipients_request(), options()) ->
                         result(post_recipients_response()).
post_recipients(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, recipient},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_recipients(get_recipients_request()) -> result(get_recipients_response()).
get_recipients(Args) ->
    get_recipients(Args, #{}).

-spec get_recipients(get_recipients_request(), options()) ->
                        result(get_recipients_response()).
get_recipients(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({verified, Value}) ->
                encode_q(form, false, <<"verified">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/recipients", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             recipient}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_plans(post_plans_request()) -> result(post_plans_response()).
post_plans(Args) ->
    post_plans(Args, #{}).

-spec post_plans(post_plans_request(), options()) -> result(post_plans_response()).
post_plans(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, plan},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_plans(get_plans_request()) -> result(get_plans_response()).
get_plans(Args) ->
    get_plans(Args, #{}).

-spec get_plans(get_plans_request(), options()) -> result(get_plans_response()).
get_plans(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({product, Value}) ->
                encode_q(form, false, <<"product">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/plans", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, plan}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_customers_customer_balance_transactions(post_customers_customer_balance_transactions_request()) ->
                                                    result(post_customers_customer_balance_transactions_response()).
post_customers_customer_balance_transactions(Args) ->
    post_customers_customer_balance_transactions(Args, #{}).

-spec
    post_customers_customer_balance_transactions(post_customers_customer_balance_transactions_request(),
                                                 options()) ->
                                                    result(post_customers_customer_balance_transactions_response()).
post_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/balance_transactions", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, customer_balance_transaction},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_customers_customer_balance_transactions(get_customers_customer_balance_transactions_request()) ->
                                                   result(get_customers_customer_balance_transactions_response()).
get_customers_customer_balance_transactions(Args) ->
    get_customers_customer_balance_transactions(Args, #{}).

-spec
    get_customers_customer_balance_transactions(get_customers_customer_balance_transactions_request(),
                                                options()) ->
                                                   result(get_customers_customer_balance_transactions_response()).
get_customers_customer_balance_transactions(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/balance_transactions", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             customer_balance_transaction}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_reviews_review_approve(post_reviews_review_approve_request()) ->
                                     result(post_reviews_review_approve_response()).
post_reviews_review_approve(Args) ->
    post_reviews_review_approve(Args, #{}).

-spec post_reviews_review_approve(post_reviews_review_approve_request(), options()) ->
                                     result(post_reviews_review_approve_response()).
post_reviews_review_approve(Args, Options) ->
    VarReview = maps:get(review, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reviews/~s/approve", [VarReview]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, review},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_customers_customer_tax_ids(post_customers_customer_tax_ids_request()) ->
                                         result(post_customers_customer_tax_ids_response()).
post_customers_customer_tax_ids(Args) ->
    post_customers_customer_tax_ids(Args, #{}).

-spec post_customers_customer_tax_ids(post_customers_customer_tax_ids_request(),
                                      options()) ->
                                         result(post_customers_customer_tax_ids_response()).
post_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, tax_id},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_customers_customer_tax_ids(get_customers_customer_tax_ids_request()) ->
                                        result(get_customers_customer_tax_ids_response()).
get_customers_customer_tax_ids(Args) ->
    get_customers_customer_tax_ids(Args, #{}).

-spec get_customers_customer_tax_ids(get_customers_customer_tax_ids_request(),
                                     options()) ->
                                        result(get_customers_customer_tax_ids_response()).
get_customers_customer_tax_ids(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/tax_ids", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, tax_id}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_tokens_token(get_tokens_token_request()) -> result(get_tokens_token_response()).
get_tokens_token(Args) ->
    get_tokens_token(Args, #{}).

-spec get_tokens_token(get_tokens_token_request(), options()) ->
                          result(get_tokens_token_response()).
get_tokens_token(Args, Options) ->
    VarToken = maps:get(token, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tokens/~s", [VarToken]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, token},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_balance_transactions(get_balance_transactions_request()) ->
                                  result(get_balance_transactions_response()).
get_balance_transactions(Args) ->
    get_balance_transactions(Args, #{}).

-spec get_balance_transactions(get_balance_transactions_request(), options()) ->
                                  result(get_balance_transactions_response()).
get_balance_transactions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({currency, Value}) ->
                encode_q(form, false, <<"currency">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payout, Value}) ->
                encode_q(form, false, <<"payout">>, Value);
            ({source, Value}) ->
                encode_q(form, false, <<"source">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance_transactions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             balance_transaction}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_tax_codes_id(get_tax_codes_id_request()) -> result(get_tax_codes_id_response()).
get_tax_codes_id(Args) ->
    get_tax_codes_id(Args, #{}).

-spec get_tax_codes_id(get_tax_codes_id_request(), options()) ->
                          result(get_tax_codes_id_response()).
get_tax_codes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_codes/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, tax_code},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_accounts_account_reject(post_accounts_account_reject_request()) ->
                                      result(post_accounts_account_reject_response()).
post_accounts_account_reject(Args) ->
    post_accounts_account_reject(Args, #{}).

-spec post_accounts_account_reject(post_accounts_account_reject_request(), options()) ->
                                      result(post_accounts_account_reject_response()).
post_accounts_account_reject(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/reject", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_subscriptions_subscription_exposed_id(delete_subscriptions_subscription_exposed_id_request()) ->
                                                    result(delete_subscriptions_subscription_exposed_id_response()).
delete_subscriptions_subscription_exposed_id(Args) ->
    delete_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    delete_subscriptions_subscription_exposed_id(delete_subscriptions_subscription_exposed_id_request(),
                                                 options()) ->
                                                    result(delete_subscriptions_subscription_exposed_id_response()).
delete_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_subscriptions_subscription_exposed_id(post_subscriptions_subscription_exposed_id_request()) ->
                                                  result(post_subscriptions_subscription_exposed_id_response()).
post_subscriptions_subscription_exposed_id(Args) ->
    post_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    post_subscriptions_subscription_exposed_id(post_subscriptions_subscription_exposed_id_request(),
                                               options()) ->
                                                  result(post_subscriptions_subscription_exposed_id_response()).
post_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_subscriptions_subscription_exposed_id(get_subscriptions_subscription_exposed_id_request()) ->
                                                 result(get_subscriptions_subscription_exposed_id_response()).
get_subscriptions_subscription_exposed_id(Args) ->
    get_subscriptions_subscription_exposed_id(Args, #{}).

-spec
    get_subscriptions_subscription_exposed_id(get_subscriptions_subscription_exposed_id_request(),
                                              options()) ->
                                                 result(get_subscriptions_subscription_exposed_id_response()).
get_subscriptions_subscription_exposed_id(Args, Options) ->
    VarSubscriptionExposedId = maps:get(subscription_exposed_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscriptions/~s", [VarSubscriptionExposedId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_country_specs_country(get_country_specs_country_request()) ->
                                   result(get_country_specs_country_response()).
get_country_specs_country(Args) ->
    get_country_specs_country(Args, #{}).

-spec get_country_specs_country(get_country_specs_country_request(), options()) ->
                                   result(get_country_specs_country_response()).
get_country_specs_country(Args, Options) ->
    VarCountry = maps:get(country, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/country_specs/~s", [VarCountry]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, country_spec},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_invoices_invoice_finalize(post_invoices_invoice_finalize_request()) ->
                                        result(post_invoices_invoice_finalize_response()).
post_invoices_invoice_finalize(Args) ->
    post_invoices_invoice_finalize(Args, #{}).

-spec post_invoices_invoice_finalize(post_invoices_invoice_finalize_request(),
                                     options()) ->
                                        result(post_invoices_invoice_finalize_response()).
post_invoices_invoice_finalize(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/finalize", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_terminal_locations_location(delete_terminal_locations_location_request()) ->
                                            result(delete_terminal_locations_location_response()).
delete_terminal_locations_location(Args) ->
    delete_terminal_locations_location(Args, #{}).

-spec delete_terminal_locations_location(delete_terminal_locations_location_request(),
                                         options()) ->
                                            result(delete_terminal_locations_location_response()).
delete_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, deleted_terminal_location},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_terminal_locations_location(post_terminal_locations_location_request()) ->
                                          result(post_terminal_locations_location_response()).
post_terminal_locations_location(Args) ->
    post_terminal_locations_location(Args, #{}).

-spec post_terminal_locations_location(post_terminal_locations_location_request(),
                                       options()) ->
                                          result(post_terminal_locations_location_response()).
post_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, terminal_location},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_terminal_locations_location(get_terminal_locations_location_request()) ->
                                         result(get_terminal_locations_location_response()).
get_terminal_locations_location(Args) ->
    get_terminal_locations_location(Args, #{}).

-spec get_terminal_locations_location(get_terminal_locations_location_request(),
                                      options()) ->
                                         result(get_terminal_locations_location_response()).
get_terminal_locations_location(Args, Options) ->
    VarLocation = maps:get(location, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations/~s", [VarLocation]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, terminal_location},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_account(delete_account_request()) -> result(delete_account_response()).
delete_account(Args) ->
    delete_account(Args, #{}).

-spec delete_account(delete_account_request(), options()) ->
                        result(delete_account_response()).
delete_account(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account(post_account_request()) -> result(post_account_response()).
post_account(Args) ->
    post_account(Args, #{}).

-spec post_account(post_account_request(), options()) -> result(post_account_response()).
post_account(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_account(get_account_request()) -> result(get_account_response()).
get_account(Args) ->
    get_account(Args, #{}).

-spec get_account(get_account_request(), options()) -> result(get_account_response()).
get_account(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_shipping_rates_shipping_rate_token(post_shipping_rates_shipping_rate_token_request()) ->
                                               result(post_shipping_rates_shipping_rate_token_response()).
post_shipping_rates_shipping_rate_token(Args) ->
    post_shipping_rates_shipping_rate_token(Args, #{}).

-spec
    post_shipping_rates_shipping_rate_token(post_shipping_rates_shipping_rate_token_request(),
                                            options()) ->
                                               result(post_shipping_rates_shipping_rate_token_response()).
post_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/shipping_rates/~s", [VarShippingRateToken]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, shipping_rate},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_shipping_rates_shipping_rate_token(get_shipping_rates_shipping_rate_token_request()) ->
                                              result(get_shipping_rates_shipping_rate_token_response()).
get_shipping_rates_shipping_rate_token(Args) ->
    get_shipping_rates_shipping_rate_token(Args, #{}).

-spec
    get_shipping_rates_shipping_rate_token(get_shipping_rates_shipping_rate_token_request(),
                                           options()) ->
                                              result(get_shipping_rates_shipping_rate_token_response()).
get_shipping_rates_shipping_rate_token(Args, Options) ->
    VarShippingRateToken = maps:get(shipping_rate_token, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/shipping_rates/~s", [VarShippingRateToken]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, shipping_rate},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_invoices_upcoming_lines(get_invoices_upcoming_lines_request()) ->
                                     result(get_invoices_upcoming_lines_response()).
get_invoices_upcoming_lines(Args) ->
    get_invoices_upcoming_lines(Args, #{}).

-spec get_invoices_upcoming_lines(get_invoices_upcoming_lines_request(), options()) ->
                                     result(get_invoices_upcoming_lines_response()).
get_invoices_upcoming_lines(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({automatic_tax, Value}) ->
                encode_q(deepObject, true, <<"automatic_tax">>, Value);
            ({coupon, Value}) ->
                encode_q(form, false, <<"coupon">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({customer_details, Value}) ->
                encode_q(deepObject, true, <<"customer_details">>, Value);
            ({discounts, Value}) ->
                encode_q(deepObject, true, <<"discounts">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice_items, Value}) ->
                encode_q(deepObject, true, <<"invoice_items">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({schedule, Value}) ->
                encode_q(form, false, <<"schedule">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({subscription, Value}) ->
                encode_q(form, false, <<"subscription">>, Value);
            ({subscription_billing_cycle_anchor, Value}) ->
                encode_q(deepObject, true, <<"subscription_billing_cycle_anchor">>, Value);
            ({subscription_cancel_at, Value}) ->
                encode_q(deepObject, true, <<"subscription_cancel_at">>, Value);
            ({subscription_cancel_at_period_end, Value}) ->
                encode_q(form, false, <<"subscription_cancel_at_period_end">>, Value);
            ({subscription_cancel_now, Value}) ->
                encode_q(form, false, <<"subscription_cancel_now">>, Value);
            ({subscription_default_tax_rates, Value}) ->
                encode_q(deepObject, true, <<"subscription_default_tax_rates">>, Value);
            ({subscription_items, Value}) ->
                encode_q(deepObject, true, <<"subscription_items">>, Value);
            ({subscription_proration_behavior, Value}) ->
                encode_q(form, false, <<"subscription_proration_behavior">>, Value);
            ({subscription_proration_date, Value}) ->
                encode_q(form, false, <<"subscription_proration_date">>, Value);
            ({subscription_start_date, Value}) ->
                encode_q(form, false, <<"subscription_start_date">>, Value);
            ({subscription_trial_end, Value}) ->
                encode_q(deepObject, true, <<"subscription_trial_end">>, Value);
            ({subscription_trial_from_plan, Value}) ->
                encode_q(form, false, <<"subscription_trial_from_plan">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/upcoming/lines", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             line_item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_issuing_cardholders(post_issuing_cardholders_request()) ->
                                  result(post_issuing_cardholders_response()).
post_issuing_cardholders(Args) ->
    post_issuing_cardholders(Args, #{}).

-spec post_issuing_cardholders(post_issuing_cardholders_request(), options()) ->
                                  result(post_issuing_cardholders_response()).
post_issuing_cardholders(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_cardholder},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_cardholders(get_issuing_cardholders_request()) ->
                                 result(get_issuing_cardholders_response()).
get_issuing_cardholders(Args) ->
    get_issuing_cardholders(Args, #{}).

-spec get_issuing_cardholders(get_issuing_cardholders_request(), options()) ->
                                 result(get_issuing_cardholders_response()).
get_issuing_cardholders(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({email, Value}) ->
                encode_q(form, false, <<"email">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({phone_number, Value}) ->
                encode_q(form, false, <<"phone_number">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cardholders", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             issuing_cardholder}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    delete_customers_customer_sources_id(delete_customers_customer_sources_id_request()) ->
                                            result(delete_customers_customer_sources_id_response()).
delete_customers_customer_sources_id(Args) ->
    delete_customers_customer_sources_id(Args, #{}).

-spec delete_customers_customer_sources_id(delete_customers_customer_sources_id_request(),
                                           options()) ->
                                              result(delete_customers_customer_sources_id_response()).
delete_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, payment_source},
                                                          {ref, stripe, deleted_payment_source}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_customers_customer_sources_id(post_customers_customer_sources_id_request()) ->
                                            result(post_customers_customer_sources_id_response()).
post_customers_customer_sources_id(Args) ->
    post_customers_customer_sources_id(Args, #{}).

-spec post_customers_customer_sources_id(post_customers_customer_sources_id_request(),
                                         options()) ->
                                            result(post_customers_customer_sources_id_response()).
post_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, card},
                                                          {ref, stripe, bank_account},
                                                          {ref, stripe, source}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_customers_customer_sources_id(get_customers_customer_sources_id_request()) ->
                                           result(get_customers_customer_sources_id_response()).
get_customers_customer_sources_id(Args) ->
    get_customers_customer_sources_id(Args, #{}).

-spec get_customers_customer_sources_id(get_customers_customer_sources_id_request(),
                                        options()) ->
                                           result(get_customers_customer_sources_id_response()).
get_customers_customer_sources_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/sources/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_source},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_application_fees(get_application_fees_request()) ->
                              result(get_application_fees_response()).
get_application_fees(Args) ->
    get_application_fees(Args, #{}).

-spec get_application_fees(get_application_fees_request(), options()) ->
                              result(get_application_fees_response()).
get_application_fees(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             application_fee}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_bitcoin_receivers(get_bitcoin_receivers_request()) ->
                               result(get_bitcoin_receivers_response()).
get_bitcoin_receivers(Args) ->
    get_bitcoin_receivers(Args, #{}).

-spec get_bitcoin_receivers(get_bitcoin_receivers_request(), options()) ->
                               result(get_bitcoin_receivers_response()).
get_bitcoin_receivers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({filled, Value}) ->
                encode_q(form, false, <<"filled">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({uncaptured_funds, Value}) ->
                encode_q(form, false, <<"uncaptured_funds">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/bitcoin/receivers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             bitcoin_receiver}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_refunds_refund(post_refunds_refund_request()) ->
                             result(post_refunds_refund_response()).
post_refunds_refund(Args) ->
    post_refunds_refund(Args, #{}).

-spec post_refunds_refund(post_refunds_refund_request(), options()) ->
                             result(post_refunds_refund_response()).
post_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/refunds/~s", [VarRefund]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, refund},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_refunds_refund(get_refunds_refund_request()) ->
                            result(get_refunds_refund_response()).
get_refunds_refund(Args) ->
    get_refunds_refund(Args, #{}).

-spec get_refunds_refund(get_refunds_refund_request(), options()) ->
                            result(get_refunds_refund_response()).
get_refunds_refund(Args, Options) ->
    VarRefund = maps:get(refund, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/refunds/~s", [VarRefund]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, refund},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_login_links(post_account_login_links_request()) ->
                                  result(post_account_login_links_response()).
post_account_login_links(Args) ->
    post_account_login_links(Args, #{}).

-spec post_account_login_links(post_account_login_links_request(), options()) ->
                                  result(post_account_login_links_response()).
post_account_login_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/login_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, login_link},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_tax_rates(post_tax_rates_request()) -> result(post_tax_rates_response()).
post_tax_rates(Args) ->
    post_tax_rates(Args, #{}).

-spec post_tax_rates(post_tax_rates_request(), options()) ->
                        result(post_tax_rates_response()).
post_tax_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, tax_rate},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_tax_rates(get_tax_rates_request()) -> result(get_tax_rates_response()).
get_tax_rates(Args) ->
    get_tax_rates(Args, #{}).

-spec get_tax_rates(get_tax_rates_request(), options()) ->
                       result(get_tax_rates_response()).
get_tax_rates(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({inclusive, Value}) ->
                encode_q(form, false, <<"inclusive">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tax_rates", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             tax_rate}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_accounts_account_people(post_accounts_account_people_request()) ->
                                      result(post_accounts_account_people_response()).
post_accounts_account_people(Args) ->
    post_accounts_account_people(Args, #{}).

-spec post_accounts_account_people(post_accounts_account_people_request(), options()) ->
                                      result(post_accounts_account_people_response()).
post_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, person},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_accounts_account_people(get_accounts_account_people_request()) ->
                                     result(get_accounts_account_people_response()).
get_accounts_account_people(Args) ->
    get_accounts_account_people(Args, #{}).

-spec get_accounts_account_people(get_accounts_account_people_request(), options()) ->
                                     result(get_accounts_account_people_response()).
get_accounts_account_people(Args, Options) ->
    VarAccount = maps:get(account, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({relationship, Value}) ->
                encode_q(deepObject, true, <<"relationship">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/accounts/~s/people", [VarAccount]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, person}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_issuing_disputes_dispute_submit(post_issuing_disputes_dispute_submit_request()) ->
                                            result(post_issuing_disputes_dispute_submit_response()).
post_issuing_disputes_dispute_submit(Args) ->
    post_issuing_disputes_dispute_submit(Args, #{}).

-spec post_issuing_disputes_dispute_submit(post_issuing_disputes_dispute_submit_request(),
                                           options()) ->
                                              result(post_issuing_disputes_dispute_submit_response()).
post_issuing_disputes_dispute_submit(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes/~s/submit", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_sources_source(post_sources_source_request()) ->
                             result(post_sources_source_response()).
post_sources_source(Args) ->
    post_sources_source(Args, #{}).

-spec post_sources_source(post_sources_source_request(), options()) ->
                             result(post_sources_source_response()).
post_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources/~s", [VarSource]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, source},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_sources_source(get_sources_source_request()) ->
                            result(get_sources_source_response()).
get_sources_source(Args) ->
    get_sources_source(Args, #{}).

-spec get_sources_source(get_sources_source_request(), options()) ->
                            result(get_sources_source_response()).
get_sources_source(Args, Options) ->
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({client_secret, Value}) ->
                encode_q(form, false, <<"client_secret">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources/~s", [VarSource]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, source},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_checkout_sessions_session(get_checkout_sessions_session_request()) ->
                                       result(get_checkout_sessions_session_response()).
get_checkout_sessions_session(Args) ->
    get_checkout_sessions_session(Args, #{}).

-spec get_checkout_sessions_session(get_checkout_sessions_session_request(), options()) ->
                                       result(get_checkout_sessions_session_response()).
get_checkout_sessions_session(Args, Options) ->
    VarSession = maps:get(session, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/checkout/sessions/~s", [VarSession]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, checkout_session},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_payment_methods_payment_method_detach(post_payment_methods_payment_method_detach_request()) ->
                                                  result(post_payment_methods_payment_method_detach_response()).
post_payment_methods_payment_method_detach(Args) ->
    post_payment_methods_payment_method_detach(Args, #{}).

-spec
    post_payment_methods_payment_method_detach(post_payment_methods_payment_method_detach_request(),
                                               options()) ->
                                                  result(post_payment_methods_payment_method_detach_response()).
post_payment_methods_payment_method_detach(Args, Options) ->
    VarPaymentMethod = maps:get(payment_method, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_methods/~s/detach", [VarPaymentMethod]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_method},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_customers(post_customers_request()) -> result(post_customers_response()).
post_customers(Args) ->
    post_customers(Args, #{}).

-spec post_customers(post_customers_request(), options()) ->
                        result(post_customers_response()).
post_customers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, customer},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_customers(get_customers_request()) -> result(get_customers_response()).
get_customers(Args) ->
    get_customers(Args, #{}).

-spec get_customers(get_customers_request(), options()) ->
                       result(get_customers_response()).
get_customers(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({email, Value}) ->
                encode_q(form, false, <<"email">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             customer}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_account_bank_accounts(post_account_bank_accounts_request()) ->
                                    result(post_account_bank_accounts_response()).
post_account_bank_accounts(Args) ->
    post_account_bank_accounts(Args, #{}).

-spec post_account_bank_accounts(post_account_bank_accounts_request(), options()) ->
                                    result(post_account_bank_accounts_response()).
post_account_bank_accounts(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/account/bank_accounts", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, external_account},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_issuing_disputes_dispute(post_issuing_disputes_dispute_request()) ->
                                       result(post_issuing_disputes_dispute_response()).
post_issuing_disputes_dispute(Args) ->
    post_issuing_disputes_dispute(Args, #{}).

-spec post_issuing_disputes_dispute(post_issuing_disputes_dispute_request(), options()) ->
                                       result(post_issuing_disputes_dispute_response()).
post_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes/~s", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_disputes_dispute(get_issuing_disputes_dispute_request()) ->
                                      result(get_issuing_disputes_dispute_response()).
get_issuing_disputes_dispute(Args) ->
    get_issuing_disputes_dispute(Args, #{}).

-spec get_issuing_disputes_dispute(get_issuing_disputes_dispute_request(), options()) ->
                                      result(get_issuing_disputes_dispute_response()).
get_issuing_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/disputes/~s", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_disputes_dispute_close(post_disputes_dispute_close_request()) ->
                                     result(post_disputes_dispute_close_response()).
post_disputes_dispute_close(Args) ->
    post_disputes_dispute_close(Args, #{}).

-spec post_disputes_dispute_close(post_disputes_dispute_close_request(), options()) ->
                                     result(post_disputes_dispute_close_response()).
post_disputes_dispute_close(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/disputes/~s/close", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_quotes_quote_cancel(post_quotes_quote_cancel_request()) ->
                                  result(post_quotes_quote_cancel_response()).
post_quotes_quote_cancel(Args) ->
    post_quotes_quote_cancel(Args, #{}).

-spec post_quotes_quote_cancel(post_quotes_quote_cancel_request(), options()) ->
                                  result(post_quotes_quote_cancel_response()).
post_quotes_quote_cancel(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/cancel", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, quote},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_customers_customer_payment_methods(get_customers_customer_payment_methods_request()) ->
                                              result(get_customers_customer_payment_methods_response()).
get_customers_customer_payment_methods(Args) ->
    get_customers_customer_payment_methods(Args, #{}).

-spec
    get_customers_customer_payment_methods(get_customers_customer_payment_methods_request(),
                                           options()) ->
                                              result(get_customers_customer_payment_methods_response()).
get_customers_customer_payment_methods(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/payment_methods", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             payment_method}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_refunds(post_refunds_request()) -> result(post_refunds_response()).
post_refunds(Args) ->
    post_refunds(Args, #{}).

-spec post_refunds(post_refunds_request(), options()) -> result(post_refunds_response()).
post_refunds(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/refunds", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, refund},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_refunds(get_refunds_request()) -> result(get_refunds_response()).
get_refunds(Args) ->
    get_refunds(Args, #{}).

-spec get_refunds(get_refunds_request(), options()) -> result(get_refunds_response()).
get_refunds(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({charge, Value}) ->
                encode_q(form, false, <<"charge">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_intent, Value}) ->
                encode_q(form, false, <<"payment_intent">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/refunds", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, refund}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_credit_notes_id(post_credit_notes_id_request()) ->
                              result(post_credit_notes_id_response()).
post_credit_notes_id(Args) ->
    post_credit_notes_id(Args, #{}).

-spec post_credit_notes_id(post_credit_notes_id_request(), options()) ->
                              result(post_credit_notes_id_response()).
post_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, credit_note},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_credit_notes_id(get_credit_notes_id_request()) ->
                             result(get_credit_notes_id_response()).
get_credit_notes_id(Args) ->
    get_credit_notes_id(Args, #{}).

-spec get_credit_notes_id(get_credit_notes_id_request(), options()) ->
                             result(get_credit_notes_id_response()).
get_credit_notes_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, credit_note},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_bitcoin_transactions(get_bitcoin_transactions_request()) ->
                                  result(get_bitcoin_transactions_response()).
get_bitcoin_transactions(Args) ->
    get_bitcoin_transactions(Args, #{}).

-spec get_bitcoin_transactions(get_bitcoin_transactions_request(), options()) ->
                                  result(get_bitcoin_transactions_response()).
get_bitcoin_transactions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({receiver, Value}) ->
                encode_q(form, false, <<"receiver">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/bitcoin/transactions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             bitcoin_transaction}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_setup_intents(post_setup_intents_request()) ->
                            result(post_setup_intents_response()).
post_setup_intents(Args) ->
    post_setup_intents(Args, #{}).

-spec post_setup_intents(post_setup_intents_request(), options()) ->
                            result(post_setup_intents_response()).
post_setup_intents(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, setup_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_setup_intents(get_setup_intents_request()) ->
                           result(get_setup_intents_response()).
get_setup_intents(Args) ->
    get_setup_intents(Args, #{}).

-spec get_setup_intents(get_setup_intents_request(), options()) ->
                           result(get_setup_intents_response()).
get_setup_intents(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({payment_method, Value}) ->
                encode_q(form, false, <<"payment_method">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/setup_intents", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             setup_intent}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payouts_payout_cancel(post_payouts_payout_cancel_request()) ->
                                    result(post_payouts_payout_cancel_response()).
post_payouts_payout_cancel(Args) ->
    post_payouts_payout_cancel(Args, #{}).

-spec post_payouts_payout_cancel(post_payouts_payout_cancel_request(), options()) ->
                                    result(post_payouts_payout_cancel_response()).
post_payouts_payout_cancel(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts/~s/cancel", [VarPayout]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payout},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_issuing_authorizations_authorization_approve(post_issuing_authorizations_authorization_approve_request()) ->
                                                         result(post_issuing_authorizations_authorization_approve_response()).
post_issuing_authorizations_authorization_approve(Args) ->
    post_issuing_authorizations_authorization_approve(Args, #{}).

-spec
    post_issuing_authorizations_authorization_approve(post_issuing_authorizations_authorization_approve_request(),
                                                      options()) ->
                                                         result(post_issuing_authorizations_authorization_approve_response()).
post_issuing_authorizations_authorization_approve(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s/approve", [VarAuthorization]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_authorization},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_issuing_authorizations_authorization_decline(post_issuing_authorizations_authorization_decline_request()) ->
                                                         result(post_issuing_authorizations_authorization_decline_response()).
post_issuing_authorizations_authorization_decline(Args) ->
    post_issuing_authorizations_authorization_decline(Args, #{}).

-spec
    post_issuing_authorizations_authorization_decline(post_issuing_authorizations_authorization_decline_request(),
                                                      options()) ->
                                                         result(post_issuing_authorizations_authorization_decline_response()).
post_issuing_authorizations_authorization_decline(Args, Options) ->
    VarAuthorization = maps:get(authorization, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/authorizations/~s/decline", [VarAuthorization]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_authorization},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_reporting_report_runs(post_reporting_report_runs_request()) ->
                                    result(post_reporting_report_runs_response()).
post_reporting_report_runs(Args) ->
    post_reporting_report_runs(Args, #{}).

-spec post_reporting_report_runs(post_reporting_report_runs_request(), options()) ->
                                    result(post_reporting_report_runs_response()).
post_reporting_report_runs(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, reporting_report_run},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_reporting_report_runs(get_reporting_report_runs_request()) ->
                                   result(get_reporting_report_runs_response()).
get_reporting_report_runs(Args) ->
    get_reporting_report_runs(Args, #{}).

-spec get_reporting_report_runs(get_reporting_report_runs_request(), options()) ->
                                   result(get_reporting_report_runs_response()).
get_reporting_report_runs(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_runs", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             reporting_report_run}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_invoices_invoice_void(post_invoices_invoice_void_request()) ->
                                    result(post_invoices_invoice_void_response()).
post_invoices_invoice_void(Args) ->
    post_invoices_invoice_void(Args, #{}).

-spec post_invoices_invoice_void(post_invoices_invoice_void_request(), options()) ->
                                    result(post_invoices_invoice_void_response()).
post_invoices_invoice_void(Args, Options) ->
    VarInvoice = maps:get(invoice, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoices/~s/void", [VarInvoice]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoice},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_sources(post_sources_request()) -> result(post_sources_response()).
post_sources(Args) ->
    post_sources(Args, #{}).

-spec post_sources(post_sources_request(), options()) -> result(post_sources_response()).
post_sources(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, source},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_billing_portal_configurations(post_billing_portal_configurations_request()) ->
                                            result(post_billing_portal_configurations_response()).
post_billing_portal_configurations(Args) ->
    post_billing_portal_configurations(Args, #{}).

-spec post_billing_portal_configurations(post_billing_portal_configurations_request(),
                                         options()) ->
                                            result(post_billing_portal_configurations_response()).
post_billing_portal_configurations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {ref, stripe, billing_portal_configuration},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_billing_portal_configurations(get_billing_portal_configurations_request()) ->
                                           result(get_billing_portal_configurations_response()).
get_billing_portal_configurations(Args) ->
    get_billing_portal_configurations(Args, #{}).

-spec get_billing_portal_configurations(get_billing_portal_configurations_request(),
                                        options()) ->
                                           result(get_billing_portal_configurations_response()).
get_billing_portal_configurations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({is_default, Value}) ->
                encode_q(form, false, <<"is_default">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/configurations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             billing_portal_configuration}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_quotes(post_quotes_request()) -> result(post_quotes_response()).
post_quotes(Args) ->
    post_quotes(Args, #{}).

-spec post_quotes(post_quotes_request(), options()) -> result(post_quotes_response()).
post_quotes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, quote},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_quotes(get_quotes_request()) -> result(get_quotes_response()).
get_quotes(Args) ->
    get_quotes(Args, #{}).

-spec get_quotes(get_quotes_request(), options()) -> result(get_quotes_response()).
get_quotes(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, quote}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_transfers_transfer(post_transfers_transfer_request()) ->
                                 result(post_transfers_transfer_response()).
post_transfers_transfer(Args) ->
    post_transfers_transfer(Args, #{}).

-spec post_transfers_transfer(post_transfers_transfer_request(), options()) ->
                                 result(post_transfers_transfer_response()).
post_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s", [VarTransfer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, transfer},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_transfers_transfer(get_transfers_transfer_request()) ->
                                result(get_transfers_transfer_response()).
get_transfers_transfer(Args) ->
    get_transfers_transfer(Args, #{}).

-spec get_transfers_transfer(get_transfers_transfer_request(), options()) ->
                                result(get_transfers_transfer_response()).
get_transfers_transfer(Args, Options) ->
    VarTransfer = maps:get(transfer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/transfers/~s", [VarTransfer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, transfer},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_quotes_quote_line_items(get_quotes_quote_line_items_request()) ->
                                     result(get_quotes_quote_line_items_response()).
get_quotes_quote_line_items(Args) ->
    get_quotes_quote_line_items(Args, #{}).

-spec get_quotes_quote_line_items(get_quotes_quote_line_items_request(), options()) ->
                                     result(get_quotes_quote_line_items_response()).
get_quotes_quote_line_items(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/line_items", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref, stripe, item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_invoiceitems_invoiceitem(delete_invoiceitems_invoiceitem_request()) ->
                                         result(delete_invoiceitems_invoiceitem_response()).
delete_invoiceitems_invoiceitem(Args) ->
    delete_invoiceitems_invoiceitem(Args, #{}).

-spec delete_invoiceitems_invoiceitem(delete_invoiceitems_invoiceitem_request(),
                                      options()) ->
                                         result(delete_invoiceitems_invoiceitem_response()).
delete_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_invoiceitem},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_invoiceitems_invoiceitem(post_invoiceitems_invoiceitem_request()) ->
                                       result(post_invoiceitems_invoiceitem_response()).
post_invoiceitems_invoiceitem(Args) ->
    post_invoiceitems_invoiceitem(Args, #{}).

-spec post_invoiceitems_invoiceitem(post_invoiceitems_invoiceitem_request(), options()) ->
                                       result(post_invoiceitems_invoiceitem_response()).
post_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoiceitem},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_invoiceitems_invoiceitem(get_invoiceitems_invoiceitem_request()) ->
                                      result(get_invoiceitems_invoiceitem_response()).
get_invoiceitems_invoiceitem(Args) ->
    get_invoiceitems_invoiceitem(Args, #{}).

-spec get_invoiceitems_invoiceitem(get_invoiceitems_invoiceitem_request(), options()) ->
                                      result(get_invoiceitems_invoiceitem_response()).
get_invoiceitems_invoiceitem(Args, Options) ->
    VarInvoiceitem = maps:get(invoiceitem, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/invoiceitems/~s", [VarInvoiceitem]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, invoiceitem},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_payment_intents_intent_capture(post_payment_intents_intent_capture_request()) ->
                                           result(post_payment_intents_intent_capture_response()).
post_payment_intents_intent_capture(Args) ->
    post_payment_intents_intent_capture(Args, #{}).

-spec post_payment_intents_intent_capture(post_payment_intents_intent_capture_request(),
                                          options()) ->
                                             result(post_payment_intents_intent_capture_response()).
post_payment_intents_intent_capture(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s/capture", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_issuing_cards(post_issuing_cards_request()) ->
                            result(post_issuing_cards_response()).
post_issuing_cards(Args) ->
    post_issuing_cards(Args, #{}).

-spec post_issuing_cards(post_issuing_cards_request(), options()) ->
                            result(post_issuing_cards_response()).
post_issuing_cards(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_card},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_cards(get_issuing_cards_request()) ->
                           result(get_issuing_cards_response()).
get_issuing_cards(Args) ->
    get_issuing_cards(Args, #{}).

-spec get_issuing_cards(get_issuing_cards_request(), options()) ->
                           result(get_issuing_cards_response()).
get_issuing_cards(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({cardholder, Value}) ->
                encode_q(form, false, <<"cardholder">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({exp_month, Value}) ->
                encode_q(form, false, <<"exp_month">>, Value);
            ({exp_year, Value}) ->
                encode_q(form, false, <<"exp_year">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({last4, Value}) ->
                encode_q(form, false, <<"last4">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({status, Value}) ->
                encode_q(form, false, <<"status">>, Value);
            ({type, Value}) ->
                encode_q(form, false, <<"type">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cards", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             issuing_card}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_sources_source_source_transactions(get_sources_source_source_transactions_request()) ->
                                              result(get_sources_source_source_transactions_response()).
get_sources_source_source_transactions(Args) ->
    get_sources_source_source_transactions(Args, #{}).

-spec
    get_sources_source_source_transactions(get_sources_source_source_transactions_request(),
                                           options()) ->
                                              result(get_sources_source_source_transactions_response()).
get_sources_source_source_transactions(Args, Options) ->
    VarSource = maps:get(source, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sources/~s/source_transactions", [VarSource]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             source_transaction}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_subscription_schedules_schedule_release(post_subscription_schedules_schedule_release_request()) ->
                                                    result(post_subscription_schedules_schedule_release_response()).
post_subscription_schedules_schedule_release(Args) ->
    post_subscription_schedules_schedule_release(Args, #{}).

-spec
    post_subscription_schedules_schedule_release(post_subscription_schedules_schedule_release_request(),
                                                 options()) ->
                                                    result(post_subscription_schedules_schedule_release_response()).
post_subscription_schedules_schedule_release(Args, Options) ->
    VarSchedule = maps:get(schedule, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules/~s/release", [VarSchedule]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription_schedule},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_customers_customer_cards_id(delete_customers_customer_cards_id_request()) ->
                                            result(delete_customers_customer_cards_id_response()).
delete_customers_customer_cards_id(Args) ->
    delete_customers_customer_cards_id(Args, #{}).

-spec delete_customers_customer_cards_id(delete_customers_customer_cards_id_request(),
                                         options()) ->
                                            result(delete_customers_customer_cards_id_response()).
delete_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, payment_source},
                                                          {ref, stripe, deleted_payment_source}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_customers_customer_cards_id(post_customers_customer_cards_id_request()) ->
                                          result(post_customers_customer_cards_id_response()).
post_customers_customer_cards_id(Args) ->
    post_customers_customer_cards_id(Args, #{}).

-spec post_customers_customer_cards_id(post_customers_customer_cards_id_request(),
                                       options()) ->
                                          result(post_customers_customer_cards_id_response()).
post_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, card},
                                                          {ref, stripe, bank_account},
                                                          {ref, stripe, source}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_customers_customer_cards_id(get_customers_customer_cards_id_request()) ->
                                         result(get_customers_customer_cards_id_response()).
get_customers_customer_cards_id(Args) ->
    get_customers_customer_cards_id(Args, #{}).

-spec get_customers_customer_cards_id(get_customers_customer_cards_id_request(),
                                      options()) ->
                                         result(get_customers_customer_cards_id_response()).
get_customers_customer_cards_id(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s/cards/~s", [VarCustomer, VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, card},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_charges_charge_dispute(post_charges_charge_dispute_request()) ->
                                     result(post_charges_charge_dispute_response()).
post_charges_charge_dispute(Args) ->
    post_charges_charge_dispute(Args, #{}).

-spec post_charges_charge_dispute(post_charges_charge_dispute_request(), options()) ->
                                     result(post_charges_charge_dispute_response()).
post_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/dispute", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_charges_charge_dispute(get_charges_charge_dispute_request()) ->
                                    result(get_charges_charge_dispute_response()).
get_charges_charge_dispute(Args) ->
    get_charges_charge_dispute(Args, #{}).

-spec get_charges_charge_dispute(get_charges_charge_dispute_request(), options()) ->
                                    result(get_charges_charge_dispute_response()).
get_charges_charge_dispute(Args, Options) ->
    VarCharge = maps:get(charge, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/charges/~s/dispute", [VarCharge]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_quotes_quote_finalize(post_quotes_quote_finalize_request()) ->
                                    result(post_quotes_quote_finalize_response()).
post_quotes_quote_finalize(Args) ->
    post_quotes_quote_finalize(Args, #{}).

-spec post_quotes_quote_finalize(post_quotes_quote_finalize_request(), options()) ->
                                    result(post_quotes_quote_finalize_response()).
post_quotes_quote_finalize(Args, Options) ->
    VarQuote = maps:get(quote, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/quotes/~s/finalize", [VarQuote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, quote},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_skus_id(delete_skus_id_request()) -> result(delete_skus_id_response()).
delete_skus_id(Args) ->
    delete_skus_id(Args, #{}).

-spec delete_skus_id(delete_skus_id_request(), options()) ->
                        result(delete_skus_id_response()).
delete_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_sku},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_skus_id(post_skus_id_request()) -> result(post_skus_id_response()).
post_skus_id(Args) ->
    post_skus_id(Args, #{}).

-spec post_skus_id(post_skus_id_request(), options()) -> result(post_skus_id_response()).
post_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, sku},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_skus_id(get_skus_id_request()) -> result(get_skus_id_response()).
get_skus_id(Args) ->
    get_skus_id(Args, #{}).

-spec get_skus_id(get_skus_id_request(), options()) -> result(get_skus_id_response()).
get_skus_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/skus/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, sku},
                                                          {ref, stripe, deleted_sku}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_disputes_dispute(post_disputes_dispute_request()) ->
                               result(post_disputes_dispute_response()).
post_disputes_dispute(Args) ->
    post_disputes_dispute(Args, #{}).

-spec post_disputes_dispute(post_disputes_dispute_request(), options()) ->
                               result(post_disputes_dispute_response()).
post_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/disputes/~s", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_disputes_dispute(get_disputes_dispute_request()) ->
                              result(get_disputes_dispute_response()).
get_disputes_dispute(Args) ->
    get_disputes_dispute(Args, #{}).

-spec get_disputes_dispute(get_disputes_dispute_request(), options()) ->
                              result(get_disputes_dispute_response()).
get_disputes_dispute(Args, Options) ->
    VarDispute = maps:get(dispute, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/disputes/~s", [VarDispute]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, dispute},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_terminal_locations(post_terminal_locations_request()) ->
                                 result(post_terminal_locations_response()).
post_terminal_locations(Args) ->
    post_terminal_locations(Args, #{}).

-spec post_terminal_locations(post_terminal_locations_request(), options()) ->
                                 result(post_terminal_locations_response()).
post_terminal_locations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, terminal_location},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_terminal_locations(get_terminal_locations_request()) ->
                                result(get_terminal_locations_response()).
get_terminal_locations(Args) ->
    get_terminal_locations(Args, #{}).

-spec get_terminal_locations(get_terminal_locations_request(), options()) ->
                                result(get_terminal_locations_response()).
get_terminal_locations(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/terminal/locations", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             terminal_location}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_subscription_schedules(post_subscription_schedules_request()) ->
                                     result(post_subscription_schedules_response()).
post_subscription_schedules(Args) ->
    post_subscription_schedules(Args, #{}).

-spec post_subscription_schedules(post_subscription_schedules_request(), options()) ->
                                     result(post_subscription_schedules_response()).
post_subscription_schedules(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, subscription_schedule},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_subscription_schedules(get_subscription_schedules_request()) ->
                                    result(get_subscription_schedules_response()).
get_subscription_schedules(Args) ->
    get_subscription_schedules(Args, #{}).

-spec get_subscription_schedules(get_subscription_schedules_request(), options()) ->
                                    result(get_subscription_schedules_response()).
get_subscription_schedules(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({canceled_at, Value}) ->
                encode_q(deepObject, true, <<"canceled_at">>, Value);
            ({completed_at, Value}) ->
                encode_q(deepObject, true, <<"completed_at">>, Value);
            ({created, Value}) ->
                encode_q(deepObject, true, <<"created">>, Value);
            ({customer, Value}) ->
                encode_q(form, false, <<"customer">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({released_at, Value}) ->
                encode_q(deepObject, true, <<"released_at">>, Value);
            ({scheduled, Value}) ->
                encode_q(form, false, <<"scheduled">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/subscription_schedules", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             subscription_schedule}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payment_links(post_payment_links_request()) ->
                            result(post_payment_links_response()).
post_payment_links(Args) ->
    post_payment_links(Args, #{}).

-spec post_payment_links(post_payment_links_request(), options()) ->
                            result(post_payment_links_response()).
post_payment_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_link},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_payment_links(get_payment_links_request()) ->
                           result(get_payment_links_response()).
get_payment_links(Args) ->
    get_payment_links(Args, #{}).

-spec get_payment_links(get_payment_links_request(), options()) ->
                           result(get_payment_links_response()).
get_payment_links(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({active, Value}) ->
                encode_q(form, false, <<"active">>, Value);
            ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             payment_link}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_tokens(post_tokens_request()) -> result(post_tokens_response()).
post_tokens(Args) ->
    post_tokens(Args, #{}).

-spec post_tokens(post_tokens_request(), options()) -> result(post_tokens_response()).
post_tokens(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/tokens", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, token},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_issuing_cardholders_cardholder(post_issuing_cardholders_cardholder_request()) ->
                                           result(post_issuing_cardholders_cardholder_response()).
post_issuing_cardholders_cardholder(Args) ->
    post_issuing_cardholders_cardholder(Args, #{}).

-spec post_issuing_cardholders_cardholder(post_issuing_cardholders_cardholder_request(),
                                          options()) ->
                                             result(post_issuing_cardholders_cardholder_response()).
post_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cardholders/~s", [VarCardholder]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_cardholder},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_issuing_cardholders_cardholder(get_issuing_cardholders_cardholder_request()) ->
                                            result(get_issuing_cardholders_cardholder_response()).
get_issuing_cardholders_cardholder(Args) ->
    get_issuing_cardholders_cardholder(Args, #{}).

-spec get_issuing_cardholders_cardholder(get_issuing_cardholders_cardholder_request(),
                                         options()) ->
                                            result(get_issuing_cardholders_cardholder_response()).
get_issuing_cardholders_cardholder(Args, Options) ->
    VarCardholder = maps:get(cardholder, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/issuing/cardholders/~s", [VarCardholder]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, issuing_cardholder},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_application_fees_id(get_application_fees_id_request()) ->
                                 result(get_application_fees_id_response()).
get_application_fees_id(Args) ->
    get_application_fees_id(Args, #{}).

-spec get_application_fees_id(get_application_fees_id_request(), options()) ->
                                 result(get_application_fees_id_response()).
get_application_fees_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/application_fees/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, application_fee},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_exchange_rates_rate_id(get_exchange_rates_rate_id_request()) ->
                                    result(get_exchange_rates_rate_id_response()).
get_exchange_rates_rate_id(Args) ->
    get_exchange_rates_rate_id(Args, #{}).

-spec get_exchange_rates_rate_id(get_exchange_rates_rate_id_request(), options()) ->
                                    result(get_exchange_rates_rate_id_response()).
get_exchange_rates_rate_id(Args, Options) ->
    VarRateId = maps:get(rate_id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/exchange_rates/~s", [VarRateId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, exchange_rate},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    post_payment_intents_intent_confirm(post_payment_intents_intent_confirm_request()) ->
                                           result(post_payment_intents_intent_confirm_response()).
post_payment_intents_intent_confirm(Args) ->
    post_payment_intents_intent_confirm(Args, #{}).

-spec post_payment_intents_intent_confirm(post_payment_intents_intent_confirm_request(),
                                          options()) ->
                                             result(post_payment_intents_intent_confirm_response()).
post_payment_intents_intent_confirm(Args, Options) ->
    VarIntent = maps:get(intent, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_intents/~s/confirm", [VarIntent]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_intent},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_credit_notes_preview(get_credit_notes_preview_request()) ->
                                  result(get_credit_notes_preview_response()).
get_credit_notes_preview(Args) ->
    get_credit_notes_preview(Args, #{}).

-spec get_credit_notes_preview(get_credit_notes_preview_request(), options()) ->
                                  result(get_credit_notes_preview_response()).
get_credit_notes_preview(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({amount, Value}) ->
                encode_q(form, false, <<"amount">>, Value);
            ({credit_amount, Value}) ->
                encode_q(form, false, <<"credit_amount">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({invoice, Value}) ->
                encode_q(form, false, <<"invoice">>, Value);
            ({lines, Value}) ->
                encode_q(deepObject, true, <<"lines">>, Value);
            ({memo, Value}) ->
                encode_q(form, false, <<"memo">>, Value);
            ({metadata, Value}) ->
                encode_q(deepObject, true, <<"metadata">>, Value);
            ({out_of_band_amount, Value}) ->
                encode_q(form, false, <<"out_of_band_amount">>, Value);
            ({reason, Value}) ->
                encode_q(form, false, <<"reason">>, Value);
            ({refund, Value}) ->
                encode_q(form, false, <<"refund">>, Value);
            ({refund_amount, Value}) ->
                encode_q(form, false, <<"refund_amount">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/preview", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, credit_note},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_balance_history_id(get_balance_history_id_request()) ->
                                result(get_balance_history_id_response()).
get_balance_history_id(Args) ->
    get_balance_history_id(Args, #{}).

-spec get_balance_history_id(get_balance_history_id_request(), options()) ->
                                result(get_balance_history_id_response()).
get_balance_history_id(Args, Options) ->
    VarId = maps:get(id, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/balance/history/~s", [VarId]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, balance_transaction},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payouts_payout_reverse(post_payouts_payout_reverse_request()) ->
                                     result(post_payouts_payout_reverse_response()).
post_payouts_payout_reverse(Args) ->
    post_payouts_payout_reverse(Args, #{}).

-spec post_payouts_payout_reverse(post_payouts_payout_reverse_request(), options()) ->
                                     result(post_payouts_payout_reverse_response()).
post_payouts_payout_reverse(Args, Options) ->
    VarPayout = maps:get(payout, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payouts/~s/reverse", [VarPayout]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payout},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_reporting_report_runs_report_run(get_reporting_report_runs_report_run_request()) ->
                                            result(get_reporting_report_runs_report_run_response()).
get_reporting_report_runs_report_run(Args) ->
    get_reporting_report_runs_report_run(Args, #{}).

-spec get_reporting_report_runs_report_run(get_reporting_report_runs_report_run_request(),
                                           options()) ->
                                              result(get_reporting_report_runs_report_run_response()).
get_reporting_report_runs_report_run(Args, Options) ->
    VarReportRun = maps:get(report_run, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/reporting/report_runs/~s", [VarReportRun]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, reporting_report_run},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec
    get_sources_source_source_transactions_source_transaction(get_sources_source_source_transactions_source_transaction_request()) ->
                                                                 result(get_sources_source_source_transactions_source_transaction_response()).
get_sources_source_source_transactions_source_transaction(Args) ->
    get_sources_source_source_transactions_source_transaction(Args, #{}).

-spec
    get_sources_source_source_transactions_source_transaction(get_sources_source_source_transactions_source_transaction_request(),
                                                              options()) ->
                                                                 result(get_sources_source_source_transactions_source_transaction_response()).
get_sources_source_source_transactions_source_transaction(Args, Options) ->
    VarSource = maps:get(source, Args),
    VarSourceTransaction = maps:get(source_transaction, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath =
        io_lib:format("/v1/sources/~s/source_transactions/~s", [VarSource, VarSourceTransaction]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, source_transaction},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec delete_customers_customer(delete_customers_customer_request()) ->
                                   result(delete_customers_customer_response()).
delete_customers_customer(Args) ->
    delete_customers_customer(Args, #{}).

-spec delete_customers_customer(delete_customers_customer_request(), options()) ->
                                   result(delete_customers_customer_response()).
delete_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => delete,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, deleted_customer},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_customers_customer(post_customers_customer_request()) ->
                                 result(post_customers_customer_response()).
post_customers_customer(Args) ->
    post_customers_customer(Args, #{}).

-spec post_customers_customer(post_customers_customer_request(), options()) ->
                                 result(post_customers_customer_response()).
post_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, customer},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_customers_customer(get_customers_customer_request()) ->
                                result(get_customers_customer_response()).
get_customers_customer(Args) ->
    get_customers_customer(Args, #{}).

-spec get_customers_customer(get_customers_customer_request(), options()) ->
                                result(get_customers_customer_response()).
get_customers_customer(Args, Options) ->
    VarCustomer = maps:get(customer, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/customers/~s", [VarCustomer]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {one_of,
                                                         [{ref, stripe, customer},
                                                          {ref, stripe, deleted_customer}]},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_billing_portal_sessions(post_billing_portal_sessions_request()) ->
                                      result(post_billing_portal_sessions_response()).
post_billing_portal_sessions(Args) ->
    post_billing_portal_sessions(Args, #{}).

-spec post_billing_portal_sessions(post_billing_portal_sessions_request(), options()) ->
                                      result(post_billing_portal_sessions_response()).
post_billing_portal_sessions(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/billing_portal/sessions", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, billing_portal_session},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec post_payment_links_payment_link(post_payment_links_payment_link_request()) ->
                                         result(post_payment_links_payment_link_response()).
post_payment_links_payment_link(Args) ->
    post_payment_links_payment_link(Args, #{}).

-spec post_payment_links_payment_link(post_payment_links_payment_link_request(),
                                      options()) ->
                                         result(post_payment_links_payment_link_response()).
post_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery = fun({Key, Value}) -> [{Key, Value}] end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links/~s", [VarPaymentLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => post,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_link},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_payment_links_payment_link(get_payment_links_payment_link_request()) ->
                                        result(get_payment_links_payment_link_response()).
get_payment_links_payment_link(Args) ->
    get_payment_links_payment_link(Args, #{}).

-spec get_payment_links_payment_link(get_payment_links_payment_link_request(),
                                     options()) ->
                                        result(get_payment_links_payment_link_response()).
get_payment_links_payment_link(Args, Options) ->
    VarPaymentLink = maps:get(payment_link, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/payment_links/~s", [VarPaymentLink]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema = {ref, stripe, payment_link},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_credit_notes_credit_note_lines(get_credit_notes_credit_note_lines_request()) ->
                                            result(get_credit_notes_credit_note_lines_response()).
get_credit_notes_credit_note_lines(Args) ->
    get_credit_notes_credit_note_lines(Args, #{}).

-spec get_credit_notes_credit_note_lines(get_credit_notes_credit_note_lines_request(),
                                         options()) ->
                                            result(get_credit_notes_credit_note_lines_response()).
get_credit_notes_credit_note_lines(Args, Options) ->
    VarCreditNote = maps:get(credit_note, Args),
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/credit_notes/~s/lines", [VarCreditNote]),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             credit_note_line_item}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec get_sigma_scheduled_query_runs(get_sigma_scheduled_query_runs_request()) ->
                                        result(get_sigma_scheduled_query_runs_response()).
get_sigma_scheduled_query_runs(Args) ->
    get_sigma_scheduled_query_runs(Args, #{}).

-spec get_sigma_scheduled_query_runs(get_sigma_scheduled_query_runs_request(),
                                     options()) ->
                                        result(get_sigma_scheduled_query_runs_response()).
get_sigma_scheduled_query_runs(Args, Options) ->
    Query = maps:get(query, Args, #{}),
    Header = maps:get(header, Args, #{}),
    EncodeQuery =
        fun ({ending_before, Value}) ->
                encode_q(form, false, <<"ending_before">>, Value);
            ({expand, Value}) ->
                encode_q(deepObject, true, <<"expand">>, Value);
            ({limit, Value}) ->
                encode_q(form, false, <<"limit">>, Value);
            ({starting_after, Value}) ->
                encode_q(form, false, <<"starting_after">>, Value);
            ({Key, Value}) ->
                [{Key, Value}]
        end,
    EncodeHeader = fun({Key, Value}) -> [{Key, Value}] end,
    ReqPath = io_lib:format("/v1/sigma/scheduled_query_runs", []),
    ReqQuery = lists:flatmap(EncodeQuery, maps:to_list(Query)),
    ReqHeader = lists:flatmap(EncodeHeader, maps:to_list(Header)),
    ReqOptions = maps:get(request_options, Options, #{}),
    Req = #{method => get,
            header => ReqHeader,
            target =>
                #{scheme => maps:get(scheme, Options, <<"https">>),
                  port => maps:get(port, Options, 443),
                  host => maps:get(host, Options, <<"api.stripe.com">>),
                  path => iolist_to_binary(ReqPath),
                  query => ReqQuery}},
    case mhttp:send_request(Req, ReqOptions) of
        {ok, Resp} ->
            RespBody = mhttp_response:body(Resp),
            RespHeader = mhttp_response:header(Resp),
            case mhttp_header:find(RespHeader, <<"Content-Type">>) of
                {ok, MediaTypeValue} ->
                    case mhttp_media_type:parse(MediaTypeValue) of
                        {ok, MediaType} ->
                            case mhttp_response:status(Resp) of
                                200 ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    Schema =
                                                        {object,
                                                         #{members =>
                                                               #{data =>
                                                                     {array,
                                                                      #{element =>
                                                                            {ref,
                                                                             stripe,
                                                                             scheduled_query_run}}},
                                                                 has_more => boolean,
                                                                 object =>
                                                                     {string, #{values => [list]}},
                                                                 url => string},
                                                           required =>
                                                               [data, has_more, object, url]}},
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data, Schema, ValidateOpts) of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end;
                                _ ->
                                    case MediaType of
                                        {<<"application">>, <<"json">>} ->
                                            case json:parse(RespBody) of
                                                {ok, Data} ->
                                                    ValidateOpts =
                                                        #{disable_verification => true,
                                                          unknown_member_handling => keep,
                                                          null_member_handling => remove},
                                                    case jsv:validate(Data,
                                                                      {ref, stripe, error},
                                                                      ValidateOpts)
                                                    of
                                                        {ok, Schema} ->
                                                            {ok, Schema, Resp};
                                                        {error, Errors} ->
                                                            {error,
                                                             #{reason =>
                                                                   {invalid_payload, {jsv, Errors}},
                                                               request => Req,
                                                               response => Resp}}
                                                    end;
                                                {error, Error} ->
                                                    {error,
                                                     #{reason => {invalid_payload, {json, Error}},
                                                       request => Req,
                                                       response => Resp}}
                                            end;
                                        _ ->
                                            {error,
                                             #{reason => unsupported_content_type,
                                               request => Req,
                                               response => Resp}}
                                    end
                            end;
                        {error, Reason} ->
                            {error,
                             #{reason => {invalid_content_type, Reason},
                               request => Req,
                               response => Resp}}
                    end;
                error ->
                    {error,
                     #{reason => missing_content_type,
                       request => Req,
                       response => Resp}}
            end;
        {error, Reason} ->
            {error, #{reason => {mhttp, Reason}, request => Req}}
    end.

-spec encode_q(Style, Explode, Key, Value) -> uri:query()
    when Style :: form | spaceDelimitde | pipeDelimited | deepObject,
         Explode :: boolean(),
         Key :: binary(),
         Value :: term().
encode_q(form, true, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_q(form, true, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_q(form, true, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_q(form, true, Key, Values) when is_list(Values) ->
    lists:map(fun (Value) when is_binary(Value) ->
                      {Key, Value};
                  (Value) when is_integer(Value) ->
                      {Key, integer_to_binary(Value)};
                  (Value) when is_atom(Value) ->
                      {Key, atom_to_binary(Value)}
              end,
              Values);
encode_q(form, true, _Key, Values) when is_map(Values) ->
    maps:fold(fun (Key, Value, Acc) when is_binary(Value) ->
                      [{Key, Value} | Acc];
                  (Key, Value, Acc) when is_integer(Value) ->
                      [{Key, integer_to_binary(Value)} | Acc];
                  (Key, Value, Acc) when is_atom(Value) ->
                      [{Key, atom_to_binary(Key)} | Acc]
              end,
              [],
              Values);
encode_q(form, false, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_q(form, false, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_q(form, false, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_q(form, false, Key, Values) when is_list(Values) ->
    Values1 =
        lists:map(fun (Value) when is_binary(Value) ->
                          Value;
                      (Value) when is_integer(Value) ->
                          integer_to_binary(Value);
                      (Value) when is_atom(Value) ->
                          atom_to_binary(Value)
                  end,
                  Values),
    [{Key,
      unicode:characters_to_binary(
          lists:join(",", Values1))}];
encode_q(form, false, Key, Values) when is_map(Values) ->
    Values1 =
        maps:fold(fun (K, V, Acc) when is_binary(V) ->
                          [[K, $,, V] | Acc];
                      (K, V, Acc) when is_integer(V) ->
                          [[K, $,, integer_to_binary(V)] | Acc];
                      (K, V, Acc) when is_atom(V) ->
                          [[K, $,, atom_to_binary(V)] | Acc]
                  end,
                  [],
                  Values),
    [{Key,
      unicode:characters_to_binary(
          lists:join(",", Values1))}];
%% deepObject MUST not encode primary or array value but Stripe use this style
%% to encode query parameter. So I'm force to extend the spec.
encode_q(deepObject, true, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_q(deepObject, true, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_q(deepObject, true, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_q(deepObject, true, Key, Values) when is_list(Values) ->
    lists:map(fun (Value) when is_binary(Value) ->
                      {<<Key/binary, "[]">>, Value};
                  (Value) when is_integer(Value) ->
                      {<<Key/binary, "[]">>, integer_to_binary(Value)};
                  (Value) when is_atom(Value) ->
                      {<<Key/binary, "[]">>, atom_to_binary(Value)}
              end,
              Values);
encode_q(deepObject, true, Key, Values) when is_map(Values) ->
    maps:fold(fun (K, V, Acc) when is_binary(V) ->
                      K2 = atom_to_binary(K),
                      [{<<Key/binary, $[, K2/binary, $]>>, V} | Acc];
                  (K, V, Acc) when is_integer(V) ->
                      K2 = atom_to_binary(K),
                      [{<<Key/binary, $[, K2/binary, $]>>, integer_to_binary(V)} | Acc];
                  (K, V, Acc) when is_atom(V) ->
                      K2 = atom_to_binary(K),
                      [{<<Key/binary, $[, K2/binary, $]>>, atom_to_binary(V)} | Acc]
              end,
              [],
              Values).

-spec encode_h(Style, Explode, Key, Value) -> mhttp:header()
    when Style :: simple,
         Explode :: boolean(),
         Key :: binary(),
         Value :: term().
encode_h(simple, false, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_h(simple, false, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_h(simple, false, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_h(simple, false, Key, Values) when is_list(Values) ->
    [{Key,
      unicode:characters_to_binary(
          lists:join(",",
                     lists:map(fun (Value) when is_binary(Value) ->
                                       Value;
                                   (Value) when is_integer(Value) ->
                                       integer_to_binary(Value);
                                   (Value) when is_atom(Value) ->
                                       atom_to_binary(Value)
                               end,
                               Values)))}];
encode_h(simple, false, Key, Values) when is_map(Values) ->
    [{Key,
      unicode:characters_to_binary(
          lists:join(",",
                     maps:fold(fun (K, V, Acc) when is_binary(V) ->
                                       [[K, $,, V] | Acc];
                                   (K, V, Acc) when is_integer(V) ->
                                       [[K, $,, integer_to_binary(V)] | Acc];
                                   (K, V, Acc) when is_atom(V) ->
                                       [[K, $,, atom_to_binary(V)] | Acc]
                               end,
                               [],
                               Values)))}];
encode_h(simple, true, Key, Value) when is_binary(Value) ->
    [{Key, Value}];
encode_h(simple, true, Key, Value) when is_integer(Value) ->
    [{Key, integer_to_binary(Value)}];
encode_h(simple, true, Key, Value) when is_atom(Value) ->
    [{Key, atom_to_binary(Value)}];
encode_h(simple, true, Key, Values) when is_list(Values) ->
    [{Key,
      unicode:characters_to_binary(
          lists:join(",",
                     lists:map(fun (Value) when is_binary(Value) ->
                                       Value;
                                   (Value) when is_integer(Value) ->
                                       integer_to_binary(Value);
                                   (Value) when is_atom(Value) ->
                                       atom_to_binary(Value)
                               end,
                               Values)))}];
encode_h(simple, true, Key, Values) when is_map(Values) ->
    [{Key,
      unicode:characters_to_binary(
          lists:join(",",
                     maps:fold(fun (K, V, Acc) when is_binary(V) ->
                                       [[K, $=, V] | Acc];
                                   (K, V, Acc) when is_integer(V) ->
                                       [[K, $=, integer_to_binary(V)] | Acc];
                                   (K, V, Acc) when is_atom(V) ->
                                       [[K, $=, atom_to_binary(V)] | Acc]
                               end,
                               [],
                               Values)))}].
